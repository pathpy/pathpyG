{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pathpyG","text":"<p>This is the index page of the pathpyG documentation.</p>"},{"location":"about/","title":"About","text":""},{"location":"about/#what-is-pathpyg","title":"What is pathpyG?","text":"<p>pathpyG is an Open Source package facilitating next-generation network analytics and graph learning for time series data on graphs.</p> <p>pathpyG is tailored to analyse time-stamped network data as well as sequential data that capture multiple short paths observed in a graph or network. Examples for data that can be analysed with pathpyG include high-resolution time-stamped network data, dynamic social networks, user click streams on the Web, biological pathway data, citation graphs, passenger trajectories in transportation networks, or information propagation in social networks.</p> <p>pathpyG is fully integrated with jupyter, providing rich interactive visualisations of networks, temporal networks, higher-, and multi-order models. Visualisations can be exported to HTML5 files that can be shared and published on the Web.</p>"},{"location":"about/#what-is-the-science-behind-pathpyg","title":"What is the science behind pathpyG?","text":"<p>The theoretical foundation of this package, higher- and multi-order network models, was developed in the following peer-reviewed research articles:</p> <ol> <li>R Lambiotte, M Rosvall, I Scholtes: From networks to optimal models of complex systems, Nature Physics 15, 313-320, March 2019</li> <li>I Scholtes: When is a network a network? Multi-Order Graphical Model Selection in Pathways and Temporal Networks, In KDD'17 - Proceedings of the 23<sup>rd</sup> ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, Halifax, Nova Scotia, Canada, August 13-17, 2017</li> <li>I Scholtes, N Wider, A Garas: Higher-Order Aggregate Networks in the Analysis of Temporal Networks: Path structures and centralities, The European Physical Journal B, 89:61, March 2016</li> <li>I Scholtes, N Wider, R Pfitzner, A Garas, CJ Tessone, F Schweitzer: Causality-driven slow-down and speed-up of diffusion in non-Markovian temporal networks, Nature Communications, 5, September 2014</li> <li>R Pfitzner, I Scholtes, A Garas, CJ Tessone, F Schweitzer: Betweenness preference: Quantifying correlations in the topological dynamics of temporal networks, Phys Rev Lett, 110(19), 198701, May 2013</li> </ol> <p>A broader view on the importance of higher-order network models in network analysis can be found in this article. An explanatory video with a high-level introduction of the the science behind pathpyG is available below. </p>"},{"location":"contributing/","title":"Contributing","text":"<p>This project is open source and welcomes contributions. In the following sections, you will find information about how to contribute to this project, set up your environment correctly, how to document your code and more.</p>"},{"location":"contributing/#overview","title":"Overview","text":"<ul> <li>Setting up your environment</li> <li>Documentation</li> <li>Code Style</li> <li>Formatting</li> <li>Testing</li> </ul>"},{"location":"contributing/#setting-up-your-environment","title":"Setting up your environment","text":""},{"location":"contributing/#clone-the-repository","title":"Clone the Repository","text":"<p>The first step is to clone the repository. You can do this by running the following command: <pre><code>git clone https://github.com/pathpy/pathpyG\n</code></pre> If you do not have the rights to push to the repository, you can also fork the repository and clone your fork instead. From there you can create a pull request to the original repository.</p>"},{"location":"contributing/#installation","title":"Installation","text":"<p>To ensure version consistency, we use a Development Container for this project.   VSCode provides an easy-to-use extension for this. Check out their official documentation for more information. Once you've installed the extension successfully,   VSCode will recommend reopening the project in the Dev Container. You can also do this manually by clicking on the button in the bottom left corner of   VSCode and then selecting <code>Reopen in Container</code>.</p> Setup without Dev Containers <p>If you do not want to use Dev Containers, you can also install the dependencies into your virtual Python environment manually. We recommend that you follow the instructions provided on our getting started page. As last step, install the package in editable mode and include the dependencies necessary for testing, documentation and general development: <pre><code>pip install -e '.[dev,test,doc]'\n</code></pre></p>"},{"location":"contributing/#git-pre-commit-hooks","title":"Git pre-commit hooks","text":"<p>If you are wondering why every commit you make takes so long, it is because we run a couple of checks on your code before it is committed. These checks are configured as pre-commit hooks and are running automatically when you commit your code. The checks are documented in detail in <code>pre-commit-config.yaml</code>. They are installed by default in the Dev Container setup. If you installed the package manually, you can set up the hooks by running the following command: <pre><code>pre-commit install\n</code></pre></p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>This project uses <code>MkDocs</code> for documentation. It is a static site generator that creates the necessary <code>html</code>-files automatically from the <code>markdown</code>-files and  Group.svg Created using Figma 0.90  Jupyter notebooks in the <code>docs/</code>-directory and the <code>Python</code>-files in <code>src/</code>. The documentation is hosted on GitHub Pages.</p>"},{"location":"contributing/#hosting-the-documentation-locally","title":"Hosting the documentation locally","text":"<p>You can host the documentation locally with the following command: <pre><code>mkdocs serve\n</code></pre> The documentation is then available at <code>http://localhost:8000/</code>.</p> Actual Deployment <p>The development version of the documentation is deployed automatically to GitHub Pages when something is pushed to the <code>main</code>-branch. The workflow for deploying a new stable version needs to be triggered manually. You can find it in the <code>Actions</code>-tab of the repository. Both workflows use <code>mike</code> instead of <code>MkDocs</code> to enable versioning.</p>"},{"location":"contributing/#code-reference","title":"Code Reference","text":"<p>The <code>Code Reference</code> is generated automatically from the   Python source files. The docstrings should be formatted according to the Google Python Style Guide. Be sure to also use the advanced stuff like notes, tips and more. They can e.g. look as follows:</p> DocstringResult <pre><code>\"\"\"\nNote:\n    This is a note.\n\nTip: This is a heading\n    This is a tip.\n\"\"\"\n</code></pre> <p>Note</p> <p>This is a note.</p> <p>This is a heading</p> <p>This is a tip.</p> <p>See the documentation of the underlying griffe package for more details.</p> <p>To get an overview for each module, <code>mkdocstrings</code> automatically uses the docstrings from the <code>__init__.py</code> files in each module as description. Thus, do not forget to add a docstring to each <code>__init__.py</code> file.</p>"},{"location":"contributing/#tutorials","title":"Tutorials","text":"<p>The tutorials are written in  Group.svg Created using Figma 0.90  Jupyter notebooks. They are located in the <code>docs/</code>-directory. You can add new tutorials by adding the notebook to the <code>docs/tutorial/</code>-directory and adding the path to the <code>mkdocs.yml</code>-file under <code>nav:</code>. The tutorials are automatically converted to <code>html</code>-files when the documentation is built.</p>"},{"location":"contributing/#adding-new-pages","title":"Adding new pages","text":"<p>You can add more pages to the documentation by adding a <code>markdown</code>-file to the <code>docs/</code>-directory and adding the path to the <code>mkdocs.yml</code>-file under <code>nav:</code>. The pages are automatically converted to <code>html</code>-files when the documentation is built. We are using Material for MkDocs as a theme. It includes many great features like annotations, code blocks, diagrams, admonitions and more. Check out their documentation for more information.</p>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We (soon) enforce code style guidelines with <code>pylint</code>, <code>flake8</code>, <code>mypy</code> and <code>pyright</code>. These packages are configured as defaults in the Dev Container setup via <code>VSCode</code> and the settings are saved in <code>pyproject.toml</code>. You can run them locally with the following commands:</p> <ul> <li><code>pylint</code>: A linter that checks for errors and code style violations.     <pre><code>pylint scr/ # (1)!\n</code></pre><ol> <li>This runs <code>pylint</code> on all files in <code>scr/</code>. You can also run <code>pylint</code> on a single file by specifying the path to the file instead.</li> </ol> </li> <li><code>flake8</code>: Another linter that checks for bad code smells and suspicious constructs.     <pre><code>flake8 . # (1)!\n</code></pre><ol> <li>This runs <code>flake8</code> on all files in the current directory. You can also run <code>flake8</code> on a single file or a subdirectory by specifying the path accordingly.</li> </ol> </li> <li><code>mypy</code>: A static type checker for Python.     <pre><code>mypy src/ # (1)!\n</code></pre><ol> <li>This runs <code>mypy</code> on all files in <code>src/</code>. You can also run <code>mypy</code> on a single file by specifying the path to the file instead.</li> </ol> </li> <li><code>pyright</code>: A second static type checker for Python.     <pre><code>pyright . # (1)!\n</code></pre><ol> <li>This runs <code>pyright</code> on all files in the current directory. You can also run it on a single file or a subdirectory by specifying the path accordingly.</li> </ol> </li> </ul>"},{"location":"contributing/#formatting","title":"Formatting","text":"<p>We use <code>black</code> for formatting. You can run it locally with the following command:</p> <pre><code>black . # (1)!\n</code></pre> <ol> <li>This command will format all files in the current directory. You can also run <code>black</code> on a single file or a subdirectory by specifying the path accordingly.</li> </ol> <p>We further use <code>isort</code> for sorting imports. You can run it locally with the following command: <pre><code>isort .\n</code></pre> The default keyboard shortcut for formatting in <code>VSCode</code> is <code>Alt + Shift + F</code>.</p>"},{"location":"contributing/#testing","title":"Testing","text":"<p>We are using <code>pytest</code> for testing. You can run the tests locally with the following command: <pre><code>pytest\n</code></pre> The tests are located in the <code>tests/</code>-directory. We use <code>pytest-cov</code> to measure the test coverage and are aiming for 100% coverage with a hard limit of 80%. Tests will fail if the coverage drops below 80%.</p> <p>Add tests</p> <p>We are currently only at 29% coverage. So the lines above are currently pure fiction.</p>"},{"location":"docker_installation/","title":"Docker Installation","text":"<p>  PyTorch provides a  Docker image with PyTorch preinstalled. Using this image, the Dockerfile below creates a Docker image with PathpyG installed.</p> GPUCPU <pre><code>FROM pytorch/pytorch:2.1.0-cuda12.1-cudnn8-runtime\nWORKDIR /workspaces/pathpyG\nRUN apt-get update\nRUN apt-get -y install git\n\nRUN pip install torch==2.1.0+cu121 --index-url https://download.pytorch.org/whl/cu121\n\nRUN pip install torch_geometric&gt;=2.4.0\nRUN pip install pyg_lib torch_scatter torch_sparse torch_cluster torch_spline_conv -f https://data.pyg.org/whl/torch-2.1.0+cu121.html\nRUN pip install git+https://github.com/pathpy/pathpyG.git\n</code></pre> <pre><code>FROM pytorch/pytorch:2.1.0-cuda12.1-cudnn8-runtime\nWORKDIR /workspaces/pathpyG\nRUN apt-get update\nRUN apt-get -y install git\n\nRUN pip install torch==2.1.0+cpu --index-url https://download.pytorch.org/whl/cpu # CPU only\n\nRUN pip install torch_geometric&gt;=2.4.0\nRUN pip install pyg_lib torch_scatter torch_sparse torch_cluster torch_spline_conv -f https://data.pyg.org/whl/torch-2.1.0+cpu.html # CPU only\nRUN pip install git+https://github.com/pathpy/pathpyG.git\n</code></pre>"},{"location":"gen_ref_pages/","title":"Gen ref pages","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"Generate the code reference pages and navigation.\"\"\"\n# See for more detail: https://mkdocstrings.github.io/recipes/\n</pre> \"\"\"Generate the code reference pages and navigation.\"\"\" # See for more detail: https://mkdocstrings.github.io/recipes/ In\u00a0[\u00a0]: Copied! <pre>from pathlib import Path\n</pre> from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>import mkdocs_gen_files\n</pre> import mkdocs_gen_files In\u00a0[\u00a0]: Copied! <pre>nav = mkdocs_gen_files.Nav()\n</pre> nav = mkdocs_gen_files.Nav() In\u00a0[\u00a0]: Copied! <pre>for path in sorted(Path(\"src\").rglob(\"*.py\")):\n    module_path = path.relative_to(\"src\").with_suffix(\"\")\n    doc_path = path.relative_to(\"src\").with_suffix(\".md\")\n    full_doc_path = Path(\"reference\", doc_path)\n\n    parts = tuple(module_path.parts)\n\n    if parts[-1] == \"__init__\":\n        parts = parts[:-1]\n        doc_path = doc_path.with_name(\"index.md\")\n        full_doc_path = full_doc_path.with_name(\"index.md\")\n    elif parts[-1] == \"__main__\":\n        continue\n\n    nav[parts] = doc_path.as_posix()\n\n    with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:\n        ident = \".\".join(parts)\n        fd.write(f\"::: {ident}\")\n\n    mkdocs_gen_files.set_edit_path(full_doc_path, Path(\"../\") / path)\n</pre> for path in sorted(Path(\"src\").rglob(\"*.py\")):     module_path = path.relative_to(\"src\").with_suffix(\"\")     doc_path = path.relative_to(\"src\").with_suffix(\".md\")     full_doc_path = Path(\"reference\", doc_path)      parts = tuple(module_path.parts)      if parts[-1] == \"__init__\":         parts = parts[:-1]         doc_path = doc_path.with_name(\"index.md\")         full_doc_path = full_doc_path.with_name(\"index.md\")     elif parts[-1] == \"__main__\":         continue      nav[parts] = doc_path.as_posix()      with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:         ident = \".\".join(parts)         fd.write(f\"::: {ident}\")      mkdocs_gen_files.set_edit_path(full_doc_path, Path(\"../\") / path) In\u00a0[\u00a0]: Copied! <pre>with mkdocs_gen_files.open(\"reference/SUMMARY.md\", \"w\") as nav_file:\n    nav_file.writelines(nav.build_literate_nav())\n</pre> with mkdocs_gen_files.open(\"reference/SUMMARY.md\", \"w\") as nav_file:     nav_file.writelines(nav.build_literate_nav())"},{"location":"getting_started/","title":"Getting Started","text":"<p>The following will guide you through the installation of the package and the first steps to use it.</p>"},{"location":"getting_started/#prerequisites","title":"Prerequisites","text":"<p>PathpyG is available for   Python versions 3.10 and above. It is not recommended to install it on your system Python. Instead, we recommend using a virtual environment such as   conda or virtualenv. You can also set up a   Docker image as described in the next section.</p>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>Once you have an environment up and running, you can install the package simply via pip. But first make sure that you installed the necessary dependencies.</p>"},{"location":"getting_started/#dependencies","title":"Dependencies","text":"<p>This package is based on   PyTorch and   PyTorch Geometric. Please install both libraries before installing PathpyG. You can follow the installation instructions in their respective documentation (  PyTorch and   PyG).</p> <p>Warning</p> <p>We currently only support PyG version 2.4.0 and above.</p>"},{"location":"getting_started/#install-stable-release","title":"Install Stable Release","text":"<p>You can install the latest stable release of PathpyG via pip:</p> <p>TODO</p> <p>This is not yet available. We will release the first stable version soon.</p> <pre><code>pip install pathpyg\n</code></pre>"},{"location":"getting_started/#install-latest-development-version","title":"Install Latest Development Version","text":"<p>If you want to install the latest development version, you can do so via pip directly from the GitHub repository:</p> <pre><code>pip install git+https://github.com/pathpy/pathpyG.git\n</code></pre>"},{"location":"plot_tutorial/","title":"Develop Custom Plot Functions","text":"<p>This tutorial guides you through the process of creating your own plotting functions in pathpyG.</p> <p>The visualization framework of pathpyg is designed in such a way that is easy to extend it according your own needs.</p> <p>For this tutorial we want to implement capabilities to plot histograms.</p> <p>You will learn:</p> <ul> <li>How to set up a generic plot function</li> <li>How to convert <code>pathpyG</code> data to plot data</li> <li>How to plot with <code>d3js</code> </li> <li>How to plot with <code>tikz</code></li> <li>How to plot with <code>matplotlib</code></li> </ul>"},{"location":"plot_tutorial/#structure","title":"Structure","text":"<p>Plotting commands and functions are located under <code>/src/pathpyG/visualisation/</code></p> <pre><code>\ud83d\udcc1 visualisation\n\u251c\u2500\u2500 \ud83d\udcc4 __init__.py\n\u251c\u2500\u2500 \ud83d\udcc1 _d3js\n\u2502   \u2514\u2500\u2500 \ud83d\udcc4 ...\n\u251c\u2500\u2500 \ud83d\udcc1 _matplotlib\n\u2502   \u2514\u2500\u2500 \ud83d\udcc4 ...\n\u251c\u2500\u2500 \ud83d\udcc1 _tikz\n\u2502   \u2514\u2500\u2500 \ud83d\udcc4 ...\n\u251c\u2500\u2500 \ud83d\udcc4 layout.py\n\u251c\u2500\u2500 \ud83d\udcc4 network_plots.py\n\u251c\u2500\u2500 \ud83d\udcc4 plot.py\n\u2514\u2500\u2500 \ud83d\udcc4 utils.py\n</code></pre> <p>Folders with <code>_...</code> indicate the supported backends. We will have a look at them later.</p> <p>The <code>layout.py</code> file includes algorithms to calculate the positions of the nodes.</p> <p>In the <code>utils.py</code> file are useful helper functions collected. E.g. among others a function that converts <code>hex_to_rgb</code>, <code>rgb_to_hex</code>, or a simple <code>Colormap</code> class. If your plot needs generic functions which might be helpful for other plots as well, this would be a good place to store them.</p> <p>The <code>network_plots.py</code> file includes all plots related to network visualization. We will create in this tutorial a similar collection for histograms.</p> <p>Finally, the <code>plot.py</code> file contains our generic <code>PathPyPlot</code> class which we will use to build our own class. </p> <p>This abstract class has a property <code>_kind</code> which will specify the type of plot for the generic plot function. Similar to <code>pandas</code> we should be able to call:</p> <pre><code>pp.plot(graph, kind=\"hist\")\n</code></pre> <p>This abstract class has two dict variables <code>self.data</code> and <code>self.config</code>. The <code>self.data</code> variable is used to store the data needed for the plot, while the <code>self.config</code> stores all the configurations passed to the plot.</p> <p>Furthermore this class has three abstract methods we have to define later for our supported backends: <code>generate</code> to generate the plot, <code>save</code> to save the plot to a file, <code>show</code> to show the current plot.</p>"},{"location":"plot_tutorial/#lets-get-started","title":"Let's get started","text":"<p>In order to get started, we have to create a new python file where we will store our histogram plots. So let's generate a new file <code>hist_plots.py</code></p> <pre><code>touch hist_plots.py\n</code></pre> <p>We start with creating a function which allows us later to plot a histogram.</p> <p>This function will take a <code>Graph</code> object as input and has the parameters <code>key</code> and <code>bins</code> as well as a dict of <code>kwargs</code> for furthermore specifications.</p> <p>We will use the <code>key</code> variable to define the data type of the histogram e.g. <code>by='betweenes'</code> to get the betweenes centrality plotted. With the <code>bins</code> parameters we will change the amount of bins in the histogram. all other options will by passed to the function as keyword arguments and can be backend specific.</p> <pre><code>\"\"\"Histogram plot classes.\"\"\"\nfrom __future__ import annotations\n\nimport logging\n\nfrom typing import TYPE_CHECKING, Any\n\n# pseudo load class for type checking\nif TYPE_CHECKING:\n    from pathpyG.core.Graph import Graph\n\n# create logger\nlogger = logging.getLogger(\"pathpyG\")\n\n\ndef hist(network: Graph, key: str = 'degree', bins: int = 10, **kwargs: Any) -&gt; HistogramPlot:\n    \"\"\"Plot a histogram.\"\"\"\n    return HistogramPlot(network, key, bins, **kwargs)\n</code></pre> <p>pathpyG is using logging to print out messages and errors. It's a good habit to use it also for your plotting function.</p> <p>Our <code>hist</code> function will be callable via the package. e.g. <code>pp.hist(...)</code>. Itself it will return a plotting class which we have to create.</p> <pre><code>from pathpyG.visualisations.plot import PathPyPlot\n\nclass HistogramPlot(PathPyPlot):\n    \"\"\"Histogram plot class for a network properties.\"\"\"\n\n    _kind = \"hist\"\n\n    def __init__(self, network: Graph, key: str = 'degree', bins: int = 10, **kwargs: Any) -&gt; None:\n        \"\"\"Initialize network plot class.\"\"\"\n        super().__init__()\n        self.network = network\n        self.config = kwargs\n        self.config['bins'] = bins\n        self.config['key'] = key\n        self.generate()\n\n    def generate(self) -&gt; None:\n        \"\"\"Generate the plot.\"\"\"\n        logger.debug(\"Generate histogram.\")\n</code></pre> <p>The <code>HistogramPlot</code> plotting class is a child from our abstract <code>PathPyPlot</code> function. We will overwrite the abstract <code>generate()</code> function in order to get the data needed for our plot.</p> <p>By convention we assume <code>d3js</code> will be the default plot backend, hence the final data generated by this function should provide the necessary data structure for this backend. </p> <p>For other backends, this data might be needed to be converted e.g. keywords might be different. We will address this later in our tutorial.</p>"},{"location":"plot_tutorial/#testing-testing-testing","title":"Testing, Testing, Testing","text":"<p>Before we start developing our histogram plot, we should set up a test environment so that we can directly develop the unit test next to our plot function.</p> <p>Therefore we are going to our testing folder an create a new test file.</p> <pre><code>cd ../../../tests/\ntouch test_hist.py\n</code></pre> <p>Now we can create a simple test environment with a simple graph and call our <code>hist(...)</code> function.</p> <pre><code>from pathpyG.core.Graph import Graph\nfrom pathpyG.visualisations.hist_plots import hist\n\n\ndef test_hist_plot() -&gt; None:\n    \"\"\"Test to plot a histogram.\"\"\"\n    net = Graph.from_edge_list([[\"a\", \"b\"], [\"b\", \"c\"], [\"a\", \"c\"]])\n    hist(net)\n</code></pre> <p>Note: If you only want to run this function and not all other test you can use:</p> <pre><code>pytest -s -k 'test_hist_plot'\n</code></pre>"},{"location":"plot_tutorial/#generating-the-plot-data","title":"Generating the plot data","text":"<p>To plot our histogram we first have to generate the required data from our graph.</p> <p>In the future we might want to add more options for histograms, hence we use the <code>match</code>-<code>case</code> function form python.</p> <pre><code>    def generate(self) -&gt; None:\n        \"\"\"Generate the plot.\"\"\"\n        logger.debug(\"Generate histogram.\")\n\n        data: dict = {}\n\n        match self.config[\"key\"]:\n            case \"indegrees\":\n                logger.debug(\"Generate data for in-degrees\")\n                data[\"values\"] = list(self.network.degrees(mode=\"in\").values())\n            case \"outdegrees\":\n                logger.debug(\"Generate data for out-degrees\")\n                data[\"values\"] = list(self.network.degrees(mode=\"out\").values())\n            case _:\n                logger.error(\n                    f\"The &lt;{self.config['key']}&gt; property\",\n                    \"is currently not supported for hist plots.\",\n                )\n                raise KeyError\n\n        data[\"title\"] = self.config[\"key\"]\n        self.data[\"data\"] = data\n</code></pre> <p>First we initialize a dictionary <code>data</code> to store our values. In this case we are interested in the in and out-degrees of our graph, which are already implemented in <code>pathpyG</code> (state 2023-11-26). </p> <p>If the keyword is not supported the function will raise a <code>KeyError</code>.</p> <p>To provide a default title for our plot we also store the keyword in the data dict. If further data is required for the plot it can be stored here.</p> <p>Finally, we add the data dict to our <code>self.data</code> variable of the plotting class. This variable will be used later in the backend classes.</p> <p>With this our basic histogram plot function is finished. We are now able to call the plot function, get the data from our graph and create a data-set which can be passed down to the backend for visualization.</p>"},{"location":"plot_tutorial/#the-matplotlib-backend","title":"The matplotlib backend","text":"<p>Let's open the <code>_matplotlib</code> folder located under <code>/src/pathpyG/visualisation/_matplotlib</code>, where all matplotlib functions are stored.</p> <pre><code>\ud83d\udcc1 _matplotlib\n\u251c\u2500\u2500 \ud83d\udcc4 __init__.py\n\u251c\u2500\u2500 \ud83d\udcc4 core.py\n\u2514\u2500\u2500 \ud83d\udcc4 network_plots.py\n</code></pre> <p>The <code>_init_.py</code> holds the configuration for the plot function, which we will modify later. The <code>core.py</code> file contains the generic <code>MatplotlibPlot</code> class, which provides <code>save</code> and <code>show</code> functionalities for our plots. We do not need to modify these functions. Instead, we have to generate a translation function from our generic data dict (see above) to a histogram in matplotlib. To do so, lets create first a new python file named <code>hist_plots.py</code></p> <pre><code>cd _matplotlib\ntouch hist_plots.py\n</code></pre> <p>Here we will add our missing piece for a functional matplotlib plot.</p> <pre><code>\"\"\"Histogram plot classes.\"\"\"\nfrom __future__ import annotations\n\nimport logging\n\nfrom typing import TYPE_CHECKING, Any\n\n# pseudo load class for type checking\nif TYPE_CHECKING:\n    from pathpyG.core.Graph import Graph\n\n# create logger\nlogger = logging.getLogger(\"pathpyG\")\n\n\ndef hist(network: Graph, key: str = 'degree', bins: int = 10, **kwargs: Any) -&gt; HistogramPlot:\n    \"\"\"Plot a histogram.\"\"\"\n    return HistogramPlot(network, key, bins, **kwargs)\n</code></pre>"},{"location":"tutorial/","title":"Overview","text":"<p>This will be an overview page of all tutorials.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>pathpyG<ul> <li>algorithms<ul> <li>centrality</li> <li>temporal</li> </ul> </li> <li>core<ul> <li>Graph</li> <li>HigherOrderGraph</li> <li>PathData</li> <li>TemporalGraph</li> </ul> </li> <li>io<ul> <li>netzschleuder</li> </ul> </li> <li>nn<ul> <li>dbgnn</li> </ul> </li> <li>utils<ul> <li>config</li> <li>progress</li> </ul> </li> <li>visualisations<ul> <li>_d3js<ul> <li>core</li> <li>network_plots</li> </ul> </li> <li>_matplotlib<ul> <li>core</li> <li>network_plots</li> </ul> </li> <li>_tikz<ul> <li>core</li> <li>network_plots</li> </ul> </li> <li>hist_plots</li> <li>layout</li> <li>network_plots</li> <li>plot</li> <li>utils</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/pathpyG/","title":"pathpyG","text":"<p>pathpyG is an Open Source package facilitating next-generation network analytics and graph learning for time series data on graphs.</p> <p>Building on the industry-proven data structures and concepts of <code>pytorch</code> and <code>torch_geometric</code>, pathpyG makes it easier than ever to apply machine learning to temporal graph data.</p> <p>pathpyG is jointly developed at University of Wuerzburg, Princeton University, and University of Zurich. The research behind pathpyG has been funded by the Swiss National Science Foundation via  grant 176938.</p>"},{"location":"reference/pathpyG/algorithms/","title":"algorithms","text":"<p>Algorithms for temporal path calculation and graph metrics.</p> <p>The functions and submodules in this module allow to compute  time-respecting or causal paths in temporal graphs and to calculate (temporal) and higher-order graph metrics like centralities.</p> Example <pre><code># Import pathpyG and configure your torch device if you want to use GPU .\nimport pathpyG as pp\npp.config['torch']['device'] = 'cuda'\n\n# Generate a toy example for a temporal graph.\ng = pp.TemporalGraph.from_edge_list([\n    ['b', 'c', 2],\n    ['a', 'b', 1],\n    ['c', 'd', 3],\n    ['d', 'a', 4],\n    ['b', 'd', 2],\n    ['d', 'a', 6],\n    ['a', 'b', 7]\n])\n\n# Extract DAG capturing causal interaction sequences in temporal graph.\ndag = pp.algorithms.temporal_graph_to_event_dag(g, delta=1)\n\n# Get path object to calculate statistics.\npaths = pp.PathData.from_temporal_dag(dag)\n\n# Generate time-aggregated static representation of temporal graph\ns = g.to_static_graph()\n\n# Calculate centrality on static graph using networkx\nc = pp.algorithms.centrality.closeness_centrality(s)\n</code></pre>"},{"location":"reference/pathpyG/algorithms/centrality/","title":"centrality","text":"<p>Algorithms to calculate centralities in (temporal) graphs.</p> <p>The functions and submodules in this module allow to compute  time-respecting or causal paths in temporal graphs and to calculate (temporal) and higher-order graph metrics like centralities.</p> Example <pre><code># Import pathpyG and configure your torch device if you want to use GPU acceleration.\nimport pathpyG as pp\npp.config['torch']['device'] = 'cuda'\n\n# Generate toy example for temporal graph\ng = pp.TemporalGraph.from_edge_list([\n    ['b', 'c', 2],\n    ['a', 'b', 1],\n    ['c', 'd', 3],\n    ['d', 'a', 4],\n    ['b', 'd', 2],\n    ['d', 'a', 6],\n    ['a', 'b', 7]\n])\n\n# Extract DAG capturing causal interaction sequences in temporal graph\ndag = pp.algorithms.temporal_graph_to_event_dag(g, delta=1)\n\n# Get path object to calculate statistics.\npaths = pp.PathData.from_temporal_dag(dag)\n\n# Generate weighted (first-order) time-aggregated graph\ng = pp.HigherOrderGraph(paths, order=1)\n\n# Call networkx function `closeness_centrality` on graph\nc = pp.algorithms.centrality.closeness_centrality(g)\n</code></pre>"},{"location":"reference/pathpyG/algorithms/centrality/#pathpyG.algorithms.centrality.__getattr__","title":"<code>__getattr__</code>","text":"<p>Map to corresponding functions in centrality module of networkx.</p> <p>Any call to a function that is not implemented in the module centrality and whose first argument is of type Graph will be delegated to the corresponding function in the networkx module <code>centrality</code>. Please refer to the networkx documentation for a reference of available functions.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the function that shall be called</p> required Source code in <code>src/pathpyG/algorithms/centrality.py</code> <pre><code>def __getattr__(name: str) -&gt; Any:\n    \"\"\"Map to corresponding functions in centrality module of networkx.\n\n    Any call to a function that is not implemented in the module centrality\n    and whose first argument is of type Graph will be delegated to the\n    corresponding function in the networkx module `centrality`. Please\n    refer to the [networkx documentation](https://networkx.org/documentation/stable/reference/algorithms/centrality.html)\n    for a reference of available functions.\n\n    Args:\n        name: the name of the function that shall be called\n    \"\"\"\n    def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n        if len(args) == 0:\n            raise RuntimeError(f'Did not find method {name} with no arguments')\n        if isinstance(args[0], TemporalGraph):\n            raise NotImplementedError(f'Missing implementation of {name} for temporal graphs')\n        # if first argument is of type Graph, delegate to networkx function    \n        if isinstance(args[0], Graph):\n            g = to_networkx(args[0].data)\n            r = getattr(centrality, name)(g, *args[1:], **kwargs)\n            if name.index('centrality') &gt; 0 and isinstance(r, dict):\n                return map_to_nodes(args[0], r)\n            return r\n        else:\n            return wrapper(*args, **kwargs)\n            #raise RuntimeError(f'Did not find method {name} that accepts first argument of type {type(args[0])}')\n    return wrapper\n</code></pre>"},{"location":"reference/pathpyG/algorithms/centrality/#pathpyG.algorithms.centrality.map_to_nodes","title":"<code>map_to_nodes</code>","text":"<p>Map node-level centralities in dictionary to node IDs.</p> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>pathpyG.Graph</code> <p>Graph object</p> required <code>c</code> <code>typing.Dict</code> <p>dictionary mapping node indices to metrics</p> required Example <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; g = pp.Graph(torch.LongTensor([[1, 1, 2], [0, 2, 1]]),\n...                               node_id=['a', 'b', 'c'])\n&gt;&gt;&gt; c = {0: 0.5, 1: 2.7, 2: 0.3}\n&gt;&gt;&gt; c_mapped = pp.algorithms.centrality.map_to_nodes(g, c)\n&gt;&gt;&gt; print(c_mapped)\n{'a': 0.5, 'b': 2.7, 'c': 0.3}\n</code></pre> Source code in <code>src/pathpyG/algorithms/centrality.py</code> <pre><code>def map_to_nodes(g: Graph, c: Dict) -&gt; Dict:\n    \"\"\"Map node-level centralities in dictionary to node IDs.\n\n    Args:\n        g: Graph object\n        c: dictionary mapping node indices to metrics\n\n    Example:\n        ```pycon\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; g = pp.Graph(torch.LongTensor([[1, 1, 2], [0, 2, 1]]),\n        ...                               node_id=['a', 'b', 'c'])\n        &gt;&gt;&gt; c = {0: 0.5, 1: 2.7, 2: 0.3}\n        &gt;&gt;&gt; c_mapped = pp.algorithms.centrality.map_to_nodes(g, c)\n        &gt;&gt;&gt; print(c_mapped)\n        {'a': 0.5, 'b': 2.7, 'c': 0.3}\n        ```\n    \"\"\"\n    if len(g.node_index_to_id) &gt; 0:\n        return {g.node_index_to_id[i]: c[i] for i in c}\n\n    return c\n</code></pre>"},{"location":"reference/pathpyG/algorithms/centrality/#pathpyG.algorithms.centrality.path_betweenness_centrality","title":"<code>path_betweenness_centrality</code>","text":"<p>Calculates the betweenness of nodes based on observed shortest paths between all pairs of nodes</p>"},{"location":"reference/pathpyG/algorithms/centrality/#pathpyG.algorithms.centrality.path_betweenness_centrality--parameters","title":"Parameters","text":"<p>paths:     Paths object normalized: bool     normalize such that largest value is 1.0</p>"},{"location":"reference/pathpyG/algorithms/centrality/#pathpyG.algorithms.centrality.path_betweenness_centrality--returns","title":"Returns","text":"<p>dict</p> Source code in <code>src/pathpyG/algorithms/centrality.py</code> <pre><code>def path_betweenness_centrality(paths, normalized=False):\n    \"\"\"Calculates the betweenness of nodes based on observed shortest paths\n    between all pairs of nodes\n\n    Parameters\n    ----------\n    paths:\n        Paths object\n    normalized: bool\n        normalize such that largest value is 1.0\n\n    Returns\n    -------\n    dict\n    \"\"\"\n    # assert isinstance(paths, pp.PathData), \"argument must be an instance of pathpy.Paths\"\n    node_centralities = defaultdict(lambda: 0)\n\n    # Log.add('Calculating betweenness in paths ...', Severity.INFO)\n\n    all_paths = shortest_paths(paths)\n\n    for s in all_paths:\n        for d in all_paths[s]:\n            for p in all_paths[s][d]:\n                for x in p[1:-1]:\n                    if s != d != x:\n                        node_centralities[x.item()] += 1.0 / len(all_paths[s][d])\n    if normalized:\n        max_centr = max(node_centralities.values())\n        for v in node_centralities:\n            node_centralities[v] /= max_centr\n    # assign zero values to nodes not occurring on shortest paths\n    nodes = [v.item() for v in paths.edge_index.reshape(-1).unique(dim=0)]\n    for v in nodes:\n        node_centralities[v] += 0\n    # Log.add('finished.')\n    return node_centralities\n</code></pre>"},{"location":"reference/pathpyG/algorithms/centrality/#pathpyG.algorithms.centrality.path_closeness_centrality","title":"<code>path_closeness_centrality</code>","text":"<p>Calculates the closeness of nodes based on observed shortest paths between all nodes</p>"},{"location":"reference/pathpyG/algorithms/centrality/#pathpyG.algorithms.centrality.path_closeness_centrality--parameters","title":"Parameters","text":"<p>paths: Paths normalized: bool     normalize such that largest value is 1.0</p>"},{"location":"reference/pathpyG/algorithms/centrality/#pathpyG.algorithms.centrality.path_closeness_centrality--returns","title":"Returns","text":"<p>dict</p> Source code in <code>src/pathpyG/algorithms/centrality.py</code> <pre><code>def path_closeness_centrality(paths, normalized=False):\n    \"\"\"Calculates the closeness of nodes based on observed shortest paths\n    between all nodes\n\n    Parameters\n    ----------\n    paths: Paths\n    normalized: bool\n        normalize such that largest value is 1.0\n\n    Returns\n    -------\n    dict\n    \"\"\"\n    node_centralities = defaultdict(lambda: 0)\n    distances = path_distance_matrix(paths)\n    nodes = [v.item() for v in paths.edge_index.reshape(-1).unique(dim=0)] # NOTE: modify once set of nodes can be obtained from path obeject\n\n    for x in nodes:\n        # calculate closeness centrality of x\n        for d in nodes:\n            if x != d and distances[d][x] &lt; _np.inf:\n                node_centralities[x] += 1.0 / distances[d][x]\n\n    # assign zero values to nodes not occurring\n\n    for v in nodes:\n        node_centralities[v] += 0.0\n\n    if normalized:\n        m = max(node_centralities.values())\n        for v in nodes:\n            node_centralities[v] /= m\n\n    return node_centralities\n</code></pre>"},{"location":"reference/pathpyG/algorithms/centrality/#pathpyG.algorithms.centrality.path_distance_matrix","title":"<code>path_distance_matrix</code>","text":"<p>Calculates shortest path distances between all pairs of nodes based on the observed shortest paths (and subpaths)</p> Source code in <code>src/pathpyG/algorithms/centrality.py</code> <pre><code>def path_distance_matrix(paths):\n    \"\"\"\n    Calculates shortest path distances between all pairs of\n    nodes based on the observed shortest paths (and subpaths)\n    \"\"\"\n    dist = defaultdict(lambda: defaultdict(lambda: _np.inf))\n    # Log.add('Calculating distance matrix based on empirical paths ...', Severity.INFO)\n    nodes = [v.item() for v in paths.edge_index.reshape(-1).unique(dim=0)] # NOTE: modify once set of nodes can be obtained from path obeject\n    for v in nodes:\n        dist[v][v] = 0\n\n    p_length = 1\n    index, edge_weights = paths.edge_index_k_weighted(k=p_length)\n    sources = index[0]\n    destinations = index[-1]\n    for e, (s, d) in enumerate(zip(sources, destinations)):\n        s = s.item()\n        d = d.item()\n        dist[s][d] = p_length\n        # s_p[s][d] = set({torch.tensor([s,d])})\n    p_length += 1\n    while True: # until max path length\n        try:\n            index, edge_weights = paths.edge_index_k_weighted(k=p_length)\n            sources = index[0, :, 0]\n            destinations = index[1, :, -1]\n            for e, (s, d) in enumerate(zip(sources, destinations)):\n                s = s.item()\n                d = d.item()\n                if p_length &lt; dist[s][d]:\n                    # update shortest path length\n                    dist[s][d] = p_length\n            p_length += 1\n        except IndexError:\n            print(f\"IndexError occurred. Reached maximum path length of {p_length}\")\n            break\n    return dist\n</code></pre>"},{"location":"reference/pathpyG/algorithms/centrality/#pathpyG.algorithms.centrality.path_node_traversals","title":"<code>path_node_traversals</code>","text":"<p>Calculate the number of times any path traverses each of the nodes.</p>"},{"location":"reference/pathpyG/algorithms/centrality/#pathpyG.algorithms.centrality.path_node_traversals--parameters","title":"Parameters","text":"<p>paths: Paths</p>"},{"location":"reference/pathpyG/algorithms/centrality/#pathpyG.algorithms.centrality.path_node_traversals--returns","title":"Returns","text":"<p>dict</p> Source code in <code>src/pathpyG/algorithms/centrality.py</code> <pre><code>def path_node_traversals(paths):\n    \"\"\"Calculate the number of times any path traverses each of the nodes.\n\n    Parameters\n    ----------\n    paths: Paths\n\n    Returns\n    -------\n    dict\n    \"\"\"\n    traversals = defaultdict(lambda: 0)\n    for path_id, path_edgelist in paths.paths.items():\n        path_seq = paths.walk_to_node_seq(path_edgelist)\n        for node in path_seq:\n            traversals[node.item()] += paths.path_freq[path_id]\n    return traversals\n</code></pre>"},{"location":"reference/pathpyG/algorithms/centrality/#pathpyG.algorithms.centrality.path_visitation_probabilities","title":"<code>path_visitation_probabilities</code>","text":"<p>Calculates the probabilities that a randomly chosen path passes through each of the nodes. If 5 out of 100 paths (of any length) traverse node v, node v will be assigned a visitation probability of 0.05. This measure can be interpreted as ground truth for the notion of importance captured by PageRank applied to a graphical abstraction of the paths.</p>"},{"location":"reference/pathpyG/algorithms/centrality/#pathpyG.algorithms.centrality.path_visitation_probabilities--parameters","title":"Parameters","text":"<p>paths: Paths</p>"},{"location":"reference/pathpyG/algorithms/centrality/#pathpyG.algorithms.centrality.path_visitation_probabilities--returns","title":"Returns","text":"<p>dict</p> Source code in <code>src/pathpyG/algorithms/centrality.py</code> <pre><code>def path_visitation_probabilities(paths):\n    \"\"\"Calculates the probabilities that a randomly chosen path passes through each of\n    the nodes. If 5 out of 100 paths (of any length) traverse node v, node v will be\n    assigned a visitation probability of 0.05. This measure can be interpreted as ground\n    truth for the notion of importance captured by PageRank applied to a graphical\n    abstraction of the paths.\n\n    Parameters\n    ----------\n    paths: Paths\n\n    Returns\n    -------\n    dict\n    \"\"\"\n    # if not isinstance(paths, PathData):\n    #    assert False, \"`paths` must be an instance of Paths\"\n    # Log.add('Calculating visitation probabilities...', Severity.INFO)\n\n    # entries capture the probability that a given node is visited on an arbitrary path\n    # Note: this is identical to the subpath count of zero-length paths\n    # (i.e. the relative frequencies of nodes across all pathways)\n    visit_probabilities = path_node_traversals(paths)\n\n    # total number of visits\n    visits = 0.0\n    for v in visit_probabilities:\n        visits += visit_probabilities[v]\n\n    for v in visit_probabilities:\n        visit_probabilities[v] /= visits\n    # Log.add('finished.', Severity.INFO)\n    return visit_probabilities\n</code></pre>"},{"location":"reference/pathpyG/algorithms/centrality/#pathpyG.algorithms.centrality.shortest_paths","title":"<code>shortest_paths</code>","text":"<p>Calculates all shortest paths between all pairs of nodes  based on a set of empirically observed paths.</p> Source code in <code>src/pathpyG/algorithms/centrality.py</code> <pre><code>def shortest_paths(paths):\n    \"\"\"\n    Calculates all shortest paths between all pairs of nodes \n    based on a set of empirically observed paths.\n    \"\"\"\n    s_p = defaultdict(lambda: defaultdict(set))\n    s_p_lengths = defaultdict(lambda: defaultdict(lambda: _np.inf))\n\n    p_length = 1\n    index, edge_weights = paths.edge_index_k_weighted(k=p_length)\n    sources = index[0]\n    destinations = index[-1]\n    for e, (s, d) in enumerate(zip(sources, destinations)):\n        s = s.item()\n        d = d.item()\n        s_p_lengths[s][d] = p_length\n        s_p[s][d] = set({tensor([s, d])})\n    p_length += 1\n    while True: # until max path length\n        try:\n            index, edge_weights = paths.edge_index_k_weighted(k=p_length)\n            sources = index[0, :, 0]\n            destinations = index[1, :, -1]\n            for e, (s, d) in enumerate(zip(sources, destinations)):\n                s = s.item()\n                d = d.item()\n                if p_length &lt; s_p_lengths[s][d]:\n                    # update shortest path length\n                    s_p_lengths[s][d] = p_length\n                    # redefine set\n                    s_p[s][d] = {paths.walk_to_node_seq(index[:, e])}\n                elif p_length == s_p_lengths[s][d]:\n                    s_p[s][d].add(paths.walk_to_node_seq(index[:, e]))\n            p_length += 1\n        except IndexError:\n            # print(f\"IndexError occurred. Reached maximum path length of {p_length}\")\n            break\n    return s_p\n</code></pre>"},{"location":"reference/pathpyG/algorithms/temporal/","title":"temporal","text":"<p>Algorithms for the analysis of causal path structures in temporal graphs.</p>"},{"location":"reference/pathpyG/algorithms/temporal/#pathpyG.algorithms.temporal.extract_causal_trees","title":"<code>extract_causal_trees</code>","text":"<p>Extract all causally isolated trees from a directed acyclic event graph.</p> <p>For a directed acyclic graph where all events are related to single root event, this function will return a single tree. For other DAGs, it will return multiple trees such that each root in the tree is not causally influenced by any other node-time event.</p> <p>Parameters:</p> Name Type Description Default <code>dag</code> <code>pathpyG.Graph</code> <p>the event graph to process</p> required Source code in <code>src/pathpyG/algorithms/temporal.py</code> <pre><code>def extract_causal_trees(dag: Graph) -&gt; Dict[Union[int, str], torch.IntTensor]:\n    \"\"\"Extract all causally isolated trees from a directed acyclic event graph.\n\n    For a directed acyclic graph where all events are related to single root\n    event, this function will return a single tree. For other DAGs, it will return\n    multiple trees such that each root in the tree is not causally influenced by\n    any other node-time event.\n\n    Args:\n        dag: the event graph to process\n    \"\"\"\n    causal_trees = {}\n    d = dag.degrees(mode='in')\n    for v in d:\n        if d[v] == 0:\n            # print('Processing root', v)\n\n            src: List[int] = []\n            dst: List[int] = []\n\n            visited = set()\n            queue = [v]\n\n            while queue:\n                x = queue.pop()\n                for w in dag.successors(x):\n                    if w not in visited:\n                        visited.add(w)\n                        queue.append(w)\n                        if len(dag.node_id_to_index) &gt; 0:\n                            src.append(dag.node_id_to_index[x])\n                            dst.append(dag.node_id_to_index[w])\n                        else:\n                            src.append(x)\n                            dst.append(w)\n            # TODO: Remove redundant zero-degree neighbors of all nodes\n            causal_trees[v] = torch.IntTensor([src, dst]).to(config['torch']['device'])\n    return causal_trees\n</code></pre>"},{"location":"reference/pathpyG/algorithms/temporal/#pathpyG.algorithms.temporal.temporal_graph_to_event_dag","title":"<code>temporal_graph_to_event_dag</code>","text":"<p>Create directed acyclic event graph where nodes are node-time events and edges are time-respecting paths.</p> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>pathpyG.TemporalGraph</code> <p>the temporal graph to be convered to an event dag</p> required <code>delta</code> <code>float</code> <p>for a maximum time difference delta two consecutive interactions      (u, v; t) and (v, w; t') are considered to contribute to a causal     path from u via v to w iff t'-t &lt;= delta</p> <code>numpy.infty</code> <code>sparsify</code> <code>bool</code> <p>whether not to add edges for time-respecting paths between same nodes for multiple inter-event times</p> <code>True</code> Source code in <code>src/pathpyG/algorithms/temporal.py</code> <pre><code>def temporal_graph_to_event_dag(g: TemporalGraph, delta: float = np.infty,\n                                sparsify: bool = True) -&gt; Graph:\n    \"\"\"Create directed acyclic event graph where nodes are node-time events and edges are time-respecting paths.\n\n        Args:\n            g: the temporal graph to be convered to an event dag\n            delta: for a maximum time difference delta two consecutive interactions \n                    (u, v; t) and (v, w; t') are considered to contribute to a causal\n                    path from u via v to w iff t'-t &lt;= delta\n            sparsify: whether not to add edges for time-respecting paths\n                between same nodes for multiple inter-event times\n    \"\"\"\n    edge_list = []\n    node_names = {}\n    edge_times = []\n\n    sources = defaultdict(set)\n\n    for v, _w, t in g.temporal_edges:\n        sources[t].add(v)\n\n    for v, w, t in g.temporal_edges:\n\n        if delta &lt; np.infty:\n            current_delta = int(delta)\n        else:\n            current_delta = g.end_time - g.start_time\n\n        event_src = f\"{v}-{t}\"\n        node_names[event_src] = v\n\n        # create one time-unfolded link for all delta in [1, delta]\n        # this implies that for delta = 2 and an edge (a,b,1) two\n        # time-unfolded links (a_1, b_2) and (a_1, b_3) will be created\n        cont = False\n        for x in range(1, int(current_delta)+1):\n\n            # only add edge to event DAG if an edge (w,*) continues a time-respecting path at time t+x\n            if w in sources[t+x] or not sparsify:\n                event_dst = \"{0}-{1}\".format(w, t+x)\n                node_names[event_dst] = w\n                edge_list.append([event_src, event_dst])\n                edge_times.append(t)\n                cont = True\n        if not cont and sparsify:  # if there is no continuing time-respecting path, include edge to t+1\n            event_dst = \"{0}-{1}\".format(w, t+1)\n            node_names[event_dst] = w\n            edge_list.append([event_src, event_dst])\n            edge_times.append(t)\n\n    dag = Graph.from_edge_list(edge_list)\n    dag.data['node_name'] = [node_names[dag.node_index_to_id[v]] for v in range(dag.N)]\n    dag.data['node_idx'] = [g.node_id_to_index[v] for v in dag.data['node_name']]\n    dag.data['edge_ts'] = torch.tensor(edge_times)\n    return dag\n</code></pre>"},{"location":"reference/pathpyG/core/","title":"core","text":"<p>Core classes for (temporal) graphs, paths, and higher-order De Bruijn graphs.</p> <p>The classes in the <code>core</code> module can be used to implement integrated pipelines to preprocess time-stamped network data, do inference and model selection of higher-order De Bruijn graph models and address temporal graph learning tasks based on time-aware graph neural networks.</p> Example <pre><code>import pathpyG as pp\npp.config['torch']['device'] = 'cuda'\n\n# Generate toy example for temporal graph\ng = pp.TemporalGraph.from_edge_list([\n    ['b', 'c', 2],\n    ['a', 'b', 1],\n    ['c', 'd', 3],\n    ['d', 'a', 4],\n    ['b', 'd', 2],\n    ['d', 'a', 6],\n    ['a', 'b', 7]])\n\n# Extract DAG capturing causal interaction sequences in temporal graph\ndag = pp.algorithms.temporal_graph_to_event_dag(g, delta=1)\n\n# Calculate path statistics\npaths = pp.PathData.from_temporal_dag(dag)\n\n# Compute first- and second-order De Bruijn graph model\ng1 = pp.HigherOrderGraph(paths, order=1, node_id=g.data[\"node_id\"])\ng2 = pp.HigherOrderGraph(paths, order=2, node_id=g.data[\"node_id\"])\n</code></pre>"},{"location":"reference/pathpyG/core/Graph/","title":"Graph","text":""},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph","title":"<code>Graph</code>","text":"<p>A graph object storing nodes, edges, and attributes.</p> <p>An object than be be used to store directed or undirected graphs with node and edge attributes. Data on nodes and edges are stored in an underlying instance of <code>torch_geometric.Data</code>.</p> Source code in <code>src/pathpyG/core/Graph.py</code> <pre><code>class Graph:\n    \"\"\"\n    A graph object storing nodes, edges, and attributes.\n\n    An object than be be used to store directed or undirected graphs with node\n    and edge attributes. Data on nodes and edges are stored in an underlying instance of\n    [`torch_geometric.Data`](https://pytorch-geometric.readthedocs.io/en/latest/generated/torch_geometric.data.Data.html#torch_geometric.data.Data).\n    \"\"\"\n\n    def __init__(self, edge_index: torch.Tensor,\n                 node_id: Optional[List[str]] = None,\n                 **kwargs: Optional[torch.Tensor]):\n        \"\"\"Generate graph instance from an edge index.\n\n        Generate a Graph instance from a `torch.Tensor` that contains an `edge_index`\n        with optional `node_id` list that maps integer node indices to string node ids.\n\n        Args:\n            edge_index: edge_index containing source and target index of all edges\n            node_id: Optional list of node identifiers\n            **kwargs: Optional keyword arguments that are passed to constructor \n                of [`torch_geometric.Data`](https://pytorch-geometric.readthedocs.io/en/latest/generated/torch_geometric.data.Data.html#torch_geometric.data.Data). \n                Keyword arguments starting with `node_` will be\n                mapped to node attributes, keywords arguments starting with `edge_` will\n                be mapped to edge attributes. Other keyword arguments will be mapped to\n                graph attributes.\n\n        Example:\n            ```py\n            import pathpyG as pp\n\n            g = pp.Graph(torch.LongTensor([[1, 1, 2], [0, 2, 1]]))\n\n            g = pp.Graph(torch.LongTensor([[1, 1, 2], [0, 2, 1]]),\n                                    node_id=['a', 'b', 'c'])\n\n            g = pp.Graph(torch.LongTensor([[1, 1, 2], [0, 2, 1]]),\n                                    node_id=['a', 'b', 'c'],\n                                    node_age=torch.LongTensor([12, 42, 17]),\n                                    edge_weight=torch.FloatTensor([1.0, 2.5, 0.7[]))\n            ```\n        \"\"\"\n        if node_id is None:\n            node_id = []\n\n        assert len(node_id) == len(set(node_id)), \"node_id entries must be unique\"\n\n        # Create pyG Data object\n        if len(node_id) == 0:\n            num_nodes = max(max(edge_index[0]).item(), max(edge_index[1]).item())+1\n            self.data = Data(edge_index=edge_index, node_id=node_id, num_nodes = num_nodes, **kwargs)\n        else:\n            self.data = Data(\n                edge_index=edge_index, node_id=node_id, num_nodes=len(node_id), **kwargs\n            )\n\n        # create mappings between node ids and node indices\n        self.node_index_to_id = dict(enumerate(node_id))\n        self.node_id_to_index = {v: i for i, v in enumerate(node_id)}\n\n        # create mapping between edge tuples and edge indices\n        self.edge_to_index = {\n            (e[0].item(), e[1].item()): i\n            for i, e in enumerate([e for e in edge_index.t()])\n        }\n\n        # initialize adjacency matrix\n        self._sparse_adj_matrix: Any = (\n            torch_geometric.utils.to_scipy_sparse_matrix(self.data.edge_index).tocsr()\n        )\n\n    def add_node_id(self, node_id: List[str]) -&gt; None:\n        \"\"\"Add a mapping of node indices to node IDs.\n\n        Args:\n            node_id: list of string IDs, corresponding to node indices\n        \"\"\"\n        assert len(node_id) == len(set(node_id)), \"node_id entries must be unique\"\n\n        self.node_index_to_id = dict(enumerate(node_id))\n        self.node_id_to_index = {v: i for i, v in enumerate(node_id)}\n        self.data[\"node_id\"] = node_id\n\n    def to_undirected(self) -&gt; None:\n        \"\"\"\n        Transform graph into undirected graph.\n\n        This method transforms the current graph instance into an undirected graph by\n        adding all directed edges in opposite direction. It applies [`ToUndirected`](https://pytorch-geometric.readthedocs.io/en/latest/generated/torch_geometric.transforms.ToUndirected.html#torch_geometric.transforms.ToUndirected)\n        transform to the underlying [`torch_geometric.Data`](https://pytorch-geometric.readthedocs.io/en/latest/generated/torch_geometric.data.Data.html#torch_geometric.data.Data) object, which automatically\n        duplicates edge attributes for newly created directed edges.\n\n        Example:\n            ```py\n            import pathpyG as pp\n            g = pp.Graph(torch.LongTensor([[1, 1, 2], [0, 2, 1]]))\n            g.to_undirected()\n            ```\n        \"\"\"\n        tf = ToUndirected()\n        self.data = tf(self.data)\n\n    @staticmethod\n    def attr_types(attr: Dict) -&gt; Dict:\n        \"\"\"\n        Return name, type, and size of all node, edge, and graph attributes.\n\n        This method returns a dictionary that contains the name (key), as well as\n        the type and size of all attributes.\n        \"\"\"\n        a = {}\n        for k in attr:\n            t = type(attr[k])\n            if t == torch.Tensor:\n                a[k] = str(t) + \" -&gt; \" + str(attr[k].size())\n            else:\n                a[k] = str(t)\n        return a\n\n    def node_attrs(self) -&gt; List:\n        \"\"\"\n        Return a list of node attributes.\n\n        This method returns a list containing the names of all node-level attributes,\n        ignoring the special `node_id` attribute.\n        \"\"\"\n        attrs = []\n        for k in self.data.keys():\n            if k != \"node_id\" and k.startswith(\"node_\"):\n                attrs.append(k)\n        return attrs\n\n    def edge_attrs(self) -&gt; List:\n        \"\"\"\n        Return a list of edge attributes.\n\n        This method returns a list containing the names of all edge-level attributes,\n        ignoring the special `edge_index` attribute.\n        \"\"\"\n        attrs = []\n        for k in self.data.keys():\n            if k != \"edge_index\" and k.startswith(\"edge_\"):\n                attrs.append(k)\n        return attrs\n\n    @property\n    def nodes(self) -&gt; Generator[Union[int, str], None, None]:\n        \"\"\"\n        Return indices or IDs of all nodes in the graph.\n\n        This method returns a generator object that yields all nodes.\n        If `node_id` is used to map node indices to string IDs, nodes\n        are returned as str IDs. If no mapping to IDs is used, nodes\n        are returned as integer indices.\n        \"\"\"\n        if len(self.node_id_to_index) &gt; 0:\n            for v in self.node_id_to_index:\n                yield v\n        else:\n            for v in range(self.N):\n                yield v\n\n    @property\n    def edges(self) -&gt; Generator[Union[Tuple[int, int], Tuple[str, str]], None, None]:\n        \"\"\"\n        Return all edges in the graph.\n\n        This method returns a generator object that yields all edges.\n        If `node_id` is used to map node indices to string IDs, edges\n        are returned as tuples of str IDs. If no mapping to IDs is used, nodes\n        are returned as tuples of integer indices.\n        \"\"\"\n        if len(self.node_index_to_id) &gt; 0:\n            for e in self.data.edge_index.t():\n                yield self.node_index_to_id[e[0].item()], self.node_index_to_id[\n                    e[1].item()\n                ]\n        else:\n            for e in self.data.edge_index.t():\n                yield e[0].item(), e[1].item()\n\n    def successors(self, node: Union[int, str] | tuple) \\\n            -&gt; Generator[Union[int, str] | tuple, None, None]:\n        \"\"\"\n        Return the successors of a given node.\n\n        This method returns a generator object that yields all successors of a\n        given node. If a `node_id` mapping is used, successors will be returned\n        as string IDs. If no mapping is used, successors are returned as indices.\n\n        Args:\n            node:   Index or string ID of node for which successors shall be returned.\n        \"\"\" \n        coo_matrix = self._sparse_adj_matrix.tocoo()      \n        if len(self.node_index_to_id) &gt; 0:\n            # Get array of col indices for which entries in row are non-zero\n            non_zero_cols = coo_matrix.col[coo_matrix.row == self.node_id_to_index[node]]\n            for i in non_zero_cols:  # type: ignore\n                yield self.node_index_to_id[i]\n        else:\n            non_zero_cols = coo_matrix.row[coo_matrix.col == node]\n            for i in non_zero_cols:  # type: ignore\n                yield i\n\n    def predecessors(self, node: Union[str, int] | tuple) \\\n            -&gt; Generator[Union[int, str] | tuple, None, None]:\n        \"\"\"Return the predecessors of a given node.\n\n        This method returns a generator object that yields all predecessors of a\n        given node. If a `node_id` mapping is used, predecessors will be returned\n        as string IDs. If no mapping is used, predecessors are returned as indices.\n\n        Args:\n            node:   Index or string ID of node for which predecessors shall be returned.\n        \"\"\"\n        coo_matrix = self._sparse_adj_matrix.tocoo()      \n        if len(self.node_index_to_id) &gt; 0:\n            # Get array of col indices for which entries in row are non-zero\n            non_zero_rows = coo_matrix.row[coo_matrix.col == self.node_id_to_index[node]]\n            for i in non_zero_rows:  # type: ignore\n                yield self.node_index_to_id[i]\n        else:\n            non_zero_rows = coo_matrix.row[coo_matrix.col == node]\n            for i in non_zero_rows:  # type: ignore\n                yield i\n\n    def is_edge(self, v: Union[str, int], w: Union[str, int]) -&gt; bool:\n        \"\"\"Return whether edge $(v,w)$ exists in the graph.\n\n        If an index to ID mapping is used, nodes are assumed to be string IDs. If no\n        mapping is used, nodes are assumed to be integer indices.\n\n        Args:\n            v: source node of edge as integer index or string ID\n            w: target node of edge as integer index or string ID       \n        \"\"\"\n        if len(self.node_index_to_id) &gt; 0:\n            return self.node_id_to_index[w] in self._sparse_adj_matrix.getrow(self.node_id_to_index[v]).indices  # type: ignore\n        else:\n            return w in self._sparse_adj_matrix.getrow(v).indices  # type: ignore\n\n    def get_sparse_adj_matrix(self, edge_attr: Any = None) -&gt; Any:\n        \"\"\"Return sparse adjacency matrix representation of (weighted) graph.\n\n        Args:\n            edge_attr: the edge attribute that shall be used as edge weight\n        \"\"\"\n        if edge_attr is None:\n            return torch_geometric.utils.to_scipy_sparse_matrix(self.data.edge_index)\n        else:\n            return torch_geometric.utils.to_scipy_sparse_matrix(\n                self.data.edge_index, edge_attr=self.data[edge_attr]\n            )\n\n    @property\n    def in_degrees(self) -&gt; Dict[str, float]:\n        \"\"\"Return in-degrees of nodes in directed network.\"\"\"\n        return self.degrees(mode=\"in\")\n\n    @property\n    def out_degrees(self) -&gt; Dict[str, float]:\n        \"\"\"Return out-degrees of nodes in directed network.\"\"\"\n        return self.degrees(mode=\"out\")\n\n    def degrees(self, mode: str = \"in\") -&gt; Dict[str, float]:\n        \"\"\"\n        Return degrees of nodes.\n\n        Args:\n            mode:   `in` or `out` to calculate the in- or out-degree for\n                directed networks.\n        \"\"\"\n        if mode == \"in\":\n            d = torch_geometric.utils.degree(\n                self.data.edge_index[1], num_nodes=self.N, dtype=torch.int\n            )\n        else:\n            d = torch_geometric.utils.degree(\n                self.data.edge_index[0], num_nodes=self.N, dtype=torch.int\n            )\n        if len(self.node_id_to_index) &gt; 0:\n            return {\n                v: d[self.node_id_to_index[v]].item() for v in self.node_id_to_index\n            }\n        else:\n            return {i: d[i].item() for i in range(self.N)}\n\n    def get_laplacian(self, normalization: Any = None, edge_attr: Any = None) -&gt; Any:\n        \"\"\"Return Laplacian matrix for a given graph.\n\n        This wrapper method will use [`torch_geometric.utils.get_laplacian`](https://pytorch-geometric.readthedocs.io/en/latest/modules/utils.html#torch_geometric.utils.get_laplacian)\n        to return a Laplcian matrix representation of a given graph.\n\n        Args:\n            normalization:  normalization parameter passed to pyG `get_laplacian`\n                            function\n            edge_attr:      optinal name of numerical edge attribute that shall\n                            be passed to pyG `get_laplacian` function as edge weight\n        \"\"\"\n        if edge_attr is None:\n            index, weight =torch_geometric.utils.get_laplacian(\n                self.data.edge_index, normalization=normalization\n            )\n            return torch_geometric.utils.to_scipy_sparse_matrix(index, weight)\n        else:\n            index, weight = torch_geometric.utils.get_laplacian(\n                self.data.edge_index,\n                normalization=normalization,\n                edge_weight=self.data[edge_attr],\n            )\n            return torch_geometric.utils.to_scipy_sparse_matrix(index, weight)\n\n    def add_node_ohe(self, attr_name: str, dim: int = 0) -&gt; None:\n        \"\"\"Add one-hot encoding of nodes to node attribute.\n\n        Args:\n            attr_name: attribute name used to store one-hot encoding\n            dim: dimension of one-hot encoding\n        \"\"\"\n        if dim == 0:\n            dim = self.N\n        self.data[attr_name] = torch.eye(dim, dtype=torch.float).to(\n            config[\"torch\"][\"device\"]\n        )[: self.N]\n\n    def add_edge_ohe(self, attr_name: str, dim: int = 0) -&gt; None:\n        \"\"\"Add one-hot encoding of edges to edge attribute.\n\n        Args:\n            attr_name: attribute name used to store one-hot encoding\n            dim: dimension of one-hot encoding\n        \"\"\"\n        if dim == 0:\n            dim = self.M\n        self.data[attr_name] = torch.eye(dim, dtype=torch.float).to(\n            config[\"torch\"][\"device\"]\n        )[: self.M]\n\n    def __getitem__(self, key: Union[tuple, str]) -&gt; Any:\n        \"\"\"Return node, edge, or graph attribute.\n\n        Args:\n            key: name of attribute to be returned\n        \"\"\"\n        if not isinstance(key, tuple):\n            if key in self.data.keys():\n                return self.data[key]\n            else:\n                print(key, \"is not a graph attribute\")\n                return None\n        elif key[0] in self.node_attrs():\n            if len(self.node_id_to_index) &gt; 0:\n                return self.data[key[0]][self.node_id_to_index[key[1]]]\n            else:\n                return self.data[key[0]][key[1]]\n        elif key[0] in self.edge_attrs():\n            if len(self.node_id_to_index) &gt; 0:\n                return self.data[key[0]][\n                    self.edge_to_index[\n                        self.node_id_to_index[key[1]], self.node_id_to_index[key[2]]\n                    ]\n                ]\n            else:\n                return self.data[key[0]][self.edge_to_index[key[1], key[2]]]\n        elif key in self.data.keys():\n            return self.data[key[0]]\n        else:\n            print(key[0], \"is not a node or edge attribute\")\n            return None\n\n    def __setitem__(self, key: str, val: torch.Tensor) -&gt; None:\n        \"\"\"Store node, edge, or graph attribute.\n\n        Args:\n            key: name of attribute to be stored\n            val: value of attribute\n        \"\"\"\n        if not isinstance(key, tuple):\n            if key in self.data.keys():\n                self.data[key] = val\n            else:\n                print(key, \"is not a graph attribute\")\n        elif self.key[0].starts_with(\"node_\"):  # type: ignore\n            if len(self.node_id_to_index) &gt; 0:\n                self.data[key[0]][self.node_id_to_index[key[1]]] = val\n            else:\n                self.data[key[0]][key[1]] = val\n        elif self.key[0].starts_with(\"edge_\"):  # type: ignore\n            if len(self.node_id_to_index) &gt; 0:\n                self.data[key[0]][\n                    self.edge_to_index[\n                        self.node_id_to_index[key[1]], self.node_id_to_index[key[2]]\n                    ]\n                ] = val\n            else:\n                self.data[key[0]][self.edge_to_index[key[1], key[2]]] = val\n        else:\n            print(key[0], \"is not a node or edge attribute\")\n\n    @property\n    def N(self) -&gt; int:\n        \"\"\"\n        Return number of nodes.\n\n        Returns the number of nodes in the graph.\n        \"\"\"\n        return self.data.num_nodes  # type: ignore\n\n    @property\n    def M(self) -&gt; int:\n        \"\"\"\n        Return number of edges.\n\n        Returns the number of edges in the graph.\n        \"\"\"\n        return self.data.num_edges  # type: ignore\n\n    @staticmethod\n    def from_pyg_data(d: Any) -&gt; Graph:\n        \"\"\"\n        Construct a graph from a [`torch_geometric.Data`](https://pytorch-geometric.readthedocs.io/en/latest/generated/torch_geometric.data.Data.html#torch_geometric.data.Data) object.\n\n        Args:\n            d:  [`torch_geometric.Data`](https://pytorch-geometric.readthedocs.io/en/latest/generated/torch_geometric.data.Data.html#torch_geometric.data.Data) object containing an edge_index as well as \n                arbitrary node, edge, and graph-level attributes\n        \"\"\"\n        x = d.to_dict()\n\n        del x[\"edge_index\"]\n\n        if d.is_node_attr(\"node_id\"):\n            del x[\"node_id\"]\n            g = Graph(d.edge_index, node_id=d[\"node_id\"], **x)\n        else:\n            g = Graph(d.edge_index, node_id=[], **x)\n        return g\n\n    def to_pyg_data(self) -&gt; Any:\n        \"\"\"Return [`torch_geometric.Data`](https://pytorch-geometric.readthedocs.io/en/latest/generated/torch_geometric.data.Data.html#torch_geometric.data.Data) representing the graph with its attributes.\"\"\"\n        return self.data\n\n    def is_directed(self) -&gt; Any:\n        \"\"\"Return whether graph is directed.\"\"\"\n        return self.data.is_directed()\n\n    def is_undirected(self) -&gt; Any:\n        \"\"\"Return whether graph is undirected.\"\"\"\n        return self.data.is_undirected()\n\n    def has_self_loops(self) -&gt; Any:\n        \"\"\"Return whether graph contains self-loops.\"\"\"\n        return self.data.has_self_loops()\n\n    @staticmethod\n    def from_edge_list(edge_list: List[List[str]]) -&gt; Graph:\n        \"\"\"Generate a Graph instance based on an edge list.\n\n        Args:\n            edge_list: List of iterables\n\n        Example:\n            ```py\n            import pathpyG as pp\n\n            l = [['a', 'b'], ['b', 'c'], ['a', 'c']]\n            g = pp.Graph.from_edge_list(l)\n            ```\n        \"\"\"\n        sources = []\n        targets = []\n\n        nodes_index = dict()\n        index_nodes = dict()\n\n        n = 0\n        for v, w in edge_list:\n            if v not in nodes_index:\n                nodes_index[v] = n\n                index_nodes[n] = v\n                n += 1\n            if w not in nodes_index:\n                nodes_index[w] = n\n                index_nodes[n] = w\n                n += 1\n            sources.append(nodes_index[v])\n            targets.append(nodes_index[w])\n\n        return Graph(\n            edge_index=torch.LongTensor([sources, targets]).to(\n                config[\"torch\"][\"device\"]\n            ),\n            node_id=[index_nodes[i] for i in range(n)],\n        )\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the graph.\"\"\"\n\n        attr_types = Graph.attr_types(self.data.to_dict())\n\n        s = \"Graph with {0} nodes and {1} edges\\n\".format(self.N, self.M)\n        if len(self.data.node_attrs()) &gt; 0:\n            s += \"\\nNode attributes\\n\"\n            for a in self.data.node_attrs():\n                s += \"\\t{0}\\t\\t{1}\\n\".format(a, attr_types[a])\n        if len(self.data.edge_attrs()) &gt; 1:\n            s += \"\\nEdge attributes\\n\"\n            for a in self.data.edge_attrs():\n                if a != \"edge_index\":\n                    s += \"\\t{0}\\t\\t{1}\\n\".format(a, attr_types[a])\n        if len(self.data.keys()) &gt; len(self.data.edge_attrs()) + len(\n            self.data.node_attrs()\n        ):\n            s += \"\\nGraph attributes\\n\"\n            for a in self.data.keys():\n                if not self.data.is_node_attr(a) and not self.data.is_edge_attr(a):\n                    s += \"\\t{0}\\t\\t{1}\\n\".format(a, attr_types[a])\n        return s\n</code></pre>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.M","title":"<code>M: int</code>  <code>property</code>","text":"<p>Return number of edges.</p> <p>Returns the number of edges in the graph.</p>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.N","title":"<code>N: int</code>  <code>property</code>","text":"<p>Return number of nodes.</p> <p>Returns the number of nodes in the graph.</p>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.edges","title":"<code>edges: Generator[Union[Tuple[int, int], Tuple[str, str]], None, None]</code>  <code>property</code>","text":"<p>Return all edges in the graph.</p> <p>This method returns a generator object that yields all edges. If <code>node_id</code> is used to map node indices to string IDs, edges are returned as tuples of str IDs. If no mapping to IDs is used, nodes are returned as tuples of integer indices.</p>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.in_degrees","title":"<code>in_degrees: Dict[str, float]</code>  <code>property</code>","text":"<p>Return in-degrees of nodes in directed network.</p>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.nodes","title":"<code>nodes: Generator[Union[int, str], None, None]</code>  <code>property</code>","text":"<p>Return indices or IDs of all nodes in the graph.</p> <p>This method returns a generator object that yields all nodes. If <code>node_id</code> is used to map node indices to string IDs, nodes are returned as str IDs. If no mapping to IDs is used, nodes are returned as integer indices.</p>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.out_degrees","title":"<code>out_degrees: Dict[str, float]</code>  <code>property</code>","text":"<p>Return out-degrees of nodes in directed network.</p>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.__getitem__","title":"<code>__getitem__</code>","text":"<p>Return node, edge, or graph attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>typing.Union[tuple, str]</code> <p>name of attribute to be returned</p> required Source code in <code>src/pathpyG/core/Graph.py</code> <pre><code>def __getitem__(self, key: Union[tuple, str]) -&gt; Any:\n    \"\"\"Return node, edge, or graph attribute.\n\n    Args:\n        key: name of attribute to be returned\n    \"\"\"\n    if not isinstance(key, tuple):\n        if key in self.data.keys():\n            return self.data[key]\n        else:\n            print(key, \"is not a graph attribute\")\n            return None\n    elif key[0] in self.node_attrs():\n        if len(self.node_id_to_index) &gt; 0:\n            return self.data[key[0]][self.node_id_to_index[key[1]]]\n        else:\n            return self.data[key[0]][key[1]]\n    elif key[0] in self.edge_attrs():\n        if len(self.node_id_to_index) &gt; 0:\n            return self.data[key[0]][\n                self.edge_to_index[\n                    self.node_id_to_index[key[1]], self.node_id_to_index[key[2]]\n                ]\n            ]\n        else:\n            return self.data[key[0]][self.edge_to_index[key[1], key[2]]]\n    elif key in self.data.keys():\n        return self.data[key[0]]\n    else:\n        print(key[0], \"is not a node or edge attribute\")\n        return None\n</code></pre>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.__init__","title":"<code>__init__</code>","text":"<p>Generate graph instance from an edge index.</p> <p>Generate a Graph instance from a <code>torch.Tensor</code> that contains an <code>edge_index</code> with optional <code>node_id</code> list that maps integer node indices to string node ids.</p> <p>Parameters:</p> Name Type Description Default <code>edge_index</code> <code>torch.Tensor</code> <p>edge_index containing source and target index of all edges</p> required <code>node_id</code> <code>typing.Optional[typing.List[str]]</code> <p>Optional list of node identifiers</p> <code>None</code> <code>**kwargs</code> <code>typing.Optional[torch.Tensor]</code> <p>Optional keyword arguments that are passed to constructor  of <code>torch_geometric.Data</code>.  Keyword arguments starting with <code>node_</code> will be mapped to node attributes, keywords arguments starting with <code>edge_</code> will be mapped to edge attributes. Other keyword arguments will be mapped to graph attributes.</p> <code>{}</code> Example <pre><code>import pathpyG as pp\n\ng = pp.Graph(torch.LongTensor([[1, 1, 2], [0, 2, 1]]))\n\ng = pp.Graph(torch.LongTensor([[1, 1, 2], [0, 2, 1]]),\n                        node_id=['a', 'b', 'c'])\n\ng = pp.Graph(torch.LongTensor([[1, 1, 2], [0, 2, 1]]),\n                        node_id=['a', 'b', 'c'],\n                        node_age=torch.LongTensor([12, 42, 17]),\n                        edge_weight=torch.FloatTensor([1.0, 2.5, 0.7[]))\n</code></pre> Source code in <code>src/pathpyG/core/Graph.py</code> <pre><code>def __init__(self, edge_index: torch.Tensor,\n             node_id: Optional[List[str]] = None,\n             **kwargs: Optional[torch.Tensor]):\n    \"\"\"Generate graph instance from an edge index.\n\n    Generate a Graph instance from a `torch.Tensor` that contains an `edge_index`\n    with optional `node_id` list that maps integer node indices to string node ids.\n\n    Args:\n        edge_index: edge_index containing source and target index of all edges\n        node_id: Optional list of node identifiers\n        **kwargs: Optional keyword arguments that are passed to constructor \n            of [`torch_geometric.Data`](https://pytorch-geometric.readthedocs.io/en/latest/generated/torch_geometric.data.Data.html#torch_geometric.data.Data). \n            Keyword arguments starting with `node_` will be\n            mapped to node attributes, keywords arguments starting with `edge_` will\n            be mapped to edge attributes. Other keyword arguments will be mapped to\n            graph attributes.\n\n    Example:\n        ```py\n        import pathpyG as pp\n\n        g = pp.Graph(torch.LongTensor([[1, 1, 2], [0, 2, 1]]))\n\n        g = pp.Graph(torch.LongTensor([[1, 1, 2], [0, 2, 1]]),\n                                node_id=['a', 'b', 'c'])\n\n        g = pp.Graph(torch.LongTensor([[1, 1, 2], [0, 2, 1]]),\n                                node_id=['a', 'b', 'c'],\n                                node_age=torch.LongTensor([12, 42, 17]),\n                                edge_weight=torch.FloatTensor([1.0, 2.5, 0.7[]))\n        ```\n    \"\"\"\n    if node_id is None:\n        node_id = []\n\n    assert len(node_id) == len(set(node_id)), \"node_id entries must be unique\"\n\n    # Create pyG Data object\n    if len(node_id) == 0:\n        num_nodes = max(max(edge_index[0]).item(), max(edge_index[1]).item())+1\n        self.data = Data(edge_index=edge_index, node_id=node_id, num_nodes = num_nodes, **kwargs)\n    else:\n        self.data = Data(\n            edge_index=edge_index, node_id=node_id, num_nodes=len(node_id), **kwargs\n        )\n\n    # create mappings between node ids and node indices\n    self.node_index_to_id = dict(enumerate(node_id))\n    self.node_id_to_index = {v: i for i, v in enumerate(node_id)}\n\n    # create mapping between edge tuples and edge indices\n    self.edge_to_index = {\n        (e[0].item(), e[1].item()): i\n        for i, e in enumerate([e for e in edge_index.t()])\n    }\n\n    # initialize adjacency matrix\n    self._sparse_adj_matrix: Any = (\n        torch_geometric.utils.to_scipy_sparse_matrix(self.data.edge_index).tocsr()\n    )\n</code></pre>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.__setitem__","title":"<code>__setitem__</code>","text":"<p>Store node, edge, or graph attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>name of attribute to be stored</p> required <code>val</code> <code>torch.Tensor</code> <p>value of attribute</p> required Source code in <code>src/pathpyG/core/Graph.py</code> <pre><code>def __setitem__(self, key: str, val: torch.Tensor) -&gt; None:\n    \"\"\"Store node, edge, or graph attribute.\n\n    Args:\n        key: name of attribute to be stored\n        val: value of attribute\n    \"\"\"\n    if not isinstance(key, tuple):\n        if key in self.data.keys():\n            self.data[key] = val\n        else:\n            print(key, \"is not a graph attribute\")\n    elif self.key[0].starts_with(\"node_\"):  # type: ignore\n        if len(self.node_id_to_index) &gt; 0:\n            self.data[key[0]][self.node_id_to_index[key[1]]] = val\n        else:\n            self.data[key[0]][key[1]] = val\n    elif self.key[0].starts_with(\"edge_\"):  # type: ignore\n        if len(self.node_id_to_index) &gt; 0:\n            self.data[key[0]][\n                self.edge_to_index[\n                    self.node_id_to_index[key[1]], self.node_id_to_index[key[2]]\n                ]\n            ] = val\n        else:\n            self.data[key[0]][self.edge_to_index[key[1], key[2]]] = val\n    else:\n        print(key[0], \"is not a node or edge attribute\")\n</code></pre>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.__str__","title":"<code>__str__</code>","text":"<p>Return a string representation of the graph.</p> Source code in <code>src/pathpyG/core/Graph.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the graph.\"\"\"\n\n    attr_types = Graph.attr_types(self.data.to_dict())\n\n    s = \"Graph with {0} nodes and {1} edges\\n\".format(self.N, self.M)\n    if len(self.data.node_attrs()) &gt; 0:\n        s += \"\\nNode attributes\\n\"\n        for a in self.data.node_attrs():\n            s += \"\\t{0}\\t\\t{1}\\n\".format(a, attr_types[a])\n    if len(self.data.edge_attrs()) &gt; 1:\n        s += \"\\nEdge attributes\\n\"\n        for a in self.data.edge_attrs():\n            if a != \"edge_index\":\n                s += \"\\t{0}\\t\\t{1}\\n\".format(a, attr_types[a])\n    if len(self.data.keys()) &gt; len(self.data.edge_attrs()) + len(\n        self.data.node_attrs()\n    ):\n        s += \"\\nGraph attributes\\n\"\n        for a in self.data.keys():\n            if not self.data.is_node_attr(a) and not self.data.is_edge_attr(a):\n                s += \"\\t{0}\\t\\t{1}\\n\".format(a, attr_types[a])\n    return s\n</code></pre>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.add_edge_ohe","title":"<code>add_edge_ohe</code>","text":"<p>Add one-hot encoding of edges to edge attribute.</p> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>attribute name used to store one-hot encoding</p> required <code>dim</code> <code>int</code> <p>dimension of one-hot encoding</p> <code>0</code> Source code in <code>src/pathpyG/core/Graph.py</code> <pre><code>def add_edge_ohe(self, attr_name: str, dim: int = 0) -&gt; None:\n    \"\"\"Add one-hot encoding of edges to edge attribute.\n\n    Args:\n        attr_name: attribute name used to store one-hot encoding\n        dim: dimension of one-hot encoding\n    \"\"\"\n    if dim == 0:\n        dim = self.M\n    self.data[attr_name] = torch.eye(dim, dtype=torch.float).to(\n        config[\"torch\"][\"device\"]\n    )[: self.M]\n</code></pre>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.add_node_id","title":"<code>add_node_id</code>","text":"<p>Add a mapping of node indices to node IDs.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>typing.List[str]</code> <p>list of string IDs, corresponding to node indices</p> required Source code in <code>src/pathpyG/core/Graph.py</code> <pre><code>def add_node_id(self, node_id: List[str]) -&gt; None:\n    \"\"\"Add a mapping of node indices to node IDs.\n\n    Args:\n        node_id: list of string IDs, corresponding to node indices\n    \"\"\"\n    assert len(node_id) == len(set(node_id)), \"node_id entries must be unique\"\n\n    self.node_index_to_id = dict(enumerate(node_id))\n    self.node_id_to_index = {v: i for i, v in enumerate(node_id)}\n    self.data[\"node_id\"] = node_id\n</code></pre>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.add_node_ohe","title":"<code>add_node_ohe</code>","text":"<p>Add one-hot encoding of nodes to node attribute.</p> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>attribute name used to store one-hot encoding</p> required <code>dim</code> <code>int</code> <p>dimension of one-hot encoding</p> <code>0</code> Source code in <code>src/pathpyG/core/Graph.py</code> <pre><code>def add_node_ohe(self, attr_name: str, dim: int = 0) -&gt; None:\n    \"\"\"Add one-hot encoding of nodes to node attribute.\n\n    Args:\n        attr_name: attribute name used to store one-hot encoding\n        dim: dimension of one-hot encoding\n    \"\"\"\n    if dim == 0:\n        dim = self.N\n    self.data[attr_name] = torch.eye(dim, dtype=torch.float).to(\n        config[\"torch\"][\"device\"]\n    )[: self.N]\n</code></pre>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.attr_types","title":"<code>attr_types</code>  <code>staticmethod</code>","text":"<p>Return name, type, and size of all node, edge, and graph attributes.</p> <p>This method returns a dictionary that contains the name (key), as well as the type and size of all attributes.</p> Source code in <code>src/pathpyG/core/Graph.py</code> <pre><code>@staticmethod\ndef attr_types(attr: Dict) -&gt; Dict:\n    \"\"\"\n    Return name, type, and size of all node, edge, and graph attributes.\n\n    This method returns a dictionary that contains the name (key), as well as\n    the type and size of all attributes.\n    \"\"\"\n    a = {}\n    for k in attr:\n        t = type(attr[k])\n        if t == torch.Tensor:\n            a[k] = str(t) + \" -&gt; \" + str(attr[k].size())\n        else:\n            a[k] = str(t)\n    return a\n</code></pre>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.degrees","title":"<code>degrees</code>","text":"<p>Return degrees of nodes.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p><code>in</code> or <code>out</code> to calculate the in- or out-degree for directed networks.</p> <code>'in'</code> Source code in <code>src/pathpyG/core/Graph.py</code> <pre><code>def degrees(self, mode: str = \"in\") -&gt; Dict[str, float]:\n    \"\"\"\n    Return degrees of nodes.\n\n    Args:\n        mode:   `in` or `out` to calculate the in- or out-degree for\n            directed networks.\n    \"\"\"\n    if mode == \"in\":\n        d = torch_geometric.utils.degree(\n            self.data.edge_index[1], num_nodes=self.N, dtype=torch.int\n        )\n    else:\n        d = torch_geometric.utils.degree(\n            self.data.edge_index[0], num_nodes=self.N, dtype=torch.int\n        )\n    if len(self.node_id_to_index) &gt; 0:\n        return {\n            v: d[self.node_id_to_index[v]].item() for v in self.node_id_to_index\n        }\n    else:\n        return {i: d[i].item() for i in range(self.N)}\n</code></pre>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.edge_attrs","title":"<code>edge_attrs</code>","text":"<p>Return a list of edge attributes.</p> <p>This method returns a list containing the names of all edge-level attributes, ignoring the special <code>edge_index</code> attribute.</p> Source code in <code>src/pathpyG/core/Graph.py</code> <pre><code>def edge_attrs(self) -&gt; List:\n    \"\"\"\n    Return a list of edge attributes.\n\n    This method returns a list containing the names of all edge-level attributes,\n    ignoring the special `edge_index` attribute.\n    \"\"\"\n    attrs = []\n    for k in self.data.keys():\n        if k != \"edge_index\" and k.startswith(\"edge_\"):\n            attrs.append(k)\n    return attrs\n</code></pre>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.from_edge_list","title":"<code>from_edge_list</code>  <code>staticmethod</code>","text":"<p>Generate a Graph instance based on an edge list.</p> <p>Parameters:</p> Name Type Description Default <code>edge_list</code> <code>typing.List[typing.List[str]]</code> <p>List of iterables</p> required Example <pre><code>import pathpyG as pp\n\nl = [['a', 'b'], ['b', 'c'], ['a', 'c']]\ng = pp.Graph.from_edge_list(l)\n</code></pre> Source code in <code>src/pathpyG/core/Graph.py</code> <pre><code>@staticmethod\ndef from_edge_list(edge_list: List[List[str]]) -&gt; Graph:\n    \"\"\"Generate a Graph instance based on an edge list.\n\n    Args:\n        edge_list: List of iterables\n\n    Example:\n        ```py\n        import pathpyG as pp\n\n        l = [['a', 'b'], ['b', 'c'], ['a', 'c']]\n        g = pp.Graph.from_edge_list(l)\n        ```\n    \"\"\"\n    sources = []\n    targets = []\n\n    nodes_index = dict()\n    index_nodes = dict()\n\n    n = 0\n    for v, w in edge_list:\n        if v not in nodes_index:\n            nodes_index[v] = n\n            index_nodes[n] = v\n            n += 1\n        if w not in nodes_index:\n            nodes_index[w] = n\n            index_nodes[n] = w\n            n += 1\n        sources.append(nodes_index[v])\n        targets.append(nodes_index[w])\n\n    return Graph(\n        edge_index=torch.LongTensor([sources, targets]).to(\n            config[\"torch\"][\"device\"]\n        ),\n        node_id=[index_nodes[i] for i in range(n)],\n    )\n</code></pre>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.from_pyg_data","title":"<code>from_pyg_data</code>  <code>staticmethod</code>","text":"<p>Construct a graph from a <code>torch_geometric.Data</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>typing.Any</code> <p><code>torch_geometric.Data</code> object containing an edge_index as well as  arbitrary node, edge, and graph-level attributes</p> required Source code in <code>src/pathpyG/core/Graph.py</code> <pre><code>@staticmethod\ndef from_pyg_data(d: Any) -&gt; Graph:\n    \"\"\"\n    Construct a graph from a [`torch_geometric.Data`](https://pytorch-geometric.readthedocs.io/en/latest/generated/torch_geometric.data.Data.html#torch_geometric.data.Data) object.\n\n    Args:\n        d:  [`torch_geometric.Data`](https://pytorch-geometric.readthedocs.io/en/latest/generated/torch_geometric.data.Data.html#torch_geometric.data.Data) object containing an edge_index as well as \n            arbitrary node, edge, and graph-level attributes\n    \"\"\"\n    x = d.to_dict()\n\n    del x[\"edge_index\"]\n\n    if d.is_node_attr(\"node_id\"):\n        del x[\"node_id\"]\n        g = Graph(d.edge_index, node_id=d[\"node_id\"], **x)\n    else:\n        g = Graph(d.edge_index, node_id=[], **x)\n    return g\n</code></pre>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.get_laplacian","title":"<code>get_laplacian</code>","text":"<p>Return Laplacian matrix for a given graph.</p> <p>This wrapper method will use <code>torch_geometric.utils.get_laplacian</code> to return a Laplcian matrix representation of a given graph.</p> <p>Parameters:</p> Name Type Description Default <code>normalization</code> <code>typing.Any</code> <p>normalization parameter passed to pyG <code>get_laplacian</code>             function</p> <code>None</code> <code>edge_attr</code> <code>typing.Any</code> <p>optinal name of numerical edge attribute that shall             be passed to pyG <code>get_laplacian</code> function as edge weight</p> <code>None</code> Source code in <code>src/pathpyG/core/Graph.py</code> <pre><code>def get_laplacian(self, normalization: Any = None, edge_attr: Any = None) -&gt; Any:\n    \"\"\"Return Laplacian matrix for a given graph.\n\n    This wrapper method will use [`torch_geometric.utils.get_laplacian`](https://pytorch-geometric.readthedocs.io/en/latest/modules/utils.html#torch_geometric.utils.get_laplacian)\n    to return a Laplcian matrix representation of a given graph.\n\n    Args:\n        normalization:  normalization parameter passed to pyG `get_laplacian`\n                        function\n        edge_attr:      optinal name of numerical edge attribute that shall\n                        be passed to pyG `get_laplacian` function as edge weight\n    \"\"\"\n    if edge_attr is None:\n        index, weight =torch_geometric.utils.get_laplacian(\n            self.data.edge_index, normalization=normalization\n        )\n        return torch_geometric.utils.to_scipy_sparse_matrix(index, weight)\n    else:\n        index, weight = torch_geometric.utils.get_laplacian(\n            self.data.edge_index,\n            normalization=normalization,\n            edge_weight=self.data[edge_attr],\n        )\n        return torch_geometric.utils.to_scipy_sparse_matrix(index, weight)\n</code></pre>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.get_sparse_adj_matrix","title":"<code>get_sparse_adj_matrix</code>","text":"<p>Return sparse adjacency matrix representation of (weighted) graph.</p> <p>Parameters:</p> Name Type Description Default <code>edge_attr</code> <code>typing.Any</code> <p>the edge attribute that shall be used as edge weight</p> <code>None</code> Source code in <code>src/pathpyG/core/Graph.py</code> <pre><code>def get_sparse_adj_matrix(self, edge_attr: Any = None) -&gt; Any:\n    \"\"\"Return sparse adjacency matrix representation of (weighted) graph.\n\n    Args:\n        edge_attr: the edge attribute that shall be used as edge weight\n    \"\"\"\n    if edge_attr is None:\n        return torch_geometric.utils.to_scipy_sparse_matrix(self.data.edge_index)\n    else:\n        return torch_geometric.utils.to_scipy_sparse_matrix(\n            self.data.edge_index, edge_attr=self.data[edge_attr]\n        )\n</code></pre>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.has_self_loops","title":"<code>has_self_loops</code>","text":"<p>Return whether graph contains self-loops.</p> Source code in <code>src/pathpyG/core/Graph.py</code> <pre><code>def has_self_loops(self) -&gt; Any:\n    \"\"\"Return whether graph contains self-loops.\"\"\"\n    return self.data.has_self_loops()\n</code></pre>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.is_directed","title":"<code>is_directed</code>","text":"<p>Return whether graph is directed.</p> Source code in <code>src/pathpyG/core/Graph.py</code> <pre><code>def is_directed(self) -&gt; Any:\n    \"\"\"Return whether graph is directed.\"\"\"\n    return self.data.is_directed()\n</code></pre>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.is_edge","title":"<code>is_edge</code>","text":"<p>Return whether edge \\((v,w)\\) exists in the graph.</p> <p>If an index to ID mapping is used, nodes are assumed to be string IDs. If no mapping is used, nodes are assumed to be integer indices.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>typing.Union[str, int]</code> <p>source node of edge as integer index or string ID</p> required <code>w</code> <code>typing.Union[str, int]</code> <p>target node of edge as integer index or string ID</p> required Source code in <code>src/pathpyG/core/Graph.py</code> <pre><code>def is_edge(self, v: Union[str, int], w: Union[str, int]) -&gt; bool:\n    \"\"\"Return whether edge $(v,w)$ exists in the graph.\n\n    If an index to ID mapping is used, nodes are assumed to be string IDs. If no\n    mapping is used, nodes are assumed to be integer indices.\n\n    Args:\n        v: source node of edge as integer index or string ID\n        w: target node of edge as integer index or string ID       \n    \"\"\"\n    if len(self.node_index_to_id) &gt; 0:\n        return self.node_id_to_index[w] in self._sparse_adj_matrix.getrow(self.node_id_to_index[v]).indices  # type: ignore\n    else:\n        return w in self._sparse_adj_matrix.getrow(v).indices  # type: ignore\n</code></pre>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.is_undirected","title":"<code>is_undirected</code>","text":"<p>Return whether graph is undirected.</p> Source code in <code>src/pathpyG/core/Graph.py</code> <pre><code>def is_undirected(self) -&gt; Any:\n    \"\"\"Return whether graph is undirected.\"\"\"\n    return self.data.is_undirected()\n</code></pre>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.node_attrs","title":"<code>node_attrs</code>","text":"<p>Return a list of node attributes.</p> <p>This method returns a list containing the names of all node-level attributes, ignoring the special <code>node_id</code> attribute.</p> Source code in <code>src/pathpyG/core/Graph.py</code> <pre><code>def node_attrs(self) -&gt; List:\n    \"\"\"\n    Return a list of node attributes.\n\n    This method returns a list containing the names of all node-level attributes,\n    ignoring the special `node_id` attribute.\n    \"\"\"\n    attrs = []\n    for k in self.data.keys():\n        if k != \"node_id\" and k.startswith(\"node_\"):\n            attrs.append(k)\n    return attrs\n</code></pre>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.predecessors","title":"<code>predecessors</code>","text":"<p>Return the predecessors of a given node.</p> <p>This method returns a generator object that yields all predecessors of a given node. If a <code>node_id</code> mapping is used, predecessors will be returned as string IDs. If no mapping is used, predecessors are returned as indices.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>typing.Union[str, int] | tuple</code> <p>Index or string ID of node for which predecessors shall be returned.</p> required Source code in <code>src/pathpyG/core/Graph.py</code> <pre><code>def predecessors(self, node: Union[str, int] | tuple) \\\n        -&gt; Generator[Union[int, str] | tuple, None, None]:\n    \"\"\"Return the predecessors of a given node.\n\n    This method returns a generator object that yields all predecessors of a\n    given node. If a `node_id` mapping is used, predecessors will be returned\n    as string IDs. If no mapping is used, predecessors are returned as indices.\n\n    Args:\n        node:   Index or string ID of node for which predecessors shall be returned.\n    \"\"\"\n    coo_matrix = self._sparse_adj_matrix.tocoo()      \n    if len(self.node_index_to_id) &gt; 0:\n        # Get array of col indices for which entries in row are non-zero\n        non_zero_rows = coo_matrix.row[coo_matrix.col == self.node_id_to_index[node]]\n        for i in non_zero_rows:  # type: ignore\n            yield self.node_index_to_id[i]\n    else:\n        non_zero_rows = coo_matrix.row[coo_matrix.col == node]\n        for i in non_zero_rows:  # type: ignore\n            yield i\n</code></pre>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.successors","title":"<code>successors</code>","text":"<p>Return the successors of a given node.</p> <p>This method returns a generator object that yields all successors of a given node. If a <code>node_id</code> mapping is used, successors will be returned as string IDs. If no mapping is used, successors are returned as indices.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>typing.Union[int, str] | tuple</code> <p>Index or string ID of node for which successors shall be returned.</p> required Source code in <code>src/pathpyG/core/Graph.py</code> <pre><code>def successors(self, node: Union[int, str] | tuple) \\\n        -&gt; Generator[Union[int, str] | tuple, None, None]:\n    \"\"\"\n    Return the successors of a given node.\n\n    This method returns a generator object that yields all successors of a\n    given node. If a `node_id` mapping is used, successors will be returned\n    as string IDs. If no mapping is used, successors are returned as indices.\n\n    Args:\n        node:   Index or string ID of node for which successors shall be returned.\n    \"\"\" \n    coo_matrix = self._sparse_adj_matrix.tocoo()      \n    if len(self.node_index_to_id) &gt; 0:\n        # Get array of col indices for which entries in row are non-zero\n        non_zero_cols = coo_matrix.col[coo_matrix.row == self.node_id_to_index[node]]\n        for i in non_zero_cols:  # type: ignore\n            yield self.node_index_to_id[i]\n    else:\n        non_zero_cols = coo_matrix.row[coo_matrix.col == node]\n        for i in non_zero_cols:  # type: ignore\n            yield i\n</code></pre>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.to_pyg_data","title":"<code>to_pyg_data</code>","text":"<p>Return <code>torch_geometric.Data</code> representing the graph with its attributes.</p> Source code in <code>src/pathpyG/core/Graph.py</code> <pre><code>def to_pyg_data(self) -&gt; Any:\n    \"\"\"Return [`torch_geometric.Data`](https://pytorch-geometric.readthedocs.io/en/latest/generated/torch_geometric.data.Data.html#torch_geometric.data.Data) representing the graph with its attributes.\"\"\"\n    return self.data\n</code></pre>"},{"location":"reference/pathpyG/core/Graph/#pathpyG.core.Graph.Graph.to_undirected","title":"<code>to_undirected</code>","text":"<p>Transform graph into undirected graph.</p> <p>This method transforms the current graph instance into an undirected graph by adding all directed edges in opposite direction. It applies <code>ToUndirected</code> transform to the underlying <code>torch_geometric.Data</code> object, which automatically duplicates edge attributes for newly created directed edges.</p> Example <pre><code>import pathpyG as pp\ng = pp.Graph(torch.LongTensor([[1, 1, 2], [0, 2, 1]]))\ng.to_undirected()\n</code></pre> Source code in <code>src/pathpyG/core/Graph.py</code> <pre><code>def to_undirected(self) -&gt; None:\n    \"\"\"\n    Transform graph into undirected graph.\n\n    This method transforms the current graph instance into an undirected graph by\n    adding all directed edges in opposite direction. It applies [`ToUndirected`](https://pytorch-geometric.readthedocs.io/en/latest/generated/torch_geometric.transforms.ToUndirected.html#torch_geometric.transforms.ToUndirected)\n    transform to the underlying [`torch_geometric.Data`](https://pytorch-geometric.readthedocs.io/en/latest/generated/torch_geometric.data.Data.html#torch_geometric.data.Data) object, which automatically\n    duplicates edge attributes for newly created directed edges.\n\n    Example:\n        ```py\n        import pathpyG as pp\n        g = pp.Graph(torch.LongTensor([[1, 1, 2], [0, 2, 1]]))\n        g.to_undirected()\n        ```\n    \"\"\"\n    tf = ToUndirected()\n    self.data = tf(self.data)\n</code></pre>"},{"location":"reference/pathpyG/core/HigherOrderGraph/","title":"HigherOrderGraph","text":""},{"location":"reference/pathpyG/core/HigherOrderGraph/#pathpyG.core.HigherOrderGraph.HigherOrderGraph","title":"<code>HigherOrderGraph</code>","text":"<p>             Bases: <code>pathpyG.Graph</code></p> <p>HigherOrderGraph based on torch_geometric.Data.</p> Source code in <code>src/pathpyG/core/HigherOrderGraph.py</code> <pre><code>class HigherOrderGraph(Graph):\n    \"\"\"HigherOrderGraph based on torch_geometric.Data.\"\"\"\n\n    def __init__(self, paths: PathData, order: int = 1, node_id: Any = None, **kwargs: Any):\n        \"\"\"Generate HigherOrderGraph based on a given PathData instance.\n\n        Args:\n            paths:\n            order:\n            node_id:\n            **kwargs:\n\n        Example:\n            ```py\n            import pathpyG as pp\n\n            paths = pp.PathData()\n            paths.add_walk(torch.Tensor([[0, 1, 2], [1, 2, 3]]))\n            g2 = Graph(paths, k=2, node_id=['a', 'b', 'c', 'd'])\n            ```\n        \"\"\"\n        if node_id is None:\n            node_id = []\n\n        assert len(node_id) == len(set(node_id)), 'node_id entries must be unique'\n\n        # generate edge_index with higher-order nodes represented as tensors\n        self.order = order\n\n        index, edge_weights = paths.edge_index_k_weighted(k=order)\n\n        if self.order &gt; 1:\n            # get tensor of unique higher-order nodes\n            self._nodes = index.reshape(-1, index.size(dim=2)).unique(dim=0)\n\n            # create mapping to first-order node indices\n            ho_nodes_to_index = {tuple(j.tolist()): i for i, j in enumerate(self._nodes)}\n\n            # create new tensor with node indices mapped to indices of higher-order nodes\n            edge_index = torch.tensor( (\n                [ho_nodes_to_index[tuple(x.tolist())] for x in index[0,:]],\n                [ho_nodes_to_index[tuple(x.tolist())] for x in index[1,:]])\n                ).to(config['torch']['device'])\n\n            # create mappings between higher-order nodes (with ids) and node indices\n            if len(node_id)&gt;0:\n                self.node_index_to_id = { i: tuple([node_id[v] for v in j.tolist()]) for i, j in enumerate(self._nodes)}\n                self.node_id_to_index = { j: i for i, j in self.node_index_to_id.items()}\n            else:\n                self.node_index_to_id = { i:tuple([v for v in j.tolist()]) for i, j in enumerate(self._nodes)}\n                self.node_id_to_index = { j:i for i, j in self.node_index_to_id.items()}\n\n        else:\n            self._nodes = index.reshape(-1).unique(dim=0)\n            edge_index = index\n\n            # create mappings between node ids and node indices\n            self.node_index_to_id = dict(enumerate(node_id))\n            self.node_id_to_index = {v: i for i, v in enumerate(node_id)}\n\n        # Create pyG Data object\n        self.data = Data(edge_index=edge_index, num_nodes=len(self._nodes), **kwargs)\n        self.data['node_id'] = node_id\n        self.data['edge_weight'] = edge_weights\n\n\n        # create mapping between edge tuples and edge indices\n        self.edge_to_index = {(e[0].item(), e[1].item()):i for i, e in enumerate([e for e in edge_index.t()])}\n\n        # initialize adjacency matrix\n        self._sparse_adj_matrix: Any = (\n            torch_geometric.utils.to_scipy_sparse_matrix(self.data.edge_index).tocsr()\n        )\n\n    # @Graph.nodes.getter\n    # def nodes(self):\n    #     if len(self.node_id_to_index) &gt; 0:\n    #         for v in self.node_id_to_index:\n    #             yield v\n    #     else:\n    #         for v in self._nodes:\n    #             yield v\n\n    # @Graph.nodes.getter\n    # def edges(self):\n    #     if len(self.node_index_to_id) &gt; 0:\n    #         for e in self.data.edge_index.t():\n    #             yield self.node_id_to_index[e[0].item()], self.node_id_to_index[e[1].item()]\n    #     else:\n    #         for e in self.data.edge_index.t():\n    #             yield e[0].item(), e[1].item()\n\n\n\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the higher-order graph.\"\"\"\n\n        attr_types = Graph.attr_types(self.data.to_dict())\n\n        s = \"HigherOrderGraph (k={0}) with {1} nodes and {2} edges\\n\".format(self.order, len(self._nodes), self.M)\n        s += \"\\tTotal edge weight = {0}\".format(self['edge_weight'].sum())\n        if len(self.data.node_attrs()) &gt; 0:\n            s += \"\\nNode attributes\\n\"\n            for a in self.data.node_attrs():\n                s += \"\\t{0}\\t\\t{1}\\n\".format(a, attr_types[a])\n        if len(self.data.edge_attrs()) &gt; 1:\n            s += \"\\nEdge attributes\\n\"\n            for a in self.data.edge_attrs():\n                if a != 'edge_index':\n                    s += \"\\t{0}\\t\\t{1}\\n\".format(a, attr_types[a])\n        if len(self.data.keys()) &gt; len(self.data.edge_attrs()) + len(self.data.node_attrs()):\n            s += \"\\nGraph attributes\\n\"\n            for a in self.data.keys():\n                if not self.data.is_node_attr(a) and not self.data.is_edge_attr(a):\n                    s += \"\\t{0}\\t\\t{1}\\n\".format(a, attr_types[a])\n        return s\n\n    @staticmethod\n    def from_temporal_graph(g, delta, order=1):\n        \"\"\"Creates a higher-order De Bruijn graph model for paths in a temporal graph.\"\"\"\n        dag = temporal_graph_to_event_dag(g, delta=1)\n        paths = PathData.from_temporal_dag(dag)\n        return HigherOrderGraph(paths, order=order, node_id=g.data[\"node_id\"])\n</code></pre>"},{"location":"reference/pathpyG/core/HigherOrderGraph/#pathpyG.core.HigherOrderGraph.HigherOrderGraph.__init__","title":"<code>__init__</code>","text":"<p>Generate HigherOrderGraph based on a given PathData instance.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>pathpyG.PathData</code> required <code>order</code> <code>int</code> <code>1</code> <code>node_id</code> <code>typing.Any</code> <code>None</code> <code>**kwargs</code> <code>typing.Any</code> <code>{}</code> Example <pre><code>import pathpyG as pp\n\npaths = pp.PathData()\npaths.add_walk(torch.Tensor([[0, 1, 2], [1, 2, 3]]))\ng2 = Graph(paths, k=2, node_id=['a', 'b', 'c', 'd'])\n</code></pre> Source code in <code>src/pathpyG/core/HigherOrderGraph.py</code> <pre><code>def __init__(self, paths: PathData, order: int = 1, node_id: Any = None, **kwargs: Any):\n    \"\"\"Generate HigherOrderGraph based on a given PathData instance.\n\n    Args:\n        paths:\n        order:\n        node_id:\n        **kwargs:\n\n    Example:\n        ```py\n        import pathpyG as pp\n\n        paths = pp.PathData()\n        paths.add_walk(torch.Tensor([[0, 1, 2], [1, 2, 3]]))\n        g2 = Graph(paths, k=2, node_id=['a', 'b', 'c', 'd'])\n        ```\n    \"\"\"\n    if node_id is None:\n        node_id = []\n\n    assert len(node_id) == len(set(node_id)), 'node_id entries must be unique'\n\n    # generate edge_index with higher-order nodes represented as tensors\n    self.order = order\n\n    index, edge_weights = paths.edge_index_k_weighted(k=order)\n\n    if self.order &gt; 1:\n        # get tensor of unique higher-order nodes\n        self._nodes = index.reshape(-1, index.size(dim=2)).unique(dim=0)\n\n        # create mapping to first-order node indices\n        ho_nodes_to_index = {tuple(j.tolist()): i for i, j in enumerate(self._nodes)}\n\n        # create new tensor with node indices mapped to indices of higher-order nodes\n        edge_index = torch.tensor( (\n            [ho_nodes_to_index[tuple(x.tolist())] for x in index[0,:]],\n            [ho_nodes_to_index[tuple(x.tolist())] for x in index[1,:]])\n            ).to(config['torch']['device'])\n\n        # create mappings between higher-order nodes (with ids) and node indices\n        if len(node_id)&gt;0:\n            self.node_index_to_id = { i: tuple([node_id[v] for v in j.tolist()]) for i, j in enumerate(self._nodes)}\n            self.node_id_to_index = { j: i for i, j in self.node_index_to_id.items()}\n        else:\n            self.node_index_to_id = { i:tuple([v for v in j.tolist()]) for i, j in enumerate(self._nodes)}\n            self.node_id_to_index = { j:i for i, j in self.node_index_to_id.items()}\n\n    else:\n        self._nodes = index.reshape(-1).unique(dim=0)\n        edge_index = index\n\n        # create mappings between node ids and node indices\n        self.node_index_to_id = dict(enumerate(node_id))\n        self.node_id_to_index = {v: i for i, v in enumerate(node_id)}\n\n    # Create pyG Data object\n    self.data = Data(edge_index=edge_index, num_nodes=len(self._nodes), **kwargs)\n    self.data['node_id'] = node_id\n    self.data['edge_weight'] = edge_weights\n\n\n    # create mapping between edge tuples and edge indices\n    self.edge_to_index = {(e[0].item(), e[1].item()):i for i, e in enumerate([e for e in edge_index.t()])}\n\n    # initialize adjacency matrix\n    self._sparse_adj_matrix: Any = (\n        torch_geometric.utils.to_scipy_sparse_matrix(self.data.edge_index).tocsr()\n    )\n</code></pre>"},{"location":"reference/pathpyG/core/HigherOrderGraph/#pathpyG.core.HigherOrderGraph.HigherOrderGraph.__str__","title":"<code>__str__</code>","text":"<p>Return a string representation of the higher-order graph.</p> Source code in <code>src/pathpyG/core/HigherOrderGraph.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the higher-order graph.\"\"\"\n\n    attr_types = Graph.attr_types(self.data.to_dict())\n\n    s = \"HigherOrderGraph (k={0}) with {1} nodes and {2} edges\\n\".format(self.order, len(self._nodes), self.M)\n    s += \"\\tTotal edge weight = {0}\".format(self['edge_weight'].sum())\n    if len(self.data.node_attrs()) &gt; 0:\n        s += \"\\nNode attributes\\n\"\n        for a in self.data.node_attrs():\n            s += \"\\t{0}\\t\\t{1}\\n\".format(a, attr_types[a])\n    if len(self.data.edge_attrs()) &gt; 1:\n        s += \"\\nEdge attributes\\n\"\n        for a in self.data.edge_attrs():\n            if a != 'edge_index':\n                s += \"\\t{0}\\t\\t{1}\\n\".format(a, attr_types[a])\n    if len(self.data.keys()) &gt; len(self.data.edge_attrs()) + len(self.data.node_attrs()):\n        s += \"\\nGraph attributes\\n\"\n        for a in self.data.keys():\n            if not self.data.is_node_attr(a) and not self.data.is_edge_attr(a):\n                s += \"\\t{0}\\t\\t{1}\\n\".format(a, attr_types[a])\n    return s\n</code></pre>"},{"location":"reference/pathpyG/core/HigherOrderGraph/#pathpyG.core.HigherOrderGraph.HigherOrderGraph.from_temporal_graph","title":"<code>from_temporal_graph</code>  <code>staticmethod</code>","text":"<p>Creates a higher-order De Bruijn graph model for paths in a temporal graph.</p> Source code in <code>src/pathpyG/core/HigherOrderGraph.py</code> <pre><code>@staticmethod\ndef from_temporal_graph(g, delta, order=1):\n    \"\"\"Creates a higher-order De Bruijn graph model for paths in a temporal graph.\"\"\"\n    dag = temporal_graph_to_event_dag(g, delta=1)\n    paths = PathData.from_temporal_dag(dag)\n    return HigherOrderGraph(paths, order=order, node_id=g.data[\"node_id\"])\n</code></pre>"},{"location":"reference/pathpyG/core/PathData/","title":"PathData","text":"<p>Manages data on paths in graphs.</p>"},{"location":"reference/pathpyG/core/PathData/#pathpyG.core.PathData.PathData","title":"<code>PathData</code>","text":"<p>An object to store observations of paths, walks and DAGs.</p> <p>PathData stores observations of paths, walks and directed acyclic graphs. It provides methods to generate edge indices of weighted higher-order De Bruijn graph models of paths and walks.</p> Source code in <code>src/pathpyG/core/PathData.py</code> <pre><code>class PathData:\n    \"\"\"An object to store observations of paths, walks and DAGs.\n\n    PathData stores observations of paths, walks and directed acyclic graphs.\n    It provides methods to generate edge indices of weighted higher-order De Bruijn\n    graph models of paths and walks.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Create an empty PathData object.\"\"\"\n        self.paths: Dict = {}\n        self.path_types: Dict = {}\n        self.path_freq: Dict = {}\n        self.node_id: List = []\n        self.mapping: Dict = {}\n\n    @property\n    def num_paths(self) -&gt; int:\n        \"\"\"Return the number of stored paths.\"\"\"\n        return len(self.paths)\n\n    @property\n    def num_nodes(self) -&gt; int:\n        \"\"\"Return the number of nodes in the underlying graph.\"\"\"\n        index = self.edge_index\n        return len(index.reshape(-1).unique(dim=0))\n\n    @property\n    def num_edges(self) -&gt; int:\n        \"\"\"Return the number of edges in the underlying graph.\"\"\"\n        return self.edge_index.size(dim=1)\n\n    def add_edge(self, p: Tensor, freq: int = 1) -&gt; None:\n        \"\"\"Add an observation of an edge traversal.\n\n        This method adds an observation of a traversed edge.\n\n        Args:\n            p: edge_index\n\n        Example:\n            Assuming a `node_id` mapping of `['A', 'B', 'C', 'D']` the following snippet\n            stores two observations of edge `A` --&gt; `C`:\n                ```py\n                import pathpyG as pp\n\n                paths = pp.PathData()\n                paths.add_edge(torch.tensor([[0],[2]]), freq=2)\n                ```\n        \"\"\"\n        self.add_walk(p, freq)\n\n    def add_dag(self, p: Tensor, freq: int = 1) -&gt; None:\n        \"\"\"Add an observation of a directed acyclic graph.\n\n        This method adds an observation of a directed acyclic graph,\n        i.e. a topologically sorted sequence of not necessarily\n        unique nodes in a graph. Like a walk, a DAG is represented\n        as an ordered edge index tensor. DAGs can be associated with an\n        integer that captures the observation frequency.\n\n        Path data that can be represented as a collection of directed\n        acyclic graphs naturally arise in the analysis of time-respecting\n        paths in temporal graphs.\n\n        Args:\n            p: topologically sorted edge_index of DAG\n            freq: The number of times this DAG has been observed.\n\n        Example:\n            Assuming a `node_id` mapping of `['A', 'B', 'C', 'D']` the following code snippet\n            stores three observations of the DAG with edges `A` --&gt; `B`, `B` --&gt; `C`, `B` --&gt; `D`\n                ```py\n                import pathpyG as pp\n\n                paths = pp.PathData()\n                paths.add_dag(torch.tensor([[0,1], [1, 2], [1, 3]]))\n                ```\n        \"\"\"\n        i = len(self.paths)\n        self.paths[i] = p\n        self.path_types[i] = PathType.DAG\n        self.path_freq[i] = freq\n\n    def add_walk(self, p: Tensor, freq: int = 1) -&gt; None:\n        \"\"\"\n        Add an observation of a path or a walk in a graph.\n\n        This method adds an observation of a walk, i.e. a sequence of not necessarily\n        unique nodes traversed in a graph. A walk of length l is represented as ordered\n        edge index tensor of size (2,l) where l is the number of traversed edges.\n        Walks can be associated with an integer that captures the observation frequency.\n\n        Since walks are a generalization of paths that allows for multiple traversals of\n        nodes, walks can be naturally used to store paths in a graph.\n\n        Walks can be seen as a special case of DAGs where the in- and out-degree of all\n        nodes is one. However, for a walk a higher-order model can be computed much more\n        efficiently using a GPU-based 1D convolution operation. It is thus advisable to\n        represent path data as walks whenever possible.\n\n        Args:\n            p:  An ordered edge index with size (2,l) that represents the sequence\n                in which a walk or path traverses the nodes of a graph.\n            freq:   The number of times this walk has been observed.\n\n        Example:\n            Assuming a `node_id` mapping of `['A', 'B', 'C', 'D']` the following snippet\n            stores three observations of the walk `A` --&gt; `C` --&gt; `D`:\n                ```py\n                import pathpyG as pp\n\n                paths = pp.PathData()\n                paths.add_walk(torch.tensor([[0, 2],[2, 3]]), freq=5)\n                ```\n        \"\"\"\n        i = len(self.paths)\n        self.paths[i] = p\n        self.path_types[i] = PathType.WALK\n        self.path_freq[i] = freq\n\n    def to_scipy_sparse_matrix(self) -&gt; Any:\n        \"\"\"Return sparse adjacency matrix of underlying graph.\"\"\"\n        return to_scipy_sparse_matrix(self.edge_index)\n\n    @property\n    def edge_index(self) -&gt; Tensor:\n        \"\"\"Return edge index of a first-order graph model of all paths.\"\"\"\n        return self.edge_index_k_weighted(k=1)[0]\n\n    @property\n    def edge_index_weighted(self) -&gt; Tuple[Tensor, Tensor]:\n        \"\"\"Return edge index and edge weights of a first-order graph \n        model of all walks or DAGs.\"\"\"\n        return self.edge_index_k_weighted(k=1)\n\n    def edge_index_k_weighted(self, k: int = 1) -&gt; Tuple[Tensor, Tensor]:\n        \"\"\"Compute edge index and edge weights of $k$-th order De Bruijn graph model.\n\n        Args:\n            k: order of the $k$-th order De Bruijn graph model\n        \"\"\"\n        freq: Tensor = torch.Tensor([])\n\n        if k == 1:\n            # TODO: Wrong edge statistics for non-sparse DAGs!\n            i = cat(list(self.paths.values()), dim=1)\n            if self.mapping:\n                i = PathData.map_nodes(i, self.mapping)\n            l_f = []\n            for idx in self.paths:\n                l_f.append(Tensor([self.path_freq[idx]]*self.paths[idx].size()[1]).to(config['torch']['device']))\n            freq = cat(l_f, dim=0)\n        else:\n            l_p = []\n            l_f = []\n            for idx in self.paths:\n                if self.path_types[idx] == PathType.WALK:\n                    p = PathData.edge_index_kth_order_walk(self.paths[idx], k)\n                    if self.mapping:\n                        p = PathData.map_nodes(p, self.mapping).unique_consecutive(dim=0)\n                    l_p.append(p)\n                    l_f.append(Tensor([self.path_freq[idx]]*(self.paths[idx].size()[1]-k+1)).to(config['torch']['device']))\n                else:\n                    # we have to reshape tensors of the form [[0,1,2], [1,2,3]] to [[[0],[1],[2]],[[1],[2],[3]]]\n                    x = self.paths[idx].reshape(self.paths[idx].size()+(1,))\n                    p = PathData.edge_index_kth_order_dag(x, k)\n                    if self.mapping:\n                        p = PathData.map_nodes(p, self.mapping).unique_consecutive(dim=0)\n                    if len(p) &gt; 0:\n                        l_p.append(p)\n                        l_f.append(Tensor([self.path_freq[idx]]*p.size()[1]).to(config['torch']['device']))\n            i = cat(l_p, dim=1)\n            freq = cat(l_f, dim=0)\n\n        # make edge index unique and keep reverse index, \n        # that maps each element in i to the corresponding element in edge_index\n        edge_index, reverse_index = i.unique(dim=1, return_inverse=True)\n\n        # for each edge in edge_index, the elements of x\n        # contain all indices in i that correspond to that edge\n        x = list((reverse_index == idx).nonzero() \n                 for idx in range(edge_index.size()[1]))\n\n        # for each edge, sum the weights of all occurences\n        edge_weights = Tensor([\n            sum(freq[x[idx]]) for idx in\n            range(edge_index.size()[1])]).to(config['torch']['device'])\n\n        return edge_index, edge_weights\n\n    # WALK METHODS\n\n    @staticmethod\n    def edge_index_kth_order_walk(edge_index: Tensor, k: int = 1) -&gt; Tensor:\n        \"\"\"Compute edge index of $k$-th order graph for a given walk.\n\n        The returned $k$-th order `edge_index` has size `(2, l-1, k)` and naturally \n        generalizes first-order edge indices, i.e. for a walk `(0,1,2,3,4,5)`\n        represented by the following ordered `edge_index` with size `(2, 5)`\n\n        ```py\n        [\n            [0, 1, 2, 3, 4],\n            [1, 2, 3, 4, 5]\n        ]\n        ```\n\n        we obtain the following second-order `edge_index` with size `(2, 4, 2)`\n\n        ```py\n        [\n            [[0, 1], [1, 2], [2, 3], [3, 4]],\n            [[1, 2], [2, 3], [3, 4], [4, 5]]\n        ]\n        ```\n\n        while for the third-order `edge_index` we get a tensor with size `(2, 3, 3)`\n\n        ```py\n        [\n            [[0, 1, 2], [1, 2, 3], [2, 3, 4]],\n            [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\n        ]\n        ```\n\n        Note that for reasons of consistency with edge_index tensors in pyG,\n        first-order `edge_indices` of walks of length $l$ have size `(2,l)` rather\n        than size `(2, l, 1)`.\n\n        Args:\n            k: order of the $k$-th order model.\n        \"\"\"\n        if k &lt;= edge_index.size(dim=1):\n            return edge_index.unfold(1, k, 1)\n\n        return IntTensor([]).to(config['torch']['device'])\n\n    @staticmethod\n    def walk_to_node_seq(walk: Tensor) -&gt; Tensor:\n        \"\"\"Turn `edge_index` for a walk into a sequence of traversed node indices.\n\n        Args:\n            walk: ordered `edge_index` of a given walk in a graph\n\n        Example:\n            ```pycon\n            &gt;&gt;&gt; import pathpyG as pp\n            &gt;&gt;&gt; s = pp.PathData.walk_to_node_seq(torch.tensor([[0,2],[2,3]]))\n            &gt;&gt;&gt; print(s)\n            [0,2,3]\n            ```\n        \"\"\"\n        return cat([walk[:, 0], walk[1, 1:]])\n\n    # DAG METHODS\n\n    @staticmethod\n    def edge_index_kth_order_dag(edge_index: Tensor, k: int) -&gt; Tensor:\n        \"\"\"Calculate $k$-th order edge_index for a single dag.\n\n        Args:\n            k: order of $k$-th order model\n        \"\"\"\n        x = edge_index\n        for _ in range(1, k):\n            x = PathData.lift_order_dag(x)\n        return x\n\n    @staticmethod\n    def map_nodes(edge_index: Tensor, mapping: Dict) -&gt; Tensor:\n        \"\"\"Efficiently map node indices in edge_index tensor based on dictionary.\n\n        Args:\n            edge_index: the tensor for which indices shall be mapped\n            mapping: dictionary mapping incides in original tensor to new values\n\n        Example:\n            ```py\n            import pathpyG as pp\n            edge_index = IntTensor([[0,1,2], [1,2,3]])\n\n            print(edge_index)\n            tensor([[0, 1, 3],\n                    [1, 2, 3]])\n\n            mapping = {0: 1, 1: 0, 2: 3, 3: 2}\n            mapped = pp.PathData.map_nodes(edge_index, mapping)\n\n            print(mapped)\n            tensor([[1, 0, 3],\n                    [0, 3, 2]])\n            ```\n        \"\"\"\n        # Inspired by `https://stackoverflow.com/questions/13572448`.\n        palette, key = zip(*mapping.items())\n        key = torch.tensor(key).to(config['torch']['device'])\n        palette = torch.tensor(palette).to(config['torch']['device'])\n\n        index = torch.bucketize(edge_index.ravel(), palette)\n        remapped = key[index].reshape(edge_index.shape)\n        return remapped\n\n    @staticmethod\n    def lift_order_dag(edge_index: Tensor) -&gt; Tensor:\n        \"\"\"Efficiently lift edge index of $k$-th order model to $(k+1)$-th order model.\n\n        Args:\n            edge_index: edge_index of $k$-th order model that will be\n                lifted to $(k+1)$-th order\n        \"\"\"\n        a = edge_index[0].unique(dim=0)\n        b = edge_index[1].unique(dim=0)\n        # intersection of a and b corresponds to all center nodes, which have \n        # at least one incoming and one outgoing edge\n        combined = torch.cat((a, b))\n        uniques, counts = combined.unique(dim=0, return_counts=True)\n        center_nodes = uniques[counts &gt; 1]\n\n        src = []\n        dst = []\n\n        # create edges of order k+1\n        for v in center_nodes:\n            # get all predecessors of v, i.e. elements in edge_index[0] where edge_index[1] == v\n            src_index = torch.all(edge_index[1] == v, axis=1).nonzero().flatten()  # type: ignore\n            srcs = edge_index[0][src_index]\n            # get all successors of v, i.e. elements in edge_index[1] where edge_index[0] == v\n            dst_index = torch.all(edge_index[0] == v, axis=1).nonzero().flatten()  # type: ignore\n            dsts = edge_index[1][dst_index]\n            for s in srcs:\n                for d in dsts:\n                    src.append(torch.cat((torch.gather(s, 0, torch.tensor([0]).to(config['torch']['device'])), v)))\n                    dst.append(torch.cat((v, torch.gather(d, 0, torch.tensor([d.size()[0]-1]).to(config['torch']['device'])))))\n\n        if len(src) &gt; 0:\n            return torch.stack((torch.stack(src), torch.stack(dst)))\n\n        return torch.tensor([]).to(config['torch']['device'])\n\n    @staticmethod\n    def from_temporal_dag(dag: Graph, detect_walks: bool = True) -&gt; PathData:\n        \"\"\"Generate PathData object from temporal DAG where nodes are node-time events.\n\n        Args:\n            dag: A directed acyclic graph representation of a temporal network, where\n                nodes are time-node events.\n            detect_walks: whether or not directed acyclic graphs that just correspond\n                        to walks will be automatically added as walks. If set to false\n                        the resulting `PathData` object will only contain DAGs. If set\n                        to true, the PathData object may contain both DAGs and walks.\n        \"\"\"\n        ds = PathData()\n\n        out_deg = degree(dag.data.edge_index[0])\n        in_deg = degree(dag.data.edge_index[1])\n\n        # check if dag exclusively consists of simple walks and apply fast method\n        if torch.max(out_deg).item() == 1.0 and torch.max(in_deg).item() == 1.0:\n\n            zero_outdegs = (out_deg==0).nonzero().squeeze()\n            zero_indegs = (in_deg==0).nonzero().squeeze()\n\n            # find indices of those elements in src where in-deg = 0, i.e. elements are in zero_indegs\n            start_segs = torch.where(torch.isin(dag.data.edge_index[0], zero_indegs))[0]\n            end_segs = torch.cat((start_segs[1:], torch.tensor([len(dag.data.edge_index[0])], device=config['torch']['device'])))\n            segments = end_segs - start_segs\n            mapping = {\n                i: dag['node_idx', dag.node_index_to_id[i]] for i in dag.node_index_to_id\n            }\n\n            # Map node-time events to node IDs\n            # Convert the tensor to a flattened 1D tensor\n            flat_tensor = dag.data.edge_index.flatten()\n\n            # Create a mask tensor to mark indices to be replaced\n            mask = torch.zeros_like(flat_tensor, device=config['torch']['device'])\n\n            for key, value in mapping.items():\n                # Find indices where the values match the keys in the mapping\n                indices = (flat_tensor == key).nonzero(as_tuple=True)\n\n                # Set the corresponding indices in the mask tensor to 1\n                mask[indices] = 1\n\n                # Replace values in the flattened tensor according to the mapping\n                flat_tensor[indices] = value\n\n            # Reshape the flattened tensor back to the original shape\n            dag.data['edge_index'] = flat_tensor.reshape(dag.data.edge_index.shape)\n\n            # split edge index into multiple independent sections: \n            # sections are limited by indices in src where in-deg = 0 and indices in tgt where out-deg = 0 \n            for t in torch.split(dag.data.edge_index, segments.tolist(), dim=1):\n                ds.add_walk(t)\n\n        else:\n            dags = extract_causal_trees(dag)\n            for d in dags:\n                # src = [ dag['node_idx', dag.node_index_to_id[s.item()]] for s in dags[d][0]] # type: ignore\n                # dst = [ dag['node_idx', dag.node_index_to_id[t.item()]] for t in dags[d][1]] # type: ignore\n                src = [s for s in dags[d][0]]\n                dst = [t for t in dags[d][1]]\n                # ds.add_dag(IntTensor([src, dst]).unique_consecutive(dim=1))\n                edge_index = torch.LongTensor([src, dst]).to(config['torch']['device'])\n                if detect_walks and degree(edge_index[1]).max() == 1 and \\\n                        degree(edge_index[0]).max() == 1:\n                    ds.add_walk(edge_index)\n                else:\n                    ds.add_dag(edge_index)\n            ds.mapping = {\n                i: dag['node_idx', dag.node_index_to_id[i]] for i in dag.node_index_to_id\n                }\n        return ds\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return string representation of PathData object.\"\"\"\n        num_walks = 0\n        num_dags = 0\n        total = 0\n        for p in self.paths:\n            if self.path_types[p] == PathType.DAG:\n                num_dags += 1\n            else:\n                num_walks += 1\n            total += self.path_freq[p]\n        s = f\"PathData with {num_walks} walks and {num_dags} dags and total weight {total}\"\n        return s\n\n    @staticmethod\n    def from_csv(file: str, sep: str = ',') -&gt; PathData:\n        \"\"\"Read path data from CSV file.\n\n        The CSV file is expected to contain one walk or path per line, where\n        nodes are separated by the character given in `sep`. The last\n        component in the resulting n-gram is assumed to be the integer\n        frequency of the observed walk.\n\n        Args:\n            file: filename of csv file containing paths or walks\n            sep: character used to separate nodes and integer observation count\n        \"\"\"\n        p = PathData()\n        name_map: Dict = defaultdict(lambda: len(name_map))\n        with open(file, \"r\", encoding=\"utf-8\") as f:\n            for line in f:\n                path = []\n                fields = line.split(sep)\n                for v in fields[:-1]:\n                    path.append(name_map[v])\n                w = IntTensor([path[:-1], path[1:]]).to(config['torch']['device'])\n                p.add_walk(w, int(float(fields[-1])))\n        reverse_map = {k: i for i, k in name_map.items()}\n        p.node_id = [reverse_map[i] for i in range(len(name_map))]\n        return p\n</code></pre>"},{"location":"reference/pathpyG/core/PathData/#pathpyG.core.PathData.PathData.edge_index","title":"<code>edge_index: Tensor</code>  <code>property</code>","text":"<p>Return edge index of a first-order graph model of all paths.</p>"},{"location":"reference/pathpyG/core/PathData/#pathpyG.core.PathData.PathData.edge_index_weighted","title":"<code>edge_index_weighted: Tuple[Tensor, Tensor]</code>  <code>property</code>","text":"<p>Return edge index and edge weights of a first-order graph  model of all walks or DAGs.</p>"},{"location":"reference/pathpyG/core/PathData/#pathpyG.core.PathData.PathData.num_edges","title":"<code>num_edges: int</code>  <code>property</code>","text":"<p>Return the number of edges in the underlying graph.</p>"},{"location":"reference/pathpyG/core/PathData/#pathpyG.core.PathData.PathData.num_nodes","title":"<code>num_nodes: int</code>  <code>property</code>","text":"<p>Return the number of nodes in the underlying graph.</p>"},{"location":"reference/pathpyG/core/PathData/#pathpyG.core.PathData.PathData.num_paths","title":"<code>num_paths: int</code>  <code>property</code>","text":"<p>Return the number of stored paths.</p>"},{"location":"reference/pathpyG/core/PathData/#pathpyG.core.PathData.PathData.__init__","title":"<code>__init__</code>","text":"<p>Create an empty PathData object.</p> Source code in <code>src/pathpyG/core/PathData.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Create an empty PathData object.\"\"\"\n    self.paths: Dict = {}\n    self.path_types: Dict = {}\n    self.path_freq: Dict = {}\n    self.node_id: List = []\n    self.mapping: Dict = {}\n</code></pre>"},{"location":"reference/pathpyG/core/PathData/#pathpyG.core.PathData.PathData.__str__","title":"<code>__str__</code>","text":"<p>Return string representation of PathData object.</p> Source code in <code>src/pathpyG/core/PathData.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return string representation of PathData object.\"\"\"\n    num_walks = 0\n    num_dags = 0\n    total = 0\n    for p in self.paths:\n        if self.path_types[p] == PathType.DAG:\n            num_dags += 1\n        else:\n            num_walks += 1\n        total += self.path_freq[p]\n    s = f\"PathData with {num_walks} walks and {num_dags} dags and total weight {total}\"\n    return s\n</code></pre>"},{"location":"reference/pathpyG/core/PathData/#pathpyG.core.PathData.PathData.add_dag","title":"<code>add_dag</code>","text":"<p>Add an observation of a directed acyclic graph.</p> <p>This method adds an observation of a directed acyclic graph, i.e. a topologically sorted sequence of not necessarily unique nodes in a graph. Like a walk, a DAG is represented as an ordered edge index tensor. DAGs can be associated with an integer that captures the observation frequency.</p> <p>Path data that can be represented as a collection of directed acyclic graphs naturally arise in the analysis of time-respecting paths in temporal graphs.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>torch.Tensor</code> <p>topologically sorted edge_index of DAG</p> required <code>freq</code> <code>int</code> <p>The number of times this DAG has been observed.</p> <code>1</code> Example <p>Assuming a <code>node_id</code> mapping of <code>['A', 'B', 'C', 'D']</code> the following code snippet stores three observations of the DAG with edges <code>A</code> \u2192 <code>B</code>, <code>B</code> \u2192 <code>C</code>, <code>B</code> \u2192 <code>D</code> <pre><code>import pathpyG as pp\n\npaths = pp.PathData()\npaths.add_dag(torch.tensor([[0,1], [1, 2], [1, 3]]))\n</code></pre></p> Source code in <code>src/pathpyG/core/PathData.py</code> <pre><code>def add_dag(self, p: Tensor, freq: int = 1) -&gt; None:\n    \"\"\"Add an observation of a directed acyclic graph.\n\n    This method adds an observation of a directed acyclic graph,\n    i.e. a topologically sorted sequence of not necessarily\n    unique nodes in a graph. Like a walk, a DAG is represented\n    as an ordered edge index tensor. DAGs can be associated with an\n    integer that captures the observation frequency.\n\n    Path data that can be represented as a collection of directed\n    acyclic graphs naturally arise in the analysis of time-respecting\n    paths in temporal graphs.\n\n    Args:\n        p: topologically sorted edge_index of DAG\n        freq: The number of times this DAG has been observed.\n\n    Example:\n        Assuming a `node_id` mapping of `['A', 'B', 'C', 'D']` the following code snippet\n        stores three observations of the DAG with edges `A` --&gt; `B`, `B` --&gt; `C`, `B` --&gt; `D`\n            ```py\n            import pathpyG as pp\n\n            paths = pp.PathData()\n            paths.add_dag(torch.tensor([[0,1], [1, 2], [1, 3]]))\n            ```\n    \"\"\"\n    i = len(self.paths)\n    self.paths[i] = p\n    self.path_types[i] = PathType.DAG\n    self.path_freq[i] = freq\n</code></pre>"},{"location":"reference/pathpyG/core/PathData/#pathpyG.core.PathData.PathData.add_edge","title":"<code>add_edge</code>","text":"<p>Add an observation of an edge traversal.</p> <p>This method adds an observation of a traversed edge.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>torch.Tensor</code> <p>edge_index</p> required Example <p>Assuming a <code>node_id</code> mapping of <code>['A', 'B', 'C', 'D']</code> the following snippet stores two observations of edge <code>A</code> \u2192 <code>C</code>:     <pre><code>import pathpyG as pp\n\npaths = pp.PathData()\npaths.add_edge(torch.tensor([[0],[2]]), freq=2)\n</code></pre></p> Source code in <code>src/pathpyG/core/PathData.py</code> <pre><code>def add_edge(self, p: Tensor, freq: int = 1) -&gt; None:\n    \"\"\"Add an observation of an edge traversal.\n\n    This method adds an observation of a traversed edge.\n\n    Args:\n        p: edge_index\n\n    Example:\n        Assuming a `node_id` mapping of `['A', 'B', 'C', 'D']` the following snippet\n        stores two observations of edge `A` --&gt; `C`:\n            ```py\n            import pathpyG as pp\n\n            paths = pp.PathData()\n            paths.add_edge(torch.tensor([[0],[2]]), freq=2)\n            ```\n    \"\"\"\n    self.add_walk(p, freq)\n</code></pre>"},{"location":"reference/pathpyG/core/PathData/#pathpyG.core.PathData.PathData.add_walk","title":"<code>add_walk</code>","text":"<p>Add an observation of a path or a walk in a graph.</p> <p>This method adds an observation of a walk, i.e. a sequence of not necessarily unique nodes traversed in a graph. A walk of length l is represented as ordered edge index tensor of size (2,l) where l is the number of traversed edges. Walks can be associated with an integer that captures the observation frequency.</p> <p>Since walks are a generalization of paths that allows for multiple traversals of nodes, walks can be naturally used to store paths in a graph.</p> <p>Walks can be seen as a special case of DAGs where the in- and out-degree of all nodes is one. However, for a walk a higher-order model can be computed much more efficiently using a GPU-based 1D convolution operation. It is thus advisable to represent path data as walks whenever possible.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>torch.Tensor</code> <p>An ordered edge index with size (2,l) that represents the sequence in which a walk or path traverses the nodes of a graph.</p> required <code>freq</code> <code>int</code> <p>The number of times this walk has been observed.</p> <code>1</code> Example <p>Assuming a <code>node_id</code> mapping of <code>['A', 'B', 'C', 'D']</code> the following snippet stores three observations of the walk <code>A</code> \u2192 <code>C</code> \u2192 <code>D</code>:     <pre><code>import pathpyG as pp\n\npaths = pp.PathData()\npaths.add_walk(torch.tensor([[0, 2],[2, 3]]), freq=5)\n</code></pre></p> Source code in <code>src/pathpyG/core/PathData.py</code> <pre><code>def add_walk(self, p: Tensor, freq: int = 1) -&gt; None:\n    \"\"\"\n    Add an observation of a path or a walk in a graph.\n\n    This method adds an observation of a walk, i.e. a sequence of not necessarily\n    unique nodes traversed in a graph. A walk of length l is represented as ordered\n    edge index tensor of size (2,l) where l is the number of traversed edges.\n    Walks can be associated with an integer that captures the observation frequency.\n\n    Since walks are a generalization of paths that allows for multiple traversals of\n    nodes, walks can be naturally used to store paths in a graph.\n\n    Walks can be seen as a special case of DAGs where the in- and out-degree of all\n    nodes is one. However, for a walk a higher-order model can be computed much more\n    efficiently using a GPU-based 1D convolution operation. It is thus advisable to\n    represent path data as walks whenever possible.\n\n    Args:\n        p:  An ordered edge index with size (2,l) that represents the sequence\n            in which a walk or path traverses the nodes of a graph.\n        freq:   The number of times this walk has been observed.\n\n    Example:\n        Assuming a `node_id` mapping of `['A', 'B', 'C', 'D']` the following snippet\n        stores three observations of the walk `A` --&gt; `C` --&gt; `D`:\n            ```py\n            import pathpyG as pp\n\n            paths = pp.PathData()\n            paths.add_walk(torch.tensor([[0, 2],[2, 3]]), freq=5)\n            ```\n    \"\"\"\n    i = len(self.paths)\n    self.paths[i] = p\n    self.path_types[i] = PathType.WALK\n    self.path_freq[i] = freq\n</code></pre>"},{"location":"reference/pathpyG/core/PathData/#pathpyG.core.PathData.PathData.edge_index_k_weighted","title":"<code>edge_index_k_weighted</code>","text":"<p>Compute edge index and edge weights of \\(k\\)-th order De Bruijn graph model.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>order of the \\(k\\)-th order De Bruijn graph model</p> <code>1</code> Source code in <code>src/pathpyG/core/PathData.py</code> <pre><code>def edge_index_k_weighted(self, k: int = 1) -&gt; Tuple[Tensor, Tensor]:\n    \"\"\"Compute edge index and edge weights of $k$-th order De Bruijn graph model.\n\n    Args:\n        k: order of the $k$-th order De Bruijn graph model\n    \"\"\"\n    freq: Tensor = torch.Tensor([])\n\n    if k == 1:\n        # TODO: Wrong edge statistics for non-sparse DAGs!\n        i = cat(list(self.paths.values()), dim=1)\n        if self.mapping:\n            i = PathData.map_nodes(i, self.mapping)\n        l_f = []\n        for idx in self.paths:\n            l_f.append(Tensor([self.path_freq[idx]]*self.paths[idx].size()[1]).to(config['torch']['device']))\n        freq = cat(l_f, dim=0)\n    else:\n        l_p = []\n        l_f = []\n        for idx in self.paths:\n            if self.path_types[idx] == PathType.WALK:\n                p = PathData.edge_index_kth_order_walk(self.paths[idx], k)\n                if self.mapping:\n                    p = PathData.map_nodes(p, self.mapping).unique_consecutive(dim=0)\n                l_p.append(p)\n                l_f.append(Tensor([self.path_freq[idx]]*(self.paths[idx].size()[1]-k+1)).to(config['torch']['device']))\n            else:\n                # we have to reshape tensors of the form [[0,1,2], [1,2,3]] to [[[0],[1],[2]],[[1],[2],[3]]]\n                x = self.paths[idx].reshape(self.paths[idx].size()+(1,))\n                p = PathData.edge_index_kth_order_dag(x, k)\n                if self.mapping:\n                    p = PathData.map_nodes(p, self.mapping).unique_consecutive(dim=0)\n                if len(p) &gt; 0:\n                    l_p.append(p)\n                    l_f.append(Tensor([self.path_freq[idx]]*p.size()[1]).to(config['torch']['device']))\n        i = cat(l_p, dim=1)\n        freq = cat(l_f, dim=0)\n\n    # make edge index unique and keep reverse index, \n    # that maps each element in i to the corresponding element in edge_index\n    edge_index, reverse_index = i.unique(dim=1, return_inverse=True)\n\n    # for each edge in edge_index, the elements of x\n    # contain all indices in i that correspond to that edge\n    x = list((reverse_index == idx).nonzero() \n             for idx in range(edge_index.size()[1]))\n\n    # for each edge, sum the weights of all occurences\n    edge_weights = Tensor([\n        sum(freq[x[idx]]) for idx in\n        range(edge_index.size()[1])]).to(config['torch']['device'])\n\n    return edge_index, edge_weights\n</code></pre>"},{"location":"reference/pathpyG/core/PathData/#pathpyG.core.PathData.PathData.edge_index_kth_order_dag","title":"<code>edge_index_kth_order_dag</code>  <code>staticmethod</code>","text":"<p>Calculate \\(k\\)-th order edge_index for a single dag.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>order of \\(k\\)-th order model</p> required Source code in <code>src/pathpyG/core/PathData.py</code> <pre><code>@staticmethod\ndef edge_index_kth_order_dag(edge_index: Tensor, k: int) -&gt; Tensor:\n    \"\"\"Calculate $k$-th order edge_index for a single dag.\n\n    Args:\n        k: order of $k$-th order model\n    \"\"\"\n    x = edge_index\n    for _ in range(1, k):\n        x = PathData.lift_order_dag(x)\n    return x\n</code></pre>"},{"location":"reference/pathpyG/core/PathData/#pathpyG.core.PathData.PathData.edge_index_kth_order_walk","title":"<code>edge_index_kth_order_walk</code>  <code>staticmethod</code>","text":"<p>Compute edge index of \\(k\\)-th order graph for a given walk.</p> <p>The returned \\(k\\)-th order <code>edge_index</code> has size <code>(2, l-1, k)</code> and naturally  generalizes first-order edge indices, i.e. for a walk <code>(0,1,2,3,4,5)</code> represented by the following ordered <code>edge_index</code> with size <code>(2, 5)</code></p> <pre><code>[\n    [0, 1, 2, 3, 4],\n    [1, 2, 3, 4, 5]\n]\n</code></pre> <p>we obtain the following second-order <code>edge_index</code> with size <code>(2, 4, 2)</code></p> <pre><code>[\n    [[0, 1], [1, 2], [2, 3], [3, 4]],\n    [[1, 2], [2, 3], [3, 4], [4, 5]]\n]\n</code></pre> <p>while for the third-order <code>edge_index</code> we get a tensor with size <code>(2, 3, 3)</code></p> <pre><code>[\n    [[0, 1, 2], [1, 2, 3], [2, 3, 4]],\n    [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\n]\n</code></pre> <p>Note that for reasons of consistency with edge_index tensors in pyG, first-order <code>edge_indices</code> of walks of length \\(l\\) have size <code>(2,l)</code> rather than size <code>(2, l, 1)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>order of the \\(k\\)-th order model.</p> <code>1</code> Source code in <code>src/pathpyG/core/PathData.py</code> <pre><code>@staticmethod\ndef edge_index_kth_order_walk(edge_index: Tensor, k: int = 1) -&gt; Tensor:\n    \"\"\"Compute edge index of $k$-th order graph for a given walk.\n\n    The returned $k$-th order `edge_index` has size `(2, l-1, k)` and naturally \n    generalizes first-order edge indices, i.e. for a walk `(0,1,2,3,4,5)`\n    represented by the following ordered `edge_index` with size `(2, 5)`\n\n    ```py\n    [\n        [0, 1, 2, 3, 4],\n        [1, 2, 3, 4, 5]\n    ]\n    ```\n\n    we obtain the following second-order `edge_index` with size `(2, 4, 2)`\n\n    ```py\n    [\n        [[0, 1], [1, 2], [2, 3], [3, 4]],\n        [[1, 2], [2, 3], [3, 4], [4, 5]]\n    ]\n    ```\n\n    while for the third-order `edge_index` we get a tensor with size `(2, 3, 3)`\n\n    ```py\n    [\n        [[0, 1, 2], [1, 2, 3], [2, 3, 4]],\n        [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\n    ]\n    ```\n\n    Note that for reasons of consistency with edge_index tensors in pyG,\n    first-order `edge_indices` of walks of length $l$ have size `(2,l)` rather\n    than size `(2, l, 1)`.\n\n    Args:\n        k: order of the $k$-th order model.\n    \"\"\"\n    if k &lt;= edge_index.size(dim=1):\n        return edge_index.unfold(1, k, 1)\n\n    return IntTensor([]).to(config['torch']['device'])\n</code></pre>"},{"location":"reference/pathpyG/core/PathData/#pathpyG.core.PathData.PathData.from_csv","title":"<code>from_csv</code>  <code>staticmethod</code>","text":"<p>Read path data from CSV file.</p> <p>The CSV file is expected to contain one walk or path per line, where nodes are separated by the character given in <code>sep</code>. The last component in the resulting n-gram is assumed to be the integer frequency of the observed walk.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>filename of csv file containing paths or walks</p> required <code>sep</code> <code>str</code> <p>character used to separate nodes and integer observation count</p> <code>','</code> Source code in <code>src/pathpyG/core/PathData.py</code> <pre><code>@staticmethod\ndef from_csv(file: str, sep: str = ',') -&gt; PathData:\n    \"\"\"Read path data from CSV file.\n\n    The CSV file is expected to contain one walk or path per line, where\n    nodes are separated by the character given in `sep`. The last\n    component in the resulting n-gram is assumed to be the integer\n    frequency of the observed walk.\n\n    Args:\n        file: filename of csv file containing paths or walks\n        sep: character used to separate nodes and integer observation count\n    \"\"\"\n    p = PathData()\n    name_map: Dict = defaultdict(lambda: len(name_map))\n    with open(file, \"r\", encoding=\"utf-8\") as f:\n        for line in f:\n            path = []\n            fields = line.split(sep)\n            for v in fields[:-1]:\n                path.append(name_map[v])\n            w = IntTensor([path[:-1], path[1:]]).to(config['torch']['device'])\n            p.add_walk(w, int(float(fields[-1])))\n    reverse_map = {k: i for i, k in name_map.items()}\n    p.node_id = [reverse_map[i] for i in range(len(name_map))]\n    return p\n</code></pre>"},{"location":"reference/pathpyG/core/PathData/#pathpyG.core.PathData.PathData.from_temporal_dag","title":"<code>from_temporal_dag</code>  <code>staticmethod</code>","text":"<p>Generate PathData object from temporal DAG where nodes are node-time events.</p> <p>Parameters:</p> Name Type Description Default <code>dag</code> <code>pathpyG.Graph</code> <p>A directed acyclic graph representation of a temporal network, where nodes are time-node events.</p> required <code>detect_walks</code> <code>bool</code> <p>whether or not directed acyclic graphs that just correspond         to walks will be automatically added as walks. If set to false         the resulting <code>PathData</code> object will only contain DAGs. If set         to true, the PathData object may contain both DAGs and walks.</p> <code>True</code> Source code in <code>src/pathpyG/core/PathData.py</code> <pre><code>@staticmethod\ndef from_temporal_dag(dag: Graph, detect_walks: bool = True) -&gt; PathData:\n    \"\"\"Generate PathData object from temporal DAG where nodes are node-time events.\n\n    Args:\n        dag: A directed acyclic graph representation of a temporal network, where\n            nodes are time-node events.\n        detect_walks: whether or not directed acyclic graphs that just correspond\n                    to walks will be automatically added as walks. If set to false\n                    the resulting `PathData` object will only contain DAGs. If set\n                    to true, the PathData object may contain both DAGs and walks.\n    \"\"\"\n    ds = PathData()\n\n    out_deg = degree(dag.data.edge_index[0])\n    in_deg = degree(dag.data.edge_index[1])\n\n    # check if dag exclusively consists of simple walks and apply fast method\n    if torch.max(out_deg).item() == 1.0 and torch.max(in_deg).item() == 1.0:\n\n        zero_outdegs = (out_deg==0).nonzero().squeeze()\n        zero_indegs = (in_deg==0).nonzero().squeeze()\n\n        # find indices of those elements in src where in-deg = 0, i.e. elements are in zero_indegs\n        start_segs = torch.where(torch.isin(dag.data.edge_index[0], zero_indegs))[0]\n        end_segs = torch.cat((start_segs[1:], torch.tensor([len(dag.data.edge_index[0])], device=config['torch']['device'])))\n        segments = end_segs - start_segs\n        mapping = {\n            i: dag['node_idx', dag.node_index_to_id[i]] for i in dag.node_index_to_id\n        }\n\n        # Map node-time events to node IDs\n        # Convert the tensor to a flattened 1D tensor\n        flat_tensor = dag.data.edge_index.flatten()\n\n        # Create a mask tensor to mark indices to be replaced\n        mask = torch.zeros_like(flat_tensor, device=config['torch']['device'])\n\n        for key, value in mapping.items():\n            # Find indices where the values match the keys in the mapping\n            indices = (flat_tensor == key).nonzero(as_tuple=True)\n\n            # Set the corresponding indices in the mask tensor to 1\n            mask[indices] = 1\n\n            # Replace values in the flattened tensor according to the mapping\n            flat_tensor[indices] = value\n\n        # Reshape the flattened tensor back to the original shape\n        dag.data['edge_index'] = flat_tensor.reshape(dag.data.edge_index.shape)\n\n        # split edge index into multiple independent sections: \n        # sections are limited by indices in src where in-deg = 0 and indices in tgt where out-deg = 0 \n        for t in torch.split(dag.data.edge_index, segments.tolist(), dim=1):\n            ds.add_walk(t)\n\n    else:\n        dags = extract_causal_trees(dag)\n        for d in dags:\n            # src = [ dag['node_idx', dag.node_index_to_id[s.item()]] for s in dags[d][0]] # type: ignore\n            # dst = [ dag['node_idx', dag.node_index_to_id[t.item()]] for t in dags[d][1]] # type: ignore\n            src = [s for s in dags[d][0]]\n            dst = [t for t in dags[d][1]]\n            # ds.add_dag(IntTensor([src, dst]).unique_consecutive(dim=1))\n            edge_index = torch.LongTensor([src, dst]).to(config['torch']['device'])\n            if detect_walks and degree(edge_index[1]).max() == 1 and \\\n                    degree(edge_index[0]).max() == 1:\n                ds.add_walk(edge_index)\n            else:\n                ds.add_dag(edge_index)\n        ds.mapping = {\n            i: dag['node_idx', dag.node_index_to_id[i]] for i in dag.node_index_to_id\n            }\n    return ds\n</code></pre>"},{"location":"reference/pathpyG/core/PathData/#pathpyG.core.PathData.PathData.lift_order_dag","title":"<code>lift_order_dag</code>  <code>staticmethod</code>","text":"<p>Efficiently lift edge index of \\(k\\)-th order model to \\((k+1)\\)-th order model.</p> <p>Parameters:</p> Name Type Description Default <code>edge_index</code> <code>torch.Tensor</code> <p>edge_index of \\(k\\)-th order model that will be lifted to \\((k+1)\\)-th order</p> required Source code in <code>src/pathpyG/core/PathData.py</code> <pre><code>@staticmethod\ndef lift_order_dag(edge_index: Tensor) -&gt; Tensor:\n    \"\"\"Efficiently lift edge index of $k$-th order model to $(k+1)$-th order model.\n\n    Args:\n        edge_index: edge_index of $k$-th order model that will be\n            lifted to $(k+1)$-th order\n    \"\"\"\n    a = edge_index[0].unique(dim=0)\n    b = edge_index[1].unique(dim=0)\n    # intersection of a and b corresponds to all center nodes, which have \n    # at least one incoming and one outgoing edge\n    combined = torch.cat((a, b))\n    uniques, counts = combined.unique(dim=0, return_counts=True)\n    center_nodes = uniques[counts &gt; 1]\n\n    src = []\n    dst = []\n\n    # create edges of order k+1\n    for v in center_nodes:\n        # get all predecessors of v, i.e. elements in edge_index[0] where edge_index[1] == v\n        src_index = torch.all(edge_index[1] == v, axis=1).nonzero().flatten()  # type: ignore\n        srcs = edge_index[0][src_index]\n        # get all successors of v, i.e. elements in edge_index[1] where edge_index[0] == v\n        dst_index = torch.all(edge_index[0] == v, axis=1).nonzero().flatten()  # type: ignore\n        dsts = edge_index[1][dst_index]\n        for s in srcs:\n            for d in dsts:\n                src.append(torch.cat((torch.gather(s, 0, torch.tensor([0]).to(config['torch']['device'])), v)))\n                dst.append(torch.cat((v, torch.gather(d, 0, torch.tensor([d.size()[0]-1]).to(config['torch']['device'])))))\n\n    if len(src) &gt; 0:\n        return torch.stack((torch.stack(src), torch.stack(dst)))\n\n    return torch.tensor([]).to(config['torch']['device'])\n</code></pre>"},{"location":"reference/pathpyG/core/PathData/#pathpyG.core.PathData.PathData.map_nodes","title":"<code>map_nodes</code>  <code>staticmethod</code>","text":"<p>Efficiently map node indices in edge_index tensor based on dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>edge_index</code> <code>torch.Tensor</code> <p>the tensor for which indices shall be mapped</p> required <code>mapping</code> <code>typing.Dict</code> <p>dictionary mapping incides in original tensor to new values</p> required Example <pre><code>import pathpyG as pp\nedge_index = IntTensor([[0,1,2], [1,2,3]])\n\nprint(edge_index)\ntensor([[0, 1, 3],\n        [1, 2, 3]])\n\nmapping = {0: 1, 1: 0, 2: 3, 3: 2}\nmapped = pp.PathData.map_nodes(edge_index, mapping)\n\nprint(mapped)\ntensor([[1, 0, 3],\n        [0, 3, 2]])\n</code></pre> Source code in <code>src/pathpyG/core/PathData.py</code> <pre><code>@staticmethod\ndef map_nodes(edge_index: Tensor, mapping: Dict) -&gt; Tensor:\n    \"\"\"Efficiently map node indices in edge_index tensor based on dictionary.\n\n    Args:\n        edge_index: the tensor for which indices shall be mapped\n        mapping: dictionary mapping incides in original tensor to new values\n\n    Example:\n        ```py\n        import pathpyG as pp\n        edge_index = IntTensor([[0,1,2], [1,2,3]])\n\n        print(edge_index)\n        tensor([[0, 1, 3],\n                [1, 2, 3]])\n\n        mapping = {0: 1, 1: 0, 2: 3, 3: 2}\n        mapped = pp.PathData.map_nodes(edge_index, mapping)\n\n        print(mapped)\n        tensor([[1, 0, 3],\n                [0, 3, 2]])\n        ```\n    \"\"\"\n    # Inspired by `https://stackoverflow.com/questions/13572448`.\n    palette, key = zip(*mapping.items())\n    key = torch.tensor(key).to(config['torch']['device'])\n    palette = torch.tensor(palette).to(config['torch']['device'])\n\n    index = torch.bucketize(edge_index.ravel(), palette)\n    remapped = key[index].reshape(edge_index.shape)\n    return remapped\n</code></pre>"},{"location":"reference/pathpyG/core/PathData/#pathpyG.core.PathData.PathData.to_scipy_sparse_matrix","title":"<code>to_scipy_sparse_matrix</code>","text":"<p>Return sparse adjacency matrix of underlying graph.</p> Source code in <code>src/pathpyG/core/PathData.py</code> <pre><code>def to_scipy_sparse_matrix(self) -&gt; Any:\n    \"\"\"Return sparse adjacency matrix of underlying graph.\"\"\"\n    return to_scipy_sparse_matrix(self.edge_index)\n</code></pre>"},{"location":"reference/pathpyG/core/PathData/#pathpyG.core.PathData.PathData.walk_to_node_seq","title":"<code>walk_to_node_seq</code>  <code>staticmethod</code>","text":"<p>Turn <code>edge_index</code> for a walk into a sequence of traversed node indices.</p> <p>Parameters:</p> Name Type Description Default <code>walk</code> <code>torch.Tensor</code> <p>ordered <code>edge_index</code> of a given walk in a graph</p> required Example <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; s = pp.PathData.walk_to_node_seq(torch.tensor([[0,2],[2,3]]))\n&gt;&gt;&gt; print(s)\n[0,2,3]\n</code></pre> Source code in <code>src/pathpyG/core/PathData.py</code> <pre><code>@staticmethod\ndef walk_to_node_seq(walk: Tensor) -&gt; Tensor:\n    \"\"\"Turn `edge_index` for a walk into a sequence of traversed node indices.\n\n    Args:\n        walk: ordered `edge_index` of a given walk in a graph\n\n    Example:\n        ```pycon\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; s = pp.PathData.walk_to_node_seq(torch.tensor([[0,2],[2,3]]))\n        &gt;&gt;&gt; print(s)\n        [0,2,3]\n        ```\n    \"\"\"\n    return cat([walk[:, 0], walk[1, 1:]])\n</code></pre>"},{"location":"reference/pathpyG/core/PathData/#pathpyG.core.PathData.PathType","title":"<code>PathType</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>An enum used to distinguish observations of walks and DAGs.</p> Source code in <code>src/pathpyG/core/PathData.py</code> <pre><code>class PathType(Enum):\n    \"\"\"An enum used to distinguish observations of walks and DAGs.\"\"\"\n\n    WALK = 0\n    DAG = 1\n</code></pre>"},{"location":"reference/pathpyG/core/TemporalGraph/","title":"TemporalGraph","text":""},{"location":"reference/pathpyG/core/TemporalGraph/#pathpyG.core.TemporalGraph.TemporalGraph","title":"<code>TemporalGraph</code>","text":"<p>             Bases: <code>pathpyG.Graph</code></p> Source code in <code>src/pathpyG/core/TemporalGraph.py</code> <pre><code>class TemporalGraph(Graph):\n    def __init__(self, edge_index, t, node_id=[], **kwargs):\n        \"\"\"Creates an instance of a temporal graph with given edge index and timestamps of edges\"\"\"\n\n        assert len(node_id) == len(set(node_id)), \"node_id entries must be unique\"\n\n        # sort edges by timestamp and reorder edge_index accordingly\n        t_sorted, indices = torch.sort(torch.tensor(t).to(config[\"torch\"][\"device\"]))\n\n        if len(node_id) == 0:\n            self.data = TemporalData(\n                src=edge_index[0][indices],\n                dst=edge_index[1][indices],\n                t=t_sorted,\n                node_id=[],\n                **kwargs,\n            )\n        else:\n            self.data = TemporalData(\n                src=edge_index[0][indices],\n                dst=edge_index[1][indices],\n                t=t_sorted,\n                node_id=node_id,\n                num_nodes=len(node_id),\n                **kwargs,\n            )\n\n        self.data[\"edge_index\"] = edge_index[:, indices]\n\n        # create mappings between node ids and node indices\n        self.node_index_to_id = dict(enumerate(node_id))\n        self.node_id_to_index = {v: i for i, v in enumerate(node_id)}\n\n        # create mapping between edge index and edge tuples\n        self.edge_to_index = {\n            (e[0].item(), e[1].item()): i\n            for i, e in enumerate([e for e in edge_index.t()])\n        }\n\n        self.start_time = t_sorted.min()\n        self.end_time = t_sorted.max()\n\n        # initialize adjacency matrix\n        self._sparse_adj_matrix = torch_geometric.utils.to_scipy_sparse_matrix(\n            self.data.edge_index\n        ).tocsr()\n\n    @staticmethod\n    def from_edge_list(edge_list):\n        sources = []\n        targets = []\n        ts = []\n\n        nodes_index = dict()\n        index_nodes = dict()\n\n        n = 0\n        for v, w, t in edge_list:\n            if v not in nodes_index:\n                nodes_index[v] = n\n                index_nodes[n] = v\n                n += 1\n            if w not in nodes_index:\n                nodes_index[w] = n\n                index_nodes[n] = w\n                n += 1\n            sources.append(nodes_index[v])\n            targets.append(nodes_index[w])\n            ts.append(t)\n\n        return TemporalGraph(\n            edge_index=torch.LongTensor([sources, targets]).to(\n                config[\"torch\"][\"device\"]\n            ),\n            t=ts,\n            node_id=[index_nodes[i] for i in range(n)],\n        )\n\n    @staticmethod\n    def from_csv(file) -&gt; TemporalGraph:\n        tedges = []\n        with open(file, \"r\", encoding=\"utf-8\") as f:\n            for line in f:\n                path = []\n                fields = line.strip().split(\",\")\n                tedges.append((fields[0], fields[1], int(fields[2])))\n        return TemporalGraph.from_edge_list(tedges)\n\n    @property\n    def temporal_edges(self):\n        if len(self.node_index_to_id) &gt; 0:\n            i = 0\n            for e in self.data.edge_index.t():\n                yield self.node_index_to_id[e[0].item()], self.node_index_to_id[e[1].item()], self.data.t[i].item()  # type: ignore\n                i += 1\n        else:\n            i = 0\n            for e in self.data.edge_index.t():\n                yield e[0].item(), e[1].item(), self.data.t[i].item()  # type: ignore\n                i += 1\n\n    @staticmethod\n    def from_pyg_data(d: TemporalData, node_id=[]):\n        x = d.to_dict()\n\n        del x[\"src\"]\n        del x[\"dst\"]\n        del x[\"t\"]\n        if \"edge_index\" in d:\n            del x[\"edge_index\"]\n        if \"node_index\" in d:\n            del x[\"node_id\"]\n\n        g = TemporalGraph(\n            edge_index=torch.tensor([d[\"src\"], d[\"dst\"]]).to(config[\"torch\"][\"device\"]),\n            t=d[\"t\"],\n            node_id=node_id,\n            **x,\n        )\n\n        return g\n\n    def to_static_graph(self) -&gt; Graph:\n        \"\"\"Return instance of [`Graph`][pathpyG.Graph] that represents the static, time-aggregated network.\n        \"\"\"\n        node_id = [self.node_index_to_id[i] for i in range(self.N)]\n        return Graph(self.data.edge_index, node_id)\n\n    def to_pyg_data(self) -&gt; TemporalData:\n        \"\"\"\n        Returns an instance of [`torch_geometric.Data`](https://pytorch-geometric.readthedocs.io/en/latest/generated/torch_geometric.data.Data.html#torch_geometric.data.Data) containing the\n        `edge_index` as well as node, edge, and graph attributes\n        \"\"\"\n        return self.data\n\n    def __str__(self):\n        \"\"\"\n        Returns a string representation of the graph\n        \"\"\"\n        s = \"Temporal Graph with {0} nodes {1} edges and {2} time-stamped events in [{3}, {4}]\\n\".format(\n            self.data.num_nodes,\n            self.data[\"edge_index\"].unique(dim=1).size(dim=1),\n            self.data.num_events,\n            self.start_time,\n            self.end_time,\n        )\n\n        attr_types = Graph.attr_types(self.data.to_dict())\n\n        if len(self.data.node_attrs()) &gt; 0:\n            s += \"\\nNode attributes\\n\"\n            for a in self.data.node_attrs():\n                s += \"\\t{0}\\t\\t{1}\\n\".format(a, attr_types[a])\n        if len(self.data.edge_attrs()) &gt; 1:\n            s += \"\\nEdge attributes\\n\"\n            for a in self.data.edge_attrs():\n                if a != \"edge_index\":\n                    s += \"\\t{0}\\t\\t{1}\\n\".format(a, attr_types[a])\n        if len(self.data.keys()) &gt; len(self.data.edge_attrs()) + len(\n            self.data.node_attrs()\n        ):\n            s += \"\\nGraph attributes\\n\"\n            for a in self.data.keys():\n                if not self.data.is_node_attr(a) and not self.data.is_edge_attr(a):\n                    s += \"\\t{0}\\t\\t{1}\\n\".format(a, attr_types[a])\n        return s\n</code></pre>"},{"location":"reference/pathpyG/core/TemporalGraph/#pathpyG.core.TemporalGraph.TemporalGraph.__init__","title":"<code>__init__</code>","text":"<p>Creates an instance of a temporal graph with given edge index and timestamps of edges</p> Source code in <code>src/pathpyG/core/TemporalGraph.py</code> <pre><code>def __init__(self, edge_index, t, node_id=[], **kwargs):\n    \"\"\"Creates an instance of a temporal graph with given edge index and timestamps of edges\"\"\"\n\n    assert len(node_id) == len(set(node_id)), \"node_id entries must be unique\"\n\n    # sort edges by timestamp and reorder edge_index accordingly\n    t_sorted, indices = torch.sort(torch.tensor(t).to(config[\"torch\"][\"device\"]))\n\n    if len(node_id) == 0:\n        self.data = TemporalData(\n            src=edge_index[0][indices],\n            dst=edge_index[1][indices],\n            t=t_sorted,\n            node_id=[],\n            **kwargs,\n        )\n    else:\n        self.data = TemporalData(\n            src=edge_index[0][indices],\n            dst=edge_index[1][indices],\n            t=t_sorted,\n            node_id=node_id,\n            num_nodes=len(node_id),\n            **kwargs,\n        )\n\n    self.data[\"edge_index\"] = edge_index[:, indices]\n\n    # create mappings between node ids and node indices\n    self.node_index_to_id = dict(enumerate(node_id))\n    self.node_id_to_index = {v: i for i, v in enumerate(node_id)}\n\n    # create mapping between edge index and edge tuples\n    self.edge_to_index = {\n        (e[0].item(), e[1].item()): i\n        for i, e in enumerate([e for e in edge_index.t()])\n    }\n\n    self.start_time = t_sorted.min()\n    self.end_time = t_sorted.max()\n\n    # initialize adjacency matrix\n    self._sparse_adj_matrix = torch_geometric.utils.to_scipy_sparse_matrix(\n        self.data.edge_index\n    ).tocsr()\n</code></pre>"},{"location":"reference/pathpyG/core/TemporalGraph/#pathpyG.core.TemporalGraph.TemporalGraph.__str__","title":"<code>__str__</code>","text":"<p>Returns a string representation of the graph</p> Source code in <code>src/pathpyG/core/TemporalGraph.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    Returns a string representation of the graph\n    \"\"\"\n    s = \"Temporal Graph with {0} nodes {1} edges and {2} time-stamped events in [{3}, {4}]\\n\".format(\n        self.data.num_nodes,\n        self.data[\"edge_index\"].unique(dim=1).size(dim=1),\n        self.data.num_events,\n        self.start_time,\n        self.end_time,\n    )\n\n    attr_types = Graph.attr_types(self.data.to_dict())\n\n    if len(self.data.node_attrs()) &gt; 0:\n        s += \"\\nNode attributes\\n\"\n        for a in self.data.node_attrs():\n            s += \"\\t{0}\\t\\t{1}\\n\".format(a, attr_types[a])\n    if len(self.data.edge_attrs()) &gt; 1:\n        s += \"\\nEdge attributes\\n\"\n        for a in self.data.edge_attrs():\n            if a != \"edge_index\":\n                s += \"\\t{0}\\t\\t{1}\\n\".format(a, attr_types[a])\n    if len(self.data.keys()) &gt; len(self.data.edge_attrs()) + len(\n        self.data.node_attrs()\n    ):\n        s += \"\\nGraph attributes\\n\"\n        for a in self.data.keys():\n            if not self.data.is_node_attr(a) and not self.data.is_edge_attr(a):\n                s += \"\\t{0}\\t\\t{1}\\n\".format(a, attr_types[a])\n    return s\n</code></pre>"},{"location":"reference/pathpyG/core/TemporalGraph/#pathpyG.core.TemporalGraph.TemporalGraph.to_pyg_data","title":"<code>to_pyg_data</code>","text":"<p>Returns an instance of <code>torch_geometric.Data</code> containing the <code>edge_index</code> as well as node, edge, and graph attributes</p> Source code in <code>src/pathpyG/core/TemporalGraph.py</code> <pre><code>def to_pyg_data(self) -&gt; TemporalData:\n    \"\"\"\n    Returns an instance of [`torch_geometric.Data`](https://pytorch-geometric.readthedocs.io/en/latest/generated/torch_geometric.data.Data.html#torch_geometric.data.Data) containing the\n    `edge_index` as well as node, edge, and graph attributes\n    \"\"\"\n    return self.data\n</code></pre>"},{"location":"reference/pathpyG/core/TemporalGraph/#pathpyG.core.TemporalGraph.TemporalGraph.to_static_graph","title":"<code>to_static_graph</code>","text":"<p>Return instance of <code>Graph</code> that represents the static, time-aggregated network.</p> Source code in <code>src/pathpyG/core/TemporalGraph.py</code> <pre><code>def to_static_graph(self) -&gt; Graph:\n    \"\"\"Return instance of [`Graph`][pathpyG.Graph] that represents the static, time-aggregated network.\n    \"\"\"\n    node_id = [self.node_index_to_id[i] for i in range(self.N)]\n    return Graph(self.data.edge_index, node_id)\n</code></pre>"},{"location":"reference/pathpyG/io/","title":"io","text":""},{"location":"reference/pathpyG/io/netzschleuder/","title":"netzschleuder","text":""},{"location":"reference/pathpyG/io/netzschleuder/#pathpyG.io.netzschleuder.list_netzschleuder_records","title":"<code>list_netzschleuder_records</code>","text":"<p>Read a list of data sets available at the netzschleuder repository.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>Base URL of netzschleuder repository</p> <code>'https://networks.skewed.de'</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments that will be passed to the netzschleuder repository as HTTP GET parameters. For supported parameters see https://networks.skewed.de/api</p> <code>{}</code> <p>Examples:</p> <p>Return a list of all data sets</p> <pre><code>&gt;&gt;&gt; import pathpy as pp\n&gt;&gt;&gt; pp.io.graphtool.list_netzschleuder_records()\n['karate', 'reality_mining', 'sp_hypertext', ...]\n</code></pre> <p>Return a list of all data sets with a given tag</p> <pre><code>&gt;&gt;&gt; pp.io.graphtool.list_netzschleuder_records(tags='temporal')\n['reality_mining', 'sp_hypertext', ...]\n</code></pre> <p>Return a dictionary containing all data set names (keys) as well as all network attributes</p> <pre><code>&gt;&gt;&gt; pp.io.graphtool.list_netzschleuder_records(full=True)\n{ 'reality_mining': [...], 'karate': [...] }\n</code></pre> <p>Returns:</p> Type Description <code>typing.Union[list, dict]</code> <p>Either a list of data set names or a dictionary containing all data set names and network attributes.</p> Source code in <code>src/pathpyG/io/netzschleuder.py</code> <pre><code>def list_netzschleuder_records(base_url: str='https://networks.skewed.de', **kwargs: Any) -&gt; Union[list, dict]:\n    \"\"\"\n    Read a list of data sets available at the netzschleuder repository.\n\n    Args:\n        base_url: Base URL of netzschleuder repository\n        **kwargs: Keyword arguments that will be passed to the netzschleuder repository as HTTP GET parameters.\n            For supported parameters see https://networks.skewed.de/api\n\n\n    Examples:\n        Return a list of all data sets\n\n        &gt;&gt;&gt; import pathpy as pp\n        &gt;&gt;&gt; pp.io.graphtool.list_netzschleuder_records()\n        ['karate', 'reality_mining', 'sp_hypertext', ...]\n\n        Return a list of all data sets with a given tag\n\n        &gt;&gt;&gt; pp.io.graphtool.list_netzschleuder_records(tags='temporal')\n        ['reality_mining', 'sp_hypertext', ...]\n\n        Return a dictionary containing all data set names (keys) as well as all network attributes\n\n        &gt;&gt;&gt; pp.io.graphtool.list_netzschleuder_records(full=True)\n        { 'reality_mining': [...], 'karate': [...] }\n\n\n    Returns:\n        Either a list of data set names or a dictionary containing all data set names and network attributes.\n\n    \"\"\"\n    url = '/api/nets'\n    for k, v in kwargs.items():\n        url += '?{0}={1}'.format(k, v)\n    try:\n        f = request.urlopen(base_url + url).read()\n        return json.loads(f)\n    except HTTPError:\n        msg = 'Could not connect to netzschleuder repository at {0}'.format(base_url)\n        # LOG.error(msg)\n        raise Exception(msg)\n</code></pre>"},{"location":"reference/pathpyG/io/netzschleuder/#pathpyG.io.netzschleuder.parse_graphtool_format","title":"<code>parse_graphtool_format</code>","text":"<p>Decodes data in graphtool binary format and returns a <code>Graph</code>. For a documentation of hte graphtool binary format, see see doc at https://graph-tool.skewed.de/static/doc/gt_format.html</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Array of bys to be decoded</p> required <code>ignore_temporal</code> <p>If False, this function will return a static or temporal network depending on whether edges contain a time attribute. If True, pathpy will not interpret time attributes and thus always return a static network.</p> required <p>Returns:</p> Type Description <code>pathpyG.core.Graph.Graph</code> <p>Network or TemporalNetwork: a static or temporal network object</p> Source code in <code>src/pathpyG/io/netzschleuder.py</code> <pre><code>def parse_graphtool_format(data: bytes, id_node_attr=None) -&gt; Graph:\n    \"\"\"\n    Decodes data in graphtool binary format and returns a [`Graph`][pathpyG.Graph]. For a documentation of\n    hte graphtool binary format, see see doc at https://graph-tool.skewed.de/static/doc/gt_format.html\n\n    Args:\n        data: Array of bys to be decoded\n        ignore_temporal: If False, this function will return a static or temporal network depending\n            on whether edges contain a time attribute. If True, pathpy will not interpret\n            time attributes and thus always return a static network.\n\n    Returns:\n        Network or TemporalNetwork: a static or temporal network object\n    \"\"\"\n\n    # check magic bytes\n    if data[0:6] != b'\\xe2\\x9b\\xbe\\x20\\x67\\x74':\n        print('Invalid graphtool file. Wrong magic bytes.')\n        raise Exception('Invalid graphtool file. Wrong magic bytes.')\n    ptr = 6\n\n    # read graphtool version byte\n    graphtool_version = int(data[ptr])\n    ptr += 1\n\n    # read endianness\n    if bool(data[ptr]):\n        graphtool_endianness = '&gt;'\n    else:\n        graphtool_endianness = '&lt;'\n    ptr += 1\n\n    # read length of comment\n    str_len = struct.unpack(graphtool_endianness + 'Q', data[ptr:ptr+8])[0]\n    ptr += 8\n\n    # read string comment\n    comment = data[ptr:ptr+str_len].decode('ascii')\n    ptr += str_len\n\n    # read network directedness\n    directed = bool(data[ptr])\n    ptr += 1\n\n    # read number of nodes\n    n_nodes = struct.unpack(graphtool_endianness + 'Q', data[ptr:ptr+8])[0]\n    ptr += 8\n\n    # create pandas dataframe\n    network_dict = {}\n    # n = Network(directed = directed, multiedges=True)\n\n    # determine binary representation of neighbour lists\n    if n_nodes&lt;2**8:\n        fmt = 'B'\n        d = 1\n    elif n_nodes&lt;2**16:\n        fmt = 'H'\n        d = 2\n    elif n_nodes&lt;2**32:\n        fmt = 'I'\n        d = 4\n    else:\n        fmt = 'Q'\n        d = 8\n\n    sources = []\n    targets = []\n    # parse lists of out-neighbors for all n nodes\n    n_edges = 0\n    for v in range(n_nodes):\n        # read number of neighbors\n        num_neighbors = struct.unpack(graphtool_endianness + 'Q', data[ptr:ptr+8])[0]\n        ptr += 8\n\n        # add edges to record\n        for j in range(num_neighbors):\n            w = struct.unpack(graphtool_endianness + fmt, data[ptr:ptr+d])[0]\n            ptr += d\n            sources.append(v)\n            targets.append(w)\n            n_edges += 1\n\n    #network_data = pd.DataFrame.from_dict(network_dict, orient='index', columns=['v', 'w'])\n\n    # collect attributes from property maps\n    graph_attr = dict()\n    node_attr = dict()\n    edge_attr = dict()\n\n    # parse property maps\n    property_maps = struct.unpack(graphtool_endianness + 'Q', data[ptr:ptr+8])[0]\n    ptr += 8\n\n    for i in range(property_maps):\n        key_type = struct.unpack(graphtool_endianness + 'B', data[ptr:ptr+1])[0]\n        ptr += 1\n\n        property_len  = struct.unpack(graphtool_endianness + 'Q', data[ptr:ptr+8])[0]\n        ptr += 8\n\n        property_name = data[ptr:ptr+property_len].decode('ascii')\n        ptr += property_len\n\n        property_type = struct.unpack(graphtool_endianness + 'B', data[ptr:ptr+1])[0]\n        ptr += 1\n\n        if key_type == 0: # graph-level property\n            res = _parse_property_value(data, ptr, property_type, graphtool_endianness)\n            graph_attr[property_name] = res[0]\n            ptr += res[1]\n        elif key_type == 1: # node-level property\n            if property_name not in node_attr:\n                node_attr[property_name] = []\n            for v in range(n_nodes):\n                res = _parse_property_value(data, ptr, property_type, graphtool_endianness)\n                node_attr[property_name].append([res[0]])\n                ptr += res[1]\n        elif key_type == 2: # edge-level property\n            if property_name not in edge_attr:\n                edge_attr[property_name] = []\n            for e in range(n_edges):\n                res = _parse_property_value(data, ptr, property_type, graphtool_endianness)\n                edge_attr[property_name].append(res[0])\n                ptr += res[1]\n        else:\n            print('Unknown key type {0}'.format(key_type))\n\n    # LOG.info('Version \\t= {0}'.format(graphtool_version))\n    # LOG.info('Endianness \\t= {0}'.format(graphtool_endianness))\n    # LOG.info('comment size \\t= {0}'.format(str_len))\n    # LOG.info('comment \\t= {0}'.format(comment))\n    # LOG.info('directed \\t= {0}'.format(directed))\n    # LOG.info('nodes \\t\\t= {0}'.format(n_nodes))\n\n    # add edge properties to data frame\n    # for p in edge_attribute_names:\n    #     # due to use of default_dict, this will add NA values to edges which have missing properties\n    #     network_data[p] = [ edge_attributes[e][p] for e in range(n_edges) ]\n\n    # create graph from pandas dataframe\n\n\n    # if 'time' in edge_attribute_names and not ignore_temporal:\n    #     raise Exception('')\n    #     n = to_temporal_network(network_data, directed=directed, **network_attributes)\n    # else:\n\n\n    if id_node_attr:\n        node_id = node_attr[id_node_attr]\n    else:\n        node_id = []\n\n    g = Graph(edge_index=torch.tensor([sources, targets], dtype=torch.long).to(config['torch']['device']), node_id=node_id)\n    for a in node_attr:\n        if not a.startswith('node_'):\n            # print(node_attr[a])\n            # g.data['node_{0}'.format(a)] = torch.tensor(node_attr[a], dtype=torch.float).to(config['torch']['device'])\n            g.data['node_{0}'.format(a)] = node_attr[a]\n    for a in edge_attr:\n        if not a.startswith('edge_'):\n            g.data['edge_{0}'.format(a)] = torch.tensor(edge_attr[a], dtype=torch.float).to(config['torch']['device'])\n    for a in graph_attr:\n        g.data[a] = graph_attr[a]\n    return g\n</code></pre>"},{"location":"reference/pathpyG/io/netzschleuder/#pathpyG.io.netzschleuder.read_graphtool","title":"<code>read_graphtool</code>","text":"<p>Read a file in graphtool binary format.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Path to graphtool file to be read</p> required Source code in <code>src/pathpyG/io/netzschleuder.py</code> <pre><code>def read_graphtool(file: str, ignore_temporal: bool=False, multiedges: bool=False) -&gt; Optional[Union[Graph, TemporalGraph]]:\n    \"\"\"\n    Read a file in graphtool binary format.\n\n    Args:\n        file: Path to graphtool file to be read\n    \"\"\"\n    with open(file, 'rb') as f:\n        if '.zst' in file:\n            try:\n                import zstandard as zstd\n                dctx = zstd.ZstdDecompressor()\n                data = f.read()\n                return parse_graphtool_format(dctx.decompress(data, max_output_size=len(data)))\n            except ModuleNotFoundError:\n                msg = 'Package zstandard is required to decompress graphtool files. Please install module, e.g., using \"pip install zstandard\".'\n                # LOG.error(msg)\n                raise Exception(msg)\n        else:\n            return parse_graphtool_format(f.read(), multiedges)\n</code></pre>"},{"location":"reference/pathpyG/io/netzschleuder/#pathpyG.io.netzschleuder.read_netzschleuder_network","title":"<code>read_netzschleuder_network</code>","text":"<p>Read a pathpy network record from the netzschleuder repository.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the network data sets to read from</p> required <code>net</code> <code>typing.Optional[str]</code> <p>Identifier of the network within the data set to read. For data sets containing a single network only, this can be set to None.</p> <code>None</code> <code>ignore_temporal</code> <code>bool</code> <p>If False, this function will return a static or temporal network depending on whether edges contain a time attribute. If True, pathpy will not interpret time attributes and thus always return a static network.</p> <code>False</code> <code>base_url</code> <code>str</code> <p>Base URL of netzschleuder repository</p> <code>'https://networks.skewed.de'</code> <p>Examples:</p> <p>Read network '77' from karate club data set</p> <pre><code>&gt;&gt;&gt; import pathpy as pp\n&gt;&gt;&gt; n = pp.io.graphtool.read_netzschleuder_network('karate', '77')\n&gt;&gt;&gt; print(type(n))\n&gt;&gt;&gt; pp.plot(n)\npp.Network\n</code></pre> <p>Read a temporal network from a data set containing a single network only (i.e. net can be omitted):</p> <pre><code>&gt;&gt;&gt; n = pp.io.graphtool.read_netzschleuder_network('reality_mining')\n&gt;&gt;&gt; print(type(n))\n&gt;&gt;&gt; pp.plot(n)\npp.TemporalNetwork\n</code></pre> <p>Read temporal network but ignore time attribute of edges:</p> <pre><code>&gt;&gt;&gt; n = pp.io.graphtool.read_netzschleuder_network('reality_mining', ignore_temporal=True)\n&gt;&gt;&gt; print(type(n))\n&gt;&gt;&gt; pp.plot(n)\npp.Network\n</code></pre> <p>Returns:</p> Type Description <code>typing.Union[pathpyG.core.Graph.Graph, pathpyG.core.TemporalGraph.TemporalGraph]</code> <p>Depending on whether the network data set contains an edge attribute</p> <code>typing.Union[pathpyG.core.Graph.Graph, pathpyG.core.TemporalGraph.TemporalGraph]</code> <p><code>time</code> (and whether ignore_temporal is set to True), this function</p> <code>typing.Union[pathpyG.core.Graph.Graph, pathpyG.core.TemporalGraph.TemporalGraph]</code> <p>returns an instance of Network or TemporalNetwork</p> Source code in <code>src/pathpyG/io/netzschleuder.py</code> <pre><code>def read_netzschleuder_network(name: str, net: Optional[str]=None,\n        ignore_temporal: bool=False, multiedges: bool=False,\n        base_url: str='https://networks.skewed.de') -&gt; Union[Graph, TemporalGraph]:\n    \"\"\"Read a pathpy network record from the netzschleuder repository.\n\n    Args:\n        name: Name of the network data sets to read from\n        net: Identifier of the network within the data set to read. For data sets\n            containing a single network only, this can be set to None.\n        ignore_temporal: If False, this function will return a static or temporal network depending\n            on whether edges contain a time attribute. If True, pathpy will not interpret\n            time attributes and thus always return a static network.\n        base_url: Base URL of netzschleuder repository\n\n    Examples:\n        Read network '77' from karate club data set\n\n        &gt;&gt;&gt; import pathpy as pp\n        &gt;&gt;&gt; n = pp.io.graphtool.read_netzschleuder_network('karate', '77')\n        &gt;&gt;&gt; print(type(n))\n        &gt;&gt;&gt; pp.plot(n)\n        pp.Network\n\n        Read a temporal network from a data set containing a single network only\n        (i.e. net can be omitted):\n\n        &gt;&gt;&gt; n = pp.io.graphtool.read_netzschleuder_network('reality_mining')\n        &gt;&gt;&gt; print(type(n))\n        &gt;&gt;&gt; pp.plot(n)\n        pp.TemporalNetwork\n\n        Read temporal network but ignore time attribute of edges:\n\n        &gt;&gt;&gt; n = pp.io.graphtool.read_netzschleuder_network('reality_mining', ignore_temporal=True)\n        &gt;&gt;&gt; print(type(n))\n        &gt;&gt;&gt; pp.plot(n)\n        pp.Network\n\n\n    Returns:\n        Depending on whether the network data set contains an edge attribute\n        `time` (and whether ignore_temporal is set to True), this function\n        returns an instance of Network or TemporalNetwork\n\n    \"\"\"\n    try:\n        import zstandard as zstd\n\n        # retrieve network properties\n        url = '/api/net/{0}'.format(name)\n        properties = json.loads(request.urlopen(base_url + url).read())\n\n        # retrieve data\n        if not net:\n            net = name\n        url = '/net/{0}/files/{1}.gt.zst'.format(name, net)\n        try:\n            f = request.urlopen(base_url + url)\n        except HTTPError:\n            msg = 'Could not connect to netzschleuder repository at {0}'.format(base_url)\n            #LOG.error(msg)\n            raise Exception(msg)\n\n        # decompress data\n        dctx = zstd.ZstdDecompressor()\n        reader = dctx.stream_reader(f)\n        decompressed = reader.readall()\n\n        # parse graphtool binary format\n        return parse_graphtool_format(bytes(decompressed))\n\n    except ModuleNotFoundError:\n        msg = 'Package zstandard is required to decompress graphtool files. Please install module, e.g., using \"pip install zstandard.'\n        # LOG.error(msg)\n        raise Exception(msg)\n</code></pre>"},{"location":"reference/pathpyG/io/netzschleuder/#pathpyG.io.netzschleuder.read_netzschleuder_record","title":"<code>read_netzschleuder_record</code>","text":"<p>Read metadata of a single data record with given name from the netzschleuder repository</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the data set for which to retrieve the metadata</p> required <code>base_url</code> <code>str</code> <p>Base URL of netzschleuder repository</p> <code>'https://networks.skewed.de'</code> <p>Examples:</p> <p>Retrieve metadata of karate club network</p> <pre><code>&gt;&gt;&gt; import pathpy as pp\n&gt;&gt;&gt; metdata = pp.io.graphtool.read_netzschleuder_record('karate')\n&gt;&gt;&gt; print(metadata)\n{\n    'analyses': {'77': {'average_degree': 4.52... } }\n}\n</code></pre> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing key-value pairs of metadata</p> Source code in <code>src/pathpyG/io/netzschleuder.py</code> <pre><code>def read_netzschleuder_record(name: str, base_url: str='https://networks.skewed.de') -&gt; dict:\n    \"\"\"\n    Read metadata of a single data record with given name from the netzschleuder repository\n\n    Args:\n        name: Name of the data set for which to retrieve the metadata\n        base_url: Base URL of netzschleuder repository\n\n    Examples:\n        Retrieve metadata of karate club network\n\n        &gt;&gt;&gt; import pathpy as pp\n        &gt;&gt;&gt; metdata = pp.io.graphtool.read_netzschleuder_record('karate')\n        &gt;&gt;&gt; print(metadata)\n        {\n            'analyses': {'77': {'average_degree': 4.52... } }\n        }\n\n    Returns:\n        Dictionary containing key-value pairs of metadata\n    \"\"\"\n    url = '/api/net/{0}'.format(name)\n    try:\n        return json.loads(request.urlopen(base_url + url).read())\n    except HTTPError:\n        msg = 'Could not connect to netzschleuder repository at {0}'.format(base_url)\n        #LOG.error(msg)\n        raise Exception(msg)\n</code></pre>"},{"location":"reference/pathpyG/nn/","title":"nn","text":""},{"location":"reference/pathpyG/nn/dbgnn/","title":"dbgnn","text":""},{"location":"reference/pathpyG/nn/dbgnn/#pathpyG.nn.dbgnn.DBGNN","title":"<code>DBGNN</code>","text":"<p>             Bases: <code>torch.nn.Module</code></p> <p>Implementation of time-aware graph neural network DBGNN (Reference paper).</p> <p>Parameters:</p> Name Type Description Default <code>num_classes</code> <code>int</code> <p>number of classes</p> required <code>num_features</code> <code>list[int]</code> <p>number of features for first order and higher order nodes, e.g. [first_order_num_features, second_order_num_features]</p> required <code>hidden_dims</code> <code>list[int]</code> <p>number of hidden dimensions per each layer in the first/higher order network</p> required <code>p_dropout</code> <code>float</code> <p>drop-out probability</p> <code>0.0</code> Source code in <code>src/pathpyG/nn/dbgnn.py</code> <pre><code>class DBGNN(Module):\n    \"\"\"Implementation of time-aware graph neural network DBGNN ([Reference paper](https://openreview.net/pdf?id=Dbkqs1EhTr)).\n\n    Args:\n        num_classes: number of classes\n        num_features: number of features for first order and higher order nodes, e.g. [first_order_num_features, second_order_num_features]\n        hidden_dims: number of hidden dimensions per each layer in the first/higher order network\n        p_dropout: drop-out probability\n    \"\"\"\n    def __init__(\n        self,\n        num_classes: int,\n        num_features: list[int],\n        hidden_dims: list[int],\n        p_dropout: float = 0.0\n    ):\n        super().__init__()\n\n        self.num_features = num_features\n        self.num_classes = num_classes\n        self.hidden_dims = hidden_dims\n        self.p_dropout = p_dropout\n\n        # higher-order layers\n        self.higher_order_layers = ModuleList()\n        self.higher_order_layers.append(GCNConv(self.num_features[1], self.hidden_dims[0]))\n\n        # first-order layers\n        self.first_order_layers = ModuleList()\n        self.first_order_layers.append(GCNConv(self.num_features[0], self.hidden_dims[0]))\n\n        for dim in range(1, len(self.hidden_dims)-1):\n            # higher-order layers\n            self.higher_order_layers.append(GCNConv(self.hidden_dims[dim-1], self.hidden_dims[dim]))\n            # first-order layers\n            self.first_order_layers.append(GCNConv(self.hidden_dims[dim-1], self.hidden_dims[dim]))\n\n        self.bipartite_layer = BipartiteGraphOperator(self.hidden_dims[-2], self.hidden_dims[-1])\n\n        # Linear layer\n        self.lin = torch.nn.Linear(self.hidden_dims[-1], num_classes)\n\n\n\n    def forward(self, data):\n\n        x = data.x\n        x_h = data.x_h\n\n        # First-order convolutions\n        for layer in self.first_order_layers:\n            x = F.dropout(x, p=self.p_dropout, training=self.training)\n            x = F.elu(layer(x, data.edge_index, data.edge_weights))\n        x = F.dropout(x, p=self.p_dropout, training=self.training)\n\n        # Second-order convolutions\n        for layer in self.higher_order_layers:\n            x_h = F.dropout(x_h, p=self.p_dropout, training=self.training)\n            x_h = F.elu(layer(x_h, data.edge_index_higher_order, data.edge_weights_higher_order))\n        x_h = F.dropout(x_h, p=self.p_dropout, training=self.training)\n\n        # Bipartite message passing\n        x = torch.nn.functional.elu(self.bipartite_layer((x_h, x), data.bipartite_edge_index, N = data.num_ho_nodes, M= data.num_nodes))\n        x = F.dropout(x, p=self.p_dropout, training=self.training)\n\n        # Linear layer\n        x = self.lin(x)\n\n        return x\n</code></pre>"},{"location":"reference/pathpyG/utils/","title":"utils","text":""},{"location":"reference/pathpyG/utils/config/","title":"config","text":""},{"location":"reference/pathpyG/utils/progress/","title":"progress","text":"<p>Progressbar for pathpy.</p>"},{"location":"reference/pathpyG/utils/progress/#pathpyG.utils.progress.tqdm_console","title":"<code>tqdm_console</code>","text":"<p>Progressbar for a console environment.</p> Source code in <code>src/pathpyG/utils/progress.py</code> <pre><code>def tqdm_console(*args, **kwargs):\n    \"\"\"Progressbar for a console environment.\"\"\"\n    if len(args[0]) &gt; config['progress']['min_iter']:\n        return tq(*args, **kwargs)\n    else:\n        return args[0]\n</code></pre>"},{"location":"reference/pathpyG/utils/progress/#pathpyG.utils.progress.tqdm_disabled","title":"<code>tqdm_disabled</code>","text":"<p>Disable the progress bar and return initial iterator.</p> Source code in <code>src/pathpyG/utils/progress.py</code> <pre><code>def tqdm_disabled(it, *args, **kwargs):\n    \"\"\"Disable the progress bar and return initial iterator.\"\"\"\n    return it\n</code></pre>"},{"location":"reference/pathpyG/utils/progress/#pathpyG.utils.progress.tqdm_notebook","title":"<code>tqdm_notebook</code>","text":"<p>Progressbar for a notebook environment.</p> Source code in <code>src/pathpyG/utils/progress.py</code> <pre><code>def tqdm_notebook(*args, **kwargs):\n    \"\"\"Progressbar for a notebook environment.\"\"\"\n    if len(args[0]) &gt; config['progress']['min_iter']:\n        return tqn(*args, **kwargs)\n    else:\n        return args[0]\n</code></pre>"},{"location":"reference/pathpyG/visualisations/","title":"visualisations","text":"<p>PathpyG visualizations.</p>"},{"location":"reference/pathpyG/visualisations/hist_plots/","title":"hist_plots","text":"<p>Histogram plot classes.</p>"},{"location":"reference/pathpyG/visualisations/hist_plots/#pathpyG.visualisations.hist_plots.HistogramPlot","title":"<code>HistogramPlot</code>","text":"<p>             Bases: <code>pathpyG.visualisations.plot.PathPyPlot</code></p> <p>Histogram plot class for a network property.</p> Source code in <code>src/pathpyG/visualisations/hist_plots.py</code> <pre><code>class HistogramPlot(PathPyPlot):\n    \"\"\"Histogram plot class for a network property.\"\"\"\n\n    _kind = \"hist\"\n\n    def __init__(\n        self, network: Graph, key: str = \"indegrees\", bins: int = 10, **kwargs: Any\n    ) -&gt; None:\n        \"\"\"Initialize network plot class.\"\"\"\n        super().__init__()\n        self.network = network\n        self.config = kwargs\n        self.config[\"bins\"] = bins\n        self.config[\"key\"] = key\n        self.generate()\n\n    def generate(self) -&gt; None:\n        \"\"\"Generate the plot.\"\"\"\n        logger.debug(\"Generate histogram.\")\n\n        data: dict = {}\n\n        match self.config[\"key\"]:\n            case \"indegrees\":\n                logger.debug(\"Generate data for in-degrees\")\n                data[\"values\"] = list(self.network.degrees(mode=\"in\").values())\n            case \"outdegrees\":\n                logger.debug(\"Generate data for out-degrees\")\n                data[\"values\"] = list(self.network.degrees(mode=\"out\").values())\n            case _:\n                logger.error(\n                    f\"The &lt;{self.config['key']}&gt; property\",\n                    \"is currently not supported for hist plots.\",\n                )\n                raise KeyError\n\n        data[\"title\"] = self.config[\"key\"]\n        self.data[\"data\"] = data\n</code></pre>"},{"location":"reference/pathpyG/visualisations/hist_plots/#pathpyG.visualisations.hist_plots.HistogramPlot.__init__","title":"<code>__init__</code>","text":"<p>Initialize network plot class.</p> Source code in <code>src/pathpyG/visualisations/hist_plots.py</code> <pre><code>def __init__(\n    self, network: Graph, key: str = \"indegrees\", bins: int = 10, **kwargs: Any\n) -&gt; None:\n    \"\"\"Initialize network plot class.\"\"\"\n    super().__init__()\n    self.network = network\n    self.config = kwargs\n    self.config[\"bins\"] = bins\n    self.config[\"key\"] = key\n    self.generate()\n</code></pre>"},{"location":"reference/pathpyG/visualisations/hist_plots/#pathpyG.visualisations.hist_plots.HistogramPlot.generate","title":"<code>generate</code>","text":"<p>Generate the plot.</p> Source code in <code>src/pathpyG/visualisations/hist_plots.py</code> <pre><code>def generate(self) -&gt; None:\n    \"\"\"Generate the plot.\"\"\"\n    logger.debug(\"Generate histogram.\")\n\n    data: dict = {}\n\n    match self.config[\"key\"]:\n        case \"indegrees\":\n            logger.debug(\"Generate data for in-degrees\")\n            data[\"values\"] = list(self.network.degrees(mode=\"in\").values())\n        case \"outdegrees\":\n            logger.debug(\"Generate data for out-degrees\")\n            data[\"values\"] = list(self.network.degrees(mode=\"out\").values())\n        case _:\n            logger.error(\n                f\"The &lt;{self.config['key']}&gt; property\",\n                \"is currently not supported for hist plots.\",\n            )\n            raise KeyError\n\n    data[\"title\"] = self.config[\"key\"]\n    self.data[\"data\"] = data\n</code></pre>"},{"location":"reference/pathpyG/visualisations/hist_plots/#pathpyG.visualisations.hist_plots.hist","title":"<code>hist</code>","text":"<p>Plot a histogram.</p> Source code in <code>src/pathpyG/visualisations/hist_plots.py</code> <pre><code>def hist(\n    network: Graph, key: str = \"indegrees\", bins: int = 10, **kwargs: Any\n) -&gt; HistogramPlot:\n    \"\"\"Plot a histogram.\"\"\"\n    return HistogramPlot(network, key, bins, **kwargs)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/layout/","title":"layout","text":""},{"location":"reference/pathpyG/visualisations/layout/#pathpyG.visualisations.layout.Layout","title":"<code>Layout</code>","text":"<p>             Bases: <code>object</code></p> <p>Default class to create layouts</p> <p>The <code>Layout</code> class is used to generate node a layout drawer and return the calculated node positions as a dictionary, where the keywords represents the node ids and the values represents a two dimensional tuple with the x and y coordinates for the associated nodes.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list</code> <p>list with node ids. The list contain a list of unique node ids.</p> required <code>**attr</code> <code>dict</code> <p>Attributes to add to node as key=value pairs. See also <code>layout</code></p> <code>{}</code> See also <p><code>layout</code></p> Source code in <code>src/pathpyG/visualisations/layout.py</code> <pre><code>class Layout(object):\n    \"\"\"Default class to create layouts\n\n    The [`Layout`][pathpyG.visualisations.layout.Layout] class is used to generate node a layout drawer and\n    return the calculated node positions as a dictionary, where the keywords\n    represents the node ids and the values represents a two dimensional tuple\n    with the x and y coordinates for the associated nodes.\n\n    Args:\n        nodes (list): list with node ids.\n            The list contain a list of unique node ids.\n        **attr (dict): Attributes to add to node as key=value pairs.\n            See also [`layout`][pathpyG.visualisations.layout.layout]\n\n    Note: See also\n        [`layout`][pathpyG.visualisations.layout.layout]\n    \"\"\"\n\n    def __init__(self, nodes, adjacency_matrix, **attr):\n        \"\"\"Initialize the Layout class\n\n        The [`Layout`][pathpyG.visualisations.layout.Layout] class is used to generate node a layout drawer and\n        return the calculated node positions as a dictionary, where the keywords\n        represents the node ids and the values represents a two dimensional tuple\n        with the x and y coordinates for the associated nodes.\n\n        Args:\n            nodes (list): list with node ids.\n                The list contain a list of unique node ids.\n            **attr (dict): Attributes to add to node as key=value pairs.\n                See also [`layout`][pathpyG.visualisations.layout.layout]\n        \"\"\"\n\n        # initialize variables\n        self.nodes = nodes\n        self.adjacency_matrix = adjacency_matrix\n\n        # rename the attributes\n        attr = self.rename_attributes(**attr)\n\n        # options for the layouts\n        self.layout_type = attr.get('layout', None)\n        self.k = attr.get('force', None,)\n        self.fixed = attr.get('fixed', None)\n        self.iterations = attr.get('iterations', 50)\n        self.threshold = attr.get('threshold', 1e-4)\n        self.weight = attr.get('weight', None)\n        self.dimension = attr.get('dimension', 2)\n        self.seed = attr.get('seed', None)\n        self.positions = attr.get('positions', None)\n        self.radius = attr.get('radius', 1.0)\n        self.direction = attr.get('direction', 1.0)\n        self.start_angle = attr.get('start_angle', 0.0)\n\n        # TODO: allow also higher dimensional layouts\n        if self.dimension &gt; 2:\n            print('Currently only plots with maximum dimension 2 are supported!')\n            self.dimension = 2\n\n    @staticmethod\n    def rename_attributes(**kwds):\n        \"\"\"Rename layout attributes.\n\n        In the style dictionary multiple keywords can be used to address\n        attributes. These keywords will be converted to an unique key word,\n        used in the remaining code.\n\n        | keys | other valid keys |\n        | ---- | ---------------- |\n        | fixed | `fixed_nodes`, `fixed_vertices`, `fixed_n`, `fixed_v` |\n        | positions | `initial_positions`, `node_positions` `vertex_positions`, `n_positions`, `v_positions` |\n        \"\"\"\n        names = {'fixed': ['fixed_nodes', 'fixed_vertices',\n                           'fixed_v', 'fixed_n'],\n                 'positions': ['initial_positions', 'node_positions',\n                               'vertex_positions', 'n_positions',\n                               'v_positions'],\n                 'layout_': ['layout_'],\n                 }\n\n        _kwds = {}\n        del_keys = []\n        for key, value in kwds.items():\n            for attr, name_list in names.items():\n                for name in name_list:\n                    if name in key and name[0] == key[0]:\n                        _kwds[key.replace(name, attr).replace(\n                            'layout_', '')] = value\n                        del_keys.append(key)\n                        break\n        # remove the replaced keys from the dict\n        for key in del_keys:\n            del kwds[key]\n\n        return {**_kwds, **kwds}\n\n    def generate_layout(self):\n        \"\"\"Function to pick and generate the right layout.\"\"\"\n        # method names\n        names_rand = ['Random', 'random', 'rand', None]\n        names_fr = ['Fruchterman-Reingold', 'fruchterman_reingold', 'fr',\n                    'spring_layout', 'spring layout', 'FR']\n        names_circular = ['circular', 'circle', 'ring', '1d-lattice', 'lattice-1d']\n        names_grid = ['grid', '2d-lattice', 'lattice-2d']\n        # check which layout should be plotted\n        if self.layout_type in names_rand:\n            self.layout = self.random()\n        elif self.layout_type in names_circular or (self.layout_type == 'lattice' and self.dimension == 1):\n            self.layout = self.circular()\n        elif self.layout_type in names_grid or (self.layout_type == 'lattice' and self.dimension == 2):\n            self.layout = self.grid()\n        elif self.layout_type in names_fr:\n            self.layout = self.fruchterman_reingold()\n\n        # print(self.layout)\n        return self.layout\n\n    def random(self):\n        \"\"\"Position nodes uniformly at random in the unit square.\n\n        For every node, a position is generated by choosing each of dimension\n        coordinates uniformly at random on the interval $[0.0, 1.0)$.\n\n        This algorithm can be enabled with the keywords: `Random`,\n        `random`, `rand`, or `None`\n\n        Keyword Args:\n            dimension (int): Dimension of layout. Currently, only plots in 2 dimension are supported. Defaults to 2.\n            seed (int): Set the random state for deterministic node layouts. If int, `seed` is\n                the seed used by the random number generator, if None, the a random\n                seed by created by the numpy random number generator is used.\n\n        Returns:\n            layout (dict): A dictionary of positions keyed by node\n        \"\"\"\n        np.random.seed(self.seed)\n        layout = np.random.rand(len(self.nodes), self.dimension)\n        return dict(zip(self.nodes, layout))\n\n    def fruchterman_reingold(self):\n        \"\"\"Position nodes using Fruchterman-Reingold force-directed algorithm.\n\n        In this algorithm, the nodes are represented by steel rings and the\n        edges are springs between them. The attractive force is analogous to the\n        spring force and the repulsive force is analogous to the electrical\n        force. The basic idea is to minimize the energy of the system by moving\n        the nodes and changing the forces between them.\n\n        This algorithm can be enabled with the keywords: `Fruchterman-Reingold`,\n        `fruchterman_reingold`, `fr`, `spring_layout`, `spring layout`, `FR`\n\n        Keyword Args:\n            force (float): Optimal distance between nodes. If None the distance is set to\n                1/sqrt(n) where n is the number of nodes.  Increase this value to move\n                nodes farther apart.\n            positions (dict): Initial positions for nodes as a dictionary with node as keys and values\n                as a coordinate list or tuple.  If None, then use random initial\n                positions.\n            fixed (list): Nodes to keep fixed at initial position.\n            iterations (int): Maximum number of iterations taken. Defaults to 50.\n            threshold (float): Threshold for relative error in node position changes.  The iteration\n                stops if the error is below this threshold. Defaults to 1e-4.\n            weight (string): The edge attribute that holds the numerical value used for the edge\n                weight.  If None, then all edge weights are 1.\n            dimension (int): Dimension of layout. Currently, only plots in 2 dimension are supported. Defaults to 2.\n            seed (int): Set the random state for deterministic node layouts. If int, `seed` is\n                the seed used by the random number generator, if None, the a random seed\n                by created by the numpy random number generator is used.\n\n        Returns:\n            layout (dict): A dictionary of positions keyed by node\n        \"\"\"\n\n        # convert adjacency matrix\n        self.adjacency_matrix = self.adjacency_matrix.astype(float)\n\n        if self.fixed is not None:\n            self.fixed = np.asarray([self.nodes.index(v) for v in self.fixed])\n\n        if self.positions is not None:\n            # Determine size of existing domain to adjust initial positions\n            _size = max(coord for t in layout.values() for coord in t) # type: ignore\n            if _size == 0:\n                _size = 1\n            np.random.seed(self.seed)\n            self.layout = np.random.rand(\n                len(self.nodes), self.dimension) * _size # type: ignore\n\n            for i, n in enumerate(self.nodes):\n                if n in self.positions:\n                    self.layout[i] = np.asarray(self.positions[n])\n        else:\n            self.layout = None\n            _size = 0\n\n        if self.k is None and self.fixed is not None:\n            # We must adjust k by domain size for layouts not near 1x1\n            self.k = _size / np.sqrt(len(self.nodes))\n\n        try:\n            # Sparse matrix\n            if len(self.nodes) &lt; 500:  # sparse solver for large graphs\n                raise ValueError\n            layout = self._sparse_fruchterman_reingold()\n        except:\n            layout = self._fruchterman_reingold()\n\n        layout = dict(zip(self.nodes, layout))\n\n        return layout\n\n    def _fruchterman_reingold(self):\n        \"\"\"Fruchterman-Reingold algorithm for dense matrices.\n\n        This algorithm is based on the Fruchterman-Reingold algorithm provided\n        by `networkx`. (Copyright (C) 2004-2018 by Aric Hagberg &lt;hagberg@lanl.gov&gt;\n        Dan Schult &lt;dschult@colgate.edu&gt; Pieter Swart &lt;swart@lanl.gov&gt; Richard\n        Penney &lt;rwpenney@users.sourceforge.net&gt; All rights reserved. BSD\n        license.)\n\n        \"\"\"\n        A = self.adjacency_matrix.todense()\n        k = self.k\n        try:\n            _n, _ = A.shape\n        except AttributeError:\n            print('Fruchterman-Reingold algorithm needs an adjacency matrix as input')\n            raise AttributeError\n\n        # make sure we have an array instead of a matrix\n        A = np.asarray(A)\n\n        if self.layout is None:\n            # random initial positions\n            np.random.seed(self.seed)\n            layout = np.asarray(np.random.rand(\n                _n, self.dimension), dtype=A.dtype)\n        else:\n            # make sure positions are of same type as matrix\n            layout = self.layout.astype(A.dtype) # type: ignore\n\n        # optimal distance between nodes\n        if k is None:\n            k = np.sqrt(1.0 / _n)\n        # the initial \"temperature\"  is about .1 of domain area (=1x1)\n        # this is the largest step allowed in the dynamics.\n        # We need to calculate this in case our fixed positions force our domain\n        # to be much bigger than 1x1\n        t = max(max(layout.T[0]) - min(layout.T[0]),\n                max(layout.T[1]) - min(layout.T[1])) * 0.1\n        # simple cooling scheme.\n        # linearly step down by dt on each iteration so last iteration is size dt.\n        dt = t / float(self.iterations + 1)\n        delta = np.zeros(\n            (layout.shape[0], layout.shape[0], layout.shape[1]), dtype=A.dtype)\n        # the inscrutable (but fast) version\n        # this is still O(V^2)\n        # could use multilevel methods to speed this up significantly\n        for iteration in tqdm(range(self.iterations), desc='Calculating Fruchterman-Reingold layout'):\n            # matrix of difference between points\n            delta = layout[:, np.newaxis, :] - layout[np.newaxis, :, :] # type: ignore\n            # distance between points\n            distance = np.linalg.norm(delta, axis=-1)\n            # enforce minimum distance of 0.01\n            np.clip(distance, 0.01, None, out=distance)\n            # displacement \"force\"\n            displacement = np.einsum('ijk,ij-&gt;ik',\n                                     delta,\n                                     (k * k / distance**2 - A * distance / k))\n            # update layoutitions\n            length = np.linalg.norm(displacement, axis=-1)\n            length = np.where(length &lt; 0.01, 0.1, length)\n            delta_layout = np.einsum('ij,i-&gt;ij', displacement, t / length)\n            if self.fixed is not None:\n                # don't change positions of fixed nodes\n                delta_layout[self.fixed] = 0.0\n            layout += delta_layout\n            # cool temperature\n            t -= dt\n            error = np.linalg.norm(delta_layout) / _n\n            if error &lt; self.threshold:\n                break\n        return layout\n\n    def _sparse_fruchterman_reingold(self):\n        \"\"\"Fruchterman-Reingold algorithm for sparse matrices.\n\n        This algorithm is based on the Fruchterman-Reingold algorithm provided\n        by networkx. (Copyright (C) 2004-2018 by Aric Hagberg &lt;hagberg@lanl.gov&gt;\n        Dan Schult &lt;dschult@colgate.edu&gt; Pieter Swart &lt;swart@lanl.gov&gt; Richard\n        Penney &lt;rwpenney@users.sourceforge.net&gt; All rights reserved. BSD\n        license.)\n\n        \"\"\"\n        A = self.adjacency_matrix\n        k = self.k\n        try:\n            _n, _ = A.shape\n        except AttributeError:\n            print('Fruchterman-Reingold algorithm needs an adjacency '\n                      'matrix as input')\n            raise AttributeError\n        try:\n            from scipy.sparse import spdiags, coo_matrix\n        except ImportError:\n            print('The sparse Fruchterman-Reingold algorithm needs the '\n                      'scipy package: http://scipy.org/')\n            raise ImportError\n        # make sure we have a LIst of Lists representation\n        try:\n            A = A.tolil()\n        except:\n            A = (coo_matrix(A)).tolil()\n\n        if self.layout is None:\n            # random initial positions\n            np.random.seed(self.seed)\n            layout = np.asarray(np.random.rand(\n                _n, self.dimension), dtype=A.dtype)\n        else:\n            # make sure positions are of same type as matrix\n            layout = layout.astype(A.dtype) # type: ignore\n\n        # no fixed nodes\n        if self.fixed is None:\n            self.fixed = []\n\n        # optimal distance between nodes\n        if k is None:\n            k = np.sqrt(1.0 / _n)\n        # the initial \"temperature\"  is about .1 of domain area (=1x1)\n        # this is the largest step allowed in the dynamics.\n        t = max(max(layout.T[0]) - min(layout.T[0]),\n                max(layout.T[1]) - min(layout.T[1])) * 0.1\n        # simple cooling scheme.\n        # linearly step down by dt on each iteration so last iteration is size dt.\n        dt = t / float(self.iterations + 1)\n\n        displacement = np.zeros((self.dimension, _n))\n        for iteration in range(self.iterations):\n            displacement *= 0\n            # loop over rows\n            for i in range(A.shape[0]):\n                if i in self.fixed:\n                    continue\n                # difference between this row's node position and all others\n                delta = (layout[i] - layout).T\n                # distance between points\n                distance = np.sqrt((delta**2).sum(axis=0))\n                # enforce minimum distance of 0.01\n                distance = np.where(distance &lt; 0.01, 0.01, distance)\n                # the adjacency matrix row\n                Ai = np.asarray(A.getrowview(i).toarray())\n                # displacement \"force\"\n                displacement[:, i] +=\\\n                    (delta * (k * k / distance**2 - Ai * distance / k)).sum(axis=1)\n            # update positions\n            length = np.sqrt((displacement**2).sum(axis=0))\n            length = np.where(length &lt; 0.01, 0.1, length)\n            delta_layout = (displacement * t / length).T\n            layout += delta_layout\n            # cool temperature\n            t -= dt\n            err = np.linalg.norm(delta_layout) / _n\n            if err &lt; self.threshold:\n                break\n        return layout\n\n\n    def circular(self):\n        \"\"\"Position nodes on a circle with given radius.\n\n        This algorithm can be enabled with the keywords: `circular`, `circle`, `ring`, `lattice-1d`, `1d-lattice`, `lattice`\n\n        Keyword Args:\n            radius (float): Sets the radius of the circle on which nodes\n                are positioned. Defaults to 1.0.\n            direction (float): Sets the direction in which nodes are placed on the circle. 1.0 for clockwise (default)\n                and -1.0 for counter-clockwise direction. Defaults to 1.0.\n            start_angle (float): Sets the angle of the first node relative to the 3pm position on a clock.\n                and -1.0 for counter-clockwise direction. Defaults to 90.0.\n\n        Returns:\n            layout (dict): A dictionary of positions keyed by node\n        \"\"\"\n\n        n = len(self.nodes)\n        rad = 2.0 * np.pi / n\n        rotation = (90.0 - self.start_angle*self.direction) * np.pi / 180.0\n        layout = {}\n\n        for i in range(n):\n            x = self.radius * np.cos(rotation - i*rad*self.direction)\n            y = self.radius * np.sin(rotation - i*rad*self.direction)\n            layout[self.nodes[i]] = (x,y)\n\n        return layout\n\n\n    def grid(self):\n        \"\"\"Position nodes on a two-dimensional grid\n\n        This algorithm can be enabled with the keywords: `grid`, `lattice-2d`, `2d-lattice`, `lattice`\n\n        Returns:\n            layout (dict): A dictionary of positions keyed by node\n        \"\"\"\n\n        n = len(self.nodes)\n        width = 1.0\n\n        # number of nodes in horizontal/vertical direction\n        k = np.floor(np.sqrt(n))\n        dist = width / k\n        layout = {}\n\n        i = 0\n        for i in range(n):\n            layout[self.nodes[i]] = ((i%k) *dist, -(np.floor(i/k))*dist)\n            i += 1\n\n        return layout\n</code></pre>"},{"location":"reference/pathpyG/visualisations/layout/#pathpyG.visualisations.layout.Layout.__init__","title":"<code>__init__</code>","text":"<p>Initialize the Layout class</p> <p>The <code>Layout</code> class is used to generate node a layout drawer and return the calculated node positions as a dictionary, where the keywords represents the node ids and the values represents a two dimensional tuple with the x and y coordinates for the associated nodes.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list</code> <p>list with node ids. The list contain a list of unique node ids.</p> required <code>**attr</code> <code>dict</code> <p>Attributes to add to node as key=value pairs. See also <code>layout</code></p> <code>{}</code> Source code in <code>src/pathpyG/visualisations/layout.py</code> <pre><code>def __init__(self, nodes, adjacency_matrix, **attr):\n    \"\"\"Initialize the Layout class\n\n    The [`Layout`][pathpyG.visualisations.layout.Layout] class is used to generate node a layout drawer and\n    return the calculated node positions as a dictionary, where the keywords\n    represents the node ids and the values represents a two dimensional tuple\n    with the x and y coordinates for the associated nodes.\n\n    Args:\n        nodes (list): list with node ids.\n            The list contain a list of unique node ids.\n        **attr (dict): Attributes to add to node as key=value pairs.\n            See also [`layout`][pathpyG.visualisations.layout.layout]\n    \"\"\"\n\n    # initialize variables\n    self.nodes = nodes\n    self.adjacency_matrix = adjacency_matrix\n\n    # rename the attributes\n    attr = self.rename_attributes(**attr)\n\n    # options for the layouts\n    self.layout_type = attr.get('layout', None)\n    self.k = attr.get('force', None,)\n    self.fixed = attr.get('fixed', None)\n    self.iterations = attr.get('iterations', 50)\n    self.threshold = attr.get('threshold', 1e-4)\n    self.weight = attr.get('weight', None)\n    self.dimension = attr.get('dimension', 2)\n    self.seed = attr.get('seed', None)\n    self.positions = attr.get('positions', None)\n    self.radius = attr.get('radius', 1.0)\n    self.direction = attr.get('direction', 1.0)\n    self.start_angle = attr.get('start_angle', 0.0)\n\n    # TODO: allow also higher dimensional layouts\n    if self.dimension &gt; 2:\n        print('Currently only plots with maximum dimension 2 are supported!')\n        self.dimension = 2\n</code></pre>"},{"location":"reference/pathpyG/visualisations/layout/#pathpyG.visualisations.layout.Layout.circular","title":"<code>circular</code>","text":"<p>Position nodes on a circle with given radius.</p> <p>This algorithm can be enabled with the keywords: <code>circular</code>, <code>circle</code>, <code>ring</code>, <code>lattice-1d</code>, <code>1d-lattice</code>, <code>lattice</code></p> <p>Other Parameters:</p> Name Type Description <code>radius</code> <code>float</code> <p>Sets the radius of the circle on which nodes are positioned. Defaults to 1.0.</p> <code>direction</code> <code>float</code> <p>Sets the direction in which nodes are placed on the circle. 1.0 for clockwise (default) and -1.0 for counter-clockwise direction. Defaults to 1.0.</p> <code>start_angle</code> <code>float</code> <p>Sets the angle of the first node relative to the 3pm position on a clock. and -1.0 for counter-clockwise direction. Defaults to 90.0.</p> <p>Returns:</p> Name Type Description <code>layout</code> <code>dict</code> <p>A dictionary of positions keyed by node</p> Source code in <code>src/pathpyG/visualisations/layout.py</code> <pre><code>def circular(self):\n    \"\"\"Position nodes on a circle with given radius.\n\n    This algorithm can be enabled with the keywords: `circular`, `circle`, `ring`, `lattice-1d`, `1d-lattice`, `lattice`\n\n    Keyword Args:\n        radius (float): Sets the radius of the circle on which nodes\n            are positioned. Defaults to 1.0.\n        direction (float): Sets the direction in which nodes are placed on the circle. 1.0 for clockwise (default)\n            and -1.0 for counter-clockwise direction. Defaults to 1.0.\n        start_angle (float): Sets the angle of the first node relative to the 3pm position on a clock.\n            and -1.0 for counter-clockwise direction. Defaults to 90.0.\n\n    Returns:\n        layout (dict): A dictionary of positions keyed by node\n    \"\"\"\n\n    n = len(self.nodes)\n    rad = 2.0 * np.pi / n\n    rotation = (90.0 - self.start_angle*self.direction) * np.pi / 180.0\n    layout = {}\n\n    for i in range(n):\n        x = self.radius * np.cos(rotation - i*rad*self.direction)\n        y = self.radius * np.sin(rotation - i*rad*self.direction)\n        layout[self.nodes[i]] = (x,y)\n\n    return layout\n</code></pre>"},{"location":"reference/pathpyG/visualisations/layout/#pathpyG.visualisations.layout.Layout.fruchterman_reingold","title":"<code>fruchterman_reingold</code>","text":"<p>Position nodes using Fruchterman-Reingold force-directed algorithm.</p> <p>In this algorithm, the nodes are represented by steel rings and the edges are springs between them. The attractive force is analogous to the spring force and the repulsive force is analogous to the electrical force. The basic idea is to minimize the energy of the system by moving the nodes and changing the forces between them.</p> <p>This algorithm can be enabled with the keywords: <code>Fruchterman-Reingold</code>, <code>fruchterman_reingold</code>, <code>fr</code>, <code>spring_layout</code>, <code>spring layout</code>, <code>FR</code></p> <p>Other Parameters:</p> Name Type Description <code>force</code> <code>float</code> <p>Optimal distance between nodes. If None the distance is set to 1/sqrt(n) where n is the number of nodes.  Increase this value to move nodes farther apart.</p> <code>positions</code> <code>dict</code> <p>Initial positions for nodes as a dictionary with node as keys and values as a coordinate list or tuple.  If None, then use random initial positions.</p> <code>fixed</code> <code>list</code> <p>Nodes to keep fixed at initial position.</p> <code>iterations</code> <code>int</code> <p>Maximum number of iterations taken. Defaults to 50.</p> <code>threshold</code> <code>float</code> <p>Threshold for relative error in node position changes.  The iteration stops if the error is below this threshold. Defaults to 1e-4.</p> <code>weight</code> <code>string</code> <p>The edge attribute that holds the numerical value used for the edge weight.  If None, then all edge weights are 1.</p> <code>dimension</code> <code>int</code> <p>Dimension of layout. Currently, only plots in 2 dimension are supported. Defaults to 2.</p> <code>seed</code> <code>int</code> <p>Set the random state for deterministic node layouts. If int, <code>seed</code> is the seed used by the random number generator, if None, the a random seed by created by the numpy random number generator is used.</p> <p>Returns:</p> Name Type Description <code>layout</code> <code>dict</code> <p>A dictionary of positions keyed by node</p> Source code in <code>src/pathpyG/visualisations/layout.py</code> <pre><code>def fruchterman_reingold(self):\n    \"\"\"Position nodes using Fruchterman-Reingold force-directed algorithm.\n\n    In this algorithm, the nodes are represented by steel rings and the\n    edges are springs between them. The attractive force is analogous to the\n    spring force and the repulsive force is analogous to the electrical\n    force. The basic idea is to minimize the energy of the system by moving\n    the nodes and changing the forces between them.\n\n    This algorithm can be enabled with the keywords: `Fruchterman-Reingold`,\n    `fruchterman_reingold`, `fr`, `spring_layout`, `spring layout`, `FR`\n\n    Keyword Args:\n        force (float): Optimal distance between nodes. If None the distance is set to\n            1/sqrt(n) where n is the number of nodes.  Increase this value to move\n            nodes farther apart.\n        positions (dict): Initial positions for nodes as a dictionary with node as keys and values\n            as a coordinate list or tuple.  If None, then use random initial\n            positions.\n        fixed (list): Nodes to keep fixed at initial position.\n        iterations (int): Maximum number of iterations taken. Defaults to 50.\n        threshold (float): Threshold for relative error in node position changes.  The iteration\n            stops if the error is below this threshold. Defaults to 1e-4.\n        weight (string): The edge attribute that holds the numerical value used for the edge\n            weight.  If None, then all edge weights are 1.\n        dimension (int): Dimension of layout. Currently, only plots in 2 dimension are supported. Defaults to 2.\n        seed (int): Set the random state for deterministic node layouts. If int, `seed` is\n            the seed used by the random number generator, if None, the a random seed\n            by created by the numpy random number generator is used.\n\n    Returns:\n        layout (dict): A dictionary of positions keyed by node\n    \"\"\"\n\n    # convert adjacency matrix\n    self.adjacency_matrix = self.adjacency_matrix.astype(float)\n\n    if self.fixed is not None:\n        self.fixed = np.asarray([self.nodes.index(v) for v in self.fixed])\n\n    if self.positions is not None:\n        # Determine size of existing domain to adjust initial positions\n        _size = max(coord for t in layout.values() for coord in t) # type: ignore\n        if _size == 0:\n            _size = 1\n        np.random.seed(self.seed)\n        self.layout = np.random.rand(\n            len(self.nodes), self.dimension) * _size # type: ignore\n\n        for i, n in enumerate(self.nodes):\n            if n in self.positions:\n                self.layout[i] = np.asarray(self.positions[n])\n    else:\n        self.layout = None\n        _size = 0\n\n    if self.k is None and self.fixed is not None:\n        # We must adjust k by domain size for layouts not near 1x1\n        self.k = _size / np.sqrt(len(self.nodes))\n\n    try:\n        # Sparse matrix\n        if len(self.nodes) &lt; 500:  # sparse solver for large graphs\n            raise ValueError\n        layout = self._sparse_fruchterman_reingold()\n    except:\n        layout = self._fruchterman_reingold()\n\n    layout = dict(zip(self.nodes, layout))\n\n    return layout\n</code></pre>"},{"location":"reference/pathpyG/visualisations/layout/#pathpyG.visualisations.layout.Layout.generate_layout","title":"<code>generate_layout</code>","text":"<p>Function to pick and generate the right layout.</p> Source code in <code>src/pathpyG/visualisations/layout.py</code> <pre><code>def generate_layout(self):\n    \"\"\"Function to pick and generate the right layout.\"\"\"\n    # method names\n    names_rand = ['Random', 'random', 'rand', None]\n    names_fr = ['Fruchterman-Reingold', 'fruchterman_reingold', 'fr',\n                'spring_layout', 'spring layout', 'FR']\n    names_circular = ['circular', 'circle', 'ring', '1d-lattice', 'lattice-1d']\n    names_grid = ['grid', '2d-lattice', 'lattice-2d']\n    # check which layout should be plotted\n    if self.layout_type in names_rand:\n        self.layout = self.random()\n    elif self.layout_type in names_circular or (self.layout_type == 'lattice' and self.dimension == 1):\n        self.layout = self.circular()\n    elif self.layout_type in names_grid or (self.layout_type == 'lattice' and self.dimension == 2):\n        self.layout = self.grid()\n    elif self.layout_type in names_fr:\n        self.layout = self.fruchterman_reingold()\n\n    # print(self.layout)\n    return self.layout\n</code></pre>"},{"location":"reference/pathpyG/visualisations/layout/#pathpyG.visualisations.layout.Layout.grid","title":"<code>grid</code>","text":"<p>Position nodes on a two-dimensional grid</p> <p>This algorithm can be enabled with the keywords: <code>grid</code>, <code>lattice-2d</code>, <code>2d-lattice</code>, <code>lattice</code></p> <p>Returns:</p> Name Type Description <code>layout</code> <code>dict</code> <p>A dictionary of positions keyed by node</p> Source code in <code>src/pathpyG/visualisations/layout.py</code> <pre><code>def grid(self):\n    \"\"\"Position nodes on a two-dimensional grid\n\n    This algorithm can be enabled with the keywords: `grid`, `lattice-2d`, `2d-lattice`, `lattice`\n\n    Returns:\n        layout (dict): A dictionary of positions keyed by node\n    \"\"\"\n\n    n = len(self.nodes)\n    width = 1.0\n\n    # number of nodes in horizontal/vertical direction\n    k = np.floor(np.sqrt(n))\n    dist = width / k\n    layout = {}\n\n    i = 0\n    for i in range(n):\n        layout[self.nodes[i]] = ((i%k) *dist, -(np.floor(i/k))*dist)\n        i += 1\n\n    return layout\n</code></pre>"},{"location":"reference/pathpyG/visualisations/layout/#pathpyG.visualisations.layout.Layout.random","title":"<code>random</code>","text":"<p>Position nodes uniformly at random in the unit square.</p> <p>For every node, a position is generated by choosing each of dimension coordinates uniformly at random on the interval \\([0.0, 1.0)\\).</p> <p>This algorithm can be enabled with the keywords: <code>Random</code>, <code>random</code>, <code>rand</code>, or <code>None</code></p> <p>Other Parameters:</p> Name Type Description <code>dimension</code> <code>int</code> <p>Dimension of layout. Currently, only plots in 2 dimension are supported. Defaults to 2.</p> <code>seed</code> <code>int</code> <p>Set the random state for deterministic node layouts. If int, <code>seed</code> is the seed used by the random number generator, if None, the a random seed by created by the numpy random number generator is used.</p> <p>Returns:</p> Name Type Description <code>layout</code> <code>dict</code> <p>A dictionary of positions keyed by node</p> Source code in <code>src/pathpyG/visualisations/layout.py</code> <pre><code>def random(self):\n    \"\"\"Position nodes uniformly at random in the unit square.\n\n    For every node, a position is generated by choosing each of dimension\n    coordinates uniformly at random on the interval $[0.0, 1.0)$.\n\n    This algorithm can be enabled with the keywords: `Random`,\n    `random`, `rand`, or `None`\n\n    Keyword Args:\n        dimension (int): Dimension of layout. Currently, only plots in 2 dimension are supported. Defaults to 2.\n        seed (int): Set the random state for deterministic node layouts. If int, `seed` is\n            the seed used by the random number generator, if None, the a random\n            seed by created by the numpy random number generator is used.\n\n    Returns:\n        layout (dict): A dictionary of positions keyed by node\n    \"\"\"\n    np.random.seed(self.seed)\n    layout = np.random.rand(len(self.nodes), self.dimension)\n    return dict(zip(self.nodes, layout))\n</code></pre>"},{"location":"reference/pathpyG/visualisations/layout/#pathpyG.visualisations.layout.Layout.rename_attributes","title":"<code>rename_attributes</code>  <code>staticmethod</code>","text":"<p>Rename layout attributes.</p> <p>In the style dictionary multiple keywords can be used to address attributes. These keywords will be converted to an unique key word, used in the remaining code.</p> keys other valid keys fixed <code>fixed_nodes</code>, <code>fixed_vertices</code>, <code>fixed_n</code>, <code>fixed_v</code> positions <code>initial_positions</code>, <code>node_positions</code> <code>vertex_positions</code>, <code>n_positions</code>, <code>v_positions</code> Source code in <code>src/pathpyG/visualisations/layout.py</code> <pre><code>@staticmethod\ndef rename_attributes(**kwds):\n    \"\"\"Rename layout attributes.\n\n    In the style dictionary multiple keywords can be used to address\n    attributes. These keywords will be converted to an unique key word,\n    used in the remaining code.\n\n    | keys | other valid keys |\n    | ---- | ---------------- |\n    | fixed | `fixed_nodes`, `fixed_vertices`, `fixed_n`, `fixed_v` |\n    | positions | `initial_positions`, `node_positions` `vertex_positions`, `n_positions`, `v_positions` |\n    \"\"\"\n    names = {'fixed': ['fixed_nodes', 'fixed_vertices',\n                       'fixed_v', 'fixed_n'],\n             'positions': ['initial_positions', 'node_positions',\n                           'vertex_positions', 'n_positions',\n                           'v_positions'],\n             'layout_': ['layout_'],\n             }\n\n    _kwds = {}\n    del_keys = []\n    for key, value in kwds.items():\n        for attr, name_list in names.items():\n            for name in name_list:\n                if name in key and name[0] == key[0]:\n                    _kwds[key.replace(name, attr).replace(\n                        'layout_', '')] = value\n                    del_keys.append(key)\n                    break\n    # remove the replaced keys from the dict\n    for key in del_keys:\n        del kwds[key]\n\n    return {**_kwds, **kwds}\n</code></pre>"},{"location":"reference/pathpyG/visualisations/layout/#pathpyG.visualisations.layout.layout","title":"<code>layout</code>","text":"<p>Function to generate a layout for the network.</p> <p>This function generates a layout configuration for the nodes in the network. Thereby, different layouts and options can be chosen. The layout function is directly included in the plot function or can be separately called.</p> <p>The layout function supports different network types and layout algorithm. Currently supported networks are:</p> <ul> <li><code>cnet</code>,</li> <li><code>networkx</code>,</li> <li><code>igraph</code>,</li> <li><code>pathpyG</code></li> <li>node/edge list</li> </ul> <p>Currently supported algorithms are:</p> <ul> <li>Fruchterman-Reingold force-directed algorithm</li> <li>Uniformly at random node positions</li> </ul> <p>The appearance of the layout can be modified by keyword arguments which will be explained in more detail below.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>network object</code> <p>Network to be drawn. The network can be a <code>cnet</code>, <code>networkx</code>, <code>igraph</code>, <code>pathpy</code> object, or a tuple of a node list and edge list.</p> required <code>**kwds</code> <code>Optional dict</code> <p>Attributes used to modify the appearance of the layout. For details see below.</p> <code>{}</code>"},{"location":"reference/pathpyG/visualisations/layout/#pathpyG.visualisations.layout.layout--layout","title":"Layout:","text":"<p>The layout can be modified by the following keyword arguments: Note:      All layout arguments can be entered with or without <code>layout_</code> at the beginning, e.g. <code>layout_iterations</code> is equal to <code>iterations</code></p> <p>Other Parameters:</p> Name Type Description <code>layout</code> <code>Optional dict or string</code> <p>A dictionary with the node positions on a 2-dimensional plane. The key value of the dict represents the node id while the value represents a tuple of coordinates (e.g. \\(n = (x,y)\\)). The initial layout can be placed anywhere on the 2-dimensional plane.</p> <p>Instead of a dictionary, the algorithm used for the layout can be defined via a string value. Currently, supported are:</p> <ul> <li>Random layout, where the nodes are uniformly at random placed in the     unit square. </li> <li>Fruchterman-Reingold force-directed algorithm. In this algorithm, the     nodes are represented by steel rings and the edges are springs between     them. The attractive force is analogous to the spring force and the     repulsive force is analogous to the electrical force. The basic idea is     to minimize the energy of the system by moving the nodes and changing     the forces between them. </li> </ul> <p>The algorithm can be enabled with the keywords: | Algorithms | Keywords | | ---------- | -------- | | Random | <code>Random</code>, <code>random</code>, <code>rand</code>, <code>None</code> | |Fruchterman-Reingold | <code>Fruchterman-Reingold</code>, <code>fruchterman_reingold</code>, <code>fr spring_layout</code>, <code>spring layout</code>, <code>FR</code> |</p> <code>force</code> <code>float</code> <p>Optimal distance between nodes.  If None the distance is set to 1/sqrt(n) where n is the number of nodes.  Increase this value to move nodes farther apart.</p> <code>positions</code> <code>dict</code> <p>Initial positions for nodes as a dictionary with node as keys and values as a coordinate list or tuple.  If None, then use random initial positions.</p> <code>fixed</code> <code>list</code> <p>Nodes to keep fixed at initial position.</p> <code>iterations</code> <code>int</code> <p>Maximum number of iterations taken. Defaults to 50.</p> <code>threshold</code> <code>float</code> <p>Threshold for relative error in node position changes.  The iteration stops if the error is below this threshold. Defaults to 1e-4.</p> <code>weight</code> <code>string</code> <p>or None, optional (default = None) The edge attribute that holds the numerical value used for the edge weight. If None, then all edge weights are 1.</p> <code>dimension</code> <code>int</code> <p>Dimension of layout. Currently, only plots in 2 dimension are supported. Defaults to 2.</p> <code>seed</code> <code>int</code> <p>Set the random state for deterministic node layouts. If int, <code>seed</code> is the seed used by the random number generator, if None, the a random seed by created by the numpy random number generator is used.</p> <p>In the layout style dictionary multiple keywords can be used to address attributes. These keywords will be converted to an unique key word, used in the remaining code.</p> keys other valid keys fixed <code>fixed_nodes</code>, <code>fixed_vertices</code>, <code>fixed_n</code>, <code>fixed_v</code> positions <code>initial_positions</code>, <code>node_positions</code>, <code>vertex_positions</code>, <code>n_positions</code>, <code>v_positions</code> <p>Examples:</p> <p>For illustration purpose a similar network as in the <code>python-igraph</code> tutorial is used. Instead of <code>igraph</code>, the <code>cnet</code> module is used for creating the network.</p> <p>Create an empty network object, and add some edges.</p> <pre><code>&gt;&gt;&gt; net = Network(name = 'my tikz test network',directed=True)\n&gt;&gt;&gt; net.add_edges_from([('ab','a','b'), ('ac','a','c'), ('cd','c','d'),\n...                     ('de','d','e'), ('ec','e','c'), ('cf','c','f'),\n...                     ('fa','f','a'), ('fg','f','g'),('gg','g','g'),\n...                     ('gd','g','d')])\n</code></pre> <p>Now a layout can be generated:</p> <pre><code>&gt;&gt;&gt; layout(net)\n{'b': array([0.88878309, 0.15685131]), 'd': array([0.4659341 , 0.79839535]),\n'c': array([0.60386662, 0.40727962]), 'e': array([0.71073353, 0.65608203]),\n'g': array([0.42663927, 0.47412449]), 'f': array([0.48759769, 0.86787594]),\n'a': array([0.84154488, 0.1633732 ])}\n</code></pre> <p>Per default, the node positions are assigned uniform random. In order to create a layout, the layout methods of the packages can be used, or the position of the nodes can be directly assigned, in form of a dictionary, where the key is the <code>node_id</code> and the value is a tuple of the node position in \\(x\\) and \\(y\\).</p> <p>Let us generate a force directed layout (e.g. Fruchterman-Reingold):</p> <pre><code>&gt;&gt;&gt; layout(net, layout='fr')\n{'g': array([-0.77646408,  1.71291126]), 'c': array([-0.18639655,0.96232326]),\n'f': array([0.33394308, 0.93778681]), 'e': array([0.09740098, 1.28511973]),\n'a': array([1.37933158, 0.23171857]), 'b': array([ 2.93561876,-0.46183461]),\n'd': array([-0.29329793,  1.48971303])}\n</code></pre> <p>Note, instead of the command <code>fr</code> also the command <code>Fruchterman-Reingold</code> or any other command mentioned above can be used. For more information see table above.</p> <p>In order to keep the properties of the layout for your network separate from the network itself, you can simply set up a Python dictionary containing the keyword arguments you would pass to <code>layout</code> and then use the double asterisk (**) operator to pass your specific layout attributes to <code>layout</code>:</p> <pre><code>&gt;&gt;&gt; layout_style = {}\n&gt;&gt;&gt; layout_style['layout'] = 'Fruchterman-Reingold'\n&gt;&gt;&gt; layout_style['seed'] = 1\n&gt;&gt;&gt; layout_style['iterations'] = 100\n&gt;&gt;&gt; layout(net,**layout_style)\n{'d': array([-0.31778276, 1.78246882]), 'f': array([-0.8603259, 0.82328291]),\n'c': array([-0.4423771 , 1.21203895]), 'e': array([-0.79934355, 1.49000119]),\n'g': array([0.43694799, 1.51428788]), 'a': array([-2.15517293, 0.23948823]),\n'b': array([-3.84803812, -0.71628417])}\n</code></pre> Source code in <code>src/pathpyG/visualisations/layout.py</code> <pre><code>def layout(network, **kwds):\n    \"\"\"Function to generate a layout for the network.\n\n    This function generates a layout configuration for the nodes in the\n    network. Thereby, different layouts and options can be chosen. The layout\n    function is directly included in the plot function or can be separately\n    called.\n\n    The layout function supports different network types and layout algorithm.\n    Currently supported networks are:\n\n    - `cnet`,\n    - `networkx`,\n    - `igraph`,\n    - `pathpyG`\n    - node/edge list\n\n    Currently supported algorithms are:\n\n    - Fruchterman-Reingold force-directed algorithm\n    - Uniformly at random node positions\n\n    The appearance of the layout can be modified by keyword arguments which will\n    be explained in more detail below.\n\n    Args:\n        network (network object): Network to be drawn. The network can be a `cnet`, `networkx`, `igraph`, `pathpy` object, or a tuple of a node list and edge list.\n        **kwds (Optional dict): Attributes used to modify the appearance of the layout. For details see below.\n\n    # Layout:\n\n    The layout can be modified by the following keyword arguments:\n    Note: \n        All layout arguments can be entered with or without `layout_` at the beginning, e.g. `layout_iterations` is equal to `iterations`\n\n    Keyword Args:\n        layout (Optional dict or string): A dictionary with the node positions on a 2-dimensional plane. The\n            key value of the dict represents the node id while the value\n            represents a tuple of coordinates (e.g. $n = (x,y)$). The initial\n            layout can be placed anywhere on the 2-dimensional plane.\n\n            Instead of a dictionary, the algorithm used for the layout can be defined\n            via a string value. Currently, supported are:\n\n            - **Random layout**, where the nodes are uniformly at random placed in the\n                unit square. \n            - **Fruchterman-Reingold force-directed algorithm**. In this algorithm, the\n                nodes are represented by steel rings and the edges are springs between\n                them. The attractive force is analogous to the spring force and the\n                repulsive force is analogous to the electrical force. The basic idea is\n                to minimize the energy of the system by moving the nodes and changing\n                the forces between them. \n\n            The algorithm can be enabled with the keywords:\n            | Algorithms | Keywords |\n            | ---------- | -------- |\n            | Random | `Random`, `random`, `rand`, `None` |\n            |Fruchterman-Reingold | `Fruchterman-Reingold`, `fruchterman_reingold`, `fr spring_layout`, `spring layout`, `FR` |\n\n        force (float): Optimal distance between nodes.  If None the distance is set to\n            1/sqrt(n) where n is the number of nodes.  Increase this value to move\n            nodes farther apart.\n        positions (dict): Initial positions for nodes as a dictionary with node as keys and values\n            as a coordinate list or tuple.  If None, then use random initial\n            positions.\n        fixed (list): Nodes to keep fixed at initial position.\n        iterations (int): Maximum number of iterations taken. Defaults to 50.\n        threshold (float): Threshold for relative error in node position changes.  The iteration\n            stops if the error is below this threshold. Defaults to 1e-4.\n        weight (string):  or None, optional (default = None)\n            The edge attribute that holds the numerical value used for the edge\n            weight. If None, then all edge weights are 1.\n        dimension (int): Dimension of layout. Currently, only plots in 2 dimension are supported. Defaults to 2.\n        seed (int): Set the random state for deterministic node layouts. If int, `seed` is\n            the seed used by the random number generator, if None, the a random seed\n            by created by the numpy random number generator is used.\n\n    In the layout style dictionary multiple keywords can be used to address\n    attributes. These keywords will be converted to an unique key word,\n    used in the remaining code.\n\n    | keys | other valid keys |\n    | ---- | ---------------- |\n    | fixed | `fixed_nodes`, `fixed_vertices`, `fixed_n`, `fixed_v` |\n    | positions| `initial_positions`, `node_positions`, `vertex_positions`, `n_positions`, `v_positions` |\n\n    Examples:\n        For illustration purpose a similar network as in the `python-igraph` tutorial\n        is used. Instead of `igraph`, the `cnet` module is used for creating the\n        network.\n\n        Create an empty network object, and add some edges.\n\n        &gt;&gt;&gt; net = Network(name = 'my tikz test network',directed=True)\n        &gt;&gt;&gt; net.add_edges_from([('ab','a','b'), ('ac','a','c'), ('cd','c','d'),\n        ...                     ('de','d','e'), ('ec','e','c'), ('cf','c','f'),\n        ...                     ('fa','f','a'), ('fg','f','g'),('gg','g','g'),\n        ...                     ('gd','g','d')])\n\n        Now a layout can be generated:\n\n        &gt;&gt;&gt; layout(net)\n        {'b': array([0.88878309, 0.15685131]), 'd': array([0.4659341 , 0.79839535]),\n        'c': array([0.60386662, 0.40727962]), 'e': array([0.71073353, 0.65608203]),\n        'g': array([0.42663927, 0.47412449]), 'f': array([0.48759769, 0.86787594]),\n        'a': array([0.84154488, 0.1633732 ])}\n\n        Per default, the node positions are assigned uniform random. In order to\n        create a layout, the layout methods of the packages can be used, or the\n        position of the nodes can be directly assigned, in form of a dictionary,\n        where the key is the `node_id` and the value is a tuple of the node position\n        in $x$ and $y$.\n\n        Let us generate a force directed layout (e.g. Fruchterman-Reingold):\n\n        &gt;&gt;&gt; layout(net, layout='fr')\n        {'g': array([-0.77646408,  1.71291126]), 'c': array([-0.18639655,0.96232326]),\n        'f': array([0.33394308, 0.93778681]), 'e': array([0.09740098, 1.28511973]),\n        'a': array([1.37933158, 0.23171857]), 'b': array([ 2.93561876,-0.46183461]),\n        'd': array([-0.29329793,  1.48971303])}\n\n        Note, instead of the command `fr` also the command\n        `Fruchterman-Reingold` or any other command mentioned above can be\n        used. For more information see table above.\n\n        In order to keep the properties of the layout for your network separate from\n        the network itself, you can simply set up a Python dictionary containing the\n        keyword arguments you would pass to [`layout`][pathpyG.visualisations.layout.layout] and then use the\n        double asterisk (**) operator to pass your specific layout attributes to\n        [`layout`][pathpyG.visualisations.layout.layout]:\n\n        &gt;&gt;&gt; layout_style = {}\n        &gt;&gt;&gt; layout_style['layout'] = 'Fruchterman-Reingold'\n        &gt;&gt;&gt; layout_style['seed'] = 1\n        &gt;&gt;&gt; layout_style['iterations'] = 100\n        &gt;&gt;&gt; layout(net,**layout_style)\n        {'d': array([-0.31778276, 1.78246882]), 'f': array([-0.8603259, 0.82328291]),\n        'c': array([-0.4423771 , 1.21203895]), 'e': array([-0.79934355, 1.49000119]),\n        'g': array([0.43694799, 1.51428788]), 'a': array([-2.15517293, 0.23948823]),\n        'b': array([-3.84803812, -0.71628417])}\n    \"\"\"\n    # initialize variables\n    _weight = kwds.get('weight', None)\n    if _weight is None:\n        _weight = kwds.get('layout_weight', None)\n\n    # check type of network\n    if 'cnet' in str(type(network)):\n        # log.debug('The network is of type \"cnet\".')\n        nodes = list(network.nodes)\n        adjacency_matrix = network.adjacency_matrix(weight=_weight)\n\n    elif 'networkx' in str(type(network)):\n        # log.debug('The network is of type \"networkx\".')\n        nodes = list(network.nodes())\n        import networkx as nx\n        adjacency_matrix = nx.adjacency_matrix(network, weight=_weight) # type: ignore\n    elif 'igraph' in str(type(network)):\n        # log.debug('The network is of type \"igraph\".')\n        nodes = list(range(len(network.vs)))\n        from scipy.sparse import coo_matrix\n        A = np.array(network.get_adjacency(attribute=_weight).data)\n        adjacency_matrix = coo_matrix(A)\n    elif 'pathpyG' in str(type(network)):\n        # log.debug('The network is of type \"pathpy\".')\n        nodes = list(network.nodes)\n        if _weight is not None:\n            _w = True\n        else:\n            _w = False\n        adjacency_matrix = network.get_sparse_adj_matrix()\n    # elif isinstance(network, tuple):\n    #     # log.debug('The network is of type \"list\".')\n    #     nodes = network[0]\n    #     from collections import OrderedDict\n    #     edges = OrderedDict()\n    #     for e in network[1]:\n    #         edges[e] = e\n\n    else:\n        print('Type of the network could not be determined.'\n                  ' Currently only \"cnet\", \"networkx\",\"igraph\", \"pathpy\"'\n                  ' and \"node/edge list\" is supported!')\n        raise NotImplementedError\n\n    # create layout class\n    layout = Layout(nodes, adjacency_matrix, **kwds)\n    # return the layout\n    return layout.generate_layout()\n</code></pre>"},{"location":"reference/pathpyG/visualisations/network_plots/","title":"network_plots","text":"<p>Network plot classes.</p>"},{"location":"reference/pathpyG/visualisations/network_plots/#pathpyG.visualisations.network_plots.NetworkPlot","title":"<code>NetworkPlot</code>","text":"<p>             Bases: <code>pathpyG.visualisations.plot.PathPyPlot</code></p> <p>Network plot class for a static network.</p> Source code in <code>src/pathpyG/visualisations/network_plots.py</code> <pre><code>class NetworkPlot(PathPyPlot):\n    \"\"\"Network plot class for a static network.\"\"\"\n\n    _kind = \"network\"\n\n    def __init__(self, network: Graph, **kwargs: Any) -&gt; None:\n        \"\"\"Initialize network plot class.\"\"\"\n        super().__init__()\n        self.network = network\n        self.config = kwargs\n        self.generate()\n\n    def generate(self) -&gt; None:\n        \"\"\"Generate the plot.\"\"\"\n        self._compute_edge_data()\n        self._compute_node_data()\n        self._compute_layout()\n        self._cleanup_data()\n\n    def _compute_node_data(self) -&gt; None:\n        \"\"\"Generate the data structure for the nodes.\"\"\"\n        # initialize values\n        nodes: dict = {}\n        attributes: set = {\"color\", \"size\", \"opacity\"}\n        attr: defaultdict = defaultdict(dict)\n\n        # get attributes categories from pathpyg\n        categories = {\n            a.replace(\"node_\", \"\") for a in self.network.node_attrs()\n        }.intersection(attributes)\n\n        # add node data to data dict\n        self._get_node_data(nodes, attributes, attr, categories)\n\n        # convert needed attributes to useful values\n        attr[\"color\"] = self._convert_color(attr[\"color\"], mode=\"node\")\n        attr[\"opacity\"] = self._convert_opacity(attr[\"opacity\"], mode=\"node\")\n        attr[\"size\"] = self._convert_size(attr[\"size\"], mode=\"node\")\n\n        # update data dict with converted attributes\n        for attribute in attr:\n            for key, value in attr[attribute].items():\n                nodes[key][attribute] = value\n\n        # save node data\n        self.data[\"nodes\"] = nodes\n\n    def _get_node_data(\n        self,\n        nodes: dict,\n        attributes: set,\n        attr: defaultdict,\n        categories: set,\n    ) -&gt; None:\n        \"\"\"Extract node data from network.\"\"\"\n        for uid in self.network.nodes:\n            nodes[uid] = {\"uid\": str(uid)}\n\n            # add edge attributes if needed\n            for attribute in attributes:\n                attr[attribute][uid] = (\n                    self.network[f\"node_{attribute}\", uid].item()\n                    if attribute in categories\n                    else None\n                )\n\n    def _compute_edge_data(self) -&gt; None:\n        \"\"\"Generate the data structure for the edges.\"\"\"\n        # initialize values\n        edges: dict = {}\n        attributes: set = {\"weight\", \"color\", \"size\", \"opacity\"}\n        attr: defaultdict = defaultdict(dict)\n\n        # get attributes categories from pathpyg\n        categories: set = {\n            a.replace(\"edge_\", \"\") for a in self.network.edge_attrs()\n        }.intersection(attributes)\n\n        # add edge data to data dict\n        self._get_edge_data(edges, attributes, attr, categories)\n\n        # convert needed attributes to useful values\n        attr[\"weight\"] = self._convert_weight(attr[\"weight\"], mode=\"edge\")\n        attr[\"color\"] = self._convert_color(attr[\"color\"], mode=\"edge\")\n        attr[\"opacity\"] = self._convert_opacity(attr[\"opacity\"], mode=\"edge\")\n        attr[\"size\"] = self._convert_size(attr[\"size\"], mode=\"edge\")\n\n        # update data dict with converted attributes\n        for attribute in attr:\n            for key, value in attr[attribute].items():\n                edges[key][attribute] = value\n\n        # save edge data\n        self.data[\"edges\"] = edges\n\n    def _get_edge_data(\n        self,\n        edges: dict,\n        attributes: set,\n        attr: defaultdict,\n        categories: set,\n    ) -&gt; None:\n        \"\"\"Extract edge data from network.\"\"\"\n        for u, v in self.network.edges:\n            uid = f\"{u}-{v}\"\n            edges[uid] = {\n                \"uid\": uid,\n                \"source\": str(u),\n                \"target\": str(v),\n            }\n            # add edge attributes if needed\n            for attribute in attributes:\n                attr[attribute][uid] = (\n                    self.network[f\"edge_{attribute}\", u, v].item()\n                    if attribute in categories\n                    else None\n                )\n\n    def _convert_weight(self, weight: dict, mode: str = \"node\") -&gt; dict:\n        \"\"\"Convert weight to float.\"\"\"\n        # get style from the config\n        style = self.config.get(f\"{mode}_weight\")\n\n        # check if new attribute is a single object\n        if isinstance(style, (int, float)):\n            weight = {k: style for k in weight}\n\n        # check if new attribute is a dict\n        elif isinstance(style, dict):\n            weight.update(**{k: v for k, v in style.items() if k in weight})\n\n        # return all weights which are not None\n        return {k: v if v is not None else 1 for k, v in weight.items()}\n\n    def _convert_color(self, color: dict, mode: str = \"node\") -&gt; dict:\n        \"\"\"Convert colors to hex if rgb.\"\"\"\n        # get style from the config\n        style = self.config.get(f\"{mode}_color\")\n\n        # check if new attribute is a single object\n        if isinstance(style, (str, int, float, tuple)):\n            color = {k: style for k in color}\n\n        # check if new attribute is a dict\n        elif isinstance(style, dict):\n            color.update(**{k: v for k, v in style.items() if k in color})\n\n        # check if new attribute is a list\n        elif isinstance(style, list):\n            for i, k in enumerate(color):\n                try:\n                    color[k] = style[i]\n                except IndexError:\n                    pass\n\n        # check if numerical values are given\n        values = [v for v in color.values() if isinstance(v, (int, float))]\n\n        if values:\n            # load colormap to map numerical values to color\n            cmap = self.config.get(f\"{mode}_cmap\", Colormap())\n            cdict = {\n                values[i]: tuple(c[:3]) for i, c in enumerate(cmap(values, bytes=True))\n            }\n\n        # convert colors to hex if not already string\n        for key, value in color.items():\n            if isinstance(value, tuple):\n                color[key] = rgb_to_hex(value)\n            elif isinstance(value, (int, float)):\n                color[key] = rgb_to_hex(cdict[value])\n\n        # return all colors wich are not None\n        return {k: v for k, v in color.items() if v is not None}\n\n    def _convert_opacity(self, opacity: dict, mode: str = \"node\") -&gt; dict:\n        \"\"\"Convert opacity to float.\"\"\"\n        # get style from the config\n        style = self.config.get(f\"{mode}_opacity\")\n\n        # check if new attribute is a single object\n        if isinstance(style, (int, float)):\n            opacity = {k: style for k in opacity}\n\n        # check if new attribute is a dict\n        elif isinstance(style, dict):\n            opacity.update(**{k: v for k, v in style.items() if k in opacity})\n\n        # return all colors wich are not None\n        return {k: v for k, v in opacity.items() if v is not None}\n\n    def _convert_size(self, size: dict, mode: str = \"node\") -&gt; dict:\n        \"\"\"Convert size to float.\"\"\"\n        # get style from the config\n        style = self.config.get(f\"{mode}_size\")\n\n        # check if new attribute is a single object\n        if isinstance(style, (int, float)):\n            size = {k: style for k in size}\n\n        # check if new attribute is a dict\n        elif isinstance(style, dict):\n            size.update(**{k: v for k, v in style.items() if k in size})\n\n        # return all colors wich are not None\n        return {k: v for k, v in size.items() if v is not None}\n\n    def _compute_layout(self) -&gt; None:\n        \"\"\"Create layout.\"\"\"\n        # get layout form the config\n        layout = self.config.get(\"layout\", \"rand\")\n\n        # if no layout is considered stop this process\n        if layout is None:\n            return\n\n        # get layout dict for each node\n        if isinstance(layout, str):\n            layout = network_layout(self.network, layout=layout)\n        elif not isinstance(layout, dict):\n            logger.error(\"The provided layout is not valid!\")\n            raise AttributeError\n\n        # update x,y position of the nodes\n        for uid, (_x, _y) in layout.items():\n            self.data[\"nodes\"][uid][\"x\"] = _x\n            self.data[\"nodes\"][uid][\"y\"] = _y\n\n    def _cleanup_data(self) -&gt; None:\n        \"\"\"Clean up final data structure.\"\"\"\n        self.data[\"nodes\"] = list(self.data[\"nodes\"].values())\n        self.data[\"edges\"] = list(self.data[\"edges\"].values())\n</code></pre>"},{"location":"reference/pathpyG/visualisations/network_plots/#pathpyG.visualisations.network_plots.NetworkPlot.__init__","title":"<code>__init__</code>","text":"<p>Initialize network plot class.</p> Source code in <code>src/pathpyG/visualisations/network_plots.py</code> <pre><code>def __init__(self, network: Graph, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize network plot class.\"\"\"\n    super().__init__()\n    self.network = network\n    self.config = kwargs\n    self.generate()\n</code></pre>"},{"location":"reference/pathpyG/visualisations/network_plots/#pathpyG.visualisations.network_plots.NetworkPlot.generate","title":"<code>generate</code>","text":"<p>Generate the plot.</p> Source code in <code>src/pathpyG/visualisations/network_plots.py</code> <pre><code>def generate(self) -&gt; None:\n    \"\"\"Generate the plot.\"\"\"\n    self._compute_edge_data()\n    self._compute_node_data()\n    self._compute_layout()\n    self._cleanup_data()\n</code></pre>"},{"location":"reference/pathpyG/visualisations/network_plots/#pathpyG.visualisations.network_plots.StaticNetworkPlot","title":"<code>StaticNetworkPlot</code>","text":"<p>             Bases: <code>pathpyG.visualisations.network_plots.NetworkPlot</code></p> <p>Network plot class for a static network.</p> Source code in <code>src/pathpyG/visualisations/network_plots.py</code> <pre><code>class StaticNetworkPlot(NetworkPlot):\n    \"\"\"Network plot class for a static network.\"\"\"\n\n    _kind = \"static\"\n</code></pre>"},{"location":"reference/pathpyG/visualisations/network_plots/#pathpyG.visualisations.network_plots.TemporalNetworkPlot","title":"<code>TemporalNetworkPlot</code>","text":"<p>             Bases: <code>pathpyG.visualisations.network_plots.NetworkPlot</code></p> <p>Network plot class for a temporal network.</p> Source code in <code>src/pathpyG/visualisations/network_plots.py</code> <pre><code>class TemporalNetworkPlot(NetworkPlot):\n    \"\"\"Network plot class for a temporal network.\"\"\"\n\n    _kind = \"temporal\"\n\n    def __init__(self, network: TemporalGraph, **kwargs: Any) -&gt; None:\n        \"\"\"Initialize network plot class.\"\"\"\n        super().__init__(network, **kwargs)\n\n    def _get_edge_data(\n        self, edges: dict, attributes: set, attr: defaultdict, categories: set\n    ) -&gt; None:\n        \"\"\"Extract edge data from temporal network.\"\"\"\n        # TODO: Fix typing issue with temporal graphs\n        for u, v, t in self.network.temporal_edges:  # type: ignore\n            uid = f\"{u}-{v}-{t}\"\n            edges[uid] = {\n                \"uid\": uid,\n                \"source\": str(u),\n                \"target\": str(v),\n                \"start\": int(t),\n                \"end\": int(t) + 1,\n            }\n            # add edge attributes if needed\n            for attribute in attributes:\n                attr[attribute][uid] = (\n                    self.network[f\"edge_{attribute}\", u, v].item()\n                    if attribute in categories\n                    else None\n                )\n\n    def _get_node_data(\n        self, nodes: dict, attributes: set, attr: defaultdict, categories: set\n    ) -&gt; None:\n        \"\"\"Extract node data from temporal network.\"\"\"\n\n        time = {e[2] for e in self.network.temporal_edges}\n\n        if self.config.get(\"end\", None) is None:\n            self.config[\"end\"] = int(max(time) + 1)\n\n        if self.config.get(\"start\", None) is None:\n            self.config[\"start\"] = int(min(time) - 1)\n\n        for uid in self.network.nodes:\n            nodes[uid] = {\n                \"uid\": uid,\n                \"start\": int(min(time) - 1),\n                \"end\": int(max(time) + 1),\n            }\n\n            # add edge attributes if needed\n            for attribute in attributes:\n                attr[attribute][uid] = (\n                    self.network[f\"node_{attribute}\", uid].item()\n                    if attribute in categories\n                    else None\n                )\n</code></pre>"},{"location":"reference/pathpyG/visualisations/network_plots/#pathpyG.visualisations.network_plots.TemporalNetworkPlot.__init__","title":"<code>__init__</code>","text":"<p>Initialize network plot class.</p> Source code in <code>src/pathpyG/visualisations/network_plots.py</code> <pre><code>def __init__(self, network: TemporalGraph, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize network plot class.\"\"\"\n    super().__init__(network, **kwargs)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/network_plots/#pathpyG.visualisations.network_plots.network_plot","title":"<code>network_plot</code>","text":"<p>Plot a static network.</p> <p>This function generates a static plot of the network with various output formats including interactive HTML with d3js, tex file with tikz code, PDF from the tex source, and PNG based on matplotlib. The appearance of the plot can be modified using keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>pathpyG.core.Graph.Graph</code> <p>A <code>Graph</code> object to be plotted.</p> required <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments to modify the appearance of the plot. Defaults to no attributes. For details see below.</p> <code>{}</code> <p>Returns:</p> Type Description <code>pathpyG.visualisations.network_plots.NetworkPlot</code> <p>A plot object, the type of which depends on the output format chosen.</p>"},{"location":"reference/pathpyG/visualisations/network_plots/#pathpyG.visualisations.network_plots.network_plot--keyword-arguments-to-modify-the-appearance-of-the-plot","title":"Keyword Arguments to modify the appearance of the plot","text":"<p>Nodes:</p> <ul> <li> <p><code>node_size</code> : diameter of the node</p> </li> <li> <p><code>node_color</code> : The fill color of the node. Possible values are:</p> <ul> <li> <p>A single color string referred to by name, RGB or RGBA code, for   instance <code>red</code> or <code>#a98d19</code> or <code>(12,34,102)</code>.</p> </li> <li> <p>A sequence of color strings referred to by name, RGB or RGBA code,   which will be used for each point's color recursively. For   instance <code>['green', 'yellow']</code> all points will be filled in green or   yellow, alternatively.</p> </li> <li> <p>A column name or position whose values will be used to color the   marker points according to a colormap.</p> </li> </ul> </li> <li> <p><code>node_cmap</code> : Colormap for node colors. If node colors are given as int   or float values the color will be assigned based on a colormap. Per   default the color map goes from red to green. Matplotlib colormaps or   seaborn color palettes can be used to style the node colors.</p> </li> <li> <p><code>node_opacity</code> : fill opacity of the node. The default is 1. The range   of the number lies between 0 and 1. Where 0 represents a fully   transparent fill and 1 a solid fill.</p> </li> </ul> <p>Edges</p> <ul> <li> <p><code>edge_size</code> : width of the edge</p> </li> <li> <p><code>edge_color</code> : The line color of the edge. Possible values are:</p> <ul> <li> <p>A single color string referred to by name, RGB or RGBA code, for   instance <code>red</code> or <code>#a98d19</code> or <code>(12,34,102)</code>.</p> </li> <li> <p>A sequence of color strings referred to by name, RGB or RGBA   code, which will be used for each point's color recursively. For   instance <code>['green','yellow']</code> all points will be filled in green or   yellow, alternatively.</p> </li> <li> <p>A column name or position whose values will be used to color the   marker points according to a colormap.</p> </li> </ul> </li> <li> <p><code>edge_cmap</code> : Colormap for edge colors. If node colors are given as int   or float values the color will be assigned based on a colormap. Per   default the color map goes from red to green. Matplotlib colormaps or   seaborn color palettes can be used to style the edge colors.</p> </li> <li> <p><code>edge_opacity</code> : line opacity of the edge. The default is 1. The range   of the number lies between 0 and 1. Where 0 represents a fully   transparent fill and 1 a solid fill.</p> </li> </ul> <p>General</p> <ul> <li> <p><code>keep_aspect_ratio</code></p> </li> <li> <p><code>margin</code></p> </li> <li> <p><code>layout</code></p> </li> </ul> Source code in <code>src/pathpyG/visualisations/network_plots.py</code> <pre><code>def network_plot(network: Graph, **kwargs: Any) -&gt; NetworkPlot:\n    \"\"\"Plot a static network.\n\n    This function generates a static plot of the network with various output\n    formats including interactive HTML with d3js, tex file with tikz code, PDF\n    from the tex source, and PNG based on matplotlib. The appearance of the\n    plot can be modified using keyword arguments.\n\n    Args:\n        network (Graph): A `Graph` object to be plotted.\n        **kwargs (Any): Keyword arguments to modify the appearance of the\n            plot. Defaults to no attributes. For details see below.\n\n    Returns:\n        A plot object, the type of which depends on the output format chosen.\n\n\n    # Keyword Arguments to modify the appearance of the plot\n    **Nodes:**\n\n    - `node_size` : diameter of the node\n\n    - `node_color` : The fill color of the node. Possible values are:\n\n        - A single color string referred to by name, RGB or RGBA code, for\n          instance `red` or `#a98d19` or `(12,34,102)`.\n\n        - A sequence of color strings referred to by name, RGB or RGBA code,\n          which will be used for each point's color recursively. For\n          instance `['green', 'yellow']` all points will be filled in green or\n          yellow, alternatively.\n\n        - A column name or position whose values will be used to color the\n          marker points according to a colormap.\n\n    - `node_cmap` : Colormap for node colors. If node colors are given as int\n      or float values the color will be assigned based on a colormap. Per\n      default the color map goes from red to green. Matplotlib colormaps or\n      seaborn color palettes can be used to style the node colors.\n\n    - `node_opacity` : fill opacity of the node. The default is 1. The range\n      of the number lies between 0 and 1. Where 0 represents a fully\n      transparent fill and 1 a solid fill.\n\n\n    **Edges**\n\n    - `edge_size` : width of the edge\n\n    - `edge_color` : The line color of the edge. Possible values are:\n\n        - A single color string referred to by name, RGB or RGBA code, for\n          instance `red` or `#a98d19` or `(12,34,102)`.\n\n        - A sequence of color strings referred to by name, RGB or RGBA\n          code, which will be used for each point's color recursively. For\n          instance `['green','yellow']` all points will be filled in green or\n          yellow, alternatively.\n\n        - A column name or position whose values will be used to color the\n          marker points according to a colormap.\n\n    - `edge_cmap` : Colormap for edge colors. If node colors are given as int\n      or float values the color will be assigned based on a colormap. Per\n      default the color map goes from red to green. Matplotlib colormaps or\n      seaborn color palettes can be used to style the edge colors.\n\n    - `edge_opacity` : line opacity of the edge. The default is 1. The range\n      of the number lies between 0 and 1. Where 0 represents a fully\n      transparent fill and 1 a solid fill.\n\n\n    **General**\n\n    - `keep_aspect_ratio`\n\n    - `margin`\n\n    - `layout`\n\n    \"\"\"\n    return NetworkPlot(network, **kwargs)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/network_plots/#pathpyG.visualisations.network_plots.static_plot","title":"<code>static_plot</code>","text":"<p>Plot a static network.</p> Source code in <code>src/pathpyG/visualisations/network_plots.py</code> <pre><code>def static_plot(network: Graph, **kwargs: Any) -&gt; NetworkPlot:\n    \"\"\"Plot a static network.\"\"\"\n    return StaticNetworkPlot(network, **kwargs)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/network_plots/#pathpyG.visualisations.network_plots.temporal_plot","title":"<code>temporal_plot</code>","text":"<p>Plot a temporal network.</p> <p>Temporal properties:</p> <ul> <li> <p><code>start</code> : start time of the simulation</p> </li> <li> <p><code>end</code> : end time of the simulation</p> </li> <li> <p><code>delta</code> : time needed for progressing one time step</p> </li> <li> <p><code>intervals</code> : number of numeric intervals</p> </li> </ul> Source code in <code>src/pathpyG/visualisations/network_plots.py</code> <pre><code>def temporal_plot(network: TemporalGraph, **kwargs: Any) -&gt; NetworkPlot:\n    \"\"\"Plot a temporal network.\n\n    **Temporal properties:**\n\n    - ``start`` : start time of the simulation\n\n    - ``end`` : end time of the simulation\n\n    - ``delta`` : time needed for progressing one time step\n\n    - ``intervals`` : number of numeric intervals\n\n    \"\"\"\n    return TemporalNetworkPlot(network, **kwargs)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/plot/","title":"plot","text":"<p>Class to plot pathpy networks.</p>"},{"location":"reference/pathpyG/visualisations/plot/#pathpyG.visualisations.plot.PathPyPlot","title":"<code>PathPyPlot</code>","text":"<p>Abstract class for assemblig plots.</p>"},{"location":"reference/pathpyG/visualisations/plot/#pathpyG.visualisations.plot.PathPyPlot--attributes","title":"Attributes","text":"<p>data : dict     data of the plot object config : dict     configuration for the plot</p> Source code in <code>src/pathpyG/visualisations/plot.py</code> <pre><code>class PathPyPlot:\n    \"\"\"Abstract class for assemblig plots.\n\n    Attributes\n    ----------\n    data : dict\n        data of the plot object\n    config : dict\n        configuration for the plot\n\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize plot class.\"\"\"\n        logger.debug(\"Initalize PathPyPlot class\")\n        self.data: dict = {}\n        self.config: dict = {}\n\n    @property\n    def _kind(self) -&gt; str:\n        \"\"\"Specify kind str. Must be overridden in child class.\"\"\"\n        raise NotImplementedError\n\n    def generate(self) -&gt; None:\n        \"\"\"Generate the plot.\"\"\"\n        raise NotImplementedError\n\n    def save(self, filename: str, **kwargs: Any) -&gt; None:\n        \"\"\"Save the plot to the hard drive.\"\"\"\n        _backend: str = kwargs.pop(\"backend\", self.config.get(\"backend\", None))\n\n        plot_backend = _get_plot_backend(_backend, filename)\n        plot_backend.plot(\n            deepcopy(self.data), self._kind, **deepcopy(self.config)\n        ).save(filename, **kwargs)\n\n    def show(self, **kwargs: Any) -&gt; None:\n        \"\"\"Show the plot on the device.\"\"\"\n        _backend: str = kwargs.pop(\"backend\", self.config.get(\"backend\", None))\n\n        plot_backend = _get_plot_backend(_backend, None)\n        plot_backend.plot(\n            deepcopy(self.data), self._kind, **deepcopy(self.config)\n        ).show(**kwargs)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/plot/#pathpyG.visualisations.plot.PathPyPlot.__init__","title":"<code>__init__</code>","text":"<p>Initialize plot class.</p> Source code in <code>src/pathpyG/visualisations/plot.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize plot class.\"\"\"\n    logger.debug(\"Initalize PathPyPlot class\")\n    self.data: dict = {}\n    self.config: dict = {}\n</code></pre>"},{"location":"reference/pathpyG/visualisations/plot/#pathpyG.visualisations.plot.PathPyPlot.generate","title":"<code>generate</code>","text":"<p>Generate the plot.</p> Source code in <code>src/pathpyG/visualisations/plot.py</code> <pre><code>def generate(self) -&gt; None:\n    \"\"\"Generate the plot.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pathpyG/visualisations/plot/#pathpyG.visualisations.plot.PathPyPlot.save","title":"<code>save</code>","text":"<p>Save the plot to the hard drive.</p> Source code in <code>src/pathpyG/visualisations/plot.py</code> <pre><code>def save(self, filename: str, **kwargs: Any) -&gt; None:\n    \"\"\"Save the plot to the hard drive.\"\"\"\n    _backend: str = kwargs.pop(\"backend\", self.config.get(\"backend\", None))\n\n    plot_backend = _get_plot_backend(_backend, filename)\n    plot_backend.plot(\n        deepcopy(self.data), self._kind, **deepcopy(self.config)\n    ).save(filename, **kwargs)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/plot/#pathpyG.visualisations.plot.PathPyPlot.show","title":"<code>show</code>","text":"<p>Show the plot on the device.</p> Source code in <code>src/pathpyG/visualisations/plot.py</code> <pre><code>def show(self, **kwargs: Any) -&gt; None:\n    \"\"\"Show the plot on the device.\"\"\"\n    _backend: str = kwargs.pop(\"backend\", self.config.get(\"backend\", None))\n\n    plot_backend = _get_plot_backend(_backend, None)\n    plot_backend.plot(\n        deepcopy(self.data), self._kind, **deepcopy(self.config)\n    ).show(**kwargs)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/utils/","title":"utils","text":"<p>Helper functions for plotting.</p>"},{"location":"reference/pathpyG/visualisations/utils/#pathpyG.visualisations.utils.Colormap","title":"<code>Colormap</code>","text":"<p>Very simple colormap class.</p> Source code in <code>src/pathpyG/visualisations/utils.py</code> <pre><code>class Colormap:\n    \"\"\"Very simple colormap class.\"\"\"\n\n    def __call__(\n        self,\n        values: list,\n        alpha: Optional[float] = None,\n        bytes: bool = False,\n    ) -&gt; list:\n        \"\"\"Return color value.\"\"\"\n        vmin, vmax = min(values), max(values)\n        if vmin == vmax:\n            vmin -= 1\n            vmax += 1\n        return [\n            self.color_tuple(v)\n            for v in ((x - vmin) / (vmax - vmin) * 100 for x in values)\n        ]\n\n    @staticmethod\n    def color_tuple(n: float) -&gt; tuple:\n        \"\"\"Return color ramp from green to red.\"\"\"\n        return (int((255 * n) * 0.01), int((255 * (100 - n)) * 0.01), 0, 255)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/utils/#pathpyG.visualisations.utils.Colormap.__call__","title":"<code>__call__</code>","text":"<p>Return color value.</p> Source code in <code>src/pathpyG/visualisations/utils.py</code> <pre><code>def __call__(\n    self,\n    values: list,\n    alpha: Optional[float] = None,\n    bytes: bool = False,\n) -&gt; list:\n    \"\"\"Return color value.\"\"\"\n    vmin, vmax = min(values), max(values)\n    if vmin == vmax:\n        vmin -= 1\n        vmax += 1\n    return [\n        self.color_tuple(v)\n        for v in ((x - vmin) / (vmax - vmin) * 100 for x in values)\n    ]\n</code></pre>"},{"location":"reference/pathpyG/visualisations/utils/#pathpyG.visualisations.utils.Colormap.color_tuple","title":"<code>color_tuple</code>  <code>staticmethod</code>","text":"<p>Return color ramp from green to red.</p> Source code in <code>src/pathpyG/visualisations/utils.py</code> <pre><code>@staticmethod\ndef color_tuple(n: float) -&gt; tuple:\n    \"\"\"Return color ramp from green to red.\"\"\"\n    return (int((255 * n) * 0.01), int((255 * (100 - n)) * 0.01), 0, 255)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/utils/#pathpyG.visualisations.utils.hex_to_rgb","title":"<code>hex_to_rgb</code>","text":"<p>Convert hex string to rgb color tuple.</p> Source code in <code>src/pathpyG/visualisations/utils.py</code> <pre><code>def hex_to_rgb(value: str) -&gt; tuple:\n    \"\"\"Convert hex string to rgb color tuple.\"\"\"\n    value = value.lstrip(\"#\")\n    _l = len(value)\n    return tuple(int(value[i : i + _l // 3], 16) for i in range(0, _l, _l // 3))\n</code></pre>"},{"location":"reference/pathpyG/visualisations/utils/#pathpyG.visualisations.utils.rgb_to_hex","title":"<code>rgb_to_hex</code>","text":"<p>Convert rgb color tuple to hex string.</p> Source code in <code>src/pathpyG/visualisations/utils.py</code> <pre><code>def rgb_to_hex(rgb: tuple) -&gt; str:\n    \"\"\"Convert rgb color tuple to hex string.\"\"\"\n    return \"#%02x%02x%02x\" % rgb\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_d3js/","title":"_d3js","text":"<p>Initialize d3js plotting functions.</p>"},{"location":"reference/pathpyG/visualisations/_d3js/#pathpyG.visualisations._d3js.plot","title":"<code>plot</code>","text":"<p>Plot function.</p> Source code in <code>src/pathpyG/visualisations/_d3js/__init__.py</code> <pre><code>def plot(data: dict, kind: str = \"network\", **kwargs: Any) -&gt; Any:\n    \"\"\"Plot function.\"\"\"\n    return PLOT_CLASSES[kind](data, **kwargs)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_d3js/core/","title":"core","text":""},{"location":"reference/pathpyG/visualisations/_d3js/core/#pathpyG.visualisations._d3js.core.D3jsPlot","title":"<code>D3jsPlot</code>","text":"<p>             Bases: <code>pathpyG.visualisations.plot.PathPyPlot</code></p> <p>Base class for plotting d3js objects.</p> Source code in <code>src/pathpyG/visualisations/_d3js/core.py</code> <pre><code>class D3jsPlot(PathPyPlot):\n    \"\"\"Base class for plotting d3js objects.\"\"\"\n\n    def generate(self) -&gt; None:\n        \"\"\"Generate the plot.\"\"\"\n        raise NotImplementedError\n\n    def save(self, filename: str, **kwargs: Any) -&gt; None:\n        \"\"\"Save the plot to the hard drive.\"\"\"\n        with open(filename, \"w+\") as new:\n            new.write(self.to_html())\n\n    def show(self, **kwargs: Any) -&gt; None:\n        \"\"\"Show the plot on the device.\"\"\"\n        if config[\"environment\"][\"interactive\"]:\n            from IPython.display import display_html, HTML\n\n            display_html(HTML(self.to_html()))\n        else:\n            # create temporal file\n            with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n                # save html\n                self.save(temp_file.name)\n                # open the file\n                webbrowser.open(r\"file:///\" + temp_file.name)\n\n    def to_json(self) -&gt; str:\n        \"\"\"Convert data to json.\"\"\"\n        raise NotImplementedError\n\n    def to_html(self) -&gt; str:\n        \"\"\"Convert data to html.\"\"\"\n        # generate unique dom uids\n        dom_id = \"#x\" + uuid.uuid4().hex\n\n        # get path to the pathpy templates\n        template_dir = os.path.join(\n            os.path.dirname(os.path.dirname(__file__)),\n            os.path.normpath(\"_d3js/templates\"),\n        )\n\n        # get d3js version\n        local = self.config.get(\"d3js_local\", False)\n        if local:\n            d3js = os.path.join(template_dir, \"d3.v5.min.js\")\n        else:\n            d3js = \"https://d3js.org/d3.v5.min.js\"\n\n        # get template files\n        with open(os.path.join(template_dir, f\"{self._kind}.js\")) as template:\n            js_template = template.read()\n\n        with open(os.path.join(template_dir, \"setup.js\")) as template:\n            setup_template = template.read()\n\n        with open(os.path.join(template_dir, \"styles.css\")) as template:\n            css_template = template.read()\n\n        # load custom template\n        _template = self.config.get(\"template\", None)\n        if _template and os.path.isfile(_template):\n            with open(_template) as template:\n                js_template = template.read()\n\n        # load custom css template\n        _template = self.config.get(\"css\", None)\n        if _template and os.path.isfile(_template):\n            with open(_template) as template:\n                css_template += template.read()\n\n        # update config\n        self.config[\"selector\"] = dom_id\n        data = self.to_json()\n\n        # generate html file\n        html = \"&lt;style&gt;\\n\" + css_template + \"\\n&lt;/style&gt;\\n\"\n\n        # div environment for the plot object\n        html += f'\\n&lt;div id = \"{dom_id[1:]}\"&gt; &lt;/div&gt;\\n'\n\n        # add d3js library\n        html += f'&lt;script charset=\"utf-8\" src=\"{d3js}\"&gt;&lt;/script&gt;\\n'\n\n        # start JavaScript\n        html += '&lt;script charset=\"utf-8\"&gt;\\n'\n\n        # add setup code to run d3js in multiple environments\n        html += Template(setup_template).substitute(d3js=d3js)\n\n        # start d3 environment\n        html += \"require(['d3'], function(d3){ //START\\n\"\n\n        # add data and config\n        html += f\"const data = {data}\\n\"\n        html += f\"const config = {json.dumps(self.config)}\\n\"\n\n        # add JavaScript\n        html += js_template\n\n        # end d3 environment\n        html += \"\\n}); //END\\n\"\n\n        # end JavaScript\n        html += \"\\n&lt;/script&gt;\"\n\n        return html\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_d3js/core/#pathpyG.visualisations._d3js.core.D3jsPlot.generate","title":"<code>generate</code>","text":"<p>Generate the plot.</p> Source code in <code>src/pathpyG/visualisations/_d3js/core.py</code> <pre><code>def generate(self) -&gt; None:\n    \"\"\"Generate the plot.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_d3js/core/#pathpyG.visualisations._d3js.core.D3jsPlot.save","title":"<code>save</code>","text":"<p>Save the plot to the hard drive.</p> Source code in <code>src/pathpyG/visualisations/_d3js/core.py</code> <pre><code>def save(self, filename: str, **kwargs: Any) -&gt; None:\n    \"\"\"Save the plot to the hard drive.\"\"\"\n    with open(filename, \"w+\") as new:\n        new.write(self.to_html())\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_d3js/core/#pathpyG.visualisations._d3js.core.D3jsPlot.show","title":"<code>show</code>","text":"<p>Show the plot on the device.</p> Source code in <code>src/pathpyG/visualisations/_d3js/core.py</code> <pre><code>def show(self, **kwargs: Any) -&gt; None:\n    \"\"\"Show the plot on the device.\"\"\"\n    if config[\"environment\"][\"interactive\"]:\n        from IPython.display import display_html, HTML\n\n        display_html(HTML(self.to_html()))\n    else:\n        # create temporal file\n        with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n            # save html\n            self.save(temp_file.name)\n            # open the file\n            webbrowser.open(r\"file:///\" + temp_file.name)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_d3js/core/#pathpyG.visualisations._d3js.core.D3jsPlot.to_html","title":"<code>to_html</code>","text":"<p>Convert data to html.</p> Source code in <code>src/pathpyG/visualisations/_d3js/core.py</code> <pre><code>def to_html(self) -&gt; str:\n    \"\"\"Convert data to html.\"\"\"\n    # generate unique dom uids\n    dom_id = \"#x\" + uuid.uuid4().hex\n\n    # get path to the pathpy templates\n    template_dir = os.path.join(\n        os.path.dirname(os.path.dirname(__file__)),\n        os.path.normpath(\"_d3js/templates\"),\n    )\n\n    # get d3js version\n    local = self.config.get(\"d3js_local\", False)\n    if local:\n        d3js = os.path.join(template_dir, \"d3.v5.min.js\")\n    else:\n        d3js = \"https://d3js.org/d3.v5.min.js\"\n\n    # get template files\n    with open(os.path.join(template_dir, f\"{self._kind}.js\")) as template:\n        js_template = template.read()\n\n    with open(os.path.join(template_dir, \"setup.js\")) as template:\n        setup_template = template.read()\n\n    with open(os.path.join(template_dir, \"styles.css\")) as template:\n        css_template = template.read()\n\n    # load custom template\n    _template = self.config.get(\"template\", None)\n    if _template and os.path.isfile(_template):\n        with open(_template) as template:\n            js_template = template.read()\n\n    # load custom css template\n    _template = self.config.get(\"css\", None)\n    if _template and os.path.isfile(_template):\n        with open(_template) as template:\n            css_template += template.read()\n\n    # update config\n    self.config[\"selector\"] = dom_id\n    data = self.to_json()\n\n    # generate html file\n    html = \"&lt;style&gt;\\n\" + css_template + \"\\n&lt;/style&gt;\\n\"\n\n    # div environment for the plot object\n    html += f'\\n&lt;div id = \"{dom_id[1:]}\"&gt; &lt;/div&gt;\\n'\n\n    # add d3js library\n    html += f'&lt;script charset=\"utf-8\" src=\"{d3js}\"&gt;&lt;/script&gt;\\n'\n\n    # start JavaScript\n    html += '&lt;script charset=\"utf-8\"&gt;\\n'\n\n    # add setup code to run d3js in multiple environments\n    html += Template(setup_template).substitute(d3js=d3js)\n\n    # start d3 environment\n    html += \"require(['d3'], function(d3){ //START\\n\"\n\n    # add data and config\n    html += f\"const data = {data}\\n\"\n    html += f\"const config = {json.dumps(self.config)}\\n\"\n\n    # add JavaScript\n    html += js_template\n\n    # end d3 environment\n    html += \"\\n}); //END\\n\"\n\n    # end JavaScript\n    html += \"\\n&lt;/script&gt;\"\n\n    return html\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_d3js/core/#pathpyG.visualisations._d3js.core.D3jsPlot.to_json","title":"<code>to_json</code>","text":"<p>Convert data to json.</p> Source code in <code>src/pathpyG/visualisations/_d3js/core.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Convert data to json.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_d3js/network_plots/","title":"network_plots","text":"<p>Network plots with d3js.</p>"},{"location":"reference/pathpyG/visualisations/_d3js/network_plots/#pathpyG.visualisations._d3js.network_plots.NetworkPlot","title":"<code>NetworkPlot</code>","text":"<p>             Bases: <code>pathpyG.visualisations._d3js.core.D3jsPlot</code></p> <p>Network plot class for a static network.</p> Source code in <code>src/pathpyG/visualisations/_d3js/network_plots.py</code> <pre><code>class NetworkPlot(D3jsPlot):\n    \"\"\"Network plot class for a static network.\"\"\"\n\n    _kind = \"network\"\n\n    def __init__(self, data: dict, **kwargs: Any) -&gt; None:\n        \"\"\"Initialize network plot class.\"\"\"\n        super().__init__()\n        self.data = data\n        self.config = kwargs\n        self.generate()\n\n    def generate(self) -&gt; None:\n        \"\"\"Clen up data.\"\"\"\n        self.config.pop(\"node_cmap\", None)\n        self.config.pop(\"edge_cmap\", None)\n        for node in self.data[\"nodes\"]:\n            node.pop(\"x\", None)\n            node.pop(\"y\", None)\n\n    def to_json(self) -&gt; Any:\n        \"\"\"Convert data to json.\"\"\"\n        return json.dumps(self.data)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_d3js/network_plots/#pathpyG.visualisations._d3js.network_plots.NetworkPlot.__init__","title":"<code>__init__</code>","text":"<p>Initialize network plot class.</p> Source code in <code>src/pathpyG/visualisations/_d3js/network_plots.py</code> <pre><code>def __init__(self, data: dict, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize network plot class.\"\"\"\n    super().__init__()\n    self.data = data\n    self.config = kwargs\n    self.generate()\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_d3js/network_plots/#pathpyG.visualisations._d3js.network_plots.NetworkPlot.generate","title":"<code>generate</code>","text":"<p>Clen up data.</p> Source code in <code>src/pathpyG/visualisations/_d3js/network_plots.py</code> <pre><code>def generate(self) -&gt; None:\n    \"\"\"Clen up data.\"\"\"\n    self.config.pop(\"node_cmap\", None)\n    self.config.pop(\"edge_cmap\", None)\n    for node in self.data[\"nodes\"]:\n        node.pop(\"x\", None)\n        node.pop(\"y\", None)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_d3js/network_plots/#pathpyG.visualisations._d3js.network_plots.NetworkPlot.to_json","title":"<code>to_json</code>","text":"<p>Convert data to json.</p> Source code in <code>src/pathpyG/visualisations/_d3js/network_plots.py</code> <pre><code>def to_json(self) -&gt; Any:\n    \"\"\"Convert data to json.\"\"\"\n    return json.dumps(self.data)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_d3js/network_plots/#pathpyG.visualisations._d3js.network_plots.StaticNetworkPlot","title":"<code>StaticNetworkPlot</code>","text":"<p>             Bases: <code>pathpyG.visualisations._d3js.network_plots.NetworkPlot</code></p> <p>Network plot class for a temporal network.</p> Source code in <code>src/pathpyG/visualisations/_d3js/network_plots.py</code> <pre><code>class StaticNetworkPlot(NetworkPlot):\n    \"\"\"Network plot class for a temporal network.\"\"\"\n\n    _kind = \"static\"\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_d3js/network_plots/#pathpyG.visualisations._d3js.network_plots.TemporalNetworkPlot","title":"<code>TemporalNetworkPlot</code>","text":"<p>             Bases: <code>pathpyG.visualisations._d3js.network_plots.NetworkPlot</code></p> <p>Network plot class for a temporal network.</p> Source code in <code>src/pathpyG/visualisations/_d3js/network_plots.py</code> <pre><code>class TemporalNetworkPlot(NetworkPlot):\n    \"\"\"Network plot class for a temporal network.\"\"\"\n\n    _kind = \"temporal\"\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_matplotlib/","title":"_matplotlib","text":"<p>Initialize matplotlib plotting functions.</p>"},{"location":"reference/pathpyG/visualisations/_matplotlib/#pathpyG.visualisations._matplotlib.plot","title":"<code>plot</code>","text":"<p>Plot function.</p> Source code in <code>src/pathpyG/visualisations/_matplotlib/__init__.py</code> <pre><code>def plot(data: dict, kind: str = \"network\", **kwargs: Any) -&gt; Any:\n    \"\"\"Plot function.\"\"\"\n    return PLOT_CLASSES[kind](data, **kwargs)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_matplotlib/core/","title":"core","text":"<p>Generic matplotlib plot class.</p>"},{"location":"reference/pathpyG/visualisations/_matplotlib/core/#pathpyG.visualisations._matplotlib.core.MatplotlibPlot","title":"<code>MatplotlibPlot</code>","text":"<p>             Bases: <code>pathpyG.visualisations.plot.PathPyPlot</code></p> <p>Base class for plotting matplotlib objects.</p> Source code in <code>src/pathpyG/visualisations/_matplotlib/core.py</code> <pre><code>class MatplotlibPlot(PathPyPlot):\n    \"\"\"Base class for plotting matplotlib objects.\"\"\"\n\n    def generate(self) -&gt; None:\n        \"\"\"Generate the plot.\"\"\"\n        raise NotImplementedError\n\n    def save(self, filename: str, **kwargs: Any) -&gt; None:  # type: ignore\n        \"\"\"Save the plot to the hard drive.\"\"\"\n        self.to_fig().savefig(filename)\n\n    def show(self, **kwargs: Any) -&gt; None:  # type: ignore\n        \"\"\"Show the plot on the device.\"\"\"\n        self.to_fig().show()\n\n    def to_fig(self) -&gt; Any:  # type: ignore\n        \"\"\"Convert to matplotlib figure.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_matplotlib/core/#pathpyG.visualisations._matplotlib.core.MatplotlibPlot.generate","title":"<code>generate</code>","text":"<p>Generate the plot.</p> Source code in <code>src/pathpyG/visualisations/_matplotlib/core.py</code> <pre><code>def generate(self) -&gt; None:\n    \"\"\"Generate the plot.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_matplotlib/core/#pathpyG.visualisations._matplotlib.core.MatplotlibPlot.save","title":"<code>save</code>","text":"<p>Save the plot to the hard drive.</p> Source code in <code>src/pathpyG/visualisations/_matplotlib/core.py</code> <pre><code>def save(self, filename: str, **kwargs: Any) -&gt; None:  # type: ignore\n    \"\"\"Save the plot to the hard drive.\"\"\"\n    self.to_fig().savefig(filename)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_matplotlib/core/#pathpyG.visualisations._matplotlib.core.MatplotlibPlot.show","title":"<code>show</code>","text":"<p>Show the plot on the device.</p> Source code in <code>src/pathpyG/visualisations/_matplotlib/core.py</code> <pre><code>def show(self, **kwargs: Any) -&gt; None:  # type: ignore\n    \"\"\"Show the plot on the device.\"\"\"\n    self.to_fig().show()\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_matplotlib/core/#pathpyG.visualisations._matplotlib.core.MatplotlibPlot.to_fig","title":"<code>to_fig</code>","text":"<p>Convert to matplotlib figure.</p> Source code in <code>src/pathpyG/visualisations/_matplotlib/core.py</code> <pre><code>def to_fig(self) -&gt; Any:  # type: ignore\n    \"\"\"Convert to matplotlib figure.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_matplotlib/network_plots/","title":"network_plots","text":"<p>Network plots with matplotlib.</p>"},{"location":"reference/pathpyG/visualisations/_matplotlib/network_plots/#pathpyG.visualisations._matplotlib.network_plots.NetworkPlot","title":"<code>NetworkPlot</code>","text":"<p>             Bases: <code>pathpyG.visualisations._matplotlib.core.MatplotlibPlot</code></p> <p>Network plot class for a static network.</p> Source code in <code>src/pathpyG/visualisations/_matplotlib/network_plots.py</code> <pre><code>class NetworkPlot(MatplotlibPlot):\n    \"\"\"Network plot class for a static network.\"\"\"\n\n    _kind = \"network\"\n\n    def __init__(self, data: dict, **kwargs: Any) -&gt; None:\n        \"\"\"Initialize network plot class.\"\"\"\n        super().__init__()\n        self.data = data\n        self.config = kwargs\n        self.generate()\n\n    def generate(self) -&gt; None:\n        \"\"\"Clen up data.\"\"\"\n        self._compute_node_data()\n        self._compute_edge_data()\n\n    def _compute_node_data(self) -&gt; None:\n        \"\"\"Generate the data structure for the nodes.\"\"\"\n        default = {\n            \"uid\": None,\n            \"x\": 0,\n            \"y\": 0,\n            \"size\": 30,\n            \"color\": \"blue\",\n            \"opacity\": 1.0,\n        }\n\n        nodes: dict = {key: [] for key in default}\n\n        for node in self.data[\"nodes\"]:\n            for key, value in default.items():\n                nodes[key].append(node.get(key, value))\n\n        self.data[\"nodes\"] = nodes\n\n    def _compute_edge_data(self) -&gt; None:\n        \"\"\"Generate the data structure for the edges.\"\"\"\n        default = {\n            \"uid\": None,\n            \"size\": 5,\n            \"color\": \"red\",\n            \"opacity\": 1.0,\n        }\n\n        edges: dict = {**{key: [] for key in default}, **{\"line\": []}}\n\n        for edge in self.data[\"edges\"]:\n            source = self.data[\"nodes\"][\"uid\"].index(edge.get(\"source\"))\n            target = self.data[\"nodes\"][\"uid\"].index(edge.get(\"target\"))\n            edges[\"line\"].append(\n                [\n                    (self.data[\"nodes\"][\"x\"][source], self.data[\"nodes\"][\"x\"][target]),\n                    (self.data[\"nodes\"][\"y\"][source], self.data[\"nodes\"][\"y\"][target]),\n                ]\n            )\n\n            for key, value in default.items():\n                edges[key].append(edge.get(key, value))\n\n        self.data[\"edges\"] = edges\n\n    def to_fig(self) -&gt; Any:\n        \"\"\"Convert data to figure.\"\"\"\n        import matplotlib.pyplot as plt\n\n        fig, ax = plt.subplots()\n        ax.set_axis_off()\n\n        # plot edges\n        for i in range(len(self.data[\"edges\"][\"uid\"])):\n            ax.plot(\n                *self.data[\"edges\"][\"line\"][i],\n                color=self.data[\"edges\"][\"color\"][i],\n                alpha=self.data[\"edges\"][\"opacity\"][i],\n                zorder=1,\n            )\n\n        # plot nodes\n        ax.scatter(\n            self.data[\"nodes\"][\"x\"],\n            self.data[\"nodes\"][\"y\"],\n            s=self.data[\"nodes\"][\"size\"],\n            c=self.data[\"nodes\"][\"color\"],\n            alpha=self.data[\"nodes\"][\"opacity\"],\n            zorder=2,\n        )\n        return plt\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_matplotlib/network_plots/#pathpyG.visualisations._matplotlib.network_plots.NetworkPlot.__init__","title":"<code>__init__</code>","text":"<p>Initialize network plot class.</p> Source code in <code>src/pathpyG/visualisations/_matplotlib/network_plots.py</code> <pre><code>def __init__(self, data: dict, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize network plot class.\"\"\"\n    super().__init__()\n    self.data = data\n    self.config = kwargs\n    self.generate()\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_matplotlib/network_plots/#pathpyG.visualisations._matplotlib.network_plots.NetworkPlot.generate","title":"<code>generate</code>","text":"<p>Clen up data.</p> Source code in <code>src/pathpyG/visualisations/_matplotlib/network_plots.py</code> <pre><code>def generate(self) -&gt; None:\n    \"\"\"Clen up data.\"\"\"\n    self._compute_node_data()\n    self._compute_edge_data()\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_matplotlib/network_plots/#pathpyG.visualisations._matplotlib.network_plots.NetworkPlot.to_fig","title":"<code>to_fig</code>","text":"<p>Convert data to figure.</p> Source code in <code>src/pathpyG/visualisations/_matplotlib/network_plots.py</code> <pre><code>def to_fig(self) -&gt; Any:\n    \"\"\"Convert data to figure.\"\"\"\n    import matplotlib.pyplot as plt\n\n    fig, ax = plt.subplots()\n    ax.set_axis_off()\n\n    # plot edges\n    for i in range(len(self.data[\"edges\"][\"uid\"])):\n        ax.plot(\n            *self.data[\"edges\"][\"line\"][i],\n            color=self.data[\"edges\"][\"color\"][i],\n            alpha=self.data[\"edges\"][\"opacity\"][i],\n            zorder=1,\n        )\n\n    # plot nodes\n    ax.scatter(\n        self.data[\"nodes\"][\"x\"],\n        self.data[\"nodes\"][\"y\"],\n        s=self.data[\"nodes\"][\"size\"],\n        c=self.data[\"nodes\"][\"color\"],\n        alpha=self.data[\"nodes\"][\"opacity\"],\n        zorder=2,\n    )\n    return plt\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_matplotlib/network_plots/#pathpyG.visualisations._matplotlib.network_plots.StaticNetworkPlot","title":"<code>StaticNetworkPlot</code>","text":"<p>             Bases: <code>pathpyG.visualisations._matplotlib.network_plots.NetworkPlot</code></p> <p>Network plot class for a static network.</p> Source code in <code>src/pathpyG/visualisations/_matplotlib/network_plots.py</code> <pre><code>class StaticNetworkPlot(NetworkPlot):\n    \"\"\"Network plot class for a static network.\"\"\"\n\n    _kind = \"static\"\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_matplotlib/network_plots/#pathpyG.visualisations._matplotlib.network_plots.TemporalNetworkPlot","title":"<code>TemporalNetworkPlot</code>","text":"<p>             Bases: <code>pathpyG.visualisations._matplotlib.network_plots.NetworkPlot</code></p> <p>Network plot class for a static network.</p> Source code in <code>src/pathpyG/visualisations/_matplotlib/network_plots.py</code> <pre><code>class TemporalNetworkPlot(NetworkPlot):\n    \"\"\"Network plot class for a static network.\"\"\"\n\n    _kind = \"temporal\"\n\n    def __init__(self, data: dict, **kwargs: Any) -&gt; None:\n        \"\"\"Initialize network plot class.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_matplotlib/network_plots/#pathpyG.visualisations._matplotlib.network_plots.TemporalNetworkPlot.__init__","title":"<code>__init__</code>","text":"<p>Initialize network plot class.</p> Source code in <code>src/pathpyG/visualisations/_matplotlib/network_plots.py</code> <pre><code>def __init__(self, data: dict, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize network plot class.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_tikz/","title":"_tikz","text":"<p>Initialize tikz plotting functions.</p>"},{"location":"reference/pathpyG/visualisations/_tikz/#pathpyG.visualisations._tikz.plot","title":"<code>plot</code>","text":"<p>Plot function.</p> Source code in <code>src/pathpyG/visualisations/_tikz/__init__.py</code> <pre><code>def plot(data: dict, kind: str = \"network\", **kwargs: Any) -&gt; Any:\n    \"\"\"Plot function.\"\"\"\n    return PLOT_CLASSES[kind](data, **kwargs)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_tikz/core/","title":"core","text":""},{"location":"reference/pathpyG/visualisations/_tikz/core/#pathpyG.visualisations._tikz.core.TikzPlot","title":"<code>TikzPlot</code>","text":"<p>             Bases: <code>pathpyG.visualisations.plot.PathPyPlot</code></p> <p>Base class for plotting d3js objects.</p> Source code in <code>src/pathpyG/visualisations/_tikz/core.py</code> <pre><code>class TikzPlot(PathPyPlot):\n    \"\"\"Base class for plotting d3js objects.\"\"\"\n\n    def __init__(self, **kwargs: Any) -&gt; None:\n        \"\"\"Initialize plot class.\"\"\"\n        super().__init__()\n        if kwargs:\n            self.config = kwargs\n\n    def generate(self) -&gt; None:\n        \"\"\"Generate the plot.\"\"\"\n        raise NotImplementedError\n\n    def save(self, filename: str, **kwargs: Any) -&gt; None:\n        \"\"\"Save the plot to the hard drive.\"\"\"\n        if filename.endswith(\"tex\"):\n            with open(filename, \"w+\") as new:\n                new.write(self.to_tex())\n        elif filename.endswith(\"pdf\"):\n            # compile temporary pdf\n            temp_file, temp_dir = self.compile_pdf()\n            # Copy a file with new name\n            shutil.copy(temp_file, filename)\n            # remove the temporal directory\n            shutil.rmtree(temp_dir)\n\n        else:\n            raise NotImplementedError\n\n    def show(self, **kwargs: Any) -&gt; None:\n        \"\"\"Show the plot on the device.\"\"\"\n        # compile temporary pdf\n        temp_file, temp_dir = self.compile_pdf()\n\n        if config[\"environment\"][\"interactive\"]:\n            from IPython.display import IFrame, display\n\n            # open the file in the notebook\n            display(IFrame(temp_file, width=600, height=300))\n        else:\n            # open the file in the webbrowser\n            webbrowser.open(r\"file:///\" + temp_file)\n\n        # Wait for .1 second before temp file is deleted\n        time.sleep(0.1)\n\n        # remove the temporal directory\n        shutil.rmtree(temp_dir)\n\n    def compile_pdf(self) -&gt; tuple:\n        \"\"\"Compile pdf from tex.\"\"\"\n        # basename\n        basename = \"default\"\n        # get current directory\n        current_dir = os.getcwd()\n\n        # template directory\n        tikz_dir = str(\n            os.path.join(\n                os.path.dirname(os.path.dirname(__file__)),\n                os.path.normpath(\"templates\"),\n                \"tikz-network.sty\",\n            )\n        )\n\n        # get temporal directory\n        temp_dir = tempfile.mkdtemp()\n\n        # copy tikz-network to temporal directory\n        shutil.copy(tikz_dir, temp_dir)\n\n        # change to output dir\n        os.chdir(temp_dir)\n\n        # save the tex file\n        self.save(basename + \".tex\")\n\n        # latex compiler\n        command = [\n            \"latexmk\",\n            \"--pdf\",\n            \"-shell-escape\",\n            \"--interaction=nonstopmode\",\n            basename + \".tex\",\n        ]\n\n        try:\n            subprocess.check_output(command, stderr=subprocess.STDOUT)\n        except Exception:\n            # If compiler does not exist, try next in the list\n            logger.error(\"No latexmk compiler found\")\n            raise AttributeError\n        finally:\n            # change back to the current directory\n            os.chdir(current_dir)\n\n        # return the name of the folder and temp pdf file\n        return (os.path.join(temp_dir, basename + \".pdf\"), temp_dir)\n\n    def to_tex(self) -&gt; str:\n        \"\"\"Convert data to tex.\"\"\"\n        # get path to the pathpy templates\n        template_dir = os.path.join(\n            os.path.dirname(os.path.dirname(__file__)),\n            os.path.normpath(\"_tikz/templates\"),\n        )\n\n        # get template files\n        with open(os.path.join(template_dir, f\"{self._kind}.tex\")) as template:\n            tex_template = template.read()\n\n        # generate data\n        data = self.to_tikz()\n\n        # fill template with data\n        tex = Template(tex_template).substitute(\n            classoptions=self.config.get(\"latex_class_options\", \"\"),\n            width=self.config.get(\"width\", \"6cm\"),\n            height=self.config.get(\"height\", \"6cm\"),\n            tikz=data,\n        )\n\n        return tex\n\n    def to_tikz(self) -&gt; str:\n        \"\"\"Convert data to tikz.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_tikz/core/#pathpyG.visualisations._tikz.core.TikzPlot.__init__","title":"<code>__init__</code>","text":"<p>Initialize plot class.</p> Source code in <code>src/pathpyG/visualisations/_tikz/core.py</code> <pre><code>def __init__(self, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize plot class.\"\"\"\n    super().__init__()\n    if kwargs:\n        self.config = kwargs\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_tikz/core/#pathpyG.visualisations._tikz.core.TikzPlot.compile_pdf","title":"<code>compile_pdf</code>","text":"<p>Compile pdf from tex.</p> Source code in <code>src/pathpyG/visualisations/_tikz/core.py</code> <pre><code>def compile_pdf(self) -&gt; tuple:\n    \"\"\"Compile pdf from tex.\"\"\"\n    # basename\n    basename = \"default\"\n    # get current directory\n    current_dir = os.getcwd()\n\n    # template directory\n    tikz_dir = str(\n        os.path.join(\n            os.path.dirname(os.path.dirname(__file__)),\n            os.path.normpath(\"templates\"),\n            \"tikz-network.sty\",\n        )\n    )\n\n    # get temporal directory\n    temp_dir = tempfile.mkdtemp()\n\n    # copy tikz-network to temporal directory\n    shutil.copy(tikz_dir, temp_dir)\n\n    # change to output dir\n    os.chdir(temp_dir)\n\n    # save the tex file\n    self.save(basename + \".tex\")\n\n    # latex compiler\n    command = [\n        \"latexmk\",\n        \"--pdf\",\n        \"-shell-escape\",\n        \"--interaction=nonstopmode\",\n        basename + \".tex\",\n    ]\n\n    try:\n        subprocess.check_output(command, stderr=subprocess.STDOUT)\n    except Exception:\n        # If compiler does not exist, try next in the list\n        logger.error(\"No latexmk compiler found\")\n        raise AttributeError\n    finally:\n        # change back to the current directory\n        os.chdir(current_dir)\n\n    # return the name of the folder and temp pdf file\n    return (os.path.join(temp_dir, basename + \".pdf\"), temp_dir)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_tikz/core/#pathpyG.visualisations._tikz.core.TikzPlot.generate","title":"<code>generate</code>","text":"<p>Generate the plot.</p> Source code in <code>src/pathpyG/visualisations/_tikz/core.py</code> <pre><code>def generate(self) -&gt; None:\n    \"\"\"Generate the plot.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_tikz/core/#pathpyG.visualisations._tikz.core.TikzPlot.save","title":"<code>save</code>","text":"<p>Save the plot to the hard drive.</p> Source code in <code>src/pathpyG/visualisations/_tikz/core.py</code> <pre><code>def save(self, filename: str, **kwargs: Any) -&gt; None:\n    \"\"\"Save the plot to the hard drive.\"\"\"\n    if filename.endswith(\"tex\"):\n        with open(filename, \"w+\") as new:\n            new.write(self.to_tex())\n    elif filename.endswith(\"pdf\"):\n        # compile temporary pdf\n        temp_file, temp_dir = self.compile_pdf()\n        # Copy a file with new name\n        shutil.copy(temp_file, filename)\n        # remove the temporal directory\n        shutil.rmtree(temp_dir)\n\n    else:\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_tikz/core/#pathpyG.visualisations._tikz.core.TikzPlot.show","title":"<code>show</code>","text":"<p>Show the plot on the device.</p> Source code in <code>src/pathpyG/visualisations/_tikz/core.py</code> <pre><code>def show(self, **kwargs: Any) -&gt; None:\n    \"\"\"Show the plot on the device.\"\"\"\n    # compile temporary pdf\n    temp_file, temp_dir = self.compile_pdf()\n\n    if config[\"environment\"][\"interactive\"]:\n        from IPython.display import IFrame, display\n\n        # open the file in the notebook\n        display(IFrame(temp_file, width=600, height=300))\n    else:\n        # open the file in the webbrowser\n        webbrowser.open(r\"file:///\" + temp_file)\n\n    # Wait for .1 second before temp file is deleted\n    time.sleep(0.1)\n\n    # remove the temporal directory\n    shutil.rmtree(temp_dir)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_tikz/core/#pathpyG.visualisations._tikz.core.TikzPlot.to_tex","title":"<code>to_tex</code>","text":"<p>Convert data to tex.</p> Source code in <code>src/pathpyG/visualisations/_tikz/core.py</code> <pre><code>def to_tex(self) -&gt; str:\n    \"\"\"Convert data to tex.\"\"\"\n    # get path to the pathpy templates\n    template_dir = os.path.join(\n        os.path.dirname(os.path.dirname(__file__)),\n        os.path.normpath(\"_tikz/templates\"),\n    )\n\n    # get template files\n    with open(os.path.join(template_dir, f\"{self._kind}.tex\")) as template:\n        tex_template = template.read()\n\n    # generate data\n    data = self.to_tikz()\n\n    # fill template with data\n    tex = Template(tex_template).substitute(\n        classoptions=self.config.get(\"latex_class_options\", \"\"),\n        width=self.config.get(\"width\", \"6cm\"),\n        height=self.config.get(\"height\", \"6cm\"),\n        tikz=data,\n    )\n\n    return tex\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_tikz/core/#pathpyG.visualisations._tikz.core.TikzPlot.to_tikz","title":"<code>to_tikz</code>","text":"<p>Convert data to tikz.</p> Source code in <code>src/pathpyG/visualisations/_tikz/core.py</code> <pre><code>def to_tikz(self) -&gt; str:\n    \"\"\"Convert data to tikz.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_tikz/network_plots/","title":"network_plots","text":"<p>Network plots with tikz.</p>"},{"location":"reference/pathpyG/visualisations/_tikz/network_plots/#pathpyG.visualisations._tikz.network_plots.NetworkPlot","title":"<code>NetworkPlot</code>","text":"<p>             Bases: <code>pathpyG.visualisations._tikz.core.TikzPlot</code></p> <p>Network plot class for a static network.</p> Source code in <code>src/pathpyG/visualisations/_tikz/network_plots.py</code> <pre><code>class NetworkPlot(TikzPlot):\n    \"\"\"Network plot class for a static network.\"\"\"\n\n    _kind = \"network\"\n\n    def __init__(self, data: dict, **kwargs: Any) -&gt; None:\n        \"\"\"Initialize network plot class.\"\"\"\n        super().__init__()\n        self.data = data\n        self.config = kwargs\n        self.config[\"width\"] = self.config.pop(\"width\", 6)\n        self.config[\"height\"] = self.config.pop(\"height\", 6)\n        self.generate()\n\n    def generate(self) -&gt; None:\n        \"\"\"Clen up data.\"\"\"\n        self._compute_node_data()\n        self._compute_edge_data()\n        self._update_layout()\n\n    def _compute_node_data(self) -&gt; None:\n        \"\"\"Generate the data structure for the nodes.\"\"\"\n        default: set = {\"uid\", \"x\", \"y\", \"size\", \"color\", \"opacity\"}\n        mapping: dict = {}\n\n        for node in self.data[\"nodes\"]:\n            for key in list(node):\n                if key in mapping:\n                    node[mapping[key]] = node.pop(key)\n                if key not in default:\n                    node.pop(key, None)\n\n            color = node.get(\"color\", None)\n            if isinstance(color, str) and \"#\" in color:\n                color = hex_to_rgb(color)\n                node[\"color\"] = f\"{{{color[0]},{color[1]},{color[2]}}}\"\n                node[\"RGB\"] = True\n\n    def _compute_edge_data(self) -&gt; None:\n        \"\"\"Generate the data structure for the edges.\"\"\"\n        default: set = {\"uid\", \"source\", \"target\", \"lw\", \"color\", \"opacity\"}\n        mapping: dict = {\"size\": \"lw\"}\n\n        for edge in self.data[\"edges\"]:\n            for key in list(edge):\n                if key in mapping:\n                    edge[mapping[key]] = edge.pop(key)\n                if key not in default:\n                    edge.pop(key, None)\n\n            color = edge.get(\"color\", None)\n            if isinstance(color, str) and \"#\" in color:\n                color = hex_to_rgb(color)\n                edge[\"color\"] = f\"{{{color[0]},{color[1]},{color[2]}}}\"\n                edge[\"RGB\"] = True\n\n    def _update_layout(self, default_size: float = 0.6) -&gt; None:\n        \"\"\"Update the layout.\"\"\"\n        layout = self.config.get(\"layout\")\n\n        if layout is None:\n            return\n\n        # get data\n        layout = {n[\"uid\"]: (n[\"x\"], n[\"y\"]) for n in self.data[\"nodes\"]}\n        sizes = {n[\"uid\"]: n.get(\"size\", default_size) for n in self.data[\"nodes\"]}\n\n        # get config values\n        width = self.config[\"width\"]\n        height = self.config[\"height\"]\n        keep_aspect_ratio = self.config.get(\"keep_aspect_ratio\", True)\n        margin = self.config.get(\"margin\", 0.0)\n        margins = {\"top\": margin, \"left\": margin, \"bottom\": margin, \"right\": margin}\n\n        # calculate the scaling ratio\n        x_ratio = float(\"inf\")\n        y_ratio = float(\"inf\")\n\n        # calculate absolute min and max coordinates\n        x_absolute = []\n        y_absolute = []\n        for uid, (_x, _y) in layout.items():\n            _s = sizes[uid] / 2\n            x_absolute.extend([_x - _s, _x + _s])\n            y_absolute.extend([_y - _s, _y + _s])\n\n        # calculate min and max center coordinates\n        x_values, y_values = zip(*layout.values())\n        x_min, x_max = min(x_values), max(x_values)\n        y_min, y_max = min(y_values), max(y_values)\n\n        # change margins\n        margins[\"left\"] += abs(x_min - min(x_absolute))\n        margins[\"bottom\"] += abs(y_min - min(y_absolute))\n        margins[\"top\"] += abs(y_max - max(y_absolute))\n        margins[\"right\"] += abs(x_max - max(x_absolute))\n\n        if x_max - x_min &gt; 0:\n            x_ratio = (width - margins[\"left\"] - margins[\"right\"]) / (x_max - x_min)\n        if y_max - y_min &gt; 0:\n            y_ratio = (height - margins[\"top\"] - margins[\"bottom\"]) / (y_max - y_min)\n\n        if keep_aspect_ratio:\n            scaling = (min(x_ratio, y_ratio), min(x_ratio, y_ratio))\n        else:\n            scaling = (x_ratio, y_ratio)\n\n        if scaling[0] == float(\"inf\"):\n            scaling = (1, scaling[1])\n        if scaling[1] == float(\"inf\"):\n            scaling = (scaling[0], 1)\n\n        x_values = []\n        y_values = []\n\n        # apply scaling to the points\n        _layout = {n: (x * scaling[0], y * scaling[1]) for n, (x, y) in layout.items()}\n\n        # find min and max values of the points\n        x_values, y_values = zip(*_layout.values())\n        x_min, x_max = min(x_values), max(x_values)\n        y_min, y_max = min(y_values), max(y_values)\n\n        # calculate the translation\n        translation = (\n            ((width - margins[\"left\"] - margins[\"right\"]) / 2 + margins[\"left\"])\n            - ((x_max - x_min) / 2 + x_min),\n            ((height - margins[\"top\"] - margins[\"bottom\"]) / 2 + margins[\"bottom\"])\n            - ((y_max - y_min) / 2 + y_min),\n        )\n\n        # apply translation to the points\n        _layout = {\n            n: (x + translation[0], y + translation[1]) for n, (x, y) in _layout.items()\n        }\n\n        # update node position for the plot\n        for node in self.data[\"nodes\"]:\n            node[\"x\"], node[\"y\"] = _layout[node[\"uid\"]]\n\n    def to_tikz(self) -&gt; str:\n        \"\"\"Convert to Tex.\"\"\"\n\n        def _add_args(args: dict):\n            string = \"\"\n            for key, value in args.items():\n                string += f\",{key}\" if value is True else f\",{key}={value}\"\n            return string\n\n        tikz = \"\"\n        for node in self.data[\"nodes\"]:\n            uid = node.pop(\"uid\")\n            string = \"\\\\Vertex[\"\n            string += _add_args(node)\n            string += \"]{{{}}}\\n\".format(uid)\n            tikz += string\n\n        for edge in self.data[\"edges\"]:\n            uid = edge.pop(\"uid\")\n            source = edge.pop(\"source\")\n            target = edge.pop(\"target\")\n            string = \"\\\\Edge[\"\n            string += _add_args(edge)\n            string += \"]({})({})\\n\".format(source, target)\n            tikz += string\n        return tikz\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_tikz/network_plots/#pathpyG.visualisations._tikz.network_plots.NetworkPlot.__init__","title":"<code>__init__</code>","text":"<p>Initialize network plot class.</p> Source code in <code>src/pathpyG/visualisations/_tikz/network_plots.py</code> <pre><code>def __init__(self, data: dict, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize network plot class.\"\"\"\n    super().__init__()\n    self.data = data\n    self.config = kwargs\n    self.config[\"width\"] = self.config.pop(\"width\", 6)\n    self.config[\"height\"] = self.config.pop(\"height\", 6)\n    self.generate()\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_tikz/network_plots/#pathpyG.visualisations._tikz.network_plots.NetworkPlot.generate","title":"<code>generate</code>","text":"<p>Clen up data.</p> Source code in <code>src/pathpyG/visualisations/_tikz/network_plots.py</code> <pre><code>def generate(self) -&gt; None:\n    \"\"\"Clen up data.\"\"\"\n    self._compute_node_data()\n    self._compute_edge_data()\n    self._update_layout()\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_tikz/network_plots/#pathpyG.visualisations._tikz.network_plots.NetworkPlot.to_tikz","title":"<code>to_tikz</code>","text":"<p>Convert to Tex.</p> Source code in <code>src/pathpyG/visualisations/_tikz/network_plots.py</code> <pre><code>def to_tikz(self) -&gt; str:\n    \"\"\"Convert to Tex.\"\"\"\n\n    def _add_args(args: dict):\n        string = \"\"\n        for key, value in args.items():\n            string += f\",{key}\" if value is True else f\",{key}={value}\"\n        return string\n\n    tikz = \"\"\n    for node in self.data[\"nodes\"]:\n        uid = node.pop(\"uid\")\n        string = \"\\\\Vertex[\"\n        string += _add_args(node)\n        string += \"]{{{}}}\\n\".format(uid)\n        tikz += string\n\n    for edge in self.data[\"edges\"]:\n        uid = edge.pop(\"uid\")\n        source = edge.pop(\"source\")\n        target = edge.pop(\"target\")\n        string = \"\\\\Edge[\"\n        string += _add_args(edge)\n        string += \"]({})({})\\n\".format(source, target)\n        tikz += string\n    return tikz\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_tikz/network_plots/#pathpyG.visualisations._tikz.network_plots.StaticNetworkPlot","title":"<code>StaticNetworkPlot</code>","text":"<p>             Bases: <code>pathpyG.visualisations._tikz.network_plots.NetworkPlot</code></p> <p>Network plot class for a static network.</p> Source code in <code>src/pathpyG/visualisations/_tikz/network_plots.py</code> <pre><code>class StaticNetworkPlot(NetworkPlot):\n    \"\"\"Network plot class for a static network.\"\"\"\n\n    _kind = \"static\"\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_tikz/network_plots/#pathpyG.visualisations._tikz.network_plots.TemporalNetworkPlot","title":"<code>TemporalNetworkPlot</code>","text":"<p>             Bases: <code>pathpyG.visualisations._tikz.network_plots.NetworkPlot</code></p> <p>Network plot class for a static network.</p> Source code in <code>src/pathpyG/visualisations/_tikz/network_plots.py</code> <pre><code>class TemporalNetworkPlot(NetworkPlot):\n    \"\"\"Network plot class for a static network.\"\"\"\n\n    _kind = \"temporal\"\n\n    def __init__(self, data: dict, **kwargs: Any) -&gt; None:\n        \"\"\"Initialize network plot class.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_tikz/network_plots/#pathpyG.visualisations._tikz.network_plots.TemporalNetworkPlot.__init__","title":"<code>__init__</code>","text":"<p>Initialize network plot class.</p> Source code in <code>src/pathpyG/visualisations/_tikz/network_plots.py</code> <pre><code>def __init__(self, data: dict, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize network plot class.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"tutorial/basic_concepts/","title":"Basic Concepts","text":"In\u00a0[1]: Copied! <pre>import torch\n\nimport pathpyG as pp\n\npp.config['torch']['device'] = 'cuda'\n</pre> import torch  import pathpyG as pp  pp.config['torch']['device'] = 'cuda' <p>The following snippet generates a graph with three nodes, which are referred to by their indices 0, 1, 2, and three edges (0,2), (1,2), (0,1).</p> In\u00a0[2]: Copied! <pre>g = pp.Graph(edge_index=torch.tensor([[0,1,0], [2,2,1]]))\nprint(g)\n</pre> g = pp.Graph(edge_index=torch.tensor([[0,1,0], [2,2,1]])) print(g) <pre>Graph with 3 nodes and 3 edges\n\nGraph attributes\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\tnode_id\t\t&lt;class 'list'&gt;\n\n</pre> <p>Let's use the generator functions <code>nodes</code> and <code>edges</code> to iterate through the nodes and edges of this graph:</p> In\u00a0[3]: Copied! <pre>for v in g.nodes:\n    print(v)\n\nfor e in g.edges:\n    print(e)\n</pre> for v in g.nodes:     print(v)  for e in g.edges:     print(e) <pre>0\n1\n2\n(0, 2)\n(1, 2)\n(0, 1)\n</pre> <p>While the representation of sparse graphs as integer tensors is highly efficient, it is often more convenient to use string identifiers to refer to nodes. To simplify the handling of real-world graphs, <code>pathpyG</code> provides a transparent mapping of string identifiers to node indices.</p> <p>If we want to associate node indices with string IDs, we can set the <code>node_id</code> attribute of the resulting graph object. To map the nodes with indices 0, 1, and 2 to string IDs <code>a</code>, <code>b</code>, and <code>c</code>, we can add the following node id mapping:</p> In\u00a0[4]: Copied! <pre>g.add_node_id(['a', 'b', 'c'])\n</pre> g.add_node_id(['a', 'b', 'c']) <p>If we now iterate through the nodes and edges of the graph, we get:</p> In\u00a0[5]: Copied! <pre>for v in g.nodes:\n    print(v)\n\nfor e in g.edges:\n    print(e)\n</pre> for v in g.nodes:     print(v)  for e in g.edges:     print(e) <pre>a\nb\nc\n('a', 'c')\n('b', 'c')\n('a', 'b')\n</pre> <p>We can get the same resulting Graph object if we pass the <code>node_id</code> mapping in the constructor of the graph, which will automatically apply the mapping in all future function calls.</p> In\u00a0[6]: Copied! <pre>g = pp.Graph(edge_index=torch.tensor([[0,1,0], [2,2,1]]), node_id=['a', 'b', 'c'])\nprint(g)\n</pre> g = pp.Graph(edge_index=torch.tensor([[0,1,0], [2,2,1]]), node_id=['a', 'b', 'c']) print(g) <pre>Graph with 3 nodes and 3 edges\n\nNode attributes\n\tnode_id\t\t&lt;class 'list'&gt;\n\nGraph attributes\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\n</pre> <p>Alternatively, we can construct the same graph based on an edge list that uses string identifiers for nodes. This will automatically generate the sparse integer tensor representation of the edge index, as well as the associated node ID mapping:</p> In\u00a0[7]: Copied! <pre>g = pp.Graph.from_edge_list([['a','b'], ['b','c'], ['a','c']])\nprint(g)\n</pre> g = pp.Graph.from_edge_list([['a','b'], ['b','c'], ['a','c']]) print(g) <pre>Graph with 3 nodes and 3 edges\n\nNode attributes\n\tnode_id\t\t&lt;class 'list'&gt;\n\nGraph attributes\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\n</pre> In\u00a0[53]: Copied! <pre>for v in g.successors('a'):\n    print(v)\n</pre> for v in g.successors('a'):     print(v) <pre>b\nc\n</pre> In\u00a0[54]: Copied! <pre>for v in g.predecessors('c'):\n    print(v)\n</pre> for v in g.predecessors('c'):     print(v) <pre>a\nb\n</pre> <p>We can also easily check, whether an edge exists in the graph:</p> In\u00a0[55]: Copied! <pre>g.is_edge('a', 'b')\n</pre> g.is_edge('a', 'b') Out[55]: <pre>True</pre> <p>Alternatively, we can use the following code to check whether node <code>b</code> is a successor of <code>a</code></p> In\u00a0[56]: Copied! <pre>'b' in g.successors('a')\n</pre> 'b' in g.successors('a') Out[56]: <pre>True</pre> <p>By default, a graph object in <code>pathpyG</code> is directed, i.e. for the graph above, the edge <code>(b,a)</code> does not exist, which we can verify as follows:</p> In\u00a0[57]: Copied! <pre>'a' in g.successors('b')\n</pre> 'a' in g.successors('b') Out[57]: <pre>False</pre> <p>To check the (directed) in- and out-degrees of nodes, we can use the properties <code>in_degrees</code> and <code>out_degrees</code>, which return a dictionary that maps node IDs to their degrees:</p> In\u00a0[58]: Copied! <pre>g.in_degrees\n</pre> g.in_degrees Out[58]: <pre>{'a': 0, 'b': 1, 'c': 2}</pre> In\u00a0[59]: Copied! <pre>g.in_degrees['b']\n</pre> g.in_degrees['b'] Out[59]: <pre>1</pre> In\u00a0[60]: Copied! <pre>g.in_degrees['c']\n</pre> g.in_degrees['c'] Out[60]: <pre>2</pre> <p>Importantly, irrespective of how we have generated the graph object, the actual node and edge data are always stored as a <code>pyG</code> data object, which we can access as follows:</p> In\u00a0[61]: Copied! <pre>g.data\n</pre> g.data Out[61]: <pre>Data(edge_index=[2, 3], node_id=[3], num_nodes=3)</pre> <p>This allows us to use the full power of <code>torch</code> and <code>pyG</code>, including, e.g., the application of transforms, splits, or any easy migration between CPU and GPU-based computation. In general, <code>pathpyG</code> will use the device specified in the <code>torch.device</code> configuration (see above) whenver it internally creates a torch tensors. Since above, we have specified the <code>cuda</code> device, the data object of the graph generated above will reside in GPU memory:</p> In\u00a0[62]: Copied! <pre>g.data.is_cuda\n</pre> g.data.is_cuda Out[62]: <pre>False</pre> <p>If we instead set the device to <code>cpu</code>, the <code>Data</code> object will internally be created in main memory instead.</p> In\u00a0[63]: Copied! <pre>pp.config['torch']['device'] = 'cpu'\n\ng = pp.Graph.from_edge_list([['a','b'], ['b','c'], ['a','c']])\ng.data.is_cuda\n</pre> pp.config['torch']['device'] = 'cpu'  g = pp.Graph.from_edge_list([['a','b'], ['b','c'], ['a','c']]) g.data.is_cuda Out[63]: <pre>False</pre> In\u00a0[64]: Copied! <pre>g.data['node_class'] = torch.tensor([[0], [0], [1]])\ng.data['edge_weight'] = torch.tensor([[1], [2], [3]])\ng.data['graph_feature'] = torch.tensor([3, 2])\n</pre> g.data['node_class'] = torch.tensor([[0], [0], [1]]) g.data['edge_weight'] = torch.tensor([[1], [2], [3]]) g.data['graph_feature'] = torch.tensor([3, 2]) <p>Once we have added attributes to nodes, edges, or the graph, those attributes, along with their type and shape will be shown when you print a string representation of the graph object:</p> In\u00a0[65]: Copied! <pre>print(g)\n</pre> print(g) <pre>Graph with 3 nodes and 3 edges\n\nNode attributes\n\tnode_id\t\t&lt;class 'list'&gt;\n\tnode_class\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([3, 1])\n\nEdge attributes\n\tedge_weight\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([3, 1])\n\nGraph attributes\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\tgraph_feature\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([2])\n\n</pre> <p>To simplify the access to attribute values, the <code>Graph</code> class in <code>pathpyG</code> provides item getter and setter functions that allow an indexed access based on the node IDs. To access the feature <code>node_feature</code> of node <code>a</code>, we can write:</p> In\u00a0[66]: Copied! <pre>g['node_class', 'a']\n</pre> g['node_class', 'a'] Out[66]: <pre>tensor([0])</pre> In\u00a0[67]: Copied! <pre>g['edge_weight', 'a', 'b']\n</pre> g['edge_weight', 'a', 'b'] Out[67]: <pre>tensor([1])</pre> In\u00a0[68]: Copied! <pre>g['graph_feature']\n</pre> g['graph_feature'] Out[68]: <pre>tensor([3, 2])</pre> <p>We can use the setter function to change attributes:</p> In\u00a0[69]: Copied! <pre>g['node_class'] = torch.tensor([[7], [2], [3]])\n</pre> g['node_class'] = torch.tensor([[7], [2], [3]]) In\u00a0[70]: Copied! <pre>g['node_class', 'a']\n</pre> g['node_class', 'a'] Out[70]: <pre>tensor([7])</pre> <p>To create a sparse adjacency matrix representations of the topology of a graph, we can use the following function:</p> In\u00a0[71]: Copied! <pre>print(g.get_sparse_adj_matrix())\n</pre> print(g.get_sparse_adj_matrix()) <pre>  (0, 1)\t1.0\n  (1, 2)\t1.0\n  (0, 2)\t1.0\n</pre> <p>This returns a <code>scipy.sparse.coo_matrix</code> object, which can be turned into a dense <code>numpy</code> matrix as follows:</p> In\u00a0[72]: Copied! <pre>print(g.get_sparse_adj_matrix().todense())\n</pre> print(g.get_sparse_adj_matrix().todense()) <pre>[[0. 1. 1.]\n [0. 0. 1.]\n [0. 0. 0.]]\n</pre> <p>By passing the name of the attribute, we can also use edge attributes in the creation of the adjacency matrix. To create a sparse, weighted adjacency matrix that uses the <code>edge_weight</code> attribute of our graph object we can simply write:</p> In\u00a0[73]: Copied! <pre>print(g.get_sparse_adj_matrix(edge_attr='edge_weight').todense())\n</pre> print(g.get_sparse_adj_matrix(edge_attr='edge_weight').todense()) <pre>[[0 1 3]\n [0 0 2]\n [0 0 0]]\n</pre> <p>To easily apply GNN models to a graph, we can add attributes based on one-hot-encodings of nodes and edges:</p> In\u00a0[74]: Copied! <pre>g.add_node_ohe(attr_name='node_ohe_feature_1')\ng.add_node_ohe(attr_name='node_ohe_feature_2', dim=4)\ng.add_edge_ohe(attr_name='edge_ohe_feature_1', dim=5)\nprint(g)\n\nprint(g.data['node_ohe_feature_1'])\nprint(g.data['node_ohe_feature_2'])\nprint(g.data['edge_ohe_feature_1'])\n</pre> g.add_node_ohe(attr_name='node_ohe_feature_1') g.add_node_ohe(attr_name='node_ohe_feature_2', dim=4) g.add_edge_ohe(attr_name='edge_ohe_feature_1', dim=5) print(g)  print(g.data['node_ohe_feature_1']) print(g.data['node_ohe_feature_2']) print(g.data['edge_ohe_feature_1']) <pre>Graph with 3 nodes and 3 edges\n\nNode attributes\n\tnode_id\t\t&lt;class 'list'&gt;\n\tnode_ohe_feature_2\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([3, 4])\n\tnode_ohe_feature_1\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([3, 3])\n\tnode_class\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([3, 1])\n\nEdge attributes\n\tedge_weight\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([3, 1])\n\tedge_ohe_feature_1\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([3, 5])\n\nGraph attributes\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\tgraph_feature\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([2])\n\ntensor([[1., 0., 0.],\n        [0., 1., 0.],\n        [0., 0., 1.]])\ntensor([[1., 0., 0., 0.],\n        [0., 1., 0., 0.],\n        [0., 0., 1., 0.]])\ntensor([[1., 0., 0., 0., 0.],\n        [0., 1., 0., 0., 0.],\n        [0., 0., 1., 0., 0.]])\n</pre> <p>By default, all graphs in <code>pathpyG</code> are directed. To represent undirected graphs, we must add all edges in both directions. We can use the <code>to_undirected()</code> function to make a directed graph undirected, i.e. to add all (missing) edges that point in the opposite direction. This will automatically duplicate and assign the corresponding edge attributes to the newly formed (directed) edges, i.e. edges are assumed to have the same attributes in both directions.</p> In\u00a0[76]: Copied! <pre>g.to_undirected()\nprint(g)\n</pre> g.to_undirected() print(g) <pre>Graph with 3 nodes and 6 edges\n\nNode attributes\n\tnode_id\t\t&lt;class 'list'&gt;\n\tnode_ohe_feature_2\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([3, 4])\n\tnode_ohe_feature_1\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([3, 3])\n\tnode_class\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([3, 1])\n\nEdge attributes\n\tedge_weight\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([6, 1])\n\tedge_ohe_feature_1\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([6, 5])\n\nGraph attributes\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\tgraph_feature\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([2])\n\n</pre> In\u00a0[34]: Copied! <pre>data = g.to_pyg_data()\nprint(data)\n</pre> data = g.to_pyg_data() print(data) <pre>Data(edge_index=[2, 3], node_id=[3], num_nodes=3, node_class=[3, 1], edge_weight=[3, 1], graph_feature=[2], node_ohe_feature_1=[3, 3], node_ohe_feature_2=[3, 4], edge_ohe_feature_1=[3, 5])\n</pre> <p>We can also easily create a graph from a pyG <code>Data</code> object:</p> In\u00a0[48]: Copied! <pre>from torch_geometric.data import Data\nd = Data(x=torch.Tensor([0,0,0,1]), edge_index=torch.Tensor([[0,0,1,3],[1,2,2,2]]), node_id=['a', 'b', 'c', 'd'])\nd.to(pp.config['torch']['device'])\n\ng = pp.Graph.from_pyg_data(d)\nprint(g)\n</pre> from torch_geometric.data import Data d = Data(x=torch.Tensor([0,0,0,1]), edge_index=torch.Tensor([[0,0,1,3],[1,2,2,2]]), node_id=['a', 'b', 'c', 'd']) d.to(pp.config['torch']['device'])  g = pp.Graph.from_pyg_data(d) print(g) <pre>Graph with 4 nodes and 4 edges\n\nNode attributes\n\tnode_id\t\t&lt;class 'list'&gt;\n\tx\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([4])\n\nGraph attributes\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\n</pre> <p>As we will see in a separate notebook focussing on the advanced (temporal) graph visualization features of <code>pathpyG</code>, it is easy to generate (interactive) HTML plots of graphs, that are embedded into jupyter notebooks. You can simply call the <code>pp.plot</code> function on the Graph object:</p> <p>Note that, for the time being, visualizations are generally undirected even if the underlying graph object is directed.</p> In\u00a0[17]: Copied! <pre>pp.plot(g);\n</pre> pp.plot(g); In\u00a0[77]: Copied! <pre>pp.algorithms.centrality.closeness_centrality(g)\n</pre> pp.algorithms.centrality.closeness_centrality(g) Out[77]: <pre>{'a': 1.0, 'b': 1.0, 'c': 1.0}</pre>"},{"location":"tutorial/basic_concepts/#basic-pathpyg-concepts","title":"Basic pathpyG Concepts\u00b6","text":""},{"location":"tutorial/basic_concepts/#motivation-and-learning-objectives","title":"Motivation and Learning Objectives\u00b6","text":"<p>This first step of our multi-stage introductory tutorial introduces foundational concepts of <code>pathpyG</code>. While <code>pathpyG</code> is particularly useful for the GPU-accelerated analysis and graph learning in time series data on graphs, it also provides great tools to represent, analyze and visualize data on static networks. The <code>Graph</code> class that we will use for this purpose is implemented based on the <code>Data</code> object in <code>pyG</code>, which comes with the advantage that we can directly apply <code>pyG</code> transforms.</p> <p>In this basic tutorial you will learn how to use <code>pathpyG</code> to represent simple static graphs. We start with basic features to create directed and undirected graphs with node-, edge-, and graph-level attributes and inspect how graph data is internally stored. We further discuss how we can analyze the centrality of nodes, and how we can read graph data from the <code>netzschleuder</code> database. We will finally show how we can implement graph algorithms.</p> <p>To get started with <code>pathpyG</code>, we first import the modules <code>torch</code> and <code>pathpyG</code>. By setting the device used by <code>torch</code>, we can further specify whether we want to run our code on the CPU or on the GPU. To run your code on the CPU, set the <code>torch.device</code> configuration to <code>cpu</code>. If you want to instead run your code on the GPU, please set the device to <code>cuda</code>.</p>"},{"location":"tutorial/basic_concepts/#creating-graphs-from-tensors-and-edge-lists","title":"Creating Graphs from Tensors and Edge Lists\u00b6","text":"<p>Let's start by generating a simple, directed graph with three nodes <code>a</code>, <code>b</code>, <code>c</code> and three edges <code>(a,b)</code>, <code>(b,c)</code> and <code>(a,b)</code>. We will represent those nodes by integer indices, where index <code>0</code> represents node <code>a</code>, index <code>1</code> represents node <code>b</code> and index <code>2</code> represents node <code>c</code>. In line with the efficient tensor-based representation of sparse graphs in <code>pyG</code>, we use an <code>edge_index</code> tensor with shape <code>(2,m)</code> to represent the <code>m</code> edges of the graph.</p>"},{"location":"tutorial/basic_concepts/#traversing-graphs","title":"Traversing Graphs\u00b6","text":"<p>If we want to implement graph algorithms that require to traverse the graph, we can use the <code>successors</code> and <code>predecessors</code> functions of the <code>Graph</code> object:</p>"},{"location":"tutorial/basic_concepts/#node-edge-or-graph-level-attributes","title":"Node-, Edge- or Graph-Level Attributes\u00b6","text":"<p>Real-world graphs commonly have node-, edge-, or graph-level attributes. In <code>pathpyG</code>, we can simply add attributes as tensors, either by directly assigning them to the <code>pyG</code> data object of an existing graph (or by adding them as keyword arguments in the constructor). Following the <code>pyG</code> semantics of attribute names, we must use the prefixes <code>node_</code> and <code>edge_</code> to refer to node- and edge-level attributes. Attributes with other names will be assumed to refer to graph-level attributes.</p>"},{"location":"tutorial/basic_concepts/#graphs-and-pyg-data","title":"Graphs and pyG Data\u00b6","text":"<p>We can easily generate pyG data frames from a Graph. This allows us to easily combine multiple node or edge features which have a tensor value.</p>"},{"location":"tutorial/basic_concepts/#node-centralities","title":"Node Centralities\u00b6","text":"<p>To calculate node centralities, we can use a <code>networkx</code> delegate mechanism implemented in the module <code>pathpyG.algorithms.centrality</code>. Simply speaking, you can call any function implented in the networkx centrality module that starts with the string <code>centrality_</code>. The <code>pathpyG</code> will be internally converted to a <code>networkx.DiGraph</code> object, the corresponding centrality function (with all of its parameters) will be called, and the result will be mapped to the nodes based on their IDs.</p> <p>In order to calculate the closeness centralities of all nodes for the graph above, we can call:</p>"},{"location":"tutorial/dbgnn/","title":"Causality-Aware GNNs","text":"In\u00a0[1]: Copied! <pre>import pathpyG as pp\n\nimport torch\nfrom pathpyG.nn.dbgnn import DBGNN\nfrom torch_geometric.transforms import RandomNodeSplit\nimport torch_geometric\nfrom sklearn.manifold import TSNE\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy as sp\n\npp.config['torch']['device'] = 'cpu'\ndevice = pp.config['torch']['device']\n</pre> import pathpyG as pp  import torch from pathpyG.nn.dbgnn import DBGNN from torch_geometric.transforms import RandomNodeSplit import torch_geometric from sklearn.manifold import TSNE import numpy as np import matplotlib.pyplot as plt import scipy as sp  pp.config['torch']['device'] = 'cpu' device = pp.config['torch']['device'] In\u00a0[63]: Copied! <pre># Read temporal network\nt = pp.TemporalGraph.from_csv('../data/temporal_clusters.tedges')\n</pre> # Read temporal network t = pp.TemporalGraph.from_csv('../data/temporal_clusters.tedges') In\u00a0[3]: Copied! <pre>node_colors = ['green']*10+['red']*10+['blue']*10\n</pre> node_colors = ['green']*10+['red']*10+['blue']*10 In\u00a0[4]: Copied! <pre>style = {}\nstyle['node_color'] = node_colors\n</pre> style = {} style['node_color'] = node_colors In\u00a0[5]: Copied! <pre>pp.plot(t, **style);\n</pre> pp.plot(t, **style); In\u00a0[6]: Copied! <pre># read the paths\npaths_original = pp.PathData.from_csv('../data/temporal_clusters.ngram')\nprint(paths_original)\nprint(paths_original.num_nodes)\n</pre> # read the paths paths_original = pp.PathData.from_csv('../data/temporal_clusters.ngram') print(paths_original) print(paths_original.num_nodes) <pre>PathData with 7460 walks and 0 dags and total weight 29042\n30\n</pre> In\u00a0[7]: Copied! <pre>#caluclate paths \ndag = pp.algorithms.temporal_graph_to_event_dag(t, delta=1)\nprint(dag)\n</pre> #caluclate paths  dag = pp.algorithms.temporal_graph_to_event_dag(t, delta=1) print(dag) <pre>Graph with 89032 nodes and 60000 edges\n\nNode attributes\n\tnode_name\t\t&lt;class 'list'&gt;\n\tnode_id\t\t&lt;class 'list'&gt;\n\tnode_idx\t\t&lt;class 'list'&gt;\n\nEdge attributes\n\tedge_ts\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([60000])\n\nGraph attributes\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\n</pre> In\u00a0[8]: Copied! <pre>paths = pp.PathData.from_temporal_dag(dag)\npaths.node_id = t.data.node_id\nprint(paths)\n</pre> paths = pp.PathData.from_temporal_dag(dag) paths.node_id = t.data.node_id print(paths) <pre>PathData with 29032 walks and 0 dags and total weight 29032\n</pre> In\u00a0[9]: Copied! <pre>print(len(set([tuple(pp.PathData.walk_to_node_seq(v).tolist()) for v in paths.paths.values()])))\n</pre> print(len(set([tuple(pp.PathData.walk_to_node_seq(v).tolist()) for v in paths.paths.values()]))) <pre>7078\n</pre> In\u00a0[10]: Copied! <pre># Create the graph corresponding to paths\ng = pp.HigherOrderGraph(paths, order=1)\n\n# Plotting the time-aggregated network (first-order graph)\npp.plot(g);\n</pre> # Create the graph corresponding to paths g = pp.HigherOrderGraph(paths, order=1)  # Plotting the time-aggregated network (first-order graph) pp.plot(g); In\u00a0[65]: Copied! <pre># Create the second-order graph corresponding to paths\ng2 = pp.HigherOrderGraph(paths, order=2, node_id=t.data.node_id)\n\n# Plotting the second-order graph\npp.plot(g2);\n</pre> # Create the second-order graph corresponding to paths g2 = pp.HigherOrderGraph(paths, order=2, node_id=t.data.node_id)  # Plotting the second-order graph pp.plot(g2); In\u00a0[12]: Copied! <pre>t_shuffled = pp.TemporalGraph.from_csv('../data/temporal_clusters.tedges')\nt_shuffled.data['t'] = t.data['t'][torch.randperm(len(t_shuffled.data['t']))]\n</pre> t_shuffled = pp.TemporalGraph.from_csv('../data/temporal_clusters.tedges') t_shuffled.data['t'] = t.data['t'][torch.randperm(len(t_shuffled.data['t']))]  In\u00a0[13]: Copied! <pre>t.data.t\n</pre> t.data.t Out[13]: <pre>tensor([    0,     1,     2,  ..., 59997, 59998, 59999])</pre> In\u00a0[14]: Copied! <pre>t_shuffled.data.t\n</pre> t_shuffled.data.t Out[14]: <pre>tensor([21541,  5967, 30001,  ...,  8319, 17186, 28812])</pre> In\u00a0[15]: Copied! <pre>#caluclate paths \ndag_shuffled = pp.algorithms.temporal_graph_to_event_dag(t_shuffled, delta=1)\nprint(dag_shuffled)\n</pre> #caluclate paths  dag_shuffled = pp.algorithms.temporal_graph_to_event_dag(t_shuffled, delta=1) print(dag_shuffled) <pre>Graph with 118015 nodes and 60000 edges\n\nNode attributes\n\tnode_name\t\t&lt;class 'list'&gt;\n\tnode_id\t\t&lt;class 'list'&gt;\n\tnode_idx\t\t&lt;class 'list'&gt;\n\nEdge attributes\n\tedge_ts\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([60000])\n\nGraph attributes\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\n</pre> In\u00a0[16]: Copied! <pre>paths_shuffled = pp.PathData.from_temporal_dag(dag_shuffled)\nprint(paths_shuffled)\nprint(paths_shuffled.num_nodes)\n</pre> paths_shuffled = pp.PathData.from_temporal_dag(dag_shuffled) print(paths_shuffled) print(paths_shuffled.num_nodes) <pre>PathData with 58015 walks and 0 dags and total weight 58015\n30\n</pre> In\u00a0[66]: Copied! <pre># Create the second-order graph corresponding to paths\ng2_shuffled = pp.HigherOrderGraph(paths_shuffled, order=2, node_id=t_shuffled.data.node_id)\nprint(g2_shuffled)\n\n# Plotting the second-order graph\npp.plot(g2_shuffled);\n</pre> # Create the second-order graph corresponding to paths g2_shuffled = pp.HigherOrderGraph(paths_shuffled, order=2, node_id=t_shuffled.data.node_id) print(g2_shuffled)  # Plotting the second-order graph pp.plot(g2_shuffled); <pre>HigherOrderGraph (k=2) with 863 nodes and 1886 edges\n\tTotal edge weight = 1985.0\nEdge attributes\n\tedge_weight\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([1886])\n\nGraph attributes\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\tnode_id\t\t&lt;class 'list'&gt;\n\n</pre> In\u00a0[55]: Copied! <pre>#g2.to_undirected()\nL = g2.get_laplacian(normalization='rw', edge_attr='edge_weight')\n\n#g2_shuffled.to_undirected()\nL_shuffled= g2_shuffled.get_laplacian(normalization='rw',edge_attr='edge_weight')\n</pre> #g2.to_undirected() L = g2.get_laplacian(normalization='rw', edge_attr='edge_weight')  #g2_shuffled.to_undirected() L_shuffled= g2_shuffled.get_laplacian(normalization='rw',edge_attr='edge_weight') In\u00a0[56]: Copied! <pre>w,v = sp.linalg.eig(L.todense(),left= False, right = True)\nw_shuffled, v_shuffled = sp.linalg.eig(L_shuffled.todense())\n</pre> w,v = sp.linalg.eig(L.todense(),left= False, right = True) w_shuffled, v_shuffled = sp.linalg.eig(L_shuffled.todense()) In\u00a0[57]: Copied! <pre>fiedler = v[:,np.argsort(w)[1]]\nfiedler_shuffled = v_shuffled[:,np.argsort(w_shuffled)[1]]\n</pre> fiedler = v[:,np.argsort(w)[1]] fiedler_shuffled = v_shuffled[:,np.argsort(w_shuffled)[1]] In\u00a0[84]: Copied! <pre>c=[]\na=[]\nfor v in g2.nodes:\n\n    if int(v[0])&lt;10 and int(v[1])&lt;10:\n        c.append('green')\n        a.append(1)\n    elif int(v[0])&lt;20 and int(v[0])&gt;= 10 and int(v[1])&lt;20 and int(v[1])&gt;=10: \n        c.append('red')\n        a.append(1)\n    elif int(v[0])&lt;30 and int(v[0])&gt;= 20 and int(v[1])&lt;30 and int(v[1])&gt;=20:\n        c.append('blue')\n        a.append(1)\n    else:\n        c.append('black')\n        a.append(0.1)\n</pre> c=[] a=[] for v in g2.nodes:      if int(v[0])&lt;10 and int(v[1])&lt;10:         c.append('green')         a.append(1)     elif int(v[0])&lt;20 and int(v[0])&gt;= 10 and int(v[1])&lt;20 and int(v[1])&gt;=10:          c.append('red')         a.append(1)     elif int(v[0])&lt;30 and int(v[0])&gt;= 20 and int(v[1])&lt;30 and int(v[1])&gt;=20:         c.append('blue')         a.append(1)     else:         c.append('black')         a.append(0.1)       In\u00a0[88]: Copied! <pre>c_shuffled=[]\na_shuffled=[]\nfor v in g2_shuffled.nodes: \n\n    if int(v[0])&lt;10 and int(v[1])&lt;10:\n        c_shuffled.append('green')\n        a_shuffled.append(1)\n    elif int(v[0])&lt;20 and int(v[0])&gt;= 10 and int(v[1])&lt;20 and int(v[1])&gt;=10: \n        c_shuffled.append('red')\n        a_shuffled.append(1)\n    elif int(v[0])&lt;30 and int(v[0])&gt;= 20 and int(v[1])&lt;30 and int(v[1])&gt;=20:\n        c_shuffled.append('blue')\n        a_shuffled.append(1)\n    else:\n        c_shuffled.append('black')\n        a_shuffled.append(0.1)\n</pre> c_shuffled=[] a_shuffled=[] for v in g2_shuffled.nodes:       if int(v[0])&lt;10 and int(v[1])&lt;10:         c_shuffled.append('green')         a_shuffled.append(1)     elif int(v[0])&lt;20 and int(v[0])&gt;= 10 and int(v[1])&lt;20 and int(v[1])&gt;=10:          c_shuffled.append('red')         a_shuffled.append(1)     elif int(v[0])&lt;30 and int(v[0])&gt;= 20 and int(v[1])&lt;30 and int(v[1])&gt;=20:         c_shuffled.append('blue')         a_shuffled.append(1)     else:         c_shuffled.append('black')         a_shuffled.append(0.1) In\u00a0[83]: Copied! <pre>plt.ylim(-.2, .25)\nplt.scatter(range(g2.data.num_nodes), np.real(fiedler),c=c, alpha=a )\n</pre> plt.ylim(-.2, .25) plt.scatter(range(g2.data.num_nodes), np.real(fiedler),c=c, alpha=a ) Out[83]: <pre>&lt;matplotlib.collections.PathCollection at 0x2c1211090&gt;</pre> In\u00a0[87]: Copied! <pre>plt.ylim(-.1, .1)\nplt.scatter(range(g2_shuffled.data.num_nodes), fiedler_shuffled, c=c_shuffled, alpha=a_shuffled)\n</pre> plt.ylim(-.1, .1) plt.scatter(range(g2_shuffled.data.num_nodes), fiedler_shuffled, c=c_shuffled, alpha=a_shuffled) <pre>/Users/franziskaheeg/miniconda3/envs/pathpy3.10/lib/python3.10/site-packages/matplotlib/cbook.py:1699: ComplexWarning: Casting complex values to real discards the imaginary part\n  return math.isfinite(val)\n/Users/franziskaheeg/miniconda3/envs/pathpy3.10/lib/python3.10/site-packages/matplotlib/collections.py:194: ComplexWarning: Casting complex values to real discards the imaginary part\n  offsets = np.asanyarray(offsets, float)\n</pre> Out[87]: <pre>&lt;matplotlib.collections.PathCollection at 0x2c121b1f0&gt;</pre> In\u00a0[23]: Copied! <pre># Define edge indices for first and second-order graphs\nedge_index_g1 = g.data.edge_index\nedge_index_g2 = g2.data.edge_index\n</pre> # Define edge indices for first and second-order graphs edge_index_g1 = g.data.edge_index edge_index_g2 = g2.data.edge_index In\u00a0[24]: Copied! <pre># Define edge weights\nedge_weights = g.data['edge_weight']\nedge_weights_higher_order = g2.data['edge_weight']\n</pre> # Define edge weights edge_weights = g.data['edge_weight'] edge_weights_higher_order = g2.data['edge_weight'] In\u00a0[25]: Copied! <pre># Define bipartite mapping\nimport torch\n\ndef generate_bipatite_edge_index(mapping = 'last'):\n\n    if mapping == 'last':\n        bipartide_edge_index = torch.tensor([list(g2.node_index_to_id.keys()),\n                                     [i[1] for i in g2.node_index_to_id.values()]])\n\n    elif mapping == 'first':\n        bipartide_edge_index = torch.tensor([list(g2.node_index_to_id.keys()),\n                                     [i[0] for i in g2.node_index_to_id.values()]])\n\n    else:\n        bipartide_edge_index = torch.tensor([list(g2.node_index_to_id.keys()) + list(g2.node_index_to_id.keys()),\n                                     [i[0] for i in g2.node_index_to_id.values()] + [i[1] for i in g2.node_index_to_id.values()]])\n\n    return bipartide_edge_index\n\n\n# Original DBGNN implementation mapping = 'last'\nbipatite_edge_index = generate_bipatite_edge_index(mapping='last')\n</pre> # Define bipartite mapping import torch  def generate_bipatite_edge_index(mapping = 'last'):      if mapping == 'last':         bipartide_edge_index = torch.tensor([list(g2.node_index_to_id.keys()),                                      [i[1] for i in g2.node_index_to_id.values()]])      elif mapping == 'first':         bipartide_edge_index = torch.tensor([list(g2.node_index_to_id.keys()),                                      [i[0] for i in g2.node_index_to_id.values()]])      else:         bipartide_edge_index = torch.tensor([list(g2.node_index_to_id.keys()) + list(g2.node_index_to_id.keys()),                                      [i[0] for i in g2.node_index_to_id.values()] + [i[1] for i in g2.node_index_to_id.values()]])      return bipartide_edge_index   # Original DBGNN implementation mapping = 'last' bipatite_edge_index = generate_bipatite_edge_index(mapping='last') In\u00a0[26]: Copied! <pre># Define the PyG data object\nfrom torch_geometric.data import Data\n\nnum_nodes = max(max(g.data['edge_index'][0]), max(g.data['edge_index'][1])).item() + 1 # since indexing starts from 0\nnum_ho_nodes = max(max(g2.data['edge_index'][0]), max(g2.data['edge_index'][1])).item() + 1 # since indexing starts from 0\n\ndata = Data(\n    num_nodes = num_nodes,\n    num_ho_nodes = num_ho_nodes,\n    x = torch.eye(num_nodes, num_nodes),\n    x_h = torch.eye(num_ho_nodes, num_ho_nodes),\n    edge_index = edge_index_g1,\n    edge_index_higher_order = edge_index_g2,\n    edge_weights = edge_weights.float(),\n    edge_weights_higher_order = edge_weights_higher_order.float(),\n    bipartite_edge_index = bipatite_edge_index,\n    y = torch.tensor([ int(i) // 10 for i in paths.node_id])\n)\n</pre> # Define the PyG data object from torch_geometric.data import Data  num_nodes = max(max(g.data['edge_index'][0]), max(g.data['edge_index'][1])).item() + 1 # since indexing starts from 0 num_ho_nodes = max(max(g2.data['edge_index'][0]), max(g2.data['edge_index'][1])).item() + 1 # since indexing starts from 0  data = Data(     num_nodes = num_nodes,     num_ho_nodes = num_ho_nodes,     x = torch.eye(num_nodes, num_nodes),     x_h = torch.eye(num_ho_nodes, num_ho_nodes),     edge_index = edge_index_g1,     edge_index_higher_order = edge_index_g2,     edge_weights = edge_weights.float(),     edge_weights_higher_order = edge_weights_higher_order.float(),     bipartite_edge_index = bipatite_edge_index,     y = torch.tensor([ int(i) // 10 for i in paths.node_id]) ) In\u00a0[27]: Copied! <pre>from sklearn.metrics import balanced_accuracy_score\n\ndef test(model, data):\n    model.eval()\n\n    _, pred = model(data).max(dim=1)\n\n    metrics_train = balanced_accuracy_score(\n        data.y[data.train_mask].cpu(),\n        pred[data.train_mask].cpu().numpy()\n        )\n\n    metrics_test = balanced_accuracy_score(\n        data.y[data.test_mask].cpu(),\n        pred[data.test_mask].cpu().numpy()\n        )\n\n    return metrics_train, metrics_test\n</pre> from sklearn.metrics import balanced_accuracy_score  def test(model, data):     model.eval()      _, pred = model(data).max(dim=1)      metrics_train = balanced_accuracy_score(         data.y[data.train_mask].cpu(),         pred[data.train_mask].cpu().numpy()         )      metrics_test = balanced_accuracy_score(         data.y[data.test_mask].cpu(),         pred[data.test_mask].cpu().numpy()         )      return metrics_train, metrics_test In\u00a0[28]: Copied! <pre>data = RandomNodeSplit(num_val=0, num_test=0.3)(data)\n\nmodel = DBGNN(\n        num_features =[num_nodes, num_ho_nodes],\n        num_classes = len(data.y.unique()),\n        hidden_dims = [16, 32, 8],\n        p_dropout = 0.4\n        ).to(device)\n\noptimizer = torch.optim.Adam(model.parameters(),  lr=0.005)\nloss_function = torch.nn.CrossEntropyLoss()\n\ndata = data.to(device)\n</pre> data = RandomNodeSplit(num_val=0, num_test=0.3)(data)  model = DBGNN(         num_features =[num_nodes, num_ho_nodes],         num_classes = len(data.y.unique()),         hidden_dims = [16, 32, 8],         p_dropout = 0.4         ).to(device)  optimizer = torch.optim.Adam(model.parameters(),  lr=0.005) loss_function = torch.nn.CrossEntropyLoss()  data = data.to(device) In\u00a0[29]: Copied! <pre>data\n</pre> data Out[29]: <pre>Data(x=[30, 30], edge_index=[2, 557], y=[30], num_nodes=30, num_ho_nodes=557, x_h=[557, 557], edge_index_higher_order=[2, 6572], edge_weights=[557], edge_weights_higher_order=[6572], bipartite_edge_index=[2, 557], train_mask=[30], val_mask=[30], test_mask=[30])</pre> In\u00a0[30]: Copied! <pre>print(model)\n</pre> print(model) <pre>DBGNN(\n  (higher_order_layers): ModuleList(\n    (0): GCNConv(557, 16)\n    (1): GCNConv(16, 32)\n  )\n  (first_order_layers): ModuleList(\n    (0): GCNConv(30, 16)\n    (1): GCNConv(16, 32)\n  )\n  (bipartite_layer): BipartiteGraphOperator()\n  (lin): Linear(in_features=8, out_features=3, bias=True)\n)\n</pre> In\u00a0[31]: Copied! <pre>losses = []\nfor epoch in range(1000):\n        output = model(data)\n        loss = loss_function(output[data.train_mask], data.y[data.train_mask])\n        loss.backward()\n        optimizer.step()\n        optimizer.zero_grad()\n        losses.append(loss)\n\n        if epoch % 10 == 0:\n                train_ba, test_ba  = test(model, data)\n                print(f'Epoch: {epoch}, Loss: {loss}, Train balanced accuracy: {train_ba}, Test balanced accuracy: {test_ba}')\n</pre> losses = [] for epoch in range(1000):         output = model(data)         loss = loss_function(output[data.train_mask], data.y[data.train_mask])         loss.backward()         optimizer.step()         optimizer.zero_grad()         losses.append(loss)          if epoch % 10 == 0:                 train_ba, test_ba  = test(model, data)                 print(f'Epoch: {epoch}, Loss: {loss}, Train balanced accuracy: {train_ba}, Test balanced accuracy: {test_ba}') <pre>Epoch: 0, Loss: 1.227025032043457, Train balanced accuracy: 0.3333333333333333, Test balanced accuracy: 0.3333333333333333\nEpoch: 10, Loss: 0.6666216850280762, Train balanced accuracy: 0.6666666666666666, Test balanced accuracy: 0.6666666666666666\nEpoch: 20, Loss: 0.09434882551431656, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 30, Loss: 0.0014071125769987702, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 40, Loss: 0.00030880115809850395, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 50, Loss: 0.0001672431972110644, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 60, Loss: 0.00011002655082847923, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 70, Loss: 8.51466174935922e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 80, Loss: 7.0924885221757e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 90, Loss: 6.107875378802419e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 100, Loss: 5.376345507102087e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 110, Loss: 4.805967182619497e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 120, Loss: 4.343973705545068e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 130, Loss: 3.959159948863089e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 140, Loss: 3.632800871855579e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 150, Loss: 3.3529791835462674e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 160, Loss: 3.1117517210077494e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 170, Loss: 2.900604704336729e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 180, Loss: 2.7149984816787764e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 190, Loss: 2.5509601982776076e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 200, Loss: 2.4011105779209174e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 210, Loss: 2.2694241124554537e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 220, Loss: 2.1479540009750053e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 230, Loss: 2.0384035451570526e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 240, Loss: 1.9385019186302088e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 250, Loss: 1.8454114979249425e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 260, Loss: 1.7619706341065466e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 270, Loss: 1.6842053810250945e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 280, Loss: 1.6104137102956884e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 290, Loss: 1.5440009519807063e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 300, Loss: 1.47985856528976e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 310, Loss: 1.4213922440831084e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 320, Loss: 1.3663317076861858e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 330, Loss: 1.3135416338627692e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 340, Loss: 1.2641573448490817e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 350, Loss: 1.2193138900329359e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 360, Loss: 1.1761733730963897e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 370, Loss: 1.1353033187333494e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 380, Loss: 1.0955684956570622e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 390, Loss: 1.0592395483399741e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 400, Loss: 1.025181063596392e-05, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 410, Loss: 9.905548722599633e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 420, Loss: 9.610374036128633e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 430, Loss: 9.309522283729166e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 440, Loss: 9.031377885548864e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 450, Loss: 8.747555511945393e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 460, Loss: 8.480761607643217e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 470, Loss: 8.248027370427735e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 480, Loss: 8.026645446079783e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 490, Loss: 7.805261702742428e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 500, Loss: 7.583881142636528e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 510, Loss: 7.373850621661404e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 520, Loss: 7.19220361133921e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 530, Loss: 6.999202923907433e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 540, Loss: 6.823232070019003e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 550, Loss: 6.63590708427364e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 560, Loss: 6.471289452747442e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 570, Loss: 6.318023679341422e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 580, Loss: 6.164757451188052e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 590, Loss: 6.022844900144264e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 600, Loss: 5.8752552831720095e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 610, Loss: 5.756049631600035e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 620, Loss: 5.619813236990012e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 630, Loss: 5.506282832357101e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 640, Loss: 5.375722594180843e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 650, Loss: 5.2508389671857e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 660, Loss: 5.148661784915021e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 670, Loss: 5.035130925534759e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 680, Loss: 4.927277132082963e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 690, Loss: 4.8364522626798134e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 700, Loss: 4.745627848024014e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 710, Loss: 4.654803433368215e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 720, Loss: 4.563979018712416e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 730, Loss: 4.478830760490382e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 740, Loss: 4.399358658702113e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 750, Loss: 4.302858087612549e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 760, Loss: 4.2233859858242795e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 770, Loss: 4.14391388403601e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 780, Loss: 4.08147252528579e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 790, Loss: 4.007677034678636e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 800, Loss: 3.933881998818833e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 810, Loss: 3.871439730573911e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 820, Loss: 3.826027295872336e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 830, Loss: 3.7465554214577423e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 840, Loss: 3.6727599308505887e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 850, Loss: 3.621670884967898e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 860, Loss: 3.5649056826514425e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 870, Loss: 3.5138166367687518e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 880, Loss: 3.462727590886061e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 890, Loss: 3.4173153835581616e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 900, Loss: 3.3491965041321237e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 910, Loss: 3.303783614683198e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 920, Loss: 3.264047563789063e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 930, Loss: 3.2129585179063724e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 940, Loss: 3.1561926334688906e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 950, Loss: 3.1164572646957822e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 960, Loss: 3.054014541703509e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 970, Loss: 3.0199551019904902e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 980, Loss: 2.9688660561077995e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 990, Loss: 2.9291297778399894e-06, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\n</pre> In\u00a0[32]: Copied! <pre>g2.node_index_to_id[0]\n</pre> g2.node_index_to_id[0] Out[32]: <pre>(0, 1)</pre> In\u00a0[33]: Copied! <pre>model.eval()\nlatent = model.higher_order_layers[0].forward(data.x_h, data.edge_index_higher_order).detach()\nnode_embedding = TSNE(n_components=2, learning_rate='auto', init='random').fit_transform(latent.cpu())\n\ncolors = []\nfor v, w in g2.nodes:\n    if data.y[v] == 0 and data.y[w] == 0:\n        colors.append('red')\n    elif data.y[v] == 1 and data.y[w] == 1:\n        colors.append('green')\n    elif data.y[v] == 2 and data.y[w] == 2:\n        colors.append('blue')\n    else:\n        colors.append('grey')\n\nplt.figure(figsize=(13,10))\nplt.scatter(node_embedding[:,0], node_embedding[:,1], c=colors, alpha=0.5)\n\nfor e in g2.edges:\n    s = g2.node_id_to_index[e[0]]\n    t = g2.node_id_to_index[e[1]]\n    plt.plot([node_embedding[s,0], node_embedding[t,0]], [node_embedding[s,1], node_embedding[t,1]], \n             color='lightsteelblue', \n             linestyle='-', \n             alpha=0.2,\n             lw=0.2)\nplt.axis('off')\nplt.show()\n</pre> model.eval() latent = model.higher_order_layers[0].forward(data.x_h, data.edge_index_higher_order).detach() node_embedding = TSNE(n_components=2, learning_rate='auto', init='random').fit_transform(latent.cpu())  colors = [] for v, w in g2.nodes:     if data.y[v] == 0 and data.y[w] == 0:         colors.append('red')     elif data.y[v] == 1 and data.y[w] == 1:         colors.append('green')     elif data.y[v] == 2 and data.y[w] == 2:         colors.append('blue')     else:         colors.append('grey')  plt.figure(figsize=(13,10)) plt.scatter(node_embedding[:,0], node_embedding[:,1], c=colors, alpha=0.5)  for e in g2.edges:     s = g2.node_id_to_index[e[0]]     t = g2.node_id_to_index[e[1]]     plt.plot([node_embedding[s,0], node_embedding[t,0]], [node_embedding[s,1], node_embedding[t,1]],               color='lightsteelblue',               linestyle='-',               alpha=0.2,              lw=0.2) plt.axis('off') plt.show() In\u00a0[34]: Copied! <pre>model.eval()\nlatent = model.higher_order_layers[1].forward(latent.cpu(), data.edge_index_higher_order).detach()\nnode_embedding = TSNE(n_components=2, learning_rate='auto', init='random').fit_transform(latent.cpu())\n\ncolors = []\nfor v, w in g2.nodes:\n    if data.y[v] == 0 and data.y[w] == 0:\n        colors.append('red')\n    elif data.y[v] == 1 and data.y[w] == 1:\n        colors.append('green')\n    elif data.y[v] == 2 and data.y[w] == 2:\n        colors.append('blue')\n    else:\n        colors.append('grey')\n\nplt.figure(figsize=(13,10))\nplt.scatter(node_embedding[:,0], node_embedding[:,1], c=colors, alpha=0.5)\n\nfor e in g2.edges:\n    s = g2.node_id_to_index[e[0]]\n    t = g2.node_id_to_index[e[1]]\n    plt.plot([node_embedding[s,0], node_embedding[t,0]], [node_embedding[s,1], node_embedding[t,1]], \n             color='lightsteelblue', \n             linestyle='-', \n             alpha=0.2,\n             lw=0.2)\nplt.axis('off')\nplt.show()\n</pre> model.eval() latent = model.higher_order_layers[1].forward(latent.cpu(), data.edge_index_higher_order).detach() node_embedding = TSNE(n_components=2, learning_rate='auto', init='random').fit_transform(latent.cpu())  colors = [] for v, w in g2.nodes:     if data.y[v] == 0 and data.y[w] == 0:         colors.append('red')     elif data.y[v] == 1 and data.y[w] == 1:         colors.append('green')     elif data.y[v] == 2 and data.y[w] == 2:         colors.append('blue')     else:         colors.append('grey')  plt.figure(figsize=(13,10)) plt.scatter(node_embedding[:,0], node_embedding[:,1], c=colors, alpha=0.5)  for e in g2.edges:     s = g2.node_id_to_index[e[0]]     t = g2.node_id_to_index[e[1]]     plt.plot([node_embedding[s,0], node_embedding[t,0]], [node_embedding[s,1], node_embedding[t,1]],               color='lightsteelblue',               linestyle='-',               alpha=0.2,              lw=0.2) plt.axis('off') plt.show() In\u00a0[35]: Copied! <pre>model.eval()\nlatent = model.forward(data).detach()\nnode_embedding = TSNE(n_components=2, learning_rate='auto', init='random', perplexity=10).fit_transform(latent.cpu())\n\ncolors = []\nfor v in g.nodes:\n    if data.y[v] == 0:\n        colors.append('red')\n    elif data.y[v] == 1:\n        colors.append('green')\n    elif data.y[v] == 2:\n        colors.append('blue')\n    else:\n        colors.append('grey')\n\nplt.figure(figsize=(13,10))\nplt.scatter(node_embedding[:,0], node_embedding[:,1], c=colors, alpha=0.5)\n\nfor e in g.edges:\n    s = e[0]\n    t = e[1]\n    plt.plot([node_embedding[s,0], node_embedding[t,0]], [node_embedding[s,1], node_embedding[t,1]], \n             color='lightsteelblue', \n             linestyle='-', \n             alpha=0.2,\n             lw=0.2)\nplt.axis('off')\nplt.show()\n</pre> model.eval() latent = model.forward(data).detach() node_embedding = TSNE(n_components=2, learning_rate='auto', init='random', perplexity=10).fit_transform(latent.cpu())  colors = [] for v in g.nodes:     if data.y[v] == 0:         colors.append('red')     elif data.y[v] == 1:         colors.append('green')     elif data.y[v] == 2:         colors.append('blue')     else:         colors.append('grey')  plt.figure(figsize=(13,10)) plt.scatter(node_embedding[:,0], node_embedding[:,1], c=colors, alpha=0.5)  for e in g.edges:     s = e[0]     t = e[1]     plt.plot([node_embedding[s,0], node_embedding[t,0]], [node_embedding[s,1], node_embedding[t,1]],               color='lightsteelblue',               linestyle='-',               alpha=0.2,              lw=0.2) plt.axis('off') plt.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorial/dbgnn/#load-the-synthetic-dataset","title":"Load the synthetic dataset\u00b6","text":""},{"location":"tutorial/dbgnn/#spectral-clustering-with-second-order-graph-laplacian","title":"Spectral clustering with second-order graph Laplacian\u00b6","text":""},{"location":"tutorial/dbgnn/#prepare-the-data","title":"Prepare the data\u00b6","text":""},{"location":"tutorial/dbgnn/#dbgnn","title":"DBGNN\u00b6","text":""},{"location":"tutorial/dbgnn/#latent-space-representation-of-edges","title":"Latent space representation of edges\u00b6","text":""},{"location":"tutorial/dbgnn/#latent-space-representation-of-nodes","title":"Latent space representation of nodes\u00b6","text":""},{"location":"tutorial/higher_order_scalability/","title":"Higher order scalability","text":"In\u00a0[1]: Copied! <pre>import time\nimport torch\n\nimport pathpy as pp2\nimport pathpyG as pp\nfrom matplotlib import pyplot as plt\n\nprint('Running on', pp.config['torch']['device'])\n</pre> import time import torch  import pathpy as pp2 import pathpyG as pp from matplotlib import pyplot as plt  print('Running on', pp.config['torch']['device']) <pre>Running on cuda\n</pre> In\u00a0[7]: Copied! <pre>p = pp.PathData.from_csv('../data/tube_paths_train.ngram')\ng2 = pp.HigherOrderGraph(p, order=2, path_freq='path_freq', node_id=p['node_name'])\nprint(g2.N)\nprint(g2.M)\nprint(g2['edge_weight'].sum().item())\n</pre> p = pp.PathData.from_csv('../data/tube_paths_train.ngram') g2 = pp.HigherOrderGraph(p, order=2, path_freq='path_freq', node_id=p['node_name']) print(g2.N) print(g2.M) print(g2['edge_weight'].sum().item()) <pre>642\n1139\n12356472.0\n</pre> In\u00a0[8]: Copied! <pre>for e in g2.edges:\n    print(e, g2['edge_weight', e[0], e[1]])\n</pre> for e in g2.edges:     print(e, g2['edge_weight', e[0], e[1]]) <pre>(('Southwark', 'Waterloo'), ('Waterloo', 'Embankment')) tensor(8405.)\n(('Southwark', 'Waterloo'), ('Waterloo', 'Westminster')) tensor(91710.)\n(('Southwark', 'Waterloo'), ('Waterloo', 'Lambeth North')) tensor(204.)\n(('Southwark', 'Waterloo'), ('Waterloo', 'Kennington')) tensor(13182.)\n(('Southwark', 'London Bridge'), ('London Bridge', 'Bank / Monument')) tensor(73218.)\n(('Southwark', 'London Bridge'), ('London Bridge', 'Bermondsey')) tensor(51530.)\n(('Southwark', 'London Bridge'), ('London Bridge', 'Borough')) tensor(296.)\n(('Waterloo', 'Southwark'), ('Southwark', 'London Bridge')) tensor(140333.)\n(('Waterloo', 'Embankment'), ('Embankment', 'Temple')) tensor(1499.)\n(('Waterloo', 'Embankment'), ('Embankment', 'Charing Cross')) tensor(11663.)\n(('Waterloo', 'Westminster'), ('Westminster', 'Green Park')) tensor(103374.)\n(('Waterloo', 'Westminster'), ('Westminster', \"St. James's Park\")) tensor(19691.)\n(('Waterloo', 'Lambeth North'), ('Lambeth North', 'Elephant &amp; Castle')) tensor(3719.)\n(('Waterloo', 'Kennington'), ('Kennington', 'Elephant &amp; Castle')) tensor(3771.)\n(('Waterloo', 'Kennington'), ('Kennington', 'Oval')) tensor(20312.)\n(('Liverpool Street', 'Bank / Monument'), ('Bank / Monument', 'Tower Hill')) tensor(205.)\n(('Liverpool Street', 'Bank / Monument'), ('Bank / Monument', 'London Bridge')) tensor(47231.)\n(('Liverpool Street', 'Bank / Monument'), ('Bank / Monument', \"St. Paul's\")) tensor(47464.)\n(('Liverpool Street', 'Bank / Monument'), ('Bank / Monument', 'Cannon Street')) tensor(2580.)\n(('Liverpool Street', 'Moorgate'), ('Moorgate', 'Old Street')) tensor(18381.)\n(('Liverpool Street', 'Moorgate'), ('Moorgate', 'Barbican')) tensor(23396.)\n(('Liverpool Street', 'Aldgate East'), ('Aldgate East', 'Tower Hill')) tensor(184.)\n(('Liverpool Street', 'Aldgate East'), ('Aldgate East', 'Whitechapel')) tensor(34708.)\n(('Liverpool Street', 'Tottenham Hale'), ('Tottenham Hale', 'Seven Sisters')) tensor(14069.)\n(('Liverpool Street', 'Tottenham Hale'), ('Tottenham Hale', 'Blackhorse Road')) tensor(8175.)\n(('Liverpool Street', 'Aldgate'), ('Aldgate', 'Tower Hill')) tensor(168.)\n(('Liverpool Street', 'Bethnal Green'), ('Bethnal Green', 'Mile End')) tensor(40307.)\n(('Bank / Monument', 'Liverpool Street'), ('Liverpool Street', 'Aldgate East')) tensor(22329.)\n(('Bank / Monument', 'Liverpool Street'), ('Liverpool Street', 'Tottenham Hale')) tensor(17445.)\n(('Bank / Monument', 'Liverpool Street'), ('Liverpool Street', 'Aldgate')) tensor(748.)\n(('Bank / Monument', 'Liverpool Street'), ('Liverpool Street', 'Bethnal Green')) tensor(30899.)\n(('Bank / Monument', 'Tower Hill'), ('Tower Hill', 'Aldgate East')) tensor(22368.)\n(('Bank / Monument', 'Tower Hill'), ('Tower Hill', 'Aldgate')) tensor(724.)\n(('Bank / Monument', 'Moorgate'), ('Moorgate', 'Old Street')) tensor(22225.)\n(('Bank / Monument', 'Moorgate'), ('Moorgate', 'Barbican')) tensor(12147.)\n(('Bank / Monument', 'London Bridge'), ('London Bridge', 'Southwark')) tensor(77592.)\n(('Bank / Monument', 'London Bridge'), ('London Bridge', 'Bermondsey')) tensor(8529.)\n(('Bank / Monument', 'London Bridge'), ('London Bridge', 'Borough')) tensor(15701.)\n(('Bank / Monument', \"St. Paul's\"), (\"St. Paul's\", 'Chancery Lane')) tensor(78212.)\n(('Bank / Monument', 'Cannon Street'), ('Cannon Street', 'Mansion House')) tensor(5484.)\n(('Barking', 'West Ham'), ('West Ham', 'BromleyByBow')) tensor(721.)\n(('Barking', 'West Ham'), ('West Ham', 'Stratford')) tensor(21639.)\n(('Barking', 'West Ham'), ('West Ham', 'Plaistow')) tensor(509.)\n(('Barking', 'West Ham'), ('West Ham', 'Canning Town')) tensor(4412.)\n(('Barking', 'Upminster'), ('Upminster', 'Upminster Bridge')) tensor(4084.)\n(('Barking', 'Upney'), ('Upney', 'Becontree')) tensor(7378.)\n(('Barking', 'East Ham'), ('East Ham', 'Upton Park')) tensor(1069.)\n(('West Ham', 'Barking'), ('Barking', 'Upminster')) tensor(4851.)\n(('West Ham', 'Barking'), ('Barking', 'Upney')) tensor(6709.)\n(('West Ham', 'Barking'), ('Barking', 'East Ham')) tensor(9255.)\n(('West Ham', 'BromleyByBow'), ('BromleyByBow', 'Bow Road')) tensor(651.)\n(('West Ham', 'Stratford'), ('Stratford', 'Whitechapel')) tensor(21610.)\n(('West Ham', 'Stratford'), ('Stratford', 'Leyton')) tensor(3793.)\n(('West Ham', 'Stratford'), ('Stratford', 'Mile End')) tensor(13025.)\n(('West Ham', 'Plaistow'), ('Plaistow', 'Upton Park')) tensor(6315.)\n(('West Ham', 'Canning Town'), ('Canning Town', 'North Greenwich')) tensor(16617.)\n(('Tufnell Park', 'Kentish Town'), ('Kentish Town', 'Camden Town')) tensor(27597.)\n(('Tufnell Park', 'Archway'), ('Archway', 'Highgate')) tensor(19211.)\n(('Kentish Town', 'Tufnell Park'), ('Tufnell Park', 'Archway')) tensor(24638.)\n(('Kentish Town', 'Camden Town'), ('Camden Town', 'Chalk Farm')) tensor(1285.)\n(('Kentish Town', 'Camden Town'), ('Camden Town', 'Euston')) tensor(29538.)\n(('Kentish Town', 'Camden Town'), ('Camden Town', 'Mornington Crescent')) tensor(517.)\n(('Ruislip Gardens', 'South Ruislip'), ('South Ruislip', 'Northolt')) tensor(837.)\n(('South Ruislip', 'Northolt'), ('Northolt', 'Greenford')) tensor(3310.)\n(('Turnpike Lane', 'Manor House'), ('Manor House', 'Finsbury Park')) tensor(27920.)\n(('Turnpike Lane', 'Wood Green'), ('Wood Green', 'Bounds Green')) tensor(13387.)\n(('Manor House', 'Turnpike Lane'), ('Turnpike Lane', 'Wood Green')) tensor(20965.)\n(('Manor House', 'Finsbury Park'), ('Finsbury Park', 'Seven Sisters')) tensor(6624.)\n(('Manor House', 'Finsbury Park'), ('Finsbury Park', 'Highbury &amp; Islington')) tensor(25704.)\n(('Manor House', 'Finsbury Park'), ('Finsbury Park', 'Arsenal')) tensor(989.)\n(('Seven Sisters', 'Finsbury Park'), ('Finsbury Park', 'Manor House')) tensor(5926.)\n(('Seven Sisters', 'Finsbury Park'), ('Finsbury Park', 'Highbury &amp; Islington')) tensor(22983.)\n(('Seven Sisters', 'Finsbury Park'), ('Finsbury Park', 'Arsenal')) tensor(1312.)\n(('Seven Sisters', 'Tottenham Hale'), ('Tottenham Hale', 'Liverpool Street')) tensor(13034.)\n(('Seven Sisters', 'Tottenham Hale'), ('Tottenham Hale', 'Blackhorse Road')) tensor(8234.)\n(('Finsbury Park', 'Manor House'), ('Manor House', 'Turnpike Lane')) tensor(26982.)\n(('Finsbury Park', 'Seven Sisters'), ('Seven Sisters', 'Tottenham Hale')) tensor(21454.)\n(('Finsbury Park', 'Highbury &amp; Islington'), ('Highbury &amp; Islington', \"King's Cross St. Pancras\")) tensor(55407.)\n(('Finsbury Park', 'Arsenal'), ('Arsenal', 'Holloway Road')) tensor(1902.)\n(('Tower Hill', 'Bank / Monument'), ('Bank / Monument', 'Liverpool Street')) tensor(169.)\n(('Tower Hill', 'Bank / Monument'), ('Bank / Monument', 'Moorgate')) tensor(1869.)\n(('Tower Hill', 'Bank / Monument'), ('Bank / Monument', 'London Bridge')) tensor(17772.)\n(('Tower Hill', 'Bank / Monument'), ('Bank / Monument', \"St. Paul's\")) tensor(15059.)\n(('Tower Hill', 'Bank / Monument'), ('Bank / Monument', 'Cannon Street')) tensor(2826.)\n(('Tower Hill', 'Aldgate East'), ('Aldgate East', 'Liverpool Street')) tensor(159.)\n(('Tower Hill', 'Aldgate East'), ('Aldgate East', 'Whitechapel')) tensor(21479.)\n(('Tower Hill', 'Aldgate'), ('Aldgate', 'Liverpool Street')) tensor(160.)\n(('Upminster', 'Barking'), ('Barking', 'West Ham')) tensor(5150.)\n(('Upminster', 'Barking'), ('Barking', 'Upney')) tensor(246.)\n(('Upminster', 'Barking'), ('Barking', 'East Ham')) tensor(408.)\n(('Upminster', 'Upminster Bridge'), ('Upminster Bridge', 'Hornchurch')) tensor(3861.)\n(('Embankment', 'Waterloo'), ('Waterloo', 'Southwark')) tensor(7763.)\n(('Embankment', 'Waterloo'), ('Waterloo', 'Lambeth North')) tensor(645.)\n(('Embankment', 'Waterloo'), ('Waterloo', 'Kennington')) tensor(5064.)\n(('Embankment', 'Temple'), ('Temple', 'Blackfriars')) tensor(10196.)\n(('Embankment', 'Westminster'), ('Westminster', 'Green Park')) tensor(12354.)\n(('Embankment', 'Westminster'), ('Westminster', \"St. James's Park\")) tensor(6660.)\n(('Embankment', 'Charing Cross'), ('Charing Cross', 'Piccadilly Circus')) tensor(3546.)\n(('Embankment', 'Charing Cross'), ('Charing Cross', 'Leicester Square')) tensor(7744.)\n(('Temple', 'Embankment'), ('Embankment', 'Waterloo')) tensor(1363.)\n(('Temple', 'Embankment'), ('Embankment', 'Westminster')) tensor(11926.)\n(('Temple', 'Embankment'), ('Embankment', 'Charing Cross')) tensor(730.)\n(('Temple', 'Blackfriars'), ('Blackfriars', 'Mansion House')) tensor(6764.)\n(('Finchley Road', 'Willesden Green'), ('Willesden Green', 'Kilburn')) tensor(2830.)\n(('Finchley Road', 'Willesden Green'), ('Willesden Green', 'Neasden')) tensor(847.)\n(('Finchley Road', 'Willesden Green'), ('Willesden Green', 'Dollis Hill')) tensor(1664.)\n(('Finchley Road', 'Baker Street'), ('Baker Street', 'Bond Street')) tensor(28461.)\n(('Finchley Road', 'Baker Street'), ('Baker Street', 'Edgware Road (Cir)')) tensor(2226.)\n(('Finchley Road', 'Baker Street'), ('Baker Street', 'Marylebone')) tensor(52.)\n(('Finchley Road', 'Baker Street'), ('Baker Street', \"St. John's Wood\")) tensor(574.)\n(('Finchley Road', 'Baker Street'), ('Baker Street', \"Regent's Park\")) tensor(1441.)\n(('Finchley Road', 'Baker Street'), ('Baker Street', 'Great Portland Street')) tensor(14548.)\n(('Finchley Road', 'Wembley Park'), ('Wembley Park', 'Kingsbury')) tensor(7588.)\n(('Finchley Road', 'Wembley Park'), ('Wembley Park', 'Neasden')) tensor(760.)\n(('Finchley Road', 'Wembley Park'), ('Wembley Park', 'Preston Road')) tensor(1669.)\n(('Finchley Road', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'North Harrow')) tensor(1496.)\n(('Finchley Road', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'West Harrow')) tensor(4891.)\n(('Finchley Road', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Marylebone')) tensor(50.)\n(('Finchley Road', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Rickmansworth')) tensor(1902.)\n(('Finchley Road', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Moor Park')) tensor(1654.)\n(('Finchley Road', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Northwick Park')) tensor(1157.)\n(('Finchley Road', 'West Hampstead'), ('West Hampstead', 'Kilburn')) tensor(2836.)\n(('Finchley Road', 'Swiss Cottage'), ('Swiss Cottage', \"St. John's Wood\")) tensor(577.)\n(('Willesden Green', 'Finchley Road'), ('Finchley Road', 'Baker Street')) tensor(9996.)\n(('Willesden Green', 'Finchley Road'), ('Finchley Road', 'Wembley Park')) tensor(464.)\n(('Willesden Green', 'Finchley Road'), ('Finchley Road', 'HarrowOnTheHill')) tensor(498.)\n(('Willesden Green', 'Finchley Road'), ('Finchley Road', 'West Hampstead')) tensor(196.)\n(('Willesden Green', 'Finchley Road'), ('Finchley Road', 'Swiss Cottage')) tensor(430.)\n(('Willesden Green', 'Kilburn'), ('Kilburn', 'West Hampstead')) tensor(215.)\n(('Willesden Green', 'Neasden'), ('Neasden', 'Wembley Park')) tensor(476.)\n(('Angel', 'Old Street'), ('Old Street', 'Moorgate')) tensor(35761.)\n(('Angel', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Caledonian Road')) tensor(638.)\n(('Angel', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Euston')) tensor(19434.)\n(('Angel', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Farringdon')) tensor(9.)\n(('Angel', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Highbury &amp; Islington')) tensor(1221.)\n(('Angel', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Russell Square')) tensor(1353.)\n(('Angel', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Euston Square')) tensor(15152.)\n(('Old Street', 'Angel'), ('Angel', \"King's Cross St. Pancras\")) tensor(38421.)\n(('Old Street', 'Moorgate'), ('Moorgate', 'Liverpool Street')) tensor(17724.)\n(('Old Street', 'Moorgate'), ('Moorgate', 'Bank / Monument')) tensor(22038.)\n(('Old Street', 'Moorgate'), ('Moorgate', 'Barbican')) tensor(31.)\n(('Holland Park', 'Notting Hill Gate'), ('Notting Hill Gate', 'Bayswater')) tensor(2607.)\n(('Holland Park', 'Notting Hill Gate'), ('Notting Hill Gate', 'Queensway')) tensor(16502.)\n(('Holland Park', 'Notting Hill Gate'), ('Notting Hill Gate', 'High Street Kensington')) tensor(2268.)\n(('Holland Park', \"Shepherd's Bush (Cen)\"), (\"Shepherd's Bush (Cen)\", 'White City')) tensor(5513.)\n(('Notting Hill Gate', 'Holland Park'), ('Holland Park', \"Shepherd's Bush (Cen)\")) tensor(18160.)\n(('Notting Hill Gate', 'Bayswater'), ('Bayswater', 'Paddington')) tensor(15205.)\n(('Notting Hill Gate', 'Queensway'), ('Queensway', 'Lancaster Gate')) tensor(24541.)\n(('Notting Hill Gate', 'High Street Kensington'), ('High Street Kensington', \"Earl's Court\")) tensor(8833.)\n(('Notting Hill Gate', 'High Street Kensington'), ('High Street Kensington', 'Gloucester Road')) tensor(6156.)\n(('Baker Street', 'Finchley Road'), ('Finchley Road', 'Willesden Green')) tensor(8821.)\n(('Baker Street', 'Finchley Road'), ('Finchley Road', 'Wembley Park')) tensor(13050.)\n(('Baker Street', 'Finchley Road'), ('Finchley Road', 'HarrowOnTheHill')) tensor(11203.)\n(('Baker Street', 'Finchley Road'), ('Finchley Road', 'West Hampstead')) tensor(7427.)\n(('Baker Street', 'Finchley Road'), ('Finchley Road', 'Swiss Cottage')) tensor(2370.)\n(('Baker Street', 'Bond Street'), ('Bond Street', 'Marble Arch')) tensor(1993.)\n(('Baker Street', 'Bond Street'), ('Bond Street', 'Green Park')) tensor(66227.)\n(('Baker Street', 'Bond Street'), ('Bond Street', 'Oxford Circus')) tensor(10133.)\n(('Baker Street', 'Bond Street'), ('Bond Street', 'Tottenham Court Road')) tensor(36979.)\n(('Baker Street', 'Edgware Road (Cir)'), ('Edgware Road (Cir)', 'Paddington')) tensor(108179.)\n(('Baker Street', 'Marylebone'), ('Marylebone', 'Edgware Road (Bak)')) tensor(3032.)\n(('Baker Street', 'Marylebone'), ('Marylebone', 'HarrowOnTheHill')) tensor(11174.)\n(('Baker Street', \"St. John's Wood\"), (\"St. John's Wood\", 'Swiss Cottage')) tensor(2337.)\n(('Baker Street', \"Regent's Park\"), (\"Regent's Park\", 'Oxford Circus')) tensor(10004.)\n(('Baker Street', 'Great Portland Street'), ('Great Portland Street', 'Euston Square')) tensor(66193.)\n(('Bond Street', 'Baker Street'), ('Baker Street', 'Finchley Road')) tensor(27994.)\n(('Bond Street', 'Baker Street'), ('Baker Street', 'Edgware Road (Cir)')) tensor(57635.)\n(('Bond Street', 'Baker Street'), ('Baker Street', 'Marylebone')) tensor(14156.)\n(('Bond Street', 'Baker Street'), ('Baker Street', \"St. John's Wood\")) tensor(4623.)\n(('Bond Street', 'Baker Street'), ('Baker Street', \"Regent's Park\")) tensor(11.)\n(('Bond Street', 'Baker Street'), ('Baker Street', 'Great Portland Street')) tensor(1540.)\n(('Bond Street', 'Marble Arch'), ('Marble Arch', 'Lancaster Gate')) tensor(30033.)\n(('Bond Street', 'Green Park'), ('Green Park', 'Westminster')) tensor(54919.)\n(('Bond Street', 'Green Park'), ('Green Park', 'Piccadilly Circus')) tensor(4359.)\n(('Bond Street', 'Green Park'), ('Green Park', 'Hyde Park Corner')) tensor(4236.)\n(('Bond Street', 'Green Park'), ('Green Park', 'Victoria')) tensor(22735.)\n(('Bond Street', 'Oxford Circus'), ('Oxford Circus', 'Piccadilly Circus')) tensor(4405.)\n(('Bond Street', 'Oxford Circus'), ('Oxford Circus', 'Warren Street')) tensor(5609.)\n(('Bond Street', 'Oxford Circus'), ('Oxford Circus', \"Regent's Park\")) tensor(6.)\n(('Bond Street', 'Tottenham Court Road'), ('Tottenham Court Road', 'Leicester Square')) tensor(5602.)\n(('Bond Street', 'Tottenham Court Road'), ('Tottenham Court Road', 'Holborn')) tensor(61150.)\n(('Bond Street', 'Tottenham Court Road'), ('Tottenham Court Road', 'Goodge Street')) tensor(1249.)\n(('Latimer Road', 'Ladbroke Grove'), ('Ladbroke Grove', 'Westbourne Park')) tensor(9931.)\n(('Latimer Road', 'Wood Lane'), ('Wood Lane', \"Shepherd's Bush Market\")) tensor(6610.)\n(('Ladbroke Grove', 'Latimer Road'), ('Latimer Road', 'Wood Lane')) tensor(8120.)\n(('Ladbroke Grove', 'Westbourne Park'), ('Westbourne Park', 'Royal Oak')) tensor(12491.)\n(('North Harrow', 'Pinner'), ('Pinner', 'Northwood Hills')) tensor(520.)\n(('North Harrow', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Finchley Road')) tensor(1654.)\n(('North Harrow', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Wembley Park')) tensor(130.)\n(('North Harrow', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'West Harrow')) tensor(48.)\n(('North Harrow', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Marylebone')) tensor(1618.)\n(('North Harrow', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Rickmansworth')) tensor(34.)\n(('North Harrow', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Moor Park')) tensor(92.)\n(('North Harrow', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Northwick Park')) tensor(51.)\n(('Pinner', 'North Harrow'), ('North Harrow', 'HarrowOnTheHill')) tensor(2447.)\n(('Pinner', 'Northwood Hills'), ('Northwood Hills', 'Northwood')) tensor(100.)\n(('Chesham', 'Chalfont &amp; Latimer'), ('Chalfont &amp; Latimer', 'Chorleywood')) tensor(552.)\n(('Chesham', 'Chalfont &amp; Latimer'), ('Chalfont &amp; Latimer', 'Amersham')) tensor(16.)\n(('Chalfont &amp; Latimer', 'Chorleywood'), ('Chorleywood', 'Rickmansworth')) tensor(2629.)\n(('Westminster', 'Waterloo'), ('Waterloo', 'Southwark')) tensor(91242.)\n(('Westminster', 'Waterloo'), ('Waterloo', 'Lambeth North')) tensor(4532.)\n(('Westminster', 'Waterloo'), ('Waterloo', 'Kennington')) tensor(5593.)\n(('Westminster', 'Embankment'), ('Embankment', 'Temple')) tensor(12612.)\n(('Westminster', 'Embankment'), ('Embankment', 'Charing Cross')) tensor(316.)\n(('Westminster', 'Green Park'), ('Green Park', 'Bond Street')) tensor(55338.)\n(('Westminster', 'Green Park'), ('Green Park', 'Piccadilly Circus')) tensor(2682.)\n(('Westminster', 'Green Park'), ('Green Park', 'Oxford Circus')) tensor(22523.)\n(('Westminster', 'Green Park'), ('Green Park', 'Hyde Park Corner')) tensor(14042.)\n(('Westminster', 'Green Park'), ('Green Park', 'Victoria')) tensor(21065.)\n(('Westminster', \"St. James's Park\"), (\"St. James's Park\", 'Victoria')) tensor(21303.)\n(('Turnham Green', 'Stamford Brook'), ('Stamford Brook', 'Ravenscourt Park')) tensor(89.)\n(('Turnham Green', 'Gunnersbury'), ('Gunnersbury', 'Kew Gardens')) tensor(9440.)\n(('Turnham Green', 'Hammersmith (Dis)'), ('Hammersmith (Dis)', 'Barons Court')) tensor(7592.)\n(('Turnham Green', 'Hammersmith (Dis)'), ('Hammersmith (Dis)', 'Ravenscourt Park')) tensor(99.)\n(('Turnham Green', 'Acton Town'), ('Acton Town', 'Ealing Common')) tensor(9792.)\n(('Turnham Green', 'Acton Town'), ('Acton Town', 'South Ealing')) tensor(198.)\n(('Stamford Brook', 'Turnham Green'), ('Turnham Green', 'Gunnersbury')) tensor(202.)\n(('Stamford Brook', 'Turnham Green'), ('Turnham Green', 'Hammersmith (Dis)')) tensor(561.)\n(('Stamford Brook', 'Turnham Green'), ('Turnham Green', 'Acton Town')) tensor(1014.)\n(('Stamford Brook', 'Turnham Green'), ('Turnham Green', 'Chiswick Park')) tensor(5.)\n(('Stamford Brook', 'Ravenscourt Park'), ('Ravenscourt Park', 'Hammersmith (Dis)')) tensor(574.)\n(('Belsize Park', 'Chalk Farm'), ('Chalk Farm', 'Camden Town')) tensor(25509.)\n(('Belsize Park', 'Hampstead'), ('Hampstead', 'Golders Green')) tensor(18504.)\n(('Chalk Farm', 'Belsize Park'), ('Belsize Park', 'Hampstead')) tensor(20819.)\n(('Chalk Farm', 'Camden Town'), ('Camden Town', 'Kentish Town')) tensor(1290.)\n(('Chalk Farm', 'Camden Town'), ('Camden Town', 'Euston')) tensor(25545.)\n(('Chalk Farm', 'Camden Town'), ('Camden Town', 'Mornington Crescent')) tensor(473.)\n(('Bow Road', 'BromleyByBow'), ('BromleyByBow', 'West Ham')) tensor(713.)\n(('Bow Road', 'Mile End'), ('Mile End', 'Stratford')) tensor(323.)\n(('Bow Road', 'Mile End'), ('Mile End', 'Stepney Green')) tensor(347.)\n(('Bow Road', 'Mile End'), ('Mile End', 'Bethnal Green')) tensor(3761.)\n(('BromleyByBow', 'West Ham'), ('West Ham', 'Barking')) tensor(966.)\n(('BromleyByBow', 'West Ham'), ('West Ham', 'Stratford')) tensor(199.)\n(('BromleyByBow', 'West Ham'), ('West Ham', 'Plaistow')) tensor(205.)\n(('BromleyByBow', 'West Ham'), ('West Ham', 'Canning Town')) tensor(62.)\n(('BromleyByBow', 'Bow Road'), ('Bow Road', 'Mile End')) tensor(1212.)\n(('Woodford', 'Buckhurst Hill'), ('Buckhurst Hill', 'Loughton')) tensor(6737.)\n(('Woodford', 'South Woodford'), ('South Woodford', 'Snaresbrook')) tensor(14085.)\n(('Woodford', 'Roding Valley'), ('Roding Valley', 'Chigwell')) tensor(2096.)\n(('Buckhurst Hill', 'Woodford'), ('Woodford', 'South Woodford')) tensor(8354.)\n(('Buckhurst Hill', 'Woodford'), ('Woodford', 'Roding Valley')) tensor(140.)\n(('Buckhurst Hill', 'Loughton'), ('Loughton', 'Debden')) tensor(4344.)\n(('Hanger Lane', 'North Acton'), ('North Acton', 'East Acton')) tensor(3666.)\n(('Hanger Lane', 'North Acton'), ('North Acton', 'West Acton')) tensor(9393.)\n(('Hanger Lane', 'Perivale'), ('Perivale', 'Greenford')) tensor(9000.)\n(('North Acton', 'Hanger Lane'), ('Hanger Lane', 'Perivale')) tensor(10210.)\n(('North Acton', 'East Acton'), ('East Acton', 'White City')) tensor(5305.)\n(('North Acton', 'West Acton'), ('West Acton', 'Ealing Broadway')) tensor(14886.)\n(('Vauxhall', 'Stockwell'), ('Stockwell', 'Clapham North')) tensor(21108.)\n(('Vauxhall', 'Stockwell'), ('Stockwell', 'Brixton')) tensor(13019.)\n(('Vauxhall', 'Stockwell'), ('Stockwell', 'Oval')) tensor(2589.)\n(('Vauxhall', 'Pimlico'), ('Pimlico', 'Victoria')) tensor(50507.)\n(('Stockwell', 'Vauxhall'), ('Vauxhall', 'Pimlico')) tensor(37135.)\n(('Stockwell', 'Clapham North'), ('Clapham North', 'Clapham Common')) tensor(42065.)\n(('Stockwell', 'Oval'), ('Oval', 'Kennington')) tensor(32144.)\n((\"Shepherd's Bush (Cen)\", 'Holland Park'), ('Holland Park', 'Notting Hill Gate')) tensor(19705.)\n((\"Shepherd's Bush (Cen)\", 'White City'), ('White City', 'East Acton')) tensor(3883.)\n(('White City', \"Shepherd's Bush (Cen)\"), (\"Shepherd's Bush (Cen)\", 'Holland Park')) tensor(5814.)\n(('White City', 'East Acton'), ('East Acton', 'North Acton')) tensor(4671.)\n(('Stratford', 'West Ham'), ('West Ham', 'Barking')) tensor(21958.)\n(('Stratford', 'West Ham'), ('West Ham', 'BromleyByBow')) tensor(282.)\n(('Stratford', 'West Ham'), ('West Ham', 'Plaistow')) tensor(7936.)\n(('Stratford', 'West Ham'), ('West Ham', 'Canning Town')) tensor(14231.)\n(('Stratford', 'Whitechapel'), ('Whitechapel', 'Aldgate East')) tensor(55499.)\n(('Stratford', 'Whitechapel'), ('Whitechapel', 'Stepney Green')) tensor(581.)\n(('Stratford', 'Leyton'), ('Leyton', 'Leytonstone')) tensor(36031.)\n(('Stratford', 'Mile End'), ('Mile End', 'Bow Road')) tensor(324.)\n(('Stratford', 'Mile End'), ('Mile End', 'Stepney Green')) tensor(622.)\n(('Stratford', 'Mile End'), ('Mile End', 'Bethnal Green')) tensor(36435.)\n(('Whitechapel', 'Stratford'), ('Stratford', 'West Ham')) tensor(20404.)\n(('Whitechapel', 'Stratford'), ('Stratford', 'Leyton')) tensor(20341.)\n(('Whitechapel', 'Stratford'), ('Stratford', 'Mile End')) tensor(365.)\n(('Whitechapel', 'Aldgate East'), ('Aldgate East', 'Liverpool Street')) tensor(38773.)\n(('Whitechapel', 'Aldgate East'), ('Aldgate East', 'Tower Hill')) tensor(23609.)\n(('Whitechapel', 'Stepney Green'), ('Stepney Green', 'Mile End')) tensor(374.)\n(('South Woodford', 'Woodford'), ('Woodford', 'Buckhurst Hill')) tensor(7764.)\n(('South Woodford', 'Woodford'), ('Woodford', 'Roding Valley')) tensor(1930.)\n(('South Woodford', 'Snaresbrook'), ('Snaresbrook', 'Leytonstone')) tensor(16771.)\n(('Snaresbrook', 'South Woodford'), ('South Woodford', 'Woodford')) tensor(12410.)\n(('Snaresbrook', 'Leytonstone'), ('Leytonstone', 'Leyton')) tensor(18559.)\n(('Snaresbrook', 'Leytonstone'), ('Leytonstone', 'Wanstead')) tensor(80.)\n(('East Acton', 'North Acton'), ('North Acton', 'Hanger Lane')) tensor(3301.)\n(('East Acton', 'North Acton'), ('North Acton', 'West Acton')) tensor(2679.)\n(('East Acton', 'White City'), ('White City', \"Shepherd's Bush (Cen)\")) tensor(3938.)\n(('Moorgate', 'Liverpool Street'), ('Liverpool Street', 'Aldgate East')) tensor(10694.)\n(('Moorgate', 'Liverpool Street'), ('Liverpool Street', 'Tottenham Hale')) tensor(1843.)\n(('Moorgate', 'Liverpool Street'), ('Liverpool Street', 'Aldgate')) tensor(3445.)\n(('Moorgate', 'Liverpool Street'), ('Liverpool Street', 'Bethnal Green')) tensor(10898.)\n(('Moorgate', 'Bank / Monument'), ('Bank / Monument', 'Tower Hill')) tensor(2081.)\n(('Moorgate', 'Bank / Monument'), ('Bank / Monument', 'London Bridge')) tensor(29326.)\n(('Moorgate', 'Bank / Monument'), ('Bank / Monument', \"St. Paul's\")) tensor(286.)\n(('Moorgate', 'Bank / Monument'), ('Bank / Monument', 'Cannon Street')) tensor(458.)\n(('Moorgate', 'Old Street'), ('Old Street', 'Angel')) tensor(35904.)\n(('Moorgate', 'Barbican'), ('Barbican', 'Farringdon')) tensor(37158.)\n(('Edgware Road (Cir)', 'Baker Street'), ('Baker Street', 'Finchley Road')) tensor(2352.)\n(('Edgware Road (Cir)', 'Baker Street'), ('Baker Street', 'Bond Street')) tensor(63305.)\n(('Edgware Road (Cir)', 'Baker Street'), ('Baker Street', 'Marylebone')) tensor(61.)\n(('Edgware Road (Cir)', 'Baker Street'), ('Baker Street', \"St. John's Wood\")) tensor(622.)\n(('Edgware Road (Cir)', 'Baker Street'), ('Baker Street', \"Regent's Park\")) tensor(7284.)\n(('Edgware Road (Cir)', 'Baker Street'), ('Baker Street', 'Great Portland Street')) tensor(39778.)\n(('Edgware Road (Cir)', 'Paddington'), ('Paddington', 'Warwick Avenue')) tensor(14789.)\n(('Edgware Road (Cir)', 'Paddington'), ('Paddington', 'Royal Oak')) tensor(9889.)\n(('Edgware Road (Cir)', 'Paddington'), ('Paddington', 'Bayswater')) tensor(8776.)\n(('Edgware Road (Cir)', 'Paddington'), ('Paddington', 'Ealing Broadway')) tensor(47148.)\n(('Paddington', 'Edgware Road (Cir)'), ('Edgware Road (Cir)', 'Baker Street')) tensor(112704.)\n(('Paddington', 'Edgware Road (Bak)'), ('Edgware Road (Bak)', 'Marylebone')) tensor(4056.)\n(('Paddington', 'Warwick Avenue'), ('Warwick Avenue', 'Maida Vale')) tensor(17006.)\n(('Paddington', 'Royal Oak'), ('Royal Oak', 'Westbourne Park')) tensor(11878.)\n(('Paddington', 'Bayswater'), ('Bayswater', 'Notting Hill Gate')) tensor(15714.)\n(('Paddington', 'Ealing Broadway'), ('Ealing Broadway', 'Ealing Common')) tensor(31377.)\n(('Paddington', 'Ealing Broadway'), ('Ealing Broadway', 'West Acton')) tensor(13398.)\n(('Caledonian Road', 'Holloway Road'), ('Holloway Road', 'Arsenal')) tensor(1248.)\n(('Caledonian Road', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Angel')) tensor(400.)\n(('Caledonian Road', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Euston')) tensor(3217.)\n(('Caledonian Road', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Farringdon')) tensor(499.)\n(('Caledonian Road', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Highbury &amp; Islington')) tensor(433.)\n(('Caledonian Road', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Russell Square')) tensor(2015.)\n(('Caledonian Road', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Euston Square')) tensor(1637.)\n(('Holloway Road', 'Caledonian Road'), ('Caledonian Road', \"King's Cross St. Pancras\")) tensor(4964.)\n(('Holloway Road', 'Arsenal'), ('Arsenal', 'Finsbury Park')) tensor(2161.)\n(('West Brompton', \"Earl's Court\"), (\"Earl's Court\", 'Barons Court')) tensor(2506.)\n(('West Brompton', \"Earl's Court\"), (\"Earl's Court\", 'West Kensington')) tensor(111.)\n(('West Brompton', \"Earl's Court\"), (\"Earl's Court\", 'Gloucester Road')) tensor(19624.)\n(('West Brompton', \"Earl's Court\"), (\"Earl's Court\", 'High Street Kensington')) tensor(6522.)\n(('West Brompton', 'Fulham Broadway'), ('Fulham Broadway', 'Parsons Green')) tensor(19823.)\n((\"Earl's Court\", 'West Brompton'), ('West Brompton', 'Fulham Broadway')) tensor(25806.)\n((\"Earl's Court\", 'Barons Court'), ('Barons Court', 'Hammersmith (Dis)')) tensor(24125.)\n((\"Earl's Court\", 'Gloucester Road'), ('Gloucester Road', 'South Kensington')) tensor(54595.)\n((\"Earl's Court\", 'High Street Kensington'), ('High Street Kensington', 'Notting Hill Gate')) tensor(8625.)\n(('Queensbury', 'Kingsbury'), ('Kingsbury', 'Wembley Park')) tensor(6626.)\n(('Queensbury', 'Canons Park'), ('Canons Park', 'Stanmore')) tensor(2667.)\n(('Kingsbury', 'Queensbury'), ('Queensbury', 'Canons Park')) tensor(4110.)\n(('Kingsbury', 'Wembley Park'), ('Wembley Park', 'Finchley Road')) tensor(7269.)\n(('Kingsbury', 'Wembley Park'), ('Wembley Park', 'HarrowOnTheHill')) tensor(809.)\n(('Kingsbury', 'Wembley Park'), ('Wembley Park', 'Neasden')) tensor(622.)\n(('Kingsbury', 'Wembley Park'), ('Wembley Park', 'Preston Road')) tensor(13.)\n(('Loughton', 'Buckhurst Hill'), ('Buckhurst Hill', 'Woodford')) tensor(7100.)\n(('Loughton', 'Debden'), ('Debden', 'Theydon Bois')) tensor(2632.)\n(('Debden', 'Loughton'), ('Loughton', 'Buckhurst Hill')) tensor(4998.)\n(('Debden', 'Theydon Bois'), ('Theydon Bois', 'Epping')) tensor(2137.)\n(('Lancaster Gate', 'Marble Arch'), ('Marble Arch', 'Bond Street')) tensor(31949.)\n(('Lancaster Gate', 'Queensway'), ('Queensway', 'Notting Hill Gate')) tensor(22816.)\n(('Marble Arch', 'Bond Street'), ('Bond Street', 'Baker Street')) tensor(2162.)\n(('Marble Arch', 'Bond Street'), ('Bond Street', 'Green Park')) tensor(7580.)\n(('Marble Arch', 'Bond Street'), ('Bond Street', 'Oxford Circus')) tensor(6412.)\n(('Marble Arch', 'Bond Street'), ('Bond Street', 'Tottenham Court Road')) tensor(23921.)\n(('Marble Arch', 'Lancaster Gate'), ('Lancaster Gate', 'Queensway')) tensor(27639.)\n(('Edgware Road (Bak)', 'Paddington'), ('Paddington', 'Warwick Avenue')) tensor(716.)\n(('Edgware Road (Bak)', 'Paddington'), ('Paddington', 'Royal Oak')) tensor(347.)\n(('Edgware Road (Bak)', 'Paddington'), ('Paddington', 'Bayswater')) tensor(927.)\n(('Edgware Road (Bak)', 'Paddington'), ('Paddington', 'Ealing Broadway')) tensor(1110.)\n(('Edgware Road (Bak)', 'Marylebone'), ('Marylebone', 'Baker Street')) tensor(3067.)\n(('Edgware Road (Bak)', 'Marylebone'), ('Marylebone', 'HarrowOnTheHill')) tensor(2926.)\n((\"King's Cross St. Pancras\", 'Angel'), ('Angel', 'Old Street')) tensor(38810.)\n((\"King's Cross St. Pancras\", 'Caledonian Road'), ('Caledonian Road', 'Holloway Road')) tensor(4712.)\n((\"King's Cross St. Pancras\", 'Euston'), ('Euston', 'Camden Town')) tensor(28166.)\n((\"King's Cross St. Pancras\", 'Euston'), ('Euston', 'Mornington Crescent')) tensor(682.)\n((\"King's Cross St. Pancras\", 'Euston'), ('Euston', 'Warren Street')) tensor(59352.)\n((\"King's Cross St. Pancras\", 'Farringdon'), ('Farringdon', 'Barbican')) tensor(35056.)\n((\"King's Cross St. Pancras\", 'Highbury &amp; Islington'), ('Highbury &amp; Islington', 'Finsbury Park')) tensor(52020.)\n((\"King's Cross St. Pancras\", 'Russell Square'), ('Russell Square', 'Holborn')) tensor(18707.)\n((\"King's Cross St. Pancras\", 'Euston Square'), ('Euston Square', 'Great Portland Street')) tensor(64658.)\n(('Euston', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Angel')) tensor(19994.)\n(('Euston', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Caledonian Road')) tensor(2765.)\n(('Euston', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Farringdon')) tensor(13515.)\n(('Euston', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Highbury &amp; Islington')) tensor(32804.)\n(('Euston', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Russell Square')) tensor(2905.)\n(('Euston', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Euston Square')) tensor(1810.)\n(('Euston', 'Camden Town'), ('Camden Town', 'Kentish Town')) tensor(28733.)\n(('Euston', 'Camden Town'), ('Camden Town', 'Chalk Farm')) tensor(24178.)\n(('Euston', 'Warren Street'), ('Warren Street', 'Oxford Circus')) tensor(96941.)\n(('Euston', 'Warren Street'), ('Warren Street', 'Goodge Street')) tensor(5150.)\n(('Bermondsey', 'Canada Water'), ('Canada Water', 'Canary Wharf')) tensor(54387.)\n(('Bermondsey', 'London Bridge'), ('London Bridge', 'Southwark')) tensor(48282.)\n(('Bermondsey', 'London Bridge'), ('London Bridge', 'Bank / Monument')) tensor(9008.)\n(('Bermondsey', 'London Bridge'), ('London Bridge', 'Borough')) tensor(2192.)\n(('Canada Water', 'Bermondsey'), ('Bermondsey', 'London Bridge')) tensor(62762.)\n(('Canada Water', 'Canary Wharf'), ('Canary Wharf', 'North Greenwich')) tensor(27856.)\n(('Clapham North', 'Stockwell'), ('Stockwell', 'Vauxhall')) tensor(21013.)\n(('Clapham North', 'Stockwell'), ('Stockwell', 'Brixton')) tensor(543.)\n(('Clapham North', 'Stockwell'), ('Stockwell', 'Oval')) tensor(23152.)\n(('Clapham North', 'Clapham Common'), ('Clapham Common', 'Clapham South')) tensor(36031.)\n(('Clapham Common', 'Clapham North'), ('Clapham North', 'Stockwell')) tensor(42200.)\n(('Clapham Common', 'Clapham South'), ('Clapham South', 'Balham')) tensor(31102.)\n(('Lambeth North', 'Waterloo'), ('Waterloo', 'Southwark')) tensor(361.)\n(('Lambeth North', 'Waterloo'), ('Waterloo', 'Embankment')) tensor(481.)\n(('Lambeth North', 'Waterloo'), ('Waterloo', 'Westminster')) tensor(4960.)\n(('Lambeth North', 'Waterloo'), ('Waterloo', 'Kennington')) tensor(56.)\n(('Lambeth North', 'Elephant &amp; Castle'), ('Elephant &amp; Castle', 'Borough')) tensor(633.)\n(('Lambeth North', 'Elephant &amp; Castle'), ('Elephant &amp; Castle', 'Kennington')) tensor(51.)\n(('Uxbridge', 'Hillingdon'), ('Hillingdon', 'Ickenham')) tensor(5939.)\n(('Hillingdon', 'Ickenham'), ('Ickenham', 'Ruislip')) tensor(6898.)\n(('Finchley Central', 'East Finchley'), ('East Finchley', 'Highgate')) tensor(11663.)\n(('Finchley Central', 'West Finchley'), ('West Finchley', 'Woodside Park')) tensor(6099.)\n(('Mill Hill East', 'Finchley Central'), ('Finchley Central', 'East Finchley')) tensor(728.)\n(('Mill Hill East', 'Finchley Central'), ('Finchley Central', 'West Finchley')) tensor(28.)\n(('Camden Town', 'Kentish Town'), ('Kentish Town', 'Tufnell Park')) tensor(26200.)\n(('Camden Town', 'Chalk Farm'), ('Chalk Farm', 'Belsize Park')) tensor(24109.)\n(('Camden Town', 'Euston'), ('Euston', \"King's Cross St. Pancras\")) tensor(29570.)\n(('Camden Town', 'Euston'), ('Euston', 'Warren Street')) tensor(33443.)\n(('Stonebridge Park', 'Wembley Central'), ('Wembley Central', 'North Wembley')) tensor(4004.)\n(('Stonebridge Park', 'Harlesden'), ('Harlesden', 'Willesden Junction')) tensor(9145.)\n(('Wembley Central', 'Stonebridge Park'), ('Stonebridge Park', 'Harlesden')) tensor(7870.)\n(('Wembley Central', 'North Wembley'), ('North Wembley', 'South Kenton')) tensor(3628.)\n(('Highgate', 'East Finchley'), ('East Finchley', 'Finchley Central')) tensor(11538.)\n(('Highgate', 'Archway'), ('Archway', 'Tufnell Park')) tensor(19764.)\n(('East Finchley', 'Finchley Central'), ('Finchley Central', 'Mill Hill East')) tensor(965.)\n(('East Finchley', 'Finchley Central'), ('Finchley Central', 'West Finchley')) tensor(6693.)\n(('East Finchley', 'Highgate'), ('Highgate', 'Archway')) tensor(16639.)\n(('Green Park', 'Bond Street'), ('Bond Street', 'Baker Street')) tensor(62749.)\n(('Green Park', 'Bond Street'), ('Bond Street', 'Marble Arch')) tensor(7936.)\n(('Green Park', 'Bond Street'), ('Bond Street', 'Tottenham Court Road')) tensor(6883.)\n(('Green Park', 'Westminster'), ('Westminster', 'Waterloo')) tensor(102943.)\n(('Green Park', 'Westminster'), ('Westminster', 'Embankment')) tensor(13309.)\n(('Green Park', 'Westminster'), ('Westminster', \"St. James's Park\")) tensor(2012.)\n(('Green Park', 'Piccadilly Circus'), ('Piccadilly Circus', 'Leicester Square')) tensor(8952.)\n(('Green Park', 'Piccadilly Circus'), ('Piccadilly Circus', 'Charing Cross')) tensor(1606.)\n(('Green Park', 'Oxford Circus'), ('Oxford Circus', 'Tottenham Court Road')) tensor(6751.)\n(('Green Park', 'Oxford Circus'), ('Oxford Circus', 'Warren Street')) tensor(64966.)\n(('Green Park', 'Oxford Circus'), ('Oxford Circus', \"Regent's Park\")) tensor(1415.)\n(('Green Park', 'Hyde Park Corner'), ('Hyde Park Corner', 'Knightsbridge')) tensor(33614.)\n(('Green Park', 'Victoria'), ('Victoria', 'Pimlico')) tensor(43712.)\n(('Green Park', 'Victoria'), ('Victoria', \"St. James's Park\")) tensor(2087.)\n(('Green Park', 'Victoria'), ('Victoria', 'Sloane Square')) tensor(28663.)\n(('Piccadilly Circus', 'Green Park'), ('Green Park', 'Bond Street')) tensor(3948.)\n(('Piccadilly Circus', 'Green Park'), ('Green Park', 'Westminster')) tensor(2945.)\n(('Piccadilly Circus', 'Green Park'), ('Green Park', 'Hyde Park Corner')) tensor(5006.)\n(('Piccadilly Circus', 'Green Park'), ('Green Park', 'Victoria')) tensor(9597.)\n(('Piccadilly Circus', 'Oxford Circus'), ('Oxford Circus', 'Bond Street')) tensor(3893.)\n(('Piccadilly Circus', 'Oxford Circus'), ('Oxford Circus', 'Tottenham Court Road')) tensor(1091.)\n(('Piccadilly Circus', 'Oxford Circus'), ('Oxford Circus', 'Warren Street')) tensor(9933.)\n(('Piccadilly Circus', 'Oxford Circus'), ('Oxford Circus', \"Regent's Park\")) tensor(3921.)\n(('Piccadilly Circus', 'Leicester Square'), ('Leicester Square', 'Tottenham Court Road')) tensor(1128.)\n(('Piccadilly Circus', 'Leicester Square'), ('Leicester Square', 'Covent Garden')) tensor(5216.)\n(('Piccadilly Circus', 'Charing Cross'), ('Charing Cross', 'Embankment')) tensor(3886.)\n(('Archway', 'Tufnell Park'), ('Tufnell Park', 'Kentish Town')) tensor(25443.)\n(('Archway', 'Highgate'), ('Highgate', 'East Finchley')) tensor(16303.)\n(('Aldgate East', 'Liverpool Street'), ('Liverpool Street', 'Bank / Monument')) tensor(24109.)\n(('Aldgate East', 'Liverpool Street'), ('Liverpool Street', 'Moorgate')) tensor(12000.)\n(('Aldgate East', 'Liverpool Street'), ('Liverpool Street', 'Tottenham Hale')) tensor(3134.)\n(('Aldgate East', 'Liverpool Street'), ('Liverpool Street', 'Aldgate')) tensor(17.)\n(('Aldgate East', 'Liverpool Street'), ('Liverpool Street', 'Bethnal Green')) tensor(122.)\n(('Aldgate East', 'Tower Hill'), ('Tower Hill', 'Bank / Monument')) tensor(24013.)\n(('Aldgate East', 'Tower Hill'), ('Tower Hill', 'Aldgate')) tensor(19.)\n(('Aldgate East', 'Whitechapel'), ('Whitechapel', 'Stratford')) tensor(50106.)\n(('Aldgate East', 'Whitechapel'), ('Whitechapel', 'Stepney Green')) tensor(1372.)\n(('Kilburn', 'Willesden Green'), ('Willesden Green', 'Finchley Road')) tensor(2687.)\n(('Kilburn', 'Willesden Green'), ('Willesden Green', 'Neasden')) tensor(323.)\n(('Kilburn', 'Willesden Green'), ('Willesden Green', 'Dollis Hill')) tensor(39.)\n(('Kilburn', 'West Hampstead'), ('West Hampstead', 'Finchley Road')) tensor(2738.)\n(('Pimlico', 'Vauxhall'), ('Vauxhall', 'Stockwell')) tensor(35331.)\n(('Pimlico', 'Victoria'), ('Victoria', 'Green Park')) tensor(45625.)\n(('Pimlico', 'Victoria'), ('Victoria', \"St. James's Park\")) tensor(1696.)\n(('Pimlico', 'Victoria'), ('Victoria', 'Sloane Square')) tensor(7374.)\n(('Mornington Crescent', 'Euston'), ('Euston', \"King's Cross St. Pancras\")) tensor(684.)\n(('Mornington Crescent', 'Euston'), ('Euston', 'Warren Street')) tensor(1707.)\n(('Mornington Crescent', 'Camden Town'), ('Camden Town', 'Kentish Town')) tensor(411.)\n(('Mornington Crescent', 'Camden Town'), ('Camden Town', 'Chalk Farm')) tensor(575.)\n(('Canons Park', 'Queensbury'), ('Queensbury', 'Kingsbury')) tensor(4161.)\n(('Wembley Park', 'Finchley Road'), ('Finchley Road', 'Willesden Green')) tensor(517.)\n(('Wembley Park', 'Finchley Road'), ('Finchley Road', 'Baker Street')) tensor(12865.)\n(('Wembley Park', 'Finchley Road'), ('Finchley Road', 'West Hampstead')) tensor(759.)\n(('Wembley Park', 'Finchley Road'), ('Finchley Road', 'Swiss Cottage')) tensor(527.)\n(('Wembley Park', 'Kingsbury'), ('Kingsbury', 'Queensbury')) tensor(6556.)\n(('Wembley Park', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'North Harrow')) tensor(241.)\n(('Wembley Park', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'West Harrow')) tensor(1090.)\n(('Wembley Park', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Marylebone')) tensor(450.)\n(('Wembley Park', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Rickmansworth')) tensor(83.)\n(('Wembley Park', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Moor Park')) tensor(219.)\n(('Wembley Park', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Northwick Park')) tensor(98.)\n(('Wembley Park', 'Neasden'), ('Neasden', 'Willesden Green')) tensor(551.)\n(('Wembley Park', 'Neasden'), ('Neasden', 'Dollis Hill')) tensor(392.)\n(('Wembley Park', 'Preston Road'), ('Preston Road', 'Northwick Park')) tensor(110.)\n(('Warwick Avenue', 'Paddington'), ('Paddington', 'Edgware Road (Cir)')) tensor(17945.)\n(('Warwick Avenue', 'Paddington'), ('Paddington', 'Edgware Road (Bak)')) tensor(1095.)\n(('Warwick Avenue', 'Paddington'), ('Paddington', 'Royal Oak')) tensor(126.)\n(('Warwick Avenue', 'Paddington'), ('Paddington', 'Bayswater')) tensor(1356.)\n(('Warwick Avenue', 'Paddington'), ('Paddington', 'Ealing Broadway')) tensor(1178.)\n(('Warwick Avenue', 'Maida Vale'), ('Maida Vale', 'Kilburn Park')) tensor(15322.)\n(('Oxford Circus', 'Bond Street'), ('Bond Street', 'Baker Street')) tensor(9769.)\n(('Oxford Circus', 'Bond Street'), ('Bond Street', 'Marble Arch')) tensor(6238.)\n(('Oxford Circus', 'Green Park'), ('Green Park', 'Westminster')) tensor(21681.)\n(('Oxford Circus', 'Green Park'), ('Green Park', 'Hyde Park Corner')) tensor(11257.)\n(('Oxford Circus', 'Green Park'), ('Green Park', 'Victoria')) tensor(58208.)\n(('Oxford Circus', 'Piccadilly Circus'), ('Piccadilly Circus', 'Leicester Square')) tensor(1632.)\n(('Oxford Circus', 'Piccadilly Circus'), ('Piccadilly Circus', 'Charing Cross')) tensor(6595.)\n(('Oxford Circus', 'Tottenham Court Road'), ('Tottenham Court Road', 'Leicester Square')) tensor(1635.)\n(('Oxford Circus', 'Tottenham Court Road'), ('Tottenham Court Road', 'Holborn')) tensor(17065.)\n(('Oxford Circus', 'Tottenham Court Road'), ('Tottenham Court Road', 'Goodge Street')) tensor(759.)\n(('Oxford Circus', 'Warren Street'), ('Warren Street', 'Euston')) tensor(89747.)\n(('Oxford Circus', 'Warren Street'), ('Warren Street', 'Goodge Street')) tensor(791.)\n(('Oxford Circus', \"Regent's Park\"), (\"Regent's Park\", 'Baker Street')) tensor(9780.)\n(('HarrowOnTheHill', 'Finchley Road'), ('Finchley Road', 'Willesden Green')) tensor(474.)\n(('HarrowOnTheHill', 'Finchley Road'), ('Finchley Road', 'Baker Street')) tensor(11136.)\n(('HarrowOnTheHill', 'Finchley Road'), ('Finchley Road', 'West Hampstead')) tensor(519.)\n(('HarrowOnTheHill', 'Finchley Road'), ('Finchley Road', 'Swiss Cottage')) tensor(313.)\n(('HarrowOnTheHill', 'North Harrow'), ('North Harrow', 'Pinner')) tensor(2347.)\n(('HarrowOnTheHill', 'Wembley Park'), ('Wembley Park', 'Kingsbury')) tensor(641.)\n(('HarrowOnTheHill', 'Wembley Park'), ('Wembley Park', 'Neasden')) tensor(385.)\n(('HarrowOnTheHill', 'Wembley Park'), ('Wembley Park', 'Preston Road')) tensor(209.)\n(('HarrowOnTheHill', 'West Harrow'), ('West Harrow', 'Rayners Lane')) tensor(12465.)\n(('HarrowOnTheHill', 'Marylebone'), ('Marylebone', 'Baker Street')) tensor(11144.)\n(('HarrowOnTheHill', 'Marylebone'), ('Marylebone', 'Edgware Road (Bak)')) tensor(2823.)\n(('HarrowOnTheHill', 'Rickmansworth'), ('Rickmansworth', 'Chorleywood')) tensor(2898.)\n(('HarrowOnTheHill', 'Moor Park'), ('Moor Park', 'Croxley')) tensor(1663.)\n(('HarrowOnTheHill', 'Moor Park'), ('Moor Park', 'Northwood')) tensor(2096.)\n(('HarrowOnTheHill', 'Northwick Park'), ('Northwick Park', 'Preston Road')) tensor(206.)\n(('West Harrow', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Finchley Road')) tensor(4629.)\n(('West Harrow', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'North Harrow')) tensor(21.)\n(('West Harrow', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Wembley Park')) tensor(882.)\n(('West Harrow', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Marylebone')) tensor(5338.)\n(('West Harrow', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Rickmansworth')) tensor(95.)\n(('West Harrow', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Moor Park')) tensor(185.)\n(('West Harrow', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Northwick Park')) tensor(382.)\n(('West Harrow', 'Rayners Lane'), ('Rayners Lane', 'Eastcote')) tensor(8469.)\n(('West Harrow', 'Rayners Lane'), ('Rayners Lane', 'South Harrow')) tensor(1783.)\n((\"St. James's Park\", 'Westminster'), ('Westminster', 'Waterloo')) tensor(21202.)\n((\"St. James's Park\", 'Westminster'), ('Westminster', 'Embankment')) tensor(6233.)\n((\"St. James's Park\", 'Westminster'), ('Westminster', 'Green Park')) tensor(1920.)\n((\"St. James's Park\", 'Victoria'), ('Victoria', 'Green Park')) tensor(1907.)\n((\"St. James's Park\", 'Victoria'), ('Victoria', 'Pimlico')) tensor(1164.)\n((\"St. James's Park\", 'Victoria'), ('Victoria', 'Sloane Square')) tensor(14258.)\n(('Gunnersbury', 'Turnham Green'), ('Turnham Green', 'Stamford Brook')) tensor(231.)\n(('Gunnersbury', 'Turnham Green'), ('Turnham Green', 'Hammersmith (Dis)')) tensor(5887.)\n(('Gunnersbury', 'Turnham Green'), ('Turnham Green', 'Acton Town')) tensor(6911.)\n(('Gunnersbury', 'Turnham Green'), ('Turnham Green', 'Chiswick Park')) tensor(2.)\n(('Gunnersbury', 'Kew Gardens'), ('Kew Gardens', 'Richmond')) tensor(7636.)\n(('Kew Gardens', 'Gunnersbury'), ('Gunnersbury', 'Turnham Green')) tensor(9636.)\n(('Tottenham Court Road', 'Bond Street'), ('Bond Street', 'Baker Street')) tensor(34389.)\n(('Tottenham Court Road', 'Bond Street'), ('Bond Street', 'Marble Arch')) tensor(21254.)\n(('Tottenham Court Road', 'Bond Street'), ('Bond Street', 'Green Park')) tensor(6875.)\n(('Tottenham Court Road', 'Oxford Circus'), ('Oxford Circus', 'Green Park')) tensor(6903.)\n(('Tottenham Court Road', 'Oxford Circus'), ('Oxford Circus', 'Piccadilly Circus')) tensor(1305.)\n(('Tottenham Court Road', 'Oxford Circus'), ('Oxford Circus', 'Warren Street')) tensor(3029.)\n(('Tottenham Court Road', 'Oxford Circus'), ('Oxford Circus', \"Regent's Park\")) tensor(144.)\n(('Tottenham Court Road', 'Leicester Square'), ('Leicester Square', 'Piccadilly Circus')) tensor(1254.)\n(('Tottenham Court Road', 'Leicester Square'), ('Leicester Square', 'Covent Garden')) tensor(1823.)\n(('Tottenham Court Road', 'Leicester Square'), ('Leicester Square', 'Charing Cross')) tensor(4239.)\n(('Tottenham Court Road', 'Holborn'), ('Holborn', 'Covent Garden')) tensor(1872.)\n(('Tottenham Court Road', 'Holborn'), ('Holborn', 'Russell Square')) tensor(8788.)\n(('Tottenham Court Road', 'Holborn'), ('Holborn', 'Chancery Lane')) tensor(72938.)\n(('Tottenham Court Road', 'Goodge Street'), ('Goodge Street', 'Warren Street')) tensor(3005.)\n(('Leicester Square', 'Piccadilly Circus'), ('Piccadilly Circus', 'Green Park')) tensor(7951.)\n(('Leicester Square', 'Piccadilly Circus'), ('Piccadilly Circus', 'Oxford Circus')) tensor(1596.)\n(('Leicester Square', 'Tottenham Court Road'), ('Tottenham Court Road', 'Bond Street')) tensor(5480.)\n(('Leicester Square', 'Tottenham Court Road'), ('Tottenham Court Road', 'Oxford Circus')) tensor(1673.)\n(('Leicester Square', 'Tottenham Court Road'), ('Tottenham Court Road', 'Holborn')) tensor(5343.)\n(('Leicester Square', 'Tottenham Court Road'), ('Tottenham Court Road', 'Goodge Street')) tensor(2577.)\n(('Leicester Square', 'Covent Garden'), ('Covent Garden', 'Holborn')) tensor(5339.)\n(('Leicester Square', 'Charing Cross'), ('Charing Cross', 'Embankment')) tensor(7422.)\n(('Goldhawk Road', \"Shepherd's Bush Market\"), (\"Shepherd's Bush Market\", 'Wood Lane')) tensor(6265.)\n(('Hammersmith (H&amp;C)', 'Goldhawk Road'), ('Goldhawk Road', \"Shepherd's Bush Market\")) tensor(5054.)\n(('Hounslow East', 'Osterley'), ('Osterley', 'Boston Manor')) tensor(17605.)\n(('Hounslow East', 'Hounslow Central'), ('Hounslow Central', 'Hounslow West')) tensor(11550.)\n(('Osterley', 'Hounslow East'), ('Hounslow East', 'Hounslow Central')) tensor(13131.)\n(('Osterley', 'Boston Manor'), ('Boston Manor', 'Northfields')) tensor(18883.)\n(('West Hampstead', 'Finchley Road'), ('Finchley Road', 'Willesden Green')) tensor(181.)\n(('West Hampstead', 'Finchley Road'), ('Finchley Road', 'Baker Street')) tensor(8227.)\n(('West Hampstead', 'Finchley Road'), ('Finchley Road', 'Wembley Park')) tensor(650.)\n(('West Hampstead', 'Finchley Road'), ('Finchley Road', 'HarrowOnTheHill')) tensor(388.)\n(('West Hampstead', 'Finchley Road'), ('Finchley Road', 'Swiss Cottage')) tensor(331.)\n(('West Hampstead', 'Kilburn'), ('Kilburn', 'Willesden Green')) tensor(180.)\n(('Royal Oak', 'Paddington'), ('Paddington', 'Edgware Road (Cir)')) tensor(11631.)\n(('Royal Oak', 'Paddington'), ('Paddington', 'Edgware Road (Bak)')) tensor(681.)\n(('Royal Oak', 'Paddington'), ('Paddington', 'Warwick Avenue')) tensor(119.)\n(('Royal Oak', 'Paddington'), ('Paddington', 'Bayswater')) tensor(434.)\n(('Royal Oak', 'Paddington'), ('Paddington', 'Ealing Broadway')) tensor(1277.)\n(('Royal Oak', 'Westbourne Park'), ('Westbourne Park', 'Ladbroke Grove')) tensor(10803.)\n(('Warren Street', 'Euston'), ('Euston', \"King's Cross St. Pancras\")) tensor(52969.)\n(('Warren Street', 'Euston'), ('Euston', 'Camden Town')) tensor(33502.)\n(('Warren Street', 'Euston'), ('Euston', 'Mornington Crescent')) tensor(1386.)\n(('Warren Street', 'Oxford Circus'), ('Oxford Circus', 'Bond Street')) tensor(5834.)\n(('Warren Street', 'Oxford Circus'), ('Oxford Circus', 'Green Park')) tensor(70077.)\n(('Warren Street', 'Oxford Circus'), ('Oxford Circus', 'Piccadilly Circus')) tensor(9160.)\n(('Warren Street', 'Oxford Circus'), ('Oxford Circus', 'Tottenham Court Road')) tensor(3084.)\n(('Warren Street', 'Oxford Circus'), ('Oxford Circus', \"Regent's Park\")) tensor(2239.)\n(('Warren Street', 'Goodge Street'), ('Goodge Street', 'Tottenham Court Road')) tensor(3078.)\n(('Barons Court', \"Earl's Court\"), (\"Earl's Court\", 'West Brompton')) tensor(2643.)\n(('Barons Court', \"Earl's Court\"), (\"Earl's Court\", 'Gloucester Road')) tensor(25122.)\n(('Barons Court', \"Earl's Court\"), (\"Earl's Court\", 'High Street Kensington')) tensor(989.)\n(('Barons Court', \"Earl's Court\"), (\"Earl's Court\", 'Kensington (Olympia)')) tensor(61.)\n(('Barons Court', 'Hammersmith (Dis)'), ('Hammersmith (Dis)', 'Turnham Green')) tensor(6491.)\n(('Barons Court', 'Hammersmith (Dis)'), ('Hammersmith (Dis)', 'Acton Town')) tensor(8431.)\n(('Barons Court', 'Hammersmith (Dis)'), ('Hammersmith (Dis)', 'Ravenscourt Park')) tensor(1802.)\n(('Barkingside', 'Newbury Park'), ('Newbury Park', 'Gants Hill')) tensor(2893.)\n(('Barkingside', 'Fairlop'), ('Fairlop', 'Hainault')) tensor(1205.)\n(('Newbury Park', 'Barkingside'), ('Barkingside', 'Fairlop')) tensor(1905.)\n(('Newbury Park', 'Gants Hill'), ('Gants Hill', 'Redbridge')) tensor(6420.)\n(('Hyde Park Corner', 'Green Park'), ('Green Park', 'Bond Street')) tensor(3687.)\n(('Hyde Park Corner', 'Green Park'), ('Green Park', 'Westminster')) tensor(15703.)\n(('Hyde Park Corner', 'Green Park'), ('Green Park', 'Piccadilly Circus')) tensor(6126.)\n(('Hyde Park Corner', 'Green Park'), ('Green Park', 'Oxford Circus')) tensor(11137.)\n(('Hyde Park Corner', 'Green Park'), ('Green Park', 'Victoria')) tensor(674.)\n(('Hyde Park Corner', 'Knightsbridge'), ('Knightsbridge', 'South Kensington')) tensor(23802.)\n(('Ruislip', 'Ickenham'), ('Ickenham', 'Hillingdon')) tensor(6732.)\n(('Ruislip', 'Ruislip Manor'), ('Ruislip Manor', 'Eastcote')) tensor(7806.)\n(('Ickenham', 'Hillingdon'), ('Hillingdon', 'Uxbridge')) tensor(5778.)\n(('Ickenham', 'Ruislip'), ('Ruislip', 'Ruislip Manor')) tensor(7220.)\n(('West Kensington', \"Earl's Court\"), (\"Earl's Court\", 'West Brompton')) tensor(73.)\n(('West Kensington', \"Earl's Court\"), (\"Earl's Court\", 'Gloucester Road')) tensor(2406.)\n(('West Kensington', \"Earl's Court\"), (\"Earl's Court\", 'High Street Kensington')) tensor(495.)\n(('West Kensington', 'Barons Court'), ('Barons Court', 'Hammersmith (Dis)')) tensor(1018.)\n(('Stepney Green', 'Whitechapel'), ('Whitechapel', 'Stratford')) tensor(557.)\n(('Stepney Green', 'Whitechapel'), ('Whitechapel', 'Aldgate East')) tensor(1679.)\n(('Stepney Green', 'Mile End'), ('Mile End', 'Bow Road')) tensor(260.)\n(('Stepney Green', 'Mile End'), ('Mile End', 'Stratford')) tensor(579.)\n(('Stepney Green', 'Mile End'), ('Mile End', 'Bethnal Green')) tensor(942.)\n(('London Bridge', 'Southwark'), ('Southwark', 'Waterloo')) tensor(144668.)\n(('London Bridge', 'Bank / Monument'), ('Bank / Monument', 'Liverpool Street')) tensor(46250.)\n(('London Bridge', 'Bank / Monument'), ('Bank / Monument', 'Tower Hill')) tensor(17293.)\n(('London Bridge', 'Bank / Monument'), ('Bank / Monument', 'Moorgate')) tensor(28818.)\n(('London Bridge', 'Bank / Monument'), ('Bank / Monument', \"St. Paul's\")) tensor(5678.)\n(('London Bridge', 'Bank / Monument'), ('Bank / Monument', 'Cannon Street')) tensor(1063.)\n(('London Bridge', 'Bermondsey'), ('Bermondsey', 'Canada Water')) tensor(65044.)\n(('London Bridge', 'Borough'), ('Borough', 'Elephant &amp; Castle')) tensor(18271.)\n(('Upminster Bridge', 'Upminster'), ('Upminster', 'Barking')) tensor(4293.)\n(('Upminster Bridge', 'Hornchurch'), ('Hornchurch', 'Elm Park')) tensor(2074.)\n(('Bayswater', 'Notting Hill Gate'), ('Notting Hill Gate', 'Holland Park')) tensor(2097.)\n(('Bayswater', 'Notting Hill Gate'), ('Notting Hill Gate', 'Queensway')) tensor(301.)\n(('Bayswater', 'Notting Hill Gate'), ('Notting Hill Gate', 'High Street Kensington')) tensor(12212.)\n(('Bayswater', 'Paddington'), ('Paddington', 'Edgware Road (Cir)')) tensor(8627.)\n(('Bayswater', 'Paddington'), ('Paddington', 'Edgware Road (Bak)')) tensor(985.)\n(('Bayswater', 'Paddington'), ('Paddington', 'Warwick Avenue')) tensor(1323.)\n(('Bayswater', 'Paddington'), ('Paddington', 'Royal Oak')) tensor(421.)\n(('Bayswater', 'Paddington'), ('Paddington', 'Ealing Broadway')) tensor(3300.)\n(('Marylebone', 'Baker Street'), ('Baker Street', 'Finchley Road')) tensor(36.)\n(('Marylebone', 'Baker Street'), ('Baker Street', 'Bond Street')) tensor(14289.)\n(('Marylebone', 'Baker Street'), ('Baker Street', 'Edgware Road (Cir)')) tensor(2.)\n(('Marylebone', 'Baker Street'), ('Baker Street', \"St. John's Wood\")) tensor(96.)\n(('Marylebone', 'Baker Street'), ('Baker Street', \"Regent's Park\")) tensor(1458.)\n(('Marylebone', 'Baker Street'), ('Baker Street', 'Great Portland Street')) tensor(6003.)\n(('Marylebone', 'Edgware Road (Bak)'), ('Edgware Road (Bak)', 'Paddington')) tensor(3499.)\n(('Marylebone', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Finchley Road')) tensor(36.)\n(('Marylebone', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'North Harrow')) tensor(1365.)\n(('Marylebone', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Wembley Park')) tensor(459.)\n(('Marylebone', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'West Harrow')) tensor(5505.)\n(('Marylebone', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Rickmansworth')) tensor(2065.)\n(('Marylebone', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Moor Park')) tensor(1582.)\n(('Marylebone', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Northwick Park')) tensor(1056.)\n(('Borough', 'London Bridge'), ('London Bridge', 'Southwark')) tensor(210.)\n(('Borough', 'London Bridge'), ('London Bridge', 'Bank / Monument')) tensor(17054.)\n(('Borough', 'London Bridge'), ('London Bridge', 'Bermondsey')) tensor(2177.)\n(('Borough', 'Elephant &amp; Castle'), ('Elephant &amp; Castle', 'Lambeth North')) tensor(422.)\n(('Borough', 'Elephant &amp; Castle'), ('Elephant &amp; Castle', 'Kennington')) tensor(13915.)\n(('Elephant &amp; Castle', 'Lambeth North'), ('Lambeth North', 'Waterloo')) tensor(3925.)\n(('Elephant &amp; Castle', 'Borough'), ('Borough', 'London Bridge')) tensor(18949.)\n(('Elephant &amp; Castle', 'Kennington'), ('Kennington', 'Waterloo')) tensor(3899.)\n(('Elephant &amp; Castle', 'Kennington'), ('Kennington', 'Oval')) tensor(15344.)\n(('Farringdon', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Angel')) tensor(37.)\n(('Farringdon', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Caledonian Road')) tensor(645.)\n(('Farringdon', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Euston')) tensor(12998.)\n(('Farringdon', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Highbury &amp; Islington')) tensor(1537.)\n(('Farringdon', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Russell Square')) tensor(656.)\n(('Farringdon', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Euston Square')) tensor(21906.)\n(('Farringdon', 'Barbican'), ('Barbican', 'Moorgate')) tensor(37479.)\n(('Ealing Broadway', 'Paddington'), ('Paddington', 'Edgware Road (Cir)')) tensor(48867.)\n(('Ealing Broadway', 'Paddington'), ('Paddington', 'Edgware Road (Bak)')) tensor(1177.)\n(('Ealing Broadway', 'Paddington'), ('Paddington', 'Warwick Avenue')) tensor(986.)\n(('Ealing Broadway', 'Paddington'), ('Paddington', 'Royal Oak')) tensor(1218.)\n(('Ealing Broadway', 'Paddington'), ('Paddington', 'Bayswater')) tensor(2832.)\n(('Ealing Broadway', 'Ealing Common'), ('Ealing Common', 'Acton Town')) tensor(31439.)\n(('Ealing Broadway', 'Ealing Common'), ('Ealing Common', 'North Ealing')) tensor(1089.)\n(('Ealing Broadway', 'West Acton'), ('West Acton', 'North Acton')) tensor(15020.)\n(('Walthamstow Central', 'Blackhorse Road'), ('Blackhorse Road', 'Tottenham Hale')) tensor(11848.)\n(('Blackhorse Road', 'Tottenham Hale'), ('Tottenham Hale', 'Liverpool Street')) tensor(7872.)\n(('Blackhorse Road', 'Tottenham Hale'), ('Tottenham Hale', 'Seven Sisters')) tensor(9301.)\n(('Covent Garden', 'Leicester Square'), ('Leicester Square', 'Piccadilly Circus')) tensor(4651.)\n(('Covent Garden', 'Leicester Square'), ('Leicester Square', 'Tottenham Court Road')) tensor(1303.)\n(('Covent Garden', 'Leicester Square'), ('Leicester Square', 'Charing Cross')) tensor(1181.)\n(('Covent Garden', 'Holborn'), ('Holborn', 'Tottenham Court Road')) tensor(1278.)\n(('Covent Garden', 'Holborn'), ('Holborn', 'Russell Square')) tensor(7523.)\n(('Covent Garden', 'Holborn'), ('Holborn', 'Chancery Lane')) tensor(3829.)\n(('Rayners Lane', 'West Harrow'), ('West Harrow', 'HarrowOnTheHill')) tensor(11971.)\n(('Rayners Lane', 'Eastcote'), ('Eastcote', 'Ruislip Manor')) tensor(8266.)\n(('Rayners Lane', 'South Harrow'), ('South Harrow', 'Sudbury Hill')) tensor(2664.)\n(('Eastcote', 'Rayners Lane'), ('Rayners Lane', 'West Harrow')) tensor(8457.)\n(('Eastcote', 'Rayners Lane'), ('Rayners Lane', 'South Harrow')) tensor(1163.)\n(('Eastcote', 'Ruislip Manor'), ('Ruislip Manor', 'Ruislip')) tensor(7665.)\n(('Hammersmith (Dis)', 'Turnham Green'), ('Turnham Green', 'Stamford Brook')) tensor(531.)\n(('Hammersmith (Dis)', 'Turnham Green'), ('Turnham Green', 'Gunnersbury')) tensor(5079.)\n(('Hammersmith (Dis)', 'Turnham Green'), ('Turnham Green', 'Chiswick Park')) tensor(164.)\n(('Hammersmith (Dis)', 'Barons Court'), ('Barons Court', \"Earl's Court\")) tensor(27373.)\n(('Hammersmith (Dis)', 'Barons Court'), ('Barons Court', 'West Kensington')) tensor(662.)\n(('Hammersmith (Dis)', 'Acton Town'), ('Acton Town', 'Ealing Common')) tensor(9852.)\n(('Hammersmith (Dis)', 'Acton Town'), ('Acton Town', 'South Ealing')) tensor(7117.)\n(('Hammersmith (Dis)', 'Acton Town'), ('Acton Town', 'Chiswick Park')) tensor(162.)\n(('Hammersmith (Dis)', 'Ravenscourt Park'), ('Ravenscourt Park', 'Stamford Brook')) tensor(556.)\n(('Ealing Common', 'Ealing Broadway'), ('Ealing Broadway', 'Paddington')) tensor(32313.)\n(('Ealing Common', 'Ealing Broadway'), ('Ealing Broadway', 'West Acton')) tensor(332.)\n(('Ealing Common', 'Acton Town'), ('Acton Town', 'Turnham Green')) tensor(9414.)\n(('Ealing Common', 'Acton Town'), ('Acton Town', 'Hammersmith (Dis)')) tensor(9156.)\n(('Ealing Common', 'Acton Town'), ('Acton Town', 'South Ealing')) tensor(14711.)\n(('Ealing Common', 'Acton Town'), ('Acton Town', 'Chiswick Park')) tensor(1327.)\n(('Ealing Common', 'North Ealing'), ('North Ealing', 'Park Royal')) tensor(5061.)\n(('Acton Town', 'Turnham Green'), ('Turnham Green', 'Stamford Brook')) tensor(955.)\n(('Acton Town', 'Turnham Green'), ('Turnham Green', 'Gunnersbury')) tensor(6350.)\n(('Acton Town', 'Hammersmith (Dis)'), ('Hammersmith (Dis)', 'Barons Court')) tensor(9595.)\n(('Acton Town', 'Hammersmith (Dis)'), ('Hammersmith (Dis)', 'Ravenscourt Park')) tensor(665.)\n(('Acton Town', 'Ealing Common'), ('Ealing Common', 'Ealing Broadway')) tensor(33044.)\n(('Acton Town', 'Ealing Common'), ('Ealing Common', 'North Ealing')) tensor(3985.)\n(('Acton Town', 'South Ealing'), ('South Ealing', 'Northfields')) tensor(20477.)\n(('Highbury &amp; Islington', 'Finsbury Park'), ('Finsbury Park', 'Manor House')) tensor(25468.)\n(('Highbury &amp; Islington', 'Finsbury Park'), ('Finsbury Park', 'Seven Sisters')) tensor(19077.)\n(('Highbury &amp; Islington', 'Finsbury Park'), ('Finsbury Park', 'Arsenal')) tensor(772.)\n(('Highbury &amp; Islington', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Angel')) tensor(1503.)\n(('Highbury &amp; Islington', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Caledonian Road')) tensor(275.)\n(('Highbury &amp; Islington', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Euston')) tensor(37568.)\n(('Highbury &amp; Islington', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Farringdon')) tensor(1279.)\n(('Highbury &amp; Islington', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Russell Square')) tensor(9923.)\n(('Highbury &amp; Islington', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Euston Square')) tensor(14597.)\n(('South Ealing', 'Acton Town'), ('Acton Town', 'Turnham Green')) tensor(269.)\n(('South Ealing', 'Acton Town'), ('Acton Town', 'Hammersmith (Dis)')) tensor(8618.)\n(('South Ealing', 'Acton Town'), ('Acton Town', 'Ealing Common')) tensor(15010.)\n(('South Ealing', 'Acton Town'), ('Acton Town', 'Chiswick Park')) tensor(118.)\n(('South Ealing', 'Northfields'), ('Northfields', 'Boston Manor')) tensor(18069.)\n(('Theydon Bois', 'Debden'), ('Debden', 'Loughton')) tensor(3191.)\n(('Epping', 'Theydon Bois'), ('Theydon Bois', 'Debden')) tensor(2685.)\n(('Kensal Green', 'Willesden Junction'), ('Willesden Junction', 'Harlesden')) tensor(6742.)\n(('Kensal Green', \"Queen's Park\"), (\"Queen's Park\", 'Kilburn Park')) tensor(12855.)\n(('Willesden Junction', 'Kensal Green'), ('Kensal Green', \"Queen's Park\")) tensor(11488.)\n(('Willesden Junction', 'Harlesden'), ('Harlesden', 'Stonebridge Park')) tensor(7496.)\n(('Tottenham Hale', 'Liverpool Street'), ('Liverpool Street', 'Bank / Monument')) tensor(17830.)\n(('Tottenham Hale', 'Liverpool Street'), ('Liverpool Street', 'Moorgate')) tensor(1361.)\n(('Tottenham Hale', 'Liverpool Street'), ('Liverpool Street', 'Aldgate East')) tensor(2196.)\n(('Tottenham Hale', 'Liverpool Street'), ('Liverpool Street', 'Aldgate')) tensor(463.)\n(('Tottenham Hale', 'Liverpool Street'), ('Liverpool Street', 'Bethnal Green')) tensor(1702.)\n(('Tottenham Hale', 'Seven Sisters'), ('Seven Sisters', 'Finsbury Park')) tensor(23467.)\n(('Tottenham Hale', 'Blackhorse Road'), ('Blackhorse Road', 'Walthamstow Central')) tensor(11746.)\n(('Chigwell', 'Grange Hill'), ('Grange Hill', 'Hainault')) tensor(1292.)\n(('Chigwell', 'Roding Valley'), ('Roding Valley', 'Woodford')) tensor(2066.)\n(('Grange Hill', 'Chigwell'), ('Chigwell', 'Roding Valley')) tensor(1661.)\n(('Grange Hill', 'Hainault'), ('Hainault', 'Fairlop')) tensor(78.)\n(('Canary Wharf', 'Canada Water'), ('Canada Water', 'Bermondsey')) tensor(53072.)\n(('Canary Wharf', 'North Greenwich'), ('North Greenwich', 'Canning Town')) tensor(23124.)\n(('South Wimbledon', 'Colliers Wood'), ('Colliers Wood', 'Tooting Broadway')) tensor(8601.)\n(('Morden', 'South Wimbledon'), ('South Wimbledon', 'Colliers Wood')) tensor(5894.)\n(('Totteridge &amp; Whetstone', 'Woodside Park'), ('Woodside Park', 'West Finchley')) tensor(4020.)\n(('Woodside Park', 'Totteridge &amp; Whetstone'), ('Totteridge &amp; Whetstone', 'High Barnet')) tensor(2374.)\n(('Woodside Park', 'West Finchley'), ('West Finchley', 'Finchley Central')) tensor(6136.)\n(('Holborn', 'Tottenham Court Road'), ('Tottenham Court Road', 'Bond Street')) tensor(57268.)\n(('Holborn', 'Tottenham Court Road'), ('Tottenham Court Road', 'Oxford Circus')) tensor(17826.)\n(('Holborn', 'Tottenham Court Road'), ('Tottenham Court Road', 'Leicester Square')) tensor(5333.)\n(('Holborn', 'Tottenham Court Road'), ('Tottenham Court Road', 'Goodge Street')) tensor(1305.)\n(('Holborn', 'Covent Garden'), ('Covent Garden', 'Leicester Square')) tensor(5289.)\n(('Holborn', 'Russell Square'), ('Russell Square', \"King's Cross St. Pancras\")) tensor(17632.)\n(('Holborn', 'Chancery Lane'), ('Chancery Lane', \"St. Paul's\")) tensor(78656.)\n(('Neasden', 'Willesden Green'), ('Willesden Green', 'Finchley Road')) tensor(949.)\n(('Neasden', 'Willesden Green'), ('Willesden Green', 'Kilburn')) tensor(329.)\n(('Neasden', 'Wembley Park'), ('Wembley Park', 'Finchley Road')) tensor(999.)\n(('Neasden', 'Wembley Park'), ('Wembley Park', 'Kingsbury')) tensor(444.)\n(('Neasden', 'Wembley Park'), ('Wembley Park', 'HarrowOnTheHill')) tensor(420.)\n(('Neasden', 'Wembley Park'), ('Wembley Park', 'Preston Road')) tensor(130.)\n(('Gants Hill', 'Newbury Park'), ('Newbury Park', 'Barkingside')) tensor(2744.)\n(('Gants Hill', 'Redbridge'), ('Redbridge', 'Wanstead')) tensor(10941.)\n(('Elm Park', 'Hornchurch'), ('Hornchurch', 'Upminster Bridge')) tensor(2179.)\n(('Elm Park', 'Dagenham East'), ('Dagenham East', 'Dagenham Heathway')) tensor(230.)\n(('Hornchurch', 'Upminster Bridge'), ('Upminster Bridge', 'Upminster')) tensor(3574.)\n(('Hornchurch', 'Elm Park'), ('Elm Park', 'Dagenham East')) tensor(177.)\n(('South Harrow', 'Rayners Lane'), ('Rayners Lane', 'West Harrow')) tensor(1443.)\n(('South Harrow', 'Rayners Lane'), ('Rayners Lane', 'Eastcote')) tensor(1117.)\n(('South Harrow', 'Sudbury Hill'), ('Sudbury Hill', 'Sudbury Town')) tensor(2872.)\n(('Sudbury Hill', 'South Harrow'), ('South Harrow', 'Rayners Lane')) tensor(2380.)\n(('Sudbury Hill', 'Sudbury Town'), ('Sudbury Town', 'Alperton')) tensor(3043.)\n(('Richmond', 'Kew Gardens'), ('Kew Gardens', 'Gunnersbury')) tensor(8358.)\n(('Harlesden', 'Stonebridge Park'), ('Stonebridge Park', 'Wembley Central')) tensor(6323.)\n(('Harlesden', 'Willesden Junction'), ('Willesden Junction', 'Kensal Green')) tensor(9052.)\n(('Burnt Oak', 'Colindale'), ('Colindale', 'Hendon Central')) tensor(5882.)\n(('Colindale', 'Burnt Oak'), ('Burnt Oak', 'Edgware')) tensor(3202.)\n(('Colindale', 'Hendon Central'), ('Hendon Central', 'Brent Cross')) tensor(8723.)\n(('Upney', 'Barking'), ('Barking', 'West Ham')) tensor(6292.)\n(('Upney', 'Barking'), ('Barking', 'Upminster')) tensor(203.)\n(('Upney', 'Barking'), ('Barking', 'East Ham')) tensor(604.)\n(('Upney', 'Becontree'), ('Becontree', 'Dagenham Heathway')) tensor(5402.)\n((\"St. John's Wood\", 'Baker Street'), ('Baker Street', 'Finchley Road')) tensor(529.)\n((\"St. John's Wood\", 'Baker Street'), ('Baker Street', 'Bond Street')) tensor(4593.)\n((\"St. John's Wood\", 'Baker Street'), ('Baker Street', 'Edgware Road (Cir)')) tensor(565.)\n((\"St. John's Wood\", 'Baker Street'), ('Baker Street', 'Marylebone')) tensor(120.)\n((\"St. John's Wood\", 'Baker Street'), ('Baker Street', \"Regent's Park\")) tensor(197.)\n((\"St. John's Wood\", 'Baker Street'), ('Baker Street', 'Great Portland Street')) tensor(1077.)\n((\"St. John's Wood\", 'Swiss Cottage'), ('Swiss Cottage', 'Finchley Road')) tensor(526.)\n(('Barbican', 'Moorgate'), ('Moorgate', 'Liverpool Street')) tensor(22858.)\n(('Barbican', 'Moorgate'), ('Moorgate', 'Bank / Monument')) tensor(12265.)\n(('Barbican', 'Moorgate'), ('Moorgate', 'Old Street')) tensor(8.)\n(('Barbican', 'Farringdon'), ('Farringdon', \"King's Cross St. Pancras\")) tensor(34204.)\n(('Gloucester Road', \"Earl's Court\"), (\"Earl's Court\", 'West Brompton')) tensor(17792.)\n(('Gloucester Road', \"Earl's Court\"), (\"Earl's Court\", 'Barons Court')) tensor(21295.)\n(('Gloucester Road', \"Earl's Court\"), (\"Earl's Court\", 'West Kensington')) tensor(2220.)\n(('Gloucester Road', \"Earl's Court\"), (\"Earl's Court\", 'Kensington (Olympia)')) tensor(466.)\n(('Gloucester Road', 'South Kensington'), ('South Kensington', 'Sloane Square')) tensor(44534.)\n(('Gloucester Road', 'South Kensington'), ('South Kensington', 'Knightsbridge')) tensor(21960.)\n(('Gloucester Road', 'High Street Kensington'), ('High Street Kensington', 'Notting Hill Gate')) tensor(5738.)\n(('South Kensington', 'Gloucester Road'), ('Gloucester Road', \"Earl's Court\")) tensor(48874.)\n(('South Kensington', 'Gloucester Road'), ('Gloucester Road', 'High Street Kensington')) tensor(9829.)\n(('South Kensington', 'Sloane Square'), ('Sloane Square', 'Victoria')) tensor(53088.)\n(('South Kensington', 'Knightsbridge'), ('Knightsbridge', 'Hyde Park Corner')) tensor(25121.)\n(('Leyton', 'Stratford'), ('Stratford', 'West Ham')) tensor(4496.)\n(('Leyton', 'Stratford'), ('Stratford', 'Whitechapel')) tensor(22554.)\n(('Leyton', 'Stratford'), ('Stratford', 'Mile End')) tensor(14434.)\n(('Leyton', 'Leytonstone'), ('Leytonstone', 'Snaresbrook')) tensor(17315.)\n(('Leyton', 'Leytonstone'), ('Leytonstone', 'Wanstead')) tensor(12859.)\n(('Balham', 'Tooting Bec'), ('Tooting Bec', 'Tooting Broadway')) tensor(20928.)\n(('Balham', 'Clapham South'), ('Clapham South', 'Clapham Common')) tensor(32494.)\n(('Tooting Bec', 'Balham'), ('Balham', 'Clapham South')) tensor(24872.)\n(('Tooting Bec', 'Tooting Broadway'), ('Tooting Broadway', 'Colliers Wood')) tensor(11632.)\n(('Mile End', 'Bow Road'), ('Bow Road', 'BromleyByBow')) tensor(1148.)\n(('Mile End', 'Stratford'), ('Stratford', 'West Ham')) tensor(12863.)\n(('Mile End', 'Stratford'), ('Stratford', 'Whitechapel')) tensor(432.)\n(('Mile End', 'Stratford'), ('Stratford', 'Leyton')) tensor(13437.)\n(('Mile End', 'Stepney Green'), ('Stepney Green', 'Whitechapel')) tensor(443.)\n(('Mile End', 'Bethnal Green'), ('Bethnal Green', 'Liverpool Street')) tensor(44854.)\n(('Russell Square', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Angel')) tensor(1576.)\n(('Russell Square', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Caledonian Road')) tensor(1810.)\n(('Russell Square', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Euston')) tensor(2708.)\n(('Russell Square', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Farringdon')) tensor(738.)\n(('Russell Square', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Highbury &amp; Islington')) tensor(9558.)\n(('Russell Square', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Euston Square')) tensor(731.)\n(('Russell Square', 'Holborn'), ('Holborn', 'Tottenham Court Road')) tensor(8773.)\n(('Russell Square', 'Holborn'), ('Holborn', 'Covent Garden')) tensor(7693.)\n(('Russell Square', 'Holborn'), ('Holborn', 'Chancery Lane')) tensor(2803.)\n(('Euston Square', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Angel')) tensor(15403.)\n(('Euston Square', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Caledonian Road')) tensor(1683.)\n(('Euston Square', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Euston')) tensor(1400.)\n(('Euston Square', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Farringdon')) tensor(22576.)\n(('Euston Square', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Highbury &amp; Islington')) tensor(13820.)\n(('Euston Square', \"King's Cross St. Pancras\"), (\"King's Cross St. Pancras\", 'Russell Square')) tensor(887.)\n(('Euston Square', 'Great Portland Street'), ('Great Portland Street', 'Baker Street')) tensor(65222.)\n(('Tooting Broadway', 'Tooting Bec'), ('Tooting Bec', 'Balham')) tensor(21217.)\n(('Tooting Broadway', 'Colliers Wood'), ('Colliers Wood', 'South Wimbledon')) tensor(8291.)\n(('Colliers Wood', 'South Wimbledon'), ('South Wimbledon', 'Morden')) tensor(5689.)\n(('Colliers Wood', 'Tooting Broadway'), ('Tooting Broadway', 'Tooting Bec')) tensor(12128.)\n(('Charing Cross', 'Embankment'), ('Embankment', 'Waterloo')) tensor(12440.)\n(('Charing Cross', 'Embankment'), ('Embankment', 'Temple')) tensor(515.)\n(('Charing Cross', 'Embankment'), ('Embankment', 'Westminster')) tensor(52.)\n(('Charing Cross', 'Piccadilly Circus'), ('Piccadilly Circus', 'Green Park')) tensor(1749.)\n(('Charing Cross', 'Piccadilly Circus'), ('Piccadilly Circus', 'Oxford Circus')) tensor(8258.)\n(('Charing Cross', 'Leicester Square'), ('Leicester Square', 'Tottenham Court Road')) tensor(4446.)\n(('Charing Cross', 'Leicester Square'), ('Leicester Square', 'Covent Garden')) tensor(1017.)\n(('Wood Green', 'Turnpike Lane'), ('Turnpike Lane', 'Manor House')) tensor(21846.)\n(('Wood Green', 'Bounds Green'), ('Bounds Green', 'Arnos Grove')) tensor(9934.)\n(('Bounds Green', 'Wood Green'), ('Wood Green', 'Turnpike Lane')) tensor(14051.)\n(('Bounds Green', 'Arnos Grove'), ('Arnos Grove', 'Southgate')) tensor(6874.)\n(('Northolt', 'South Ruislip'), ('South Ruislip', 'Ruislip Gardens')) tensor(728.)\n(('Northolt', 'South Ruislip'), ('South Ruislip', 'West Ruislip')) tensor(1062.)\n(('Northolt', 'Greenford'), ('Greenford', 'Perivale')) tensor(6546.)\n(('East Ham', 'Barking'), ('Barking', 'West Ham')) tensor(8843.)\n(('East Ham', 'Barking'), ('Barking', 'Upminster')) tensor(393.)\n(('East Ham', 'Barking'), ('Barking', 'Upney')) tensor(644.)\n(('East Ham', 'Upton Park'), ('Upton Park', 'Plaistow')) tensor(991.)\n(('Westbourne Park', 'Ladbroke Grove'), ('Ladbroke Grove', 'Latimer Road')) tensor(8388.)\n(('Westbourne Park', 'Royal Oak'), ('Royal Oak', 'Paddington')) tensor(14499.)\n(('West Ruislip', 'South Ruislip'), ('South Ruislip', 'Northolt')) tensor(1198.)\n((\"St. Paul's\", 'Bank / Monument'), ('Bank / Monument', 'Liverpool Street')) tensor(47806.)\n((\"St. Paul's\", 'Bank / Monument'), ('Bank / Monument', 'Tower Hill')) tensor(14617.)\n((\"St. Paul's\", 'Bank / Monument'), ('Bank / Monument', 'Moorgate')) tensor(180.)\n((\"St. Paul's\", 'Bank / Monument'), ('Bank / Monument', 'London Bridge')) tensor(5159.)\n((\"St. Paul's\", 'Bank / Monument'), ('Bank / Monument', 'Cannon Street')) tensor(499.)\n((\"St. Paul's\", 'Chancery Lane'), ('Chancery Lane', 'Holborn')) tensor(79673.)\n(('Chancery Lane', 'Holborn'), ('Holborn', 'Tottenham Court Road')) tensor(70953.)\n(('Chancery Lane', 'Holborn'), ('Holborn', 'Covent Garden')) tensor(3964.)\n(('Chancery Lane', 'Holborn'), ('Holborn', 'Russell Square')) tensor(2686.)\n(('Chancery Lane', \"St. Paul's\"), (\"St. Paul's\", 'Bank / Monument')) tensor(77578.)\n(('Clapham South', 'Clapham Common'), ('Clapham Common', 'Clapham North')) tensor(37068.)\n(('Clapham South', 'Balham'), ('Balham', 'Tooting Bec')) tensor(23865.)\n(('Arsenal', 'Finsbury Park'), ('Finsbury Park', 'Manor House')) tensor(896.)\n(('Arsenal', 'Finsbury Park'), ('Finsbury Park', 'Seven Sisters')) tensor(1448.)\n(('Arsenal', 'Finsbury Park'), ('Finsbury Park', 'Highbury &amp; Islington')) tensor(872.)\n(('Arsenal', 'Holloway Road'), ('Holloway Road', 'Caledonian Road')) tensor(1137.)\n(('Wood Lane', 'Latimer Road'), ('Latimer Road', 'Ladbroke Grove')) tensor(9627.)\n(('Wood Lane', \"Shepherd's Bush Market\"), (\"Shepherd's Bush Market\", 'Goldhawk Road')) tensor(4992.)\n(('Redbridge', 'Gants Hill'), ('Gants Hill', 'Newbury Park')) tensor(5306.)\n(('Redbridge', 'Wanstead'), ('Wanstead', 'Leytonstone')) tensor(12846.)\n((\"Queen's Park\", 'Kensal Green'), ('Kensal Green', 'Willesden Junction')) tensor(8849.)\n((\"Queen's Park\", 'Kilburn Park'), ('Kilburn Park', 'Maida Vale')) tensor(16575.)\n(('Sudbury Town', 'Sudbury Hill'), ('Sudbury Hill', 'South Harrow')) tensor(2535.)\n(('Sudbury Town', 'Alperton'), ('Alperton', 'Park Royal')) tensor(3640.)\n(('West Acton', 'North Acton'), ('North Acton', 'Hanger Lane')) tensor(9172.)\n(('West Acton', 'North Acton'), ('North Acton', 'East Acton')) tensor(2992.)\n(('West Acton', 'Ealing Broadway'), ('Ealing Broadway', 'Paddington')) tensor(14063.)\n(('West Acton', 'Ealing Broadway'), ('Ealing Broadway', 'Ealing Common')) tensor(333.)\n(('Victoria', 'Green Park'), ('Green Park', 'Bond Street')) tensor(21890.)\n(('Victoria', 'Green Park'), ('Green Park', 'Westminster')) tensor(22934.)\n(('Victoria', 'Green Park'), ('Green Park', 'Piccadilly Circus')) tensor(8586.)\n(('Victoria', 'Green Park'), ('Green Park', 'Oxford Circus')) tensor(56772.)\n(('Victoria', 'Green Park'), ('Green Park', 'Hyde Park Corner')) tensor(727.)\n(('Victoria', 'Pimlico'), ('Pimlico', 'Vauxhall')) tensor(47370.)\n(('Victoria', \"St. James's Park\"), (\"St. James's Park\", 'Westminster')) tensor(22721.)\n(('Victoria', 'Sloane Square'), ('Sloane Square', 'South Kensington')) tensor(51117.)\n(('Aldgate', 'Liverpool Street'), ('Liverpool Street', 'Bank / Monument')) tensor(658.)\n(('Aldgate', 'Liverpool Street'), ('Liverpool Street', 'Moorgate')) tensor(3877.)\n(('Aldgate', 'Liverpool Street'), ('Liverpool Street', 'Aldgate East')) tensor(35.)\n(('Aldgate', 'Liverpool Street'), ('Liverpool Street', 'Tottenham Hale')) tensor(297.)\n(('Aldgate', 'Liverpool Street'), ('Liverpool Street', 'Bethnal Green')) tensor(50.)\n(('Aldgate', 'Tower Hill'), ('Tower Hill', 'Bank / Monument')) tensor(664.)\n(('Aldgate', 'Tower Hill'), ('Tower Hill', 'Aldgate East')) tensor(35.)\n(('Sloane Square', 'South Kensington'), ('South Kensington', 'Gloucester Road')) tensor(41513.)\n(('Sloane Square', 'South Kensington'), ('South Kensington', 'Knightsbridge')) tensor(594.)\n(('Sloane Square', 'Victoria'), ('Victoria', 'Green Park')) tensor(29799.)\n(('Sloane Square', 'Victoria'), ('Victoria', 'Pimlico')) tensor(6279.)\n(('Sloane Square', 'Victoria'), ('Victoria', \"St. James's Park\")) tensor(15604.)\n(('Upton Park', 'East Ham'), ('East Ham', 'Barking')) tensor(936.)\n(('Upton Park', 'Plaistow'), ('Plaistow', 'West Ham')) tensor(7073.)\n(('Hainault', 'Grange Hill'), ('Grange Hill', 'Chigwell')) tensor(1235.)\n(('Hainault', 'Fairlop'), ('Fairlop', 'Barkingside')) tensor(1259.)\n(('Fairlop', 'Barkingside'), ('Barkingside', 'Newbury Park')) tensor(1990.)\n(('Fairlop', 'Hainault'), ('Hainault', 'Grange Hill')) tensor(50.)\n(('Queensway', 'Notting Hill Gate'), ('Notting Hill Gate', 'Holland Park')) tensor(15003.)\n(('Queensway', 'Notting Hill Gate'), ('Notting Hill Gate', 'Bayswater')) tensor(302.)\n(('Queensway', 'Notting Hill Gate'), ('Notting Hill Gate', 'High Street Kensington')) tensor(1993.)\n(('Queensway', 'Lancaster Gate'), ('Lancaster Gate', 'Marble Arch')) tensor(29199.)\n(('Rickmansworth', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Finchley Road')) tensor(2158.)\n(('Rickmansworth', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'North Harrow')) tensor(45.)\n(('Rickmansworth', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Wembley Park')) tensor(201.)\n(('Rickmansworth', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'West Harrow')) tensor(91.)\n(('Rickmansworth', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Marylebone')) tensor(2265.)\n(('Rickmansworth', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Northwick Park')) tensor(32.)\n(('Rickmansworth', 'Chorleywood'), ('Chorleywood', 'Chalfont &amp; Latimer')) tensor(2490.)\n(('Rickmansworth', 'Moor Park'), ('Moor Park', 'Croxley')) tensor(127.)\n(('Rickmansworth', 'Moor Park'), ('Moor Park', 'Northwood')) tensor(63.)\n(('Chorleywood', 'Chalfont &amp; Latimer'), ('Chalfont &amp; Latimer', 'Chesham')) tensor(474.)\n(('Chorleywood', 'Chalfont &amp; Latimer'), ('Chalfont &amp; Latimer', 'Amersham')) tensor(1251.)\n(('Chorleywood', 'Rickmansworth'), ('Rickmansworth', 'HarrowOnTheHill')) tensor(3148.)\n(('Chorleywood', 'Rickmansworth'), ('Rickmansworth', 'Moor Park')) tensor(148.)\n(('Moor Park', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Finchley Road')) tensor(1624.)\n(('Moor Park', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'North Harrow')) tensor(186.)\n(('Moor Park', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Wembley Park')) tensor(292.)\n(('Moor Park', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'West Harrow')) tensor(185.)\n(('Moor Park', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Marylebone')) tensor(1540.)\n(('Moor Park', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Northwick Park')) tensor(201.)\n(('Moor Park', 'Rickmansworth'), ('Rickmansworth', 'Chorleywood')) tensor(197.)\n(('Moor Park', 'Croxley'), ('Croxley', 'Watford')) tensor(1218.)\n(('Moor Park', 'Northwood'), ('Northwood', 'Northwood Hills')) tensor(755.)\n(('Alperton', 'Sudbury Town'), ('Sudbury Town', 'Sudbury Hill')) tensor(2570.)\n(('Alperton', 'Park Royal'), ('Park Royal', 'North Ealing')) tensor(4955.)\n(('Park Royal', 'Alperton'), ('Alperton', 'Sudbury Town')) tensor(2808.)\n(('Park Royal', 'North Ealing'), ('North Ealing', 'Ealing Common')) tensor(5652.)\n(('Heathrow Terminals 123', 'Hatton Cross'), ('Hatton Cross', 'Hounslow West')) tensor(8055.)\n(('Heathrow Terminal 5', 'Heathrow Terminals 123'), ('Heathrow Terminals 123', 'Hatton Cross')) tensor(2729.)\n(('East Putney', 'Putney Bridge'), ('Putney Bridge', 'Parsons Green')) tensor(15318.)\n(('East Putney', 'Southfields'), ('Southfields', 'Wimbledon Park')) tensor(8399.)\n(('Putney Bridge', 'East Putney'), ('East Putney', 'Southfields')) tensor(11045.)\n(('Putney Bridge', 'Parsons Green'), ('Parsons Green', 'Fulham Broadway')) tensor(17898.)\n(('Edgware', 'Burnt Oak'), ('Burnt Oak', 'Colindale')) tensor(3300.)\n(('Bethnal Green', 'Liverpool Street'), ('Liverpool Street', 'Bank / Monument')) tensor(33559.)\n(('Bethnal Green', 'Liverpool Street'), ('Liverpool Street', 'Moorgate')) tensor(11915.)\n(('Bethnal Green', 'Liverpool Street'), ('Liverpool Street', 'Aldgate East')) tensor(164.)\n(('Bethnal Green', 'Liverpool Street'), ('Liverpool Street', 'Tottenham Hale')) tensor(2631.)\n(('Bethnal Green', 'Liverpool Street'), ('Liverpool Street', 'Aldgate')) tensor(64.)\n(('Bethnal Green', 'Mile End'), ('Mile End', 'Bow Road')) tensor(3733.)\n(('Bethnal Green', 'Mile End'), ('Mile End', 'Stratford')) tensor(33508.)\n(('Bethnal Green', 'Mile End'), ('Mile End', 'Stepney Green')) tensor(838.)\n(('Hatton Cross', 'Heathrow Terminals 123'), ('Heathrow Terminals 123', 'Heathrow Terminal 5')) tensor(2203.)\n(('Hatton Cross', 'Hounslow West'), ('Hounslow West', 'Hounslow Central')) tensor(11380.)\n(('Hounslow West', 'Hatton Cross'), ('Hatton Cross', 'Heathrow Terminals 123')) tensor(6952.)\n(('Hounslow West', 'Hatton Cross'), ('Hatton Cross', 'Heathrow Terminal 4')) tensor(1390.)\n(('Hounslow West', 'Hounslow Central'), ('Hounslow Central', 'Hounslow East')) tensor(13000.)\n(('Brixton', 'Stockwell'), ('Stockwell', 'Vauxhall')) tensor(14004.)\n(('Brixton', 'Stockwell'), ('Stockwell', 'Clapham North')) tensor(534.)\n(('Brixton', 'Stockwell'), ('Stockwell', 'Oval')) tensor(4931.)\n(('Harrow &amp; Wealdstone', 'Kenton'), ('Kenton', 'South Kenton')) tensor(2842.)\n(('Kenton', 'South Kenton'), ('South Kenton', 'North Wembley')) tensor(4199.)\n(('Hendon Central', 'Colindale'), ('Colindale', 'Burnt Oak')) tensor(5780.)\n(('Hendon Central', 'Brent Cross'), ('Brent Cross', 'Golders Green')) tensor(13615.)\n(('Brent Cross', 'Hendon Central'), ('Hendon Central', 'Colindale')) tensor(7986.)\n(('Brent Cross', 'Golders Green'), ('Golders Green', 'Hampstead')) tensor(14209.)\n(('High Street Kensington', 'Notting Hill Gate'), ('Notting Hill Gate', 'Holland Park')) tensor(2225.)\n(('High Street Kensington', 'Notting Hill Gate'), ('Notting Hill Gate', 'Bayswater')) tensor(11861.)\n(('High Street Kensington', 'Notting Hill Gate'), ('Notting Hill Gate', 'Queensway')) tensor(1895.)\n(('High Street Kensington', \"Earl's Court\"), (\"Earl's Court\", 'West Brompton')) tensor(6501.)\n(('High Street Kensington', \"Earl's Court\"), (\"Earl's Court\", 'Barons Court')) tensor(997.)\n(('High Street Kensington', \"Earl's Court\"), (\"Earl's Court\", 'West Kensington')) tensor(349.)\n(('High Street Kensington', \"Earl's Court\"), (\"Earl's Court\", 'Kensington (Olympia)')) tensor(137.)\n(('High Street Kensington', 'Gloucester Road'), ('Gloucester Road', 'South Kensington')) tensor(9717.)\n(('Northfields', 'South Ealing'), ('South Ealing', 'Acton Town')) tensor(22272.)\n(('Northfields', 'Boston Manor'), ('Boston Manor', 'Osterley')) tensor(17118.)\n(('Wanstead', 'Redbridge'), ('Redbridge', 'Gants Hill')) tensor(9593.)\n(('Wanstead', 'Leytonstone'), ('Leytonstone', 'Snaresbrook')) tensor(196.)\n(('Wanstead', 'Leytonstone'), ('Leytonstone', 'Leyton')) tensor(13971.)\n(('Knightsbridge', 'Hyde Park Corner'), ('Hyde Park Corner', 'Green Park')) tensor(36327.)\n(('Knightsbridge', 'South Kensington'), ('South Kensington', 'Gloucester Road')) tensor(19345.)\n(('Knightsbridge', 'South Kensington'), ('South Kensington', 'Sloane Square')) tensor(600.)\n(('Wimbledon Park', 'Southfields'), ('Southfields', 'East Putney')) tensor(9455.)\n(('Wimbledon', 'Wimbledon Park'), ('Wimbledon Park', 'Southfields')) tensor(9206.)\n(('Amersham', 'Chalfont &amp; Latimer'), ('Chalfont &amp; Latimer', 'Chesham')) tensor(2.)\n(('Amersham', 'Chalfont &amp; Latimer'), ('Chalfont &amp; Latimer', 'Chorleywood')) tensor(1353.)\n(('Dagenham East', 'Elm Park'), ('Elm Park', 'Hornchurch')) tensor(215.)\n(('Dagenham East', 'Dagenham Heathway'), ('Dagenham Heathway', 'Becontree')) tensor(1861.)\n(('Cannon Street', 'Bank / Monument'), ('Bank / Monument', 'Liverpool Street')) tensor(2214.)\n(('Cannon Street', 'Bank / Monument'), ('Bank / Monument', 'Tower Hill')) tensor(2570.)\n(('Cannon Street', 'Bank / Monument'), ('Bank / Monument', 'Moorgate')) tensor(365.)\n(('Cannon Street', 'Bank / Monument'), ('Bank / Monument', 'London Bridge')) tensor(1122.)\n(('Cannon Street', 'Bank / Monument'), ('Bank / Monument', \"St. Paul's\")) tensor(560.)\n(('Cannon Street', 'Mansion House'), ('Mansion House', 'Blackfriars')) tensor(6204.)\n(('Stanmore', 'Canons Park'), ('Canons Park', 'Queensbury')) tensor(2569.)\n(('Blackfriars', 'Temple'), ('Temple', 'Embankment')) tensor(10189.)\n(('Blackfriars', 'Mansion House'), ('Mansion House', 'Cannon Street')) tensor(4996.)\n(('Plaistow', 'West Ham'), ('West Ham', 'Barking')) tensor(471.)\n(('Plaistow', 'West Ham'), ('West Ham', 'BromleyByBow')) tensor(217.)\n(('Plaistow', 'West Ham'), ('West Ham', 'Stratford')) tensor(9431.)\n(('Plaistow', 'West Ham'), ('West Ham', 'Canning Town')) tensor(1711.)\n(('Plaistow', 'Upton Park'), ('Upton Park', 'East Ham')) tensor(226.)\n(('Roding Valley', 'Woodford'), ('Woodford', 'Buckhurst Hill')) tensor(147.)\n(('Roding Valley', 'Woodford'), ('Woodford', 'South Woodford')) tensor(2057.)\n(('Roding Valley', 'Chigwell'), ('Chigwell', 'Grange Hill')) tensor(1731.)\n(('Parsons Green', 'Putney Bridge'), ('Putney Bridge', 'East Putney')) tensor(13626.)\n(('Parsons Green', 'Fulham Broadway'), ('Fulham Broadway', 'West Brompton')) tensor(21231.)\n(('Greenford', 'Northolt'), ('Northolt', 'South Ruislip')) tensor(2892.)\n(('Greenford', 'Perivale'), ('Perivale', 'Hanger Lane')) tensor(9404.)\n(('Mansion House', 'Cannon Street'), ('Cannon Street', 'Bank / Monument')) tensor(4715.)\n(('Mansion House', 'Blackfriars'), ('Blackfriars', 'Temple')) tensor(7272.)\n(('Southfields', 'East Putney'), ('East Putney', 'Putney Bridge')) tensor(12207.)\n(('Southfields', 'Wimbledon Park'), ('Wimbledon Park', 'Wimbledon')) tensor(8425.)\n(('Hampstead', 'Belsize Park'), ('Belsize Park', 'Chalk Farm')) tensor(21607.)\n(('Hampstead', 'Golders Green'), ('Golders Green', 'Brent Cross')) tensor(13901.)\n(('Oakwood', 'Southgate'), ('Southgate', 'Arnos Grove')) tensor(3294.)\n(('Cockfosters', 'Oakwood'), ('Oakwood', 'Southgate')) tensor(1364.)\n(('Dagenham Heathway', 'Dagenham East'), ('Dagenham East', 'Elm Park')) tensor(214.)\n(('Dagenham Heathway', 'Becontree'), ('Becontree', 'Upney')) tensor(5716.)\n(('North Ealing', 'Ealing Common'), ('Ealing Common', 'Ealing Broadway')) tensor(1020.)\n(('North Ealing', 'Ealing Common'), ('Ealing Common', 'Acton Town')) tensor(4523.)\n(('North Ealing', 'Park Royal'), ('Park Royal', 'Alperton')) tensor(4307.)\n(('Arnos Grove', 'Bounds Green'), ('Bounds Green', 'Wood Green')) tensor(9987.)\n(('Arnos Grove', 'Southgate'), ('Southgate', 'Oakwood')) tensor(3047.)\n(('Southgate', 'Oakwood'), ('Oakwood', 'Cockfosters')) tensor(1413.)\n(('Southgate', 'Arnos Grove'), ('Arnos Grove', 'Bounds Green')) tensor(6979.)\n((\"Shepherd's Bush Market\", 'Goldhawk Road'), ('Goldhawk Road', 'Hammersmith (H&amp;C)')) tensor(4050.)\n((\"Shepherd's Bush Market\", 'Wood Lane'), ('Wood Lane', 'Latimer Road')) tensor(8097.)\n(('Northwood Hills', 'Pinner'), ('Pinner', 'North Harrow')) tensor(526.)\n(('Northwood Hills', 'Northwood'), ('Northwood', 'Moor Park')) tensor(731.)\n((\"Regent's Park\", 'Baker Street'), ('Baker Street', 'Finchley Road')) tensor(1506.)\n((\"Regent's Park\", 'Baker Street'), ('Baker Street', 'Edgware Road (Cir)')) tensor(7178.)\n((\"Regent's Park\", 'Baker Street'), ('Baker Street', 'Marylebone')) tensor(1403.)\n((\"Regent's Park\", 'Baker Street'), ('Baker Street', \"St. John's Wood\")) tensor(177.)\n((\"Regent's Park\", 'Baker Street'), ('Baker Street', 'Great Portland Street')) tensor(26.)\n((\"Regent's Park\", 'Oxford Circus'), ('Oxford Circus', 'Green Park')) tensor(1183.)\n((\"Regent's Park\", 'Oxford Circus'), ('Oxford Circus', 'Piccadilly Circus')) tensor(3694.)\n((\"Regent's Park\", 'Oxford Circus'), ('Oxford Circus', 'Tottenham Court Road')) tensor(301.)\n((\"Regent's Park\", 'Oxford Circus'), ('Oxford Circus', 'Warren Street')) tensor(1665.)\n(('Ravenscourt Park', 'Stamford Brook'), ('Stamford Brook', 'Turnham Green')) tensor(111.)\n(('Ravenscourt Park', 'Hammersmith (Dis)'), ('Hammersmith (Dis)', 'Turnham Green')) tensor(103.)\n(('Ravenscourt Park', 'Hammersmith (Dis)'), ('Hammersmith (Dis)', 'Barons Court')) tensor(2033.)\n(('Ravenscourt Park', 'Hammersmith (Dis)'), ('Hammersmith (Dis)', 'Acton Town')) tensor(586.)\n(('Kilburn Park', \"Queen's Park\"), (\"Queen's Park\", 'Kensal Green')) tensor(9950.)\n(('Kilburn Park', 'Maida Vale'), ('Maida Vale', 'Warwick Avenue')) tensor(18624.)\n(('Canning Town', 'West Ham'), ('West Ham', 'Barking')) tensor(4186.)\n(('Canning Town', 'West Ham'), ('West Ham', 'BromleyByBow')) tensor(61.)\n(('Canning Town', 'West Ham'), ('West Ham', 'Stratford')) tensor(14809.)\n(('Canning Town', 'West Ham'), ('West Ham', 'Plaistow')) tensor(1276.)\n(('Canning Town', 'North Greenwich'), ('North Greenwich', 'Canary Wharf')) tensor(26019.)\n(('North Greenwich', 'Canary Wharf'), ('Canary Wharf', 'Canada Water')) tensor(26152.)\n(('North Greenwich', 'Canning Town'), ('Canning Town', 'West Ham')) tensor(16016.)\n(('Kennington', 'Waterloo'), ('Waterloo', 'Southwark')) tensor(13463.)\n(('Kennington', 'Waterloo'), ('Waterloo', 'Embankment')) tensor(4645.)\n(('Kennington', 'Waterloo'), ('Waterloo', 'Westminster')) tensor(6044.)\n(('Kennington', 'Waterloo'), ('Waterloo', 'Lambeth North')) tensor(45.)\n(('Kennington', 'Elephant &amp; Castle'), ('Elephant &amp; Castle', 'Lambeth North')) tensor(50.)\n(('Kennington', 'Elephant &amp; Castle'), ('Elephant &amp; Castle', 'Borough')) tensor(14437.)\n(('Kennington', 'Oval'), ('Oval', 'Stockwell')) tensor(32598.)\n(('Dollis Hill', 'Willesden Green'), ('Willesden Green', 'Finchley Road')) tensor(2230.)\n(('Dollis Hill', 'Willesden Green'), ('Willesden Green', 'Kilburn')) tensor(95.)\n(('Dollis Hill', 'Neasden'), ('Neasden', 'Wembley Park')) tensor(563.)\n(('Becontree', 'Upney'), ('Upney', 'Barking')) tensor(7703.)\n(('Becontree', 'Dagenham Heathway'), ('Dagenham Heathway', 'Dagenham East')) tensor(1849.)\n(('Hounslow Central', 'Hounslow East'), ('Hounslow East', 'Osterley')) tensor(15506.)\n(('Hounslow Central', 'Hounslow West'), ('Hounslow West', 'Hatton Cross')) tensor(9620.)\n(('Golders Green', 'Brent Cross'), ('Brent Cross', 'Hendon Central')) tensor(12632.)\n(('Golders Green', 'Hampstead'), ('Hampstead', 'Belsize Park')) tensor(19644.)\n(('Goodge Street', 'Tottenham Court Road'), ('Tottenham Court Road', 'Bond Street')) tensor(1026.)\n(('Goodge Street', 'Tottenham Court Road'), ('Tottenham Court Road', 'Oxford Circus')) tensor(739.)\n(('Goodge Street', 'Tottenham Court Road'), ('Tottenham Court Road', 'Leicester Square')) tensor(2650.)\n(('Goodge Street', 'Tottenham Court Road'), ('Tottenham Court Road', 'Holborn')) tensor(936.)\n(('Goodge Street', 'Warren Street'), ('Warren Street', 'Euston')) tensor(5428.)\n(('Goodge Street', 'Warren Street'), ('Warren Street', 'Oxford Circus')) tensor(751.)\n(('Northwick Park', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Finchley Road')) tensor(1406.)\n(('Northwick Park', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'North Harrow')) tensor(41.)\n(('Northwick Park', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Wembley Park')) tensor(90.)\n(('Northwick Park', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'West Harrow')) tensor(413.)\n(('Northwick Park', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Marylebone')) tensor(1106.)\n(('Northwick Park', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Rickmansworth')) tensor(11.)\n(('Northwick Park', 'HarrowOnTheHill'), ('HarrowOnTheHill', 'Moor Park')) tensor(152.)\n(('Northwick Park', 'Preston Road'), ('Preston Road', 'Wembley Park')) tensor(89.)\n(('Preston Road', 'Wembley Park'), ('Wembley Park', 'Finchley Road')) tensor(1551.)\n(('Preston Road', 'Wembley Park'), ('Wembley Park', 'Kingsbury')) tensor(8.)\n(('Preston Road', 'Wembley Park'), ('Wembley Park', 'HarrowOnTheHill')) tensor(325.)\n(('Preston Road', 'Wembley Park'), ('Wembley Park', 'Neasden')) tensor(51.)\n(('Preston Road', 'Northwick Park'), ('Northwick Park', 'HarrowOnTheHill')) tensor(358.)\n(('Great Portland Street', 'Baker Street'), ('Baker Street', 'Finchley Road')) tensor(13037.)\n(('Great Portland Street', 'Baker Street'), ('Baker Street', 'Bond Street')) tensor(1271.)\n(('Great Portland Street', 'Baker Street'), ('Baker Street', 'Edgware Road (Cir)')) tensor(40888.)\n(('Great Portland Street', 'Baker Street'), ('Baker Street', 'Marylebone')) tensor(5798.)\n(('Great Portland Street', 'Baker Street'), ('Baker Street', \"St. John's Wood\")) tensor(1130.)\n(('Great Portland Street', 'Baker Street'), ('Baker Street', \"Regent's Park\")) tensor(69.)\n(('Great Portland Street', 'Euston Square'), ('Euston Square', \"King's Cross St. Pancras\")) tensor(64583.)\n(('South Kenton', 'Kenton'), ('Kenton', 'Harrow &amp; Wealdstone')) tensor(2223.)\n(('South Kenton', 'North Wembley'), ('North Wembley', 'Wembley Central')) tensor(4725.)\n(('Heathrow Terminal 4', 'Hatton Cross'), ('Hatton Cross', 'Hounslow West')) tensor(1634.)\n(('Swiss Cottage', 'Finchley Road'), ('Finchley Road', 'Willesden Green')) tensor(468.)\n(('Swiss Cottage', 'Finchley Road'), ('Finchley Road', 'Baker Street')) tensor(2392.)\n(('Swiss Cottage', 'Finchley Road'), ('Finchley Road', 'Wembley Park')) tensor(529.)\n(('Swiss Cottage', 'Finchley Road'), ('Finchley Road', 'HarrowOnTheHill')) tensor(290.)\n(('Swiss Cottage', 'Finchley Road'), ('Finchley Road', 'West Hampstead')) tensor(374.)\n(('Swiss Cottage', \"St. John's Wood\"), (\"St. John's Wood\", 'Baker Street')) tensor(2362.)\n(('Boston Manor', 'Osterley'), ('Osterley', 'Hounslow East')) tensor(15898.)\n(('Boston Manor', 'Northfields'), ('Northfields', 'South Ealing')) tensor(19683.)\n(('Maida Vale', 'Warwick Avenue'), ('Warwick Avenue', 'Paddington')) tensor(20518.)\n(('Maida Vale', 'Kilburn Park'), ('Kilburn Park', \"Queen's Park\")) tensor(13370.)\n(('Leytonstone', 'Snaresbrook'), ('Snaresbrook', 'South Woodford')) tensor(16022.)\n(('Leytonstone', 'Leyton'), ('Leyton', 'Stratford')) tensor(38725.)\n(('Leytonstone', 'Wanstead'), ('Wanstead', 'Redbridge')) tensor(11278.)\n(('Oval', 'Stockwell'), ('Stockwell', 'Vauxhall')) tensor(2531.)\n(('Oval', 'Stockwell'), ('Stockwell', 'Clapham North')) tensor(24190.)\n(('Oval', 'Stockwell'), ('Stockwell', 'Brixton')) tensor(5042.)\n(('Oval', 'Kennington'), ('Kennington', 'Waterloo')) tensor(20087.)\n(('Oval', 'Kennington'), ('Kennington', 'Elephant &amp; Castle')) tensor(15227.)\n(('Croxley', 'Moor Park'), ('Moor Park', 'HarrowOnTheHill')) tensor(1503.)\n(('Croxley', 'Moor Park'), ('Moor Park', 'Rickmansworth')) tensor(96.)\n(('Croxley', 'Moor Park'), ('Moor Park', 'Northwood')) tensor(280.)\n(('Watford', 'Croxley'), ('Croxley', 'Moor Park')) tensor(1328.)\n(('West Finchley', 'Finchley Central'), ('Finchley Central', 'Mill Hill East')) tensor(31.)\n(('West Finchley', 'Finchley Central'), ('Finchley Central', 'East Finchley')) tensor(6959.)\n(('West Finchley', 'Woodside Park'), ('Woodside Park', 'Totteridge &amp; Whetstone')) tensor(3955.)\n(('Perivale', 'Hanger Lane'), ('Hanger Lane', 'North Acton')) tensor(10813.)\n(('Perivale', 'Greenford'), ('Greenford', 'Northolt')) tensor(6071.)\n(('North Wembley', 'Wembley Central'), ('Wembley Central', 'Stonebridge Park')) tensor(5254.)\n(('North Wembley', 'South Kenton'), ('South Kenton', 'Kenton')) tensor(3232.)\n(('Ruislip Manor', 'Ruislip'), ('Ruislip', 'Ickenham')) tensor(7218.)\n(('Ruislip Manor', 'Eastcote'), ('Eastcote', 'Rayners Lane')) tensor(8348.)\n(('Fulham Broadway', 'West Brompton'), ('West Brompton', \"Earl's Court\")) tensor(27066.)\n(('Fulham Broadway', 'West Brompton'), ('West Brompton', 'Kensington (Olympia)')) tensor(75.)\n(('Fulham Broadway', 'Parsons Green'), ('Parsons Green', 'Putney Bridge')) tensor(17190.)\n(('High Barnet', 'Totteridge &amp; Whetstone'), ('Totteridge &amp; Whetstone', 'Woodside Park')) tensor(2467.)\n(('Chiswick Park', 'Turnham Green'), ('Turnham Green', 'Stamford Brook')) tensor(1.)\n(('Chiswick Park', 'Turnham Green'), ('Turnham Green', 'Hammersmith (Dis)')) tensor(280.)\n(('Chiswick Park', 'Acton Town'), ('Acton Town', 'Hammersmith (Dis)')) tensor(269.)\n(('Chiswick Park', 'Acton Town'), ('Acton Town', 'Ealing Common')) tensor(965.)\n(('Chiswick Park', 'Acton Town'), ('Acton Town', 'South Ealing')) tensor(144.)\n(('Northwood', 'Moor Park'), ('Moor Park', 'HarrowOnTheHill')) tensor(2306.)\n(('Northwood', 'Moor Park'), ('Moor Park', 'Rickmansworth')) tensor(107.)\n(('Northwood', 'Moor Park'), ('Moor Park', 'Croxley')) tensor(136.)\n(('Northwood', 'Northwood Hills'), ('Northwood Hills', 'Pinner')) tensor(185.)\n</pre> In\u00a0[4]: Copied! <pre>g2['edge_weight', ('Southwark', 'Waterloo'), ('Waterloo', 'Embankment')]\n</pre> g2['edge_weight', ('Southwark', 'Waterloo'), ('Waterloo', 'Embankment')] Out[4]: <pre>tensor(8405.)</pre> In\u00a0[10]: Copied! <pre>paths = pp2.Paths.read_file(\"../data/tube_paths_train.ngram\", max_subpath_length=2)\ng2 = pp2.HigherOrderNetwork(paths, k=2)\nprint(g2)\n</pre> paths = pp2.Paths.read_file(\"../data/tube_paths_train.ngram\", max_subpath_length=2) g2 = pp2.HigherOrderNetwork(paths, k=2) print(g2) <pre>2023-08-11 12:47:32 [Severity.INFO]\tReading ngram data ... \n2023-08-11 12:47:33 [Severity.INFO]\tfinished. Read 61748 paths with maximum length 35\n2023-08-11 12:47:33 [Severity.INFO]\tCalculating sub path statistics ... \n2023-08-11 12:47:34 [Severity.INFO]\tfinished.\nHigher-order network of order k = 2\n\nNodes:\t\t\t\t646\nLinks:\t\t\t\t1139\nTotal weight (subpaths/longest paths):\t12182604.0/173868.0\n\n</pre> In\u00a0[11]: Copied! <pre>ks = range(1,10)\ntimes = []\nfor k in ks:\n    start = time.time() \n    paths = pp2.Paths.read_file(\"../data/tube_paths_train.ngram\", max_subpath_length=k)\n    g2 = pp2.HigherOrderNetwork(paths, k=k)\n    print(g2)\n    elapsed_pp = time.time()-start\n    times.append(elapsed_pp)\nplt.plot(ks, times)\n</pre> ks = range(1,10) times = [] for k in ks:     start = time.time()      paths = pp2.Paths.read_file(\"../data/tube_paths_train.ngram\", max_subpath_length=k)     g2 = pp2.HigherOrderNetwork(paths, k=k)     print(g2)     elapsed_pp = time.time()-start     times.append(elapsed_pp) plt.plot(ks, times) <pre>2023-08-11 12:47:39 [Severity.INFO]\tReading ngram data ... \n2023-08-11 12:47:40 [Severity.INFO]\tfinished. Read 61748 paths with maximum length 35\n2023-08-11 12:47:40 [Severity.INFO]\tCalculating sub path statistics ... \n2023-08-11 12:47:40 [Severity.INFO]\tfinished.\nHigher-order network of order k = 1\n\nNodes:\t\t\t\t268\nLinks:\t\t\t\t646\nTotal weight (subpaths/longest paths):\t14404381.0/99956.0\n\n2023-08-11 12:47:40 [Severity.INFO]\tReading ngram data ... \n2023-08-11 12:47:41 [Severity.INFO]\tfinished. Read 61748 paths with maximum length 35\n2023-08-11 12:47:41 [Severity.INFO]\tCalculating sub path statistics ... \n2023-08-11 12:47:42 [Severity.INFO]\tfinished.\nHigher-order network of order k = 2\n\nNodes:\t\t\t\t646\nLinks:\t\t\t\t1139\nTotal weight (subpaths/longest paths):\t12182604.0/173868.0\n\n2023-08-11 12:47:42 [Severity.INFO]\tReading ngram data ... \n2023-08-11 12:47:43 [Severity.INFO]\tfinished. Read 61748 paths with maximum length 35\n2023-08-11 12:47:43 [Severity.INFO]\tCalculating sub path statistics ... \n2023-08-11 12:47:44 [Severity.INFO]\tfinished.\nHigher-order network of order k = 3\n\nNodes:\t\t\t\t1889\nLinks:\t\t\t\t1869\nTotal weight (subpaths/longest paths):\t10078001.0/230562.0\n\n2023-08-11 12:47:45 [Severity.INFO]\tReading ngram data ... \n2023-08-11 12:47:45 [Severity.INFO]\tfinished. Read 61748 paths with maximum length 35\n2023-08-11 12:47:45 [Severity.INFO]\tCalculating sub path statistics ... \n2023-08-11 12:47:47 [Severity.INFO]\tfinished.\nHigher-order network of order k = 4\n\nNodes:\t\t\t\t5770\nLinks:\t\t\t\t2730\nTotal weight (subpaths/longest paths):\t8198110.0/236412.0\n\n2023-08-11 12:47:47 [Severity.INFO]\tReading ngram data ... \n2023-08-11 12:47:48 [Severity.INFO]\tfinished. Read 61748 paths with maximum length 35\n2023-08-11 12:47:48 [Severity.INFO]\tCalculating sub path statistics ... \n2023-08-11 12:47:51 [Severity.INFO]\tfinished.\nHigher-order network of order k = 5\n\nNodes:\t\t\t\t19424\nLinks:\t\t\t\t3683\nTotal weight (subpaths/longest paths):\t6547275.0/243768.0\n\n2023-08-11 12:47:51 [Severity.INFO]\tReading ngram data ... \n2023-08-11 12:47:52 [Severity.INFO]\tfinished. Read 61748 paths with maximum length 35\n2023-08-11 12:47:52 [Severity.INFO]\tCalculating sub path statistics ... \n2023-08-11 12:47:55 [Severity.INFO]\tfinished.\nHigher-order network of order k = 6\n\nNodes:\t\t\t\t66882\nLinks:\t\t\t\t4748\nTotal weight (subpaths/longest paths):\t5174028.0/209948.0\n\n2023-08-11 12:47:57 [Severity.INFO]\tReading ngram data ... \n2023-08-11 12:47:58 [Severity.INFO]\tfinished. Read 61748 paths with maximum length 35\n2023-08-11 12:47:58 [Severity.INFO]\tCalculating sub path statistics ... \n2023-08-11 12:48:01 [Severity.INFO]\tfinished.\nHigher-order network of order k = 7\n\nNodes:\t\t\t\t242779\nLinks:\t\t\t\t5745\nTotal weight (subpaths/longest paths):\t4044268.0/176409.0\n\n2023-08-11 12:48:06 [Severity.INFO]\tReading ngram data ... \n2023-08-11 12:48:07 [Severity.INFO]\tfinished. Read 61748 paths with maximum length 35\n2023-08-11 12:48:07 [Severity.INFO]\tCalculating sub path statistics ... \n2023-08-11 12:48:11 [Severity.INFO]\tfinished.\nHigher-order network of order k = 8\n\nNodes:\t\t\t\t888479\nLinks:\t\t\t\t6463\nTotal weight (subpaths/longest paths):\t3116104.0/151222.0\n\n2023-08-11 12:48:30 [Severity.INFO]\tReading ngram data ... \n2023-08-11 12:48:31 [Severity.INFO]\tfinished. Read 61748 paths with maximum length 35\n2023-08-11 12:48:31 [Severity.INFO]\tCalculating sub path statistics ... \n2023-08-11 12:48:36 [Severity.INFO]\tfinished.\nHigher-order network of order k = 9\n\nNodes:\t\t\t\t3348421\nLinks:\t\t\t\t7053\nTotal weight (subpaths/longest paths):\t2349934.0/140450.0\n\n</pre> Out[11]: <pre>[&lt;matplotlib.lines.Line2D at 0x7f4731a0b970&gt;]</pre> In\u00a0[4]: Copied! <pre>pp.config['torch']['device'] = 'cuda:0'\n</pre> pp.config['torch']['device'] = 'cuda:0' In\u00a0[5]: Copied! <pre>ks = range(1,10)\ntimes_new_gpu = []\nfor k in ks:\n    start = time.time()\n    p = pp.PathData.from_csv('../data/tube_paths_train.ngram')\n    gk = pp.HigherOrderGraph(p, order=k, path_freq='path_freq')\n    print(gk)\n    print('---')\n    elapsed_new = time.time()-start\n    times_new_gpu.append(elapsed_new)\n</pre> ks = range(1,10) times_new_gpu = [] for k in ks:     start = time.time()     p = pp.PathData.from_csv('../data/tube_paths_train.ngram')     gk = pp.HigherOrderGraph(p, order=k, path_freq='path_freq')     print(gk)     print('---')     elapsed_new = time.time()-start     times_new_gpu.append(elapsed_new) <pre>HigherOrderGraph (k=1) with 268 nodes and 646 edges\n\nEdge attributes\n\tedge_weight\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([646])\n\nGraph attributes\n\tnode_id\t\t&lt;class 'list'&gt;\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\n---\nHigherOrderGraph (k=2) with 642 nodes and 1139 edges\n\nEdge attributes\n\tedge_weight\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([1139])\n\nGraph attributes\n\tnode_id\t\t&lt;class 'list'&gt;\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\n---\nHigherOrderGraph (k=3) with 1134 nodes and 1869 edges\n\nEdge attributes\n\tedge_weight\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([1869])\n\nGraph attributes\n\tnode_id\t\t&lt;class 'list'&gt;\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\n---\nHigherOrderGraph (k=4) with 1812 nodes and 2730 edges\n\nEdge attributes\n\tedge_weight\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([2730])\n\nGraph attributes\n\tnode_id\t\t&lt;class 'list'&gt;\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\n---\nHigherOrderGraph (k=5) with 2576 nodes and 3683 edges\n\nEdge attributes\n\tedge_weight\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([3683])\n\nGraph attributes\n\tnode_id\t\t&lt;class 'list'&gt;\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\n---\nHigherOrderGraph (k=6) with 3471 nodes and 4748 edges\n\nEdge attributes\n\tedge_weight\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([4748])\n\nGraph attributes\n\tnode_id\t\t&lt;class 'list'&gt;\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\n---\nHigherOrderGraph (k=7) with 4418 nodes and 5745 edges\n\nEdge attributes\n\tedge_weight\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([5745])\n\nGraph attributes\n\tnode_id\t\t&lt;class 'list'&gt;\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\n---\nHigherOrderGraph (k=8) with 5332 nodes and 6463 edges\n\nEdge attributes\n\tedge_weight\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([6463])\n\nGraph attributes\n\tnode_id\t\t&lt;class 'list'&gt;\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\n---\nHigherOrderGraph (k=9) with 6075 nodes and 7053 edges\n\nEdge attributes\n\tedge_weight\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([7053])\n\nGraph attributes\n\tnode_id\t\t&lt;class 'list'&gt;\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\n---\n</pre> In\u00a0[9]: Copied! <pre>pp.config['torch']['device'] = 'cpu'\n</pre> pp.config['torch']['device'] = 'cpu' In\u00a0[10]: Copied! <pre>ks = range(1,10)\ntimes_new_cpu = []\nfor k in ks:\n    start = time.time()\n    p = pp.PathData.from_csv('../data/tube_paths_train.ngram')\n    gk = pp.HigherOrderGraph(p, order=k, path_freq='path_freq')\n    print(gk)\n    print('---')\n    elapsed_new = time.time()-start\n    times_new_cpu.append(elapsed_new)\n</pre> ks = range(1,10) times_new_cpu = [] for k in ks:     start = time.time()     p = pp.PathData.from_csv('../data/tube_paths_train.ngram')     gk = pp.HigherOrderGraph(p, order=k, path_freq='path_freq')     print(gk)     print('---')     elapsed_new = time.time()-start     times_new_cpu.append(elapsed_new) <pre>HigherOrderGraph (k=1) with 268 nodes and 646 edges\n\nEdge attributes\n\tedge_weight\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([646])\n\nGraph attributes\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\tnode_id\t\t&lt;class 'list'&gt;\n\n---\nHigherOrderGraph (k=2) with 642 nodes and 1139 edges\n\nEdge attributes\n\tedge_weight\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([1139])\n\nGraph attributes\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\tnode_id\t\t&lt;class 'list'&gt;\n\n---\nHigherOrderGraph (k=3) with 1134 nodes and 1869 edges\n\nEdge attributes\n\tedge_weight\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([1869])\n\nGraph attributes\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\tnode_id\t\t&lt;class 'list'&gt;\n\n---\nHigherOrderGraph (k=4) with 1812 nodes and 2730 edges\n\nEdge attributes\n\tedge_weight\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([2730])\n\nGraph attributes\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\tnode_id\t\t&lt;class 'list'&gt;\n\n---\nHigherOrderGraph (k=5) with 2576 nodes and 3683 edges\n\nEdge attributes\n\tedge_weight\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([3683])\n\nGraph attributes\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\tnode_id\t\t&lt;class 'list'&gt;\n\n---\nHigherOrderGraph (k=6) with 3471 nodes and 4748 edges\n\nEdge attributes\n\tedge_weight\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([4748])\n\nGraph attributes\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\tnode_id\t\t&lt;class 'list'&gt;\n\n---\nHigherOrderGraph (k=7) with 4418 nodes and 5745 edges\n\nEdge attributes\n\tedge_weight\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([5745])\n\nGraph attributes\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\tnode_id\t\t&lt;class 'list'&gt;\n\n---\nHigherOrderGraph (k=8) with 5332 nodes and 6463 edges\n\nEdge attributes\n\tedge_weight\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([6463])\n\nGraph attributes\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\tnode_id\t\t&lt;class 'list'&gt;\n\n---\nHigherOrderGraph (k=9) with 6075 nodes and 7053 edges\n\nEdge attributes\n\tedge_weight\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([7053])\n\nGraph attributes\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\tnode_id\t\t&lt;class 'list'&gt;\n\n---\n</pre> In\u00a0[13]: Copied! <pre>plt.plot(ks, times, label='pathpy2')\nplt.plot(ks, times_new_gpu, label='pathpyG prototype (GPU)')\nplt.plot(ks, times_new_cpu, label='pathpyG prototype (CPU)')\nplt.xlabel('order')\nplt.grid()\nplt.ylabel('time [s]')\nplt.legend()\n</pre> plt.plot(ks, times, label='pathpy2') plt.plot(ks, times_new_gpu, label='pathpyG prototype (GPU)') plt.plot(ks, times_new_cpu, label='pathpyG prototype (CPU)') plt.xlabel('order') plt.grid() plt.ylabel('time [s]') plt.legend() Out[13]: <pre>&lt;matplotlib.legend.Legend at 0x7f8323e01660&gt;</pre> In\u00a0[14]: Copied! <pre>plt.plot(ks, times, label='pathpy2')\nplt.plot(ks, times_new_gpu, label='pathpyG prototype (GPU)')\nplt.plot(ks, times_new_cpu, label='pathpyG prototype (CPU)')\nplt.xlabel('order')\nplt.ylabel('time [s]')\nplt.legend()\nplt.grid()\nplt.yscale('log')\nplt.ylim(1,100)\n</pre> plt.plot(ks, times, label='pathpy2') plt.plot(ks, times_new_gpu, label='pathpyG prototype (GPU)') plt.plot(ks, times_new_cpu, label='pathpyG prototype (CPU)') plt.xlabel('order') plt.ylabel('time [s]') plt.legend() plt.grid() plt.yscale('log') plt.ylim(1,100) Out[14]: <pre>(1, 100)</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorial/higher_order_scalability/#pathpy-20","title":"Pathpy 2.0\u00b6","text":""},{"location":"tutorial/higher_order_scalability/#pathpyg-gpu","title":"pathpyG (GPU)\u00b6","text":""},{"location":"tutorial/netzschleuder/","title":"Accessing Netzschleuder","text":"In\u00a0[2]: Copied! <pre>import numpy as np\nfrom matplotlib import pyplot as plt\n\nfrom sklearn import metrics\nfrom sklearn.decomposition import TruncatedSVD\n\nimport torch\nfrom torch.nn import Linear, ReLU, Sigmoid, Parameter\n\nimport torch_geometric\nfrom torch_geometric.nn import Sequential, GCNConv, SimpleConv, MessagePassing\n\nimport pathpyG as pp\n\npp.config['torch']['device'] = 'cpu'\n</pre> import numpy as np from matplotlib import pyplot as plt  from sklearn import metrics from sklearn.decomposition import TruncatedSVD  import torch from torch.nn import Linear, ReLU, Sigmoid, Parameter  import torch_geometric from torch_geometric.nn import Sequential, GCNConv, SimpleConv, MessagePassing  import pathpyG as pp  pp.config['torch']['device'] = 'cpu' In\u00a0[3]: Copied! <pre>g = pp.io.read_netzschleuder_network('polbooks')\nprint(g)\n</pre> g = pp.io.read_netzschleuder_network('polbooks') print(g) <pre>Graph with 105 nodes and 441 edges\n\nNode attributes\n\tnode_label\t\t&lt;class 'list'&gt;\n\tnode__pos\t\t&lt;class 'list'&gt;\n\tnode_value\t\t&lt;class 'list'&gt;\n\nGraph attributes\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\ttags\t\t&lt;class 'list'&gt;\n\tdescription\t\t&lt;class 'str'&gt;\n\turl\t\t&lt;class 'str'&gt;\n\tnode_id\t\t&lt;class 'list'&gt;\n\tcitation\t\t&lt;class 'str'&gt;\n\tdirected\t\t&lt;class 'float'&gt;\n\tname\t\t&lt;class 'str'&gt;\n\n</pre> <p>If we print the resulting <code>Graph</code> instance, we find that the meta information at the node- and grah-level are automatically retrieved and added to the graph.</p> <p>Let us read the famous karate club network. The record <code>karate club</code> actually contains two networks with labels <code>77</code> and <code>78</code>, which refer to two different versions of the graph data. If multiple graph data sets exist in the same record, we need to specify the name of the graph as second argument.</p> In\u00a0[34]: Copied! <pre>g = pp.io.read_netzschleuder_network('karate', '77')\nprint(g)\n</pre> g = pp.io.read_netzschleuder_network('karate', '77') print(g) <pre>Graph with 34 nodes and 77 edges\n\nNode attributes\n\tnode__pos\t\t&lt;class 'list'&gt;\n\tnode_name\t\t&lt;class 'list'&gt;\n\tnode_groups\t\t&lt;class 'list'&gt;\n\nGraph attributes\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\ttags\t\t&lt;class 'list'&gt;\n\tdescription\t\t&lt;class 'str'&gt;\n\turl\t\t&lt;class 'str'&gt;\n\tnode_id\t\t&lt;class 'list'&gt;\n\tcitation\t\t&lt;class 'str'&gt;\n\tname\t\t&lt;class 'str'&gt;\n\n</pre> In\u00a0[39]: Copied! <pre>pp.plot(g);\n</pre> pp.plot(g); <p>We see that the nodes actually contain a <code>node_group</code> property, which maps the nodes to two groups. Those groups are often used as <code>ground truth</code> for communities in this simple illustrative graph. We will instead use it as ground truth categorical node label for a node classification experiment based on a Graph Neural Network.</p> In\u00a0[36]: Copied! <pre>print(g['node_groups'])\n</pre> print(g['node_groups']) <pre>[[1], [1], [1], [1], [1], [1], [1], [1], [1], [2], [1], [1], [1], [1], [2], [2], [1], [1], [2], [1], [2], [1], [2], [2], [2], [2], [2], [2], [2], [2], [2], [2], [2], [2]]\n</pre> <p>We can plot categorical labels by passing them as node colors in the pathpy plot function.</p> In\u00a0[38]: Copied! <pre>pp.plot(g, node_color = [g['node_groups',v][0] for v in g.nodes])\n</pre> pp.plot(g, node_color = [g['node_groups',v][0] for v in g.nodes]) Out[38]: <pre>&lt;pathpyG.visualisations.network_plots.StaticNetworkPlot at 0x7f63a35117e0&gt;</pre> <p>For convenience, let us shift the group labels to binary values 0 and 1:</p> In\u00a0[24]: Copied! <pre>g['node_groups'] = torch.tensor(g['node_groups']).float()\ng['node_groups'] -= 1\nprint(g['node_groups'])\n</pre> g['node_groups'] = torch.tensor(g['node_groups']).float() g['node_groups'] -= 1 print(g['node_groups']) <pre>tensor([[0.],\n        [0.],\n        [0.],\n        [0.],\n        [0.],\n        [0.],\n        [0.],\n        [0.],\n        [0.],\n        [1.],\n        [0.],\n        [0.],\n        [0.],\n        [0.],\n        [1.],\n        [1.],\n        [0.],\n        [0.],\n        [1.],\n        [0.],\n        [1.],\n        [0.],\n        [1.],\n        [1.],\n        [1.],\n        [1.],\n        [1.],\n        [1.],\n        [1.],\n        [1.],\n        [1.],\n        [1.],\n        [1.],\n        [1.]])\n</pre> <p>We can retrieve a pytorch geometric data object that contains this information.</p> In\u00a0[25]: Copied! <pre>print(g.data)\n</pre> print(g.data) <pre>Data(edge_index=[2, 77], node_id=[0], num_nodes=34, node_name=[34], node_groups=[34, 1], node__pos=[34], name='karate (77)', description='Network of friendships among members of a university karate club. Includes metadata for faction membership after a social partition. Note: there are two versions of this network, one with 77 edges and one with 78, due to an ambiguous typo in the original study. (The most commonly used is the one with 78 edges.)[^icon]\n[^icon]: Description obtained from the [ICON](https://icon.colorado.edu) project.', citation='['W. W. Zachary, \"An information flow model for conflict and fission in small groups.\" Journal of Anthropological Research 33, 452-473 (1977)., https://doi.org/10.1086/jar.33.4.3629752']', url='https://aaronclauset.github.io/datacode.htm', tags=[3])\n</pre> <p>Let's use a one-hot encoding of nodes as a simple feature <code>x</code>, and let's use the node groups as target label <code>y</code>.</p> In\u00a0[26]: Copied! <pre>data = g.data\ng.add_node_ohe('node_feature')\ndata['x'] = data['node_feature']\ndata['y'] = data['node_groups']\n</pre> data = g.data g.add_node_ohe('node_feature') data['x'] = data['node_feature'] data['y'] = data['node_groups'] <p>We can now apply a GCN to the Karate club network:</p> In\u00a0[27]: Copied! <pre>model = Sequential('node_ohe, edge_index', [\n    (GCNConv(in_channels=data.num_node_features, out_channels=8), 'node_ohe, edge_index -&gt; node_ohe'),\n    ReLU(inplace=True),\n    (GCNConv(in_channels=8, out_channels=1), 'node_ohe, edge_index -&gt; node_ohe'),\n    Sigmoid(),\n])\nmodel.to(pp.config['torch']['device'])\n</pre> model = Sequential('node_ohe, edge_index', [     (GCNConv(in_channels=data.num_node_features, out_channels=8), 'node_ohe, edge_index -&gt; node_ohe'),     ReLU(inplace=True),     (GCNConv(in_channels=8, out_channels=1), 'node_ohe, edge_index -&gt; node_ohe'),     Sigmoid(), ]) model.to(pp.config['torch']['device']) Out[27]: <pre>Sequential(\n  (0) - GCNConv(34, 8): node_ohe, edge_index -&gt; node_ohe\n  (1) - ReLU(inplace=True): node_ohe -&gt; node_ohe\n  (2) - GCNConv(8, 1): node_ohe, edge_index -&gt; node_ohe\n  (3) - Sigmoid(): node_ohe -&gt; node_ohe\n)</pre> <p>We next apply a <code>RandomNodeSplit</code> transformation to split the nodes in a training and test set.</p> In\u00a0[28]: Copied! <pre>transform = torch_geometric.transforms.RandomNodeSplit(split='train_rest', num_val=0.5, num_test=0)\ndata = transform(data)\n</pre> transform = torch_geometric.transforms.RandomNodeSplit(split='train_rest', num_val=0.5, num_test=0) data = transform(data) <p>We then train our model for 1000 epochs on the training set.</p> In\u00a0[29]: Copied! <pre>epochs = 1000\n\noptimizer = torch.optim.Adam(model.parameters(), lr=0.01, weight_decay=5e-4)\n    \nlosses = []\n\nmodel.train()\nfor epoch in range(epochs):\n    optimizer.zero_grad()\n    out = model(data.x, data.edge_index)\n    loss = torch.nn.functional.binary_cross_entropy(out[data.train_mask], data.y[data.train_mask])\n    loss.backward()\n    optimizer.step()\n\n    losses.append(loss.cpu().detach().numpy())\n</pre> epochs = 1000  optimizer = torch.optim.Adam(model.parameters(), lr=0.01, weight_decay=5e-4)      losses = []  model.train() for epoch in range(epochs):     optimizer.zero_grad()     out = model(data.x, data.edge_index)     loss = torch.nn.functional.binary_cross_entropy(out[data.train_mask], data.y[data.train_mask])     loss.backward()     optimizer.step()      losses.append(loss.cpu().detach().numpy()) In\u00a0[17]: Copied! <pre>plt.plot(range(epochs), losses)\nplt.grid()\n</pre> plt.plot(range(epochs), losses) plt.grid() <p>We evaluate the model in the test set and calculate the adjusted mutual information for the ground truth.</p> In\u00a0[31]: Copied! <pre>model.eval()\npredicted_groups = model(data.x, data.edge_index).round().long()\nmetrics.adjusted_mutual_info_score(data.y[data.test_mask].squeeze().cpu().numpy(), predicted_groups[data.test_mask].squeeze().cpu().numpy())\n</pre> model.eval() predicted_groups = model(data.x, data.edge_index).round().long() metrics.adjusted_mutual_info_score(data.y[data.test_mask].squeeze().cpu().numpy(), predicted_groups[data.test_mask].squeeze().cpu().numpy()) Out[31]: <pre>1.0</pre> <p>We visualize node representations learned by the model. The training nodes are colored, while test nodes are greyed out.</p> In\u00a0[32]: Copied! <pre># get activations in first-layer\nembedding = model[0].forward(data.x, data.edge_index)\n\n# dimensionality reduction\nsvd = TruncatedSVD()\nlow_dim = svd.fit_transform(embedding.cpu().detach().numpy())\n\n# plot with colors corresponding to groups in validation set\ncolors = {}\nfor v in range(g.N):\n    if data.val_mask[v]:\n        colors[v] = 'grey'\n    else:\n        if data.y[v].item() == 0.0:\n            colors[v] = 'blue'\n        else:\n            colors[v] = 'orange'\n\nplt.scatter(low_dim[:,0], low_dim[:,1], c=colors.values());\n</pre> # get activations in first-layer embedding = model[0].forward(data.x, data.edge_index)  # dimensionality reduction svd = TruncatedSVD() low_dim = svd.fit_transform(embedding.cpu().detach().numpy())  # plot with colors corresponding to groups in validation set colors = {} for v in range(g.N):     if data.val_mask[v]:         colors[v] = 'grey'     else:         if data.y[v].item() == 0.0:             colors[v] = 'blue'         else:             colors[v] = 'orange'  plt.scatter(low_dim[:,0], low_dim[:,1], c=colors.values()); <p>This simple code gives you thousands of networks with various meta information at your fingertips, to wich you can directly apply graph learning models provided in pyG, or deep graoh learning architectures defined by yourself.</p>"},{"location":"tutorial/netzschleuder/#accessing-the-netzschleuder-repository","title":"Accessing the Netzschleuder Repository\u00b6","text":""},{"location":"tutorial/netzschleuder/#motivation-and-learning-objectives","title":"Motivation and Learning Objectives\u00b6","text":"<p>Access to a large number of graphs with different topological characteristics and from different domains is crucial for the development and evaluation of graph learning methods. Tousands of graph data sets are available scattered throughout the web, possibly using different data formats and with missing information on their actual origin. Addressing this issue the Netschleuder Online Repository by Tiago Peixoto provides a single repository of graphs in a single format, including descriptions, citations, and node-/edge- or graph-level meta-data. To facilitate the development of graph learning techniques, pathpyG provides a feature that allows to directly read networks from the netzschleuder repository via an API.</p> <p>In this brief unit, we will learn how we can retrieve network records and graph data from the netzschleuder repository. We will further demonstrate how we can conveniently apply a Graph Neural Network to predict node-level categories contained in the meta-data.</p> <p>We first need to import a few modules.</p>"},{"location":"tutorial/netzschleuder/#reading-graphs-from-the-netzschleuder-repository","title":"Reading graphs from the netzschleuder repository\u00b6","text":"<p>In the <code>pathpy.io</code> module, there is a function that allows to read graph data from the API.</p> <p>We can read a given networks from the netzschleuder database using its record name. Just browse the Netschleuder Online Repository to find the record names. In the following, we use a graph capturing co-purchase relationships between political books.</p>"},{"location":"tutorial/netzschleuder/#applying-graph-neural-networks-to-netzschleuder-data","title":"Applying Graph Neural Networks to Netzschleuder Data\u00b6","text":""},{"location":"tutorial/paths_higher_order/","title":"Paths and Higher-Order Models","text":"In\u00a0[1]: Copied! <pre>import torch\nimport pathpyG as pp\n\npp.config['torch']['device'] = 'cpu'\n</pre> import torch import pathpyG as pp  pp.config['torch']['device'] = 'cpu' In\u00a0[3]: Copied! <pre>g = pp.Graph.from_edge_list([['a', 'c'], ['b', 'c'], ['c', 'd'], ['c', 'e']])\npp.plot(g);\n</pre> g = pp.Graph.from_edge_list([['a', 'c'], ['b', 'c'], ['c', 'd'], ['c', 'e']]) pp.plot(g); <p>Let us now assume that we have additional data that captures two observations each for the following two paths (or walks) of length two:</p> <ul> <li>2 x <code>a</code> -&gt; <code>c</code> -&gt; <code>d</code></li> <li>2 x <code>b</code> -&gt; <code>c</code> -&gt; <code>e</code></li> </ul> <p>Note that we define the length of a path or walk as the number of edges that are traversed, i.e. a sequence that consists of a single node, e.g. <code>a</code> is a walk or path of length zero, while every edge in a graph is a walk or path of length one.</p> <p>The <code>PathData</code> object in <code>pathpyG</code> can be used to store such observations of paths or walks of length $l$ in the form of tensor with shape $(2,l)$. To manually construct an instance of <code>PathData</code> we can just create an empty instance and then add observations.</p> <p>In the following, we will use the mapping node IDs to indices from the Graph above:</p> In\u00a0[20]: Copied! <pre>g.node_index_to_id\n</pre> g.node_index_to_id Out[20]: <pre>{0: 'a', 1: 'c', 2: 'b', 3: 'd', 4: 'e'}</pre> <p>With this mapping, we can use the following ordered <code>edge_index</code> with source and target node indices to represent the walk <code>a</code> -&gt; <code>c</code> -&gt; <code>d</code>:</p> <p><code>[[0,2],</code> # source node indices for <code>a</code> and <code>c</code> <code> [2,3]]</code>   # target node indices for <code>c</code> and <code>d</code></p> <p>It is easy to see that this representation naturally extends the <code>edge_index</code> semantics of <code>pyG</code>. It will further allow us to efficiently generate higher-order De Bruijn graph models for path data based on a convolution operation that can actually be executed on the GPU.</p> <p>For our data set, we can add two walks as follows, where each walk is observed two times.</p> In\u00a0[106]: Copied! <pre>paths = pp.PathData()\npaths.add_walk(torch.tensor([[0,2],[2,3]]), freq=2) # a -&gt; c -&gt; d\npaths.add_walk(torch.tensor([[1,2],[2,4]]), freq=2) # b -&gt; c -&gt; e\n</pre> paths = pp.PathData() paths.add_walk(torch.tensor([[0,2],[2,3]]), freq=2) # a -&gt; c -&gt; d paths.add_walk(torch.tensor([[1,2],[2,4]]), freq=2) # b -&gt; c -&gt; e <p>After adding the four walks, we can directly access an aggregate graph representation of the paths:</p> In\u00a0[53]: Copied! <pre>print(f'Paths traverse {paths.num_nodes} nodes via {paths.num_edges}')\nprint(paths.edge_index)\n</pre> print(f'Paths traverse {paths.num_nodes} nodes via {paths.num_edges}') print(paths.edge_index) <pre>Paths traverse 5 nodes via 4\ntensor([[0, 1, 2, 2],\n        [2, 2, 3, 4]])\n</pre> <p>We can also create a weighted <code>edge_index</code> where each traversed edge occurs only once, and the weights capture the number of times each edge is traversed. This function returnes two tensors, the first one being the edge_index and the second one being the edge weights.</p> In\u00a0[54]: Copied! <pre>print(paths.edge_index_weighted)\n</pre> print(paths.edge_index_weighted) <pre>(tensor([[0, 1, 2, 2],\n        [2, 2, 3, 4]]), tensor([2., 2., 2., 2.]))\n</pre> <p>Naturally, for real data on observed walks in graphs it is not convenient to manually construct and add walks based on edge tensors. For such data, we can load paths from an n-gram file, i.e. a text file where each line correponds to one observed path consisting of comma-separated node IDs. The last component of each line is considered to be the observation count of that particular walk.</p> <p>As an example, the file <code>data/tube_paths_train.ngram</code> contains observed passenger itineraries between stations in the London Tube network, along with their observation frequencies. The following is an excerpt from that file:</p> <pre><code>Southwark,Waterloo,212.0\nLiverpool Street,Bank / Monument,1271.0\nBarking,West Ham,283.0\nTufnell Park,Kentish Town,103.0\n...\n</code></pre> In\u00a0[55]: Copied! <pre>paths_tube = pp.PathData.from_csv('../data/tube_paths_train.ngram', sep=',')\nprint(paths_tube)\nprint(f'London Tube network has {paths_tube.num_nodes} nodes and {paths_tube.num_edges} edges.')\n</pre> paths_tube = pp.PathData.from_csv('../data/tube_paths_train.ngram', sep=',') print(paths_tube) print(f'London Tube network has {paths_tube.num_nodes} nodes and {paths_tube.num_edges} edges.') <pre>PathData with 61748 walks and 0 dags\nLondon Tube network has 268 nodes and 646 edges.\n</pre> <p>In the example above, our observations exclusively consisted of walks, i.e. simple sequences of traversed nodes. Let's now have a look how walks are internally stored in the <code>PathData</code> object. Each observation in the <code>PathData</code> object is internally assigned an integer identifier and there are three dictionaries that store (i) the tensors capturing the observed path, (ii) their frequencies, and (iii) the type of the observation.</p> In\u00a0[36]: Copied! <pre>paths.paths\n</pre> paths.paths Out[36]: <pre>{0: tensor([[0, 2],\n         [2, 3]]),\n 1: tensor([[1, 2],\n         [2, 4]])}</pre> <p>For the sake of convenience, there is a helper function that can be used to transform the tensor-based <code>edge_index</code> representation of a given walk into a simple sequence of traversed nodes, i.e. for the walk with index 0 above we get the node index sequence <code>[0,2,3]</code>:</p> In\u00a0[48]: Copied! <pre>pp.PathData.walk_to_node_seq(paths.paths[0])\n</pre> pp.PathData.walk_to_node_seq(paths.paths[0]) Out[48]: <pre>tensor([0, 2, 3])</pre> <p>The frequencies of walks are stored in the dictionary <code>path_freq</code>.</p> In\u00a0[56]: Copied! <pre>paths.path_freq\n</pre> paths.path_freq Out[56]: <pre>{0: 2, 1: 2}</pre> <p>There is a third dictionary that stores the type of paths:</p> In\u00a0[57]: Copied! <pre>paths.path_types\n</pre> paths.path_types Out[57]: <pre>{0: &lt;PathType.WALK: 0&gt;, 1: &lt;PathType.WALK: 0&gt;}</pre> In\u00a0[109]: Copied! <pre>paths = pp.PathData()\npaths.node_id = ['a', 'b', 'c', 'd']\npaths.add_dag(torch.tensor([[0, 1, 1],\n                            [1, 2, 3]]),\n                        freq=2)\n</pre> paths = pp.PathData() paths.node_id = ['a', 'b', 'c', 'd'] paths.add_dag(torch.tensor([[0, 1, 1],                             [1, 2, 3]]),                         freq=2) <p>In pathpyG, we can actually mix observations of walks and DAGs, i.e. we can additionally add two observations of a walk <code>a</code> -&gt; <code>b</code> -&gt; <code>c</code> -&gt; <code>d</code> to our <code>PathData</code> object as follows:</p> In\u00a0[110]: Copied! <pre>paths.add_walk(torch.tensor([[0, 1, 2], \n                             [1, 2, 3]]), \n                             freq=2)\n</pre> paths.add_walk(torch.tensor([[0, 1, 2],                               [1, 2, 3]]),                               freq=2) <p>We can now again inspect the internal dictionaries holding our data, which now consists of two tensors with different types:</p> In\u00a0[111]: Copied! <pre>print(paths.paths)\nprint(paths.path_types)\nprint(paths.path_freq)\n</pre> print(paths.paths) print(paths.path_types) print(paths.path_freq) <pre>{0: tensor([[0, 1, 1],\n        [1, 2, 3]]), 1: tensor([[0, 1, 2],\n        [1, 2, 3]])}\n{0: &lt;PathType.DAG: 1&gt;, 1: &lt;PathType.WALK: 0&gt;}\n{0: 2, 1: 2}\n</pre> <p>At first glance, it may actually seem unnecessary to distinguish between walks and DAGs, as a walk is simply a special type of a DAG, where all nodes have in- and out-degrees smaller or equal than one. And indeed, you could simply ignore this distinction and store both walks and DAGs as a DAG. Nevertheless, <code>pathpyG</code> explicitly dinstiguishes between the two types of path data, since some downstream operations - specifically the creation of higher-order De Bruijn graph models - are much faster for walks (which are essentially just sequences of nodes) than for DAGs  (which can have arbitrarily complex structures). It is thus advisable to explicitly store walk data as WALK. To improve the scalability of  path calculations in temporal graphs, <code>pathpyG</code> will further detect whether the resulting paths actually require a DAG representation, automatically choosing the most efficient representation.</p> <p>As shown before, we can use the <code>PathData</code> class to easily generate an <code>edge_index</code> tensor of a weighted graph representation, which essentially aggregates all of the observed walks and DAGs into a weighted static graph. For the example above, this graph has four nodes connected by four edges that have weights four and two.</p> In\u00a0[112]: Copied! <pre>edge_index, edge_weight = paths.edge_index_weighted\nprint(edge_index)\nprint(edge_weight)\n</pre> edge_index, edge_weight = paths.edge_index_weighted print(edge_index) print(edge_weight) <pre>tensor([[0, 1, 1, 2],\n        [1, 2, 3, 3]])\ntensor([4., 4., 2., 2.])\n</pre> <p>Let's have a look at a visualization of this graph:</p> In\u00a0[113]: Copied! <pre>g = pp.Graph(edge_index, edge_weight=edge_weight, node_id = paths.node_id)\npp.plot(g);\n</pre> g = pp.Graph(edge_index, edge_weight=edge_weight, node_id = paths.node_id) pp.plot(g); <p>This is a first-order graph representation, as it only captures the (weighted) edges in the underlying path data, i.e. we could say that we only count the paths of length one. This naturally gives rise to an <code>edge_index</code> tensor with shape $(2,m)$, where $m$ is the number of unique edges in the graph that are traversed by the paths.</p> <p>A key feature of <code>pathpyG</code> is it allows to generalize this first-order modelling perspective to $k$-th order De Bruijn graph models for paths, where the nodes in a $k$-th order De Bruijn graph model are sequences of $k$ nodes. Edges connect pairs of nodes that overlap in $k-1$ nodes and capture paths of length $k$.</p> <p>A De Bruijn graph of order $k=1$ is simply a normal (weighted) graph consisting of nodes and edges. Fere the pairs of nodes connected by edges overlap in $k-1=0$ nodes and capture paths of length $k=1$, i.e. simple edges in the underlying path data.</p> <p>For a De Bruijn graph with order $k=2$, in our example above, an edge could connect a pair of nodes $[a,b]$ and $[b,c]$ overlapping in the $k-1=1$ node $b$ and such an edge would represent the path $a -&gt; b -&gt; c$ of length two.</p> <p>In <code>pathpyG</code>, we can directly calculate the <code>edge_index</code> for a $k$-th order De Bruijn graph model of the paths contained in a <code>PathData</code> object. For our example, we can do this as follows:</p> In\u00a0[114]: Copied! <pre>i, w = paths.edge_index_k_weighted(k=2)\nprint('higher-order edges =', i)\nprint('weights =', w)\n</pre> i, w = paths.edge_index_k_weighted(k=2) print('higher-order edges =', i) print('weights =', w) <pre>higher-order edges = tensor([[[0, 1],\n         [0, 1],\n         [1, 2]],\n\n        [[1, 2],\n         [1, 3],\n         [2, 3]]])\nweights = tensor([4., 2., 2.])\n</pre> <p>Naturally extending the <code>pyG</code>-style <code>edge_index</code> to a higher-dimensional representation, the edge_index of a k-th De Bruijn graph model with m edges has the shape [2,m,k], i.e. it consists of a src and dst tensor with $m$ entries, where each entry is a k-dimensional tensor that contains the k nodes in the graph that constitute the higher-order node. For the example above, each node is thus actually a tensor with two elements.</p> <p>While this go way beyond the scope of the tutorial, thanks to the tensor-based representation of walks and DAGs in the <code>PathData</code> object, the construction of a higher-order De Bruijn graph model can actually be done based on efficient GPU operations, i.e. we can scale up the models for large graphs.</p> <p>We can use paths to generate k-th order graphs that can be used for GNNs. To make access to nodes and edges convenient, we can pass a node_id mapping that assigns string IDs to the indices of the first-order nodes:</p> In\u00a0[142]: Copied! <pre>g2 = pp.HigherOrderGraph(paths, order=2, node_id=paths.node_id)\nprint(g2)\npp.plot(g2);\n</pre> g2 = pp.HigherOrderGraph(paths, order=2, node_id=paths.node_id) print(g2) pp.plot(g2); <pre>HigherOrderGraph (k=2) with 4 nodes and 3 edges\n\tTotal edge weight = 8.0\nNode attributes\n\tnode_id\t\t&lt;class 'list'&gt;\n\nEdge attributes\n\tedge_weight\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([3])\n\nGraph attributes\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\n</pre> <p>Just like for a \"normal\" first-order graph, we can iterate through the nodes of a higher-order graph, which are tuples with k elements:</p> In\u00a0[128]: Copied! <pre>for n in g2.nodes:\n    print(n)\n</pre> for n in g2.nodes:     print(n) <pre>('a', 'b')\n('b', 'c')\n('b', 'd')\n('c', 'd')\n</pre> <p>Edges are tuples with two elements, where each element is a k-th order node:</p> In\u00a0[129]: Copied! <pre>for e in g.edges:\n    print(e)\n</pre> for e in g.edges:     print(e) <pre>(('a', 'b', 'c'), ('b', 'c', 'd'))\n</pre> <p>The weight attribute stores a tensor whose entries capture the frequencies of edges, i.e. the frequencies of paths of length $k$.</p> In\u00a0[133]: Copied! <pre>for e in g2.edges:\n    print(e, g2['edge_weight', e[0], e[1]].item())\n</pre> for e in g2.edges:     print(e, g2['edge_weight', e[0], e[1]].item()) <pre>(('a', 'b'), ('b', 'c')) 4.0\n(('a', 'b'), ('b', 'd')) 2.0\n(('b', 'c'), ('c', 'd')) 2.0\n</pre> In\u00a0[134]: Copied! <pre>g3 = pp.HigherOrderGraph(paths, order=3, node_id=paths.node_id)\nprint(g3)\n</pre> g3 = pp.HigherOrderGraph(paths, order=3, node_id=paths.node_id) print(g3) <pre>HigherOrderGraph (k=3) with 2 nodes and 1 edges\n\tTotal edge weight = 2.0\nEdge attributes\n\tedge_weight\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([1])\n\nGraph attributes\n\tnode_id\t\t&lt;class 'list'&gt;\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\n</pre> In\u00a0[140]: Copied! <pre>edge_index, edge_weight = paths.edge_index_k_weighted(k=3)\nprint(edge_index)\nprint(edge_weight)\n</pre> edge_index, edge_weight = paths.edge_index_k_weighted(k=3) print(edge_index) print(edge_weight) <pre>tensor([[[0, 1, 2]],\n\n        [[1, 2, 3]]])\ntensor([2.])\n</pre> In\u00a0[141]: Copied! <pre>for e in g3.edges:\n    print(e, g3['edge_weight', e[0], e[1]].item())\n</pre> for e in g3.edges:     print(e, g3['edge_weight', e[0], e[1]].item()) <pre>(('a', 'b', 'c'), ('b', 'c', 'd')) 2.0\n</pre> <p>As we shall see in the following tutorial, the ``PathData<code>and the</code>HigherOrderGraph` classes are the basis for the GPU-based analysis and modelling of causal structures in temporal graphs. In particular, the underlying generalization of first-order static graph models to higher-order De Bruijn graphs allows us to easily build causality-aware graph neural network architectures that consider both the topology and the temoral ordering of time-stamped edges in a temporal graph.</p>"},{"location":"tutorial/paths_higher_order/#path-data-and-higher-order-de-bruijn-graphs","title":"Path Data and Higher-Order De Bruijn Graphs\u00b6","text":""},{"location":"tutorial/paths_higher_order/#motivation-and-learning-objective","title":"Motivation and Learning Objective\u00b6","text":"<p>While <code>pathpyG</code> is useful to handle static graphs - as the name suggests - its main advantage is that it facilitates the GPU-based analysis of time series data capturing paths in networks. As we shall see in the following tutorial, there are various types of data that naturally give rise to paths, including (random) walks or trajectories in networks, traces of dynamical processes giving rise to directed acyclic graphs, or temporal graphs with time-stamped edges. ``pathpyG` allows to model patterns in such graphs based on higher-order De Bruijn graph models, a modelling framework that naturally extends well-known graph models to causal topologies in temporal graphs.</p> <p>In this first unit, we will introduce the <code>PathData</code> class, which can be used to store data on walks and directed acyclic graphs. We will show how such data are internally stored as torch Tensors, and how this approach faciliattes the GPU-based gemeration of higher-order De Bruijn graph models, a modelling approach that is able to captures higher-order correlations in time series data, and which facilitates graph learning and network analysis tasks.</p> <p>As before, we first import the modules <code>torch</code> and <code>pathpyG</code>. By setting the device used by <code>torch</code>, we can pecify whether we want to run our code on the CPU or on the GPU. If you want to run your code on the GPU, just set the device to <code>cuda</code>.</p>"},{"location":"tutorial/paths_higher_order/#modelling-walks-in-a-graph","title":"Modelling Walks in a Graph\u00b6","text":"<p>Let us consider a simple graph consisting of five nodes <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code> and four edges. The graph is shown below:</p>"},{"location":"tutorial/paths_higher_order/#loading-empirical-walks-from-n-gram-files","title":"Loading empirical walks from N-Gram Files\u00b6","text":""},{"location":"tutorial/paths_higher_order/#from-walks-to-dags","title":"From Walks to DAGs\u00b6","text":"<p>We see that this corresponds to our two walks, each being observed two times. But what is the point of explicitly storing the type of an observation as a walk? What other types of path data can be stored and analyzed in <code>pathpyG</code>?</p> <p>A major feature of <code>pathpyG</code> is that it allows us to model the causal topology of temporal graph data, i.e. the topology of time-stamped edges by which nodes can causally influence each other via time-respecting paths, i.e. paths that must (minimally) follow the arrow of time.</p> <p>As we shall see in the next tutorial, time-respecting paths in temporal graphs naturally give rise to directed acyclic graphs, where the directionality of edges is due to the directionality of the arrow of time. A very simple example for a DAG is one that consists of the following edges:</p> <p><code>a</code> -&gt; <code>b</code> <code>b</code> -&gt; <code>c</code> <code>b</code> -&gt; <code>d</code></p> <p>This DAG captures that node <code>a</code> causally influences node <code>b</code>, which in turn causally influences the two nodes <code>c</code> and <code>d</code>, potentially at a later point in time. In <code>pathpyG</code>, such a DAG can be represented by a topologically ordered edge index, where the order of edges corresponds to the topological ordering. For the example above, and assuming the same node ID mapping as in the example before, we can thus add two observations of this DAG to a <code>pathData</code> object as follows:</p>"},{"location":"tutorial/paths_higher_order/#higher-order-de-bruijn-graph-models-of-paths","title":"Higher-Order De Bruijn Graph Models of Paths\u00b6","text":""},{"location":"tutorial/temporal_graphs/","title":"Temporal Graphs","text":"In\u00a0[33]: Copied! <pre>import torch\nfrom torch_geometric.data import TemporalData\nimport numpy as np\nimport pathpyG as pp\n\npp.config['torch']['device'] = 'cpu'\n</pre> import torch from torch_geometric.data import TemporalData import numpy as np import pathpyG as pp  pp.config['torch']['device'] = 'cpu' <p>Let's start with a simple temporal graph with four nodes <code>a</code>,<code>b</code>,<code>c</code>,<code>d</code> and seven timestamped edges <code>(b,c;2)</code>,<code>(a,b;1)</code>,<code>(c,d;3)</code>,<code>(d,a;4)</code>,<code>(b,d;2)</code>, <code>(d,a;6)</code>,<code>(a,b;7)</code>.</p> <p>The following code generates this temporal graph from the given edge list.</p> In\u00a0[34]: Copied! <pre>g = pp.TemporalGraph.from_edge_list([['b', 'c', 2],['a', 'b', 1], ['c', 'd', 3], ['d', 'a', 4], ['b', 'd', 2], ['d', 'a', 6], ['a', 'b', 7]])\nprint(g)\n</pre> g = pp.TemporalGraph.from_edge_list([['b', 'c', 2],['a', 'b', 1], ['c', 'd', 3], ['d', 'a', 4], ['b', 'd', 2], ['d', 'a', 6], ['a', 'b', 7]]) print(g) <pre>Temporal Graph with 4 nodes 5 edges and 7 time-stamped events in [1, 7]\n\nNode attributes\n\tnode_id\t\t&lt;class 'list'&gt;\n\nGraph attributes\n\tt\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([7])\n\tsrc\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([7])\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\tdst\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([7])\n\n</pre> <p>We can visualize a temporal graph by using the pathpyG plot function.</p> In\u00a0[35]: Copied! <pre>pp.plot(g, edge_color='lightgray')\n</pre> pp.plot(g, edge_color='lightgray') Out[35]: <pre>&lt;pathpyG.visualisations.network_plots.TemporalNetworkPlot at 0x16e7b5240&gt;</pre> <p>Consistent with <code>pyG</code> the sources, destinations and timestamps are stored as a <code>pyG TemporalData</code> object, which we can access in the following way.</p> In\u00a0[36]: Copied! <pre>g.data\n</pre> g.data Out[36]: <pre>TemporalData(src=[7], dst=[7], t=[7], node_id=[4], num_nodes=4, edge_index=[2, 7])</pre> In\u00a0[37]: Copied! <pre>print(g.data.t)\n</pre> print(g.data.t) <pre>tensor([1, 2, 2, 3, 4, 6, 7])\n</pre> <p>With the generator functions <code>edges</code> and <code>temporal_edges</code> we can iterate through the (temporal) edges of this graph.</p> In\u00a0[38]: Copied! <pre>for v, w in g.edges:\n    print(v, w)\n</pre> for v, w in g.edges:     print(v, w) <pre>a b\nb c\nb d\nc d\nd a\nd a\na b\n</pre> In\u00a0[39]: Copied! <pre>for v, w, t in g.temporal_edges:\n    print(v, w, t)\n</pre> for v, w, t in g.temporal_edges:     print(v, w, t) <pre>a b 1\nb c 2\nb d 2\nc d 3\nd a 4\nd a 6\na b 7\n</pre> <p>We are often interested in the time respecting paths of a temporal graph.</p> <p>A time respecting path is defined as a sequence of nodes $v_0,...,v_l$ where the corresponding edges occur in the right time ordering and with a maximum time difference of $\\delta\\in \\N$.</p> <p>In order to extract those paths out of a temporal graph, we have to construct a time-unfolded directed acyclic graph (DAG) that represents the network and captures all causal structures.</p> <p>The nodes of a DAG are node-time-events of the temporal graph, i.e a node <code>a-t</code> represents the node <code>a</code> at time <code>t</code>.</p> <p>Two nodes <code>a-t</code> and <code>b-t'</code> are connected (with exceptions, see code ) if <code>a-t</code> directly influences <code>b-t'</code></p> In\u00a0[40]: Copied! <pre>dag = pp.algorithms.temporal_graph_to_event_dag(g, delta=1)\nprint(dag)\n\nprint(dag.data['node_id'])\nprint(dag.data.edge_index)\n\npp.plot(dag, edge_color='lightgray')\n</pre> dag = pp.algorithms.temporal_graph_to_event_dag(g, delta=1) print(dag)  print(dag.data['node_id']) print(dag.data.edge_index)  pp.plot(dag, edge_color='lightgray') <pre>Graph with 9 nodes and 7 edges\n\nNode attributes\n\tnode_id\t\t&lt;class 'list'&gt;\n\tnode_name\t\t&lt;class 'list'&gt;\n\tnode_idx\t\t&lt;class 'list'&gt;\n\nEdge attributes\n\tedge_ts\t\t&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([7])\n\nGraph attributes\n\tnum_nodes\t\t&lt;class 'int'&gt;\n\n['a-1', 'b-2', 'c-3', 'd-3', 'd-4', 'a-5', 'd-6', 'a-7', 'b-8']\ntensor([[0, 1, 1, 2, 4, 6, 7],\n        [1, 2, 3, 4, 5, 7, 8]])\n</pre> Out[40]: <pre>&lt;pathpyG.visualisations.network_plots.StaticNetworkPlot at 0x16e76fd60&gt;</pre> <p>With the following code, we can extract DAGs with only one single root node, which is not influenced by any other node-time event in the temporal graph.</p> In\u00a0[42]: Copied! <pre>x = pp.algorithms.extract_causal_trees(dag)\nprint(x)\n</pre> x = pp.algorithms.extract_causal_trees(dag) print(x) <pre>{'a-1': tensor([[0, 1, 1, 2, 4],\n        [1, 2, 3, 4, 5]], dtype=torch.int32), 'd-6': tensor([[6, 7],\n        [7, 8]], dtype=torch.int32)}\n</pre> <p>With the DAG, we can now extract the time-respecting paths in our temporal graph.</p> In\u00a0[43]: Copied! <pre>paths = pp.PathData.from_temporal_dag(dag)\nprint(paths.paths[0])\nprint(paths.paths[1])\nprint(g.node_index_to_id)\n</pre> paths = pp.PathData.from_temporal_dag(dag) print(paths.paths[0]) print(paths.paths[1]) print(g.node_index_to_id) <pre>tensor([[0, 1, 1, 2, 4],\n        [1, 2, 3, 4, 5]])\ntensor([[6, 7],\n        [7, 8]])\n{0: 'b', 1: 'c', 2: 'a', 3: 'd'}\n</pre> <p>The path data allows us to construct a Higher-Order De Bruijn Graph model belong to our temporal network.</p> In\u00a0[45]: Copied! <pre>g2 = pp.HigherOrderGraph(paths, order=2, node_id=g.data['node_id'])\npp.plot(g2)\n</pre> g2 = pp.HigherOrderGraph(paths, order=2, node_id=g.data['node_id']) pp.plot(g2) Out[45]: <pre>&lt;pathpyG.visualisations.network_plots.StaticNetworkPlot at 0x16e7b4130&gt;</pre> <p>In a nutshell, the following shows the steps that are needed to construct a Higher Order Graph. Here we construct our temporal graph from a <code>pyG TemporalData</code> by providing the sources, distances and timestamps.</p> In\u00a0[52]: Copied! <pre># Create temporal network\nd = TemporalData(src=[0,2,1,2,0,2,1,2], dst=[2,3,2,4,2,3,2,4], t=[1,2,3,4,5,6,7,8])\ng = pp.TemporalGraph.from_pyg_data(d, node_id=['a', 'b', 'c', 'd', 'e'])\n\n# Create event DAG and extract path data\ndag = pp.algorithms.temporal_graph_to_event_dag(g, delta=1)\npaths = pp.PathData.from_temporal_dag(dag)\n\n# Create Higher Order Graph\ng2 = pp.HigherOrderGraph(paths, order=2, node_id=g.data.node_id)\npp.plot(g2)\n</pre> # Create temporal network d = TemporalData(src=[0,2,1,2,0,2,1,2], dst=[2,3,2,4,2,3,2,4], t=[1,2,3,4,5,6,7,8]) g = pp.TemporalGraph.from_pyg_data(d, node_id=['a', 'b', 'c', 'd', 'e'])  # Create event DAG and extract path data dag = pp.algorithms.temporal_graph_to_event_dag(g, delta=1) paths = pp.PathData.from_temporal_dag(dag)  # Create Higher Order Graph g2 = pp.HigherOrderGraph(paths, order=2, node_id=g.data.node_id) pp.plot(g2) Out[52]: <pre>&lt;pathpyG.visualisations.network_plots.StaticNetworkPlot at 0x16e76f610&gt;</pre> <p>We can also skip the step of creating an event DAG by just using the following code.</p> In\u00a0[53]: Copied! <pre>g2 = pp.HigherOrderGraph.from_temporal_graph(g, delta=1, order=2)\npp.plot(g2)\n</pre> g2 = pp.HigherOrderGraph.from_temporal_graph(g, delta=1, order=2) pp.plot(g2) Out[53]: <pre>&lt;pathpyG.visualisations.network_plots.StaticNetworkPlot at 0x16e7b6ec0&gt;</pre>"},{"location":"tutorial/temporal_graphs/#temporal-graphs-and-path-data","title":"Temporal Graphs and Path Data\u00b6","text":""},{"location":"tutorial/temporal_graphs/#motivation-and-learning-objectives","title":"Motivation and Learning Objectives\u00b6","text":"<p>In this tutorial we will introduce the representation of temporal graph data in the <code>Temporal Graph</code> class and how such data can be used to calculate time respecting paths.</p>"},{"location":"tutorial/temporal_graphs/#temporal-graphs","title":"Temporal Graphs\u00b6","text":""},{"location":"tutorial/temporal_graphs/#extracting-causal-topologies-via-node-time-event-dags","title":"Extracting Causal Topologies via Node-Time Event DAGs\u00b6","text":""},{"location":"tutorial/temporal_graphs/#higher-order-de-bruijn-graph-models-for-causal-paths","title":"Higher-Order De Bruijn Graph Models for Causal Paths\u00b6","text":""},{"location":"tutorial/visualisation/","title":"Interactive Graph Visualisation","text":"In\u00a0[1]: Copied! <pre>import pathpyG as pp\nimport torch\nprint('Running on', pp.config['torch']['device'])\n</pre> import pathpyG as pp import torch print('Running on', pp.config['torch']['device']) <pre>Running on cuda\n</pre> <p>With these preparations complete, we are ready to construct our first graph. This is achieved through the <code>Graph.from_edge_list</code> constructor provided by <code>pathpyG</code>, a method that allows us to transform a list of edges into a basic graphical representation.</p> In\u00a0[2]: Copied! <pre>g = pp.Graph.from_edge_list([['a', 'b'], ['c','b']])\ng.to_undirected()\n</pre> g = pp.Graph.from_edge_list([['a', 'b'], ['c','b']]) g.to_undirected() <p>After successfully creating a simple graph using <code>pathpyG</code>, our next step is to examine its structure. This is a crucial part of the process as it gives us an initial understanding of the complexity and scale of our graph. By printing out the number of nodes and edges, we gain insight into the size and connectivity of the graph.</p> <p>Although it may seem unnecessary for this simple graph, it's good practice to gather information about the number of nodes and edges before attempting to visualize it. This preemptive step is crucial, especially when dealing with larger graphs. Visualizing extensive networks can be a time-consuming or even unfeasible task, depending on the sheer volume of elements that need to be represented. Therefore, understanding the graph's scale upfront helps in efficiently planning the visualization process and avoiding potential complications that could arise with larger datasets.</p> In\u00a0[3]: Copied! <pre>f'Our graph has {g.N} nodes and {g.M} edges.'\n</pre> f'Our graph has {g.N} nodes and {g.M} edges.' Out[3]: <pre>'Our graph has 3 nodes and 4 edges.'</pre> In\u00a0[4]: Copied! <pre>pp.plot(g)\n</pre> pp.plot(g) Out[4]: <pre>&lt;pathpyG.visualisations.network_plots.StaticNetworkPlot at 0x7fe1b9347670&gt;</pre> In\u00a0[5]: Copied! <pre>pp.plot(g,backend='matplotlib');\n</pre> pp.plot(g,backend='matplotlib'); In\u00a0[6]: Copied! <pre>pp.plot(g,backend='matplotlib',layout='fr')\n</pre> pp.plot(g,backend='matplotlib',layout='fr') Out[6]: <pre>&lt;pathpyG.visualisations.network_plots.StaticNetworkPlot at 0x7fe192eaf9d0&gt;</pre> <p>Additionally, <code>pathpyG</code> offers the flexibility to incorporate custom layout algorithms. If you have developed your own method or have specific requirements for node positioning, you can directly provide the node coordinates to the visualization. This capability ensures that <code>pathpyG</code> can cater to a wide range of visualization needs, from simple and automatic layouts to highly customized and complex arrangements, making it a versatile tool in the field of data visualization.</p> In\u00a0[7]: Copied! <pre>layout = {'a':[0,0],'b':[1,1],\"c\":[2,2]}\npp.plot(g,backend='matplotlib',layout=layout)\n</pre> layout = {'a':[0,0],'b':[1,1],\"c\":[2,2]} pp.plot(g,backend='matplotlib',layout=layout) Out[7]: <pre>&lt;pathpyG.visualisations.network_plots.StaticNetworkPlot at 0x7fe2986ee440&gt;</pre> In\u00a0[8]: Copied! <pre>style = {}\nstyle['node_color'] = (255,1,255) # RGB tuple\nstyle['edge_color'] = 'green'     # Color name as str\npp.plot(g,**style)\n</pre> style = {} style['node_color'] = (255,1,255) # RGB tuple style['edge_color'] = 'green'     # Color name as str pp.plot(g,**style) Out[8]: <pre>&lt;pathpyG.visualisations.network_plots.StaticNetworkPlot at 0x7fe192f482b0&gt;</pre> <p>In <code>pathpyG</code>, there are various methods for assigning styles to objects, each offering a different level of customization and control. A straightforward approach, as previously shown, involves using a single value, such as a color string (e.g., <code>'green'</code>) or an RGB tuple (e.g., <code>(255,1,255)</code>). Applying this single value uniformly alters the appearance of all elements within a specific category, providing a quick and easy way to set a general style. However, for more detailed styling, one can utilize a <code>list</code> of values. In this approach, each value in the <code>list</code> is associated with an element according to its index position. This method is particularly familiar and efficient when working with tensors, where the association of values to elements is often index-based.</p> <p>Additionally, a more tailored approach can be employed through the use of dictionaries. In this case, each element id is paired with a corresponding value in the <code>dict</code>. Elements not included in the dictionary are assigned default values, ensuring that every element is styled, albeit some with custom and others with default styles. The types of values that can be used in these styling methods are diverse, including strings, integers, floats, and tuples, each type depending on the specific styling parameter being adjusted. This flexibility in value types and assignment methods allows for a high degree of customization, enabling the creation of visually distinct and information-rich visualizations.</p> In\u00a0[9]: Copied! <pre>style = {}\nstyle['node_color'] = ['red', 'green','blue'] # list based approach\nstyle['node_size'] = {\"a\":40,\"b\":10, \"c\":25}  # dict based approach\nstyle['node_opacity'] = {\"b\":.5,\"c\":.3}       # missing dict value\nstyle['edge_color'] = ['orange','#00FF00']    # hex based color\npp.plot(g,**style)\n</pre> style = {} style['node_color'] = ['red', 'green','blue'] # list based approach style['node_size'] = {\"a\":40,\"b\":10, \"c\":25}  # dict based approach style['node_opacity'] = {\"b\":.5,\"c\":.3}       # missing dict value style['edge_color'] = ['orange','#00FF00']    # hex based color pp.plot(g,**style) Out[9]: <pre>&lt;pathpyG.visualisations.network_plots.StaticNetworkPlot at 0x7fe192f48430&gt;</pre> In\u00a0[10]: Copied! <pre>from matplotlib.pyplot import get_cmap\nmy_map = get_cmap()\nmy_map\n</pre> from matplotlib.pyplot import get_cmap my_map = get_cmap() my_map Out[10]: viridis  underbad over  In\u00a0[11]: Copied! <pre>style = {}\nstyle['edge_color'] = [1, 9]      # int values\n\nstyle['node_color'] = pp.algorithms.centrality.betweenness_centrality(g)\nstyle['node_cmap'] = my_map       # new color map from matplotlib for nodes\npp.plot(g,**style)\n</pre> style = {} style['edge_color'] = [1, 9]      # int values  style['node_color'] = pp.algorithms.centrality.betweenness_centrality(g) style['node_cmap'] = my_map       # new color map from matplotlib for nodes pp.plot(g,**style) Out[11]: <pre>&lt;pathpyG.visualisations.network_plots.StaticNetworkPlot at 0x7fe192f4b940&gt;</pre> In\u00a0[12]: Copied! <pre>pp.plot(g,filename='test_plot.html')\n</pre> pp.plot(g,filename='test_plot.html') Out[12]: <pre>&lt;pathpyG.visualisations.network_plots.StaticNetworkPlot at 0x7fe192f4bb80&gt;</pre> In\u00a0[13]: Copied! <pre>n = pp.io.read_netzschleuder_network('karate', '77')\n</pre> n = pp.io.read_netzschleuder_network('karate', '77') In\u00a0[14]: Copied! <pre>pp.plot(n)\n</pre> pp.plot(n) <pre>/opt/conda/lib/python3.10/site-packages/torch_geometric/data/storage.py:327: UserWarning: Unable to accurately infer 'num_nodes' from the attribute set '{'node_groups', 'name', 'node_id', 'node_name', 'node__pos', 'tags', 'description', 'citation', 'edge_index', 'url'}'. Please explicitly set 'num_nodes' as an attribute of 'data' to suppress this warning\n  warnings.warn(\n</pre> Out[14]: <pre>&lt;pathpyG.visualisations.network_plots.StaticNetworkPlot at 0x7fe192f4ac50&gt;</pre> In\u00a0[15]: Copied! <pre>node_color = [n['node_groups',v][0] for v in n.nodes]\npp.plot(n, edge_color='gray',node_color=node_color)\n</pre> node_color = [n['node_groups',v][0] for v in n.nodes] pp.plot(n, edge_color='gray',node_color=node_color) Out[15]: <pre>&lt;pathpyG.visualisations.network_plots.StaticNetworkPlot at 0x7fe192f49900&gt;</pre> In\u00a0[16]: Copied! <pre>t = pp.TemporalGraph.from_edge_list(\n        [\n            (\"a\", \"b\", 1),\n            (\"b\", \"c\", 5),\n            (\"c\", \"d\", 9),\n            (\"d\", \"a\", 9),\n            (\"a\", \"b\", 10),\n            (\"b\", \"c\", 10),\n        ]\n    )\n</pre> t = pp.TemporalGraph.from_edge_list(         [             (\"a\", \"b\", 1),             (\"b\", \"c\", 5),             (\"c\", \"d\", 9),             (\"d\", \"a\", 9),             (\"a\", \"b\", 10),             (\"b\", \"c\", 10),         ]     ) In\u00a0[25]: Copied! <pre>pp.plot(t)\n</pre> pp.plot(t) Out[25]: <pre>&lt;pathpyG.visualisations.network_plots.TemporalNetworkPlot at 0x7fe192f4aa70&gt;</pre> <p>Besides the standard formatting options available in <code>pathpyG</code>, temporal plots come with specific options tailored to their unique nature. These specialized settings allow for precise control over the time dimension of the visualization. With the <code>start</code> and <code>end</code> parameters, you can define the exact start time and end time of the simulation, effectively setting the temporal boundaries of your graph. This feature is crucial for focusing on a particular time frame within your dataset. Additionally, the <code>delta</code> option lets you adjust the progression speed through the time steps of your visualization. Here, a value of 1000 translates to a one-second interval, providing a way to calibrate the pace at which the temporal data unfolds. Moreover, the <code>interval</code> option offers the flexibility to either widen or narrow the time intervals considered in the visualization. This feature is particularly useful for either zooming in on finer time-scaled details or zooming out for a broader, more comprehensive view of the temporal dynamics in your network.</p> In\u00a0[27]: Copied! <pre>color = {\"a\": \"blue\", \"b\": \"red\", \"c\": \"green\", \"d\": \"yellow\"}\npp.plot(t,node_color=color,start=-1,end=25,delta=1000)\n</pre> color = {\"a\": \"blue\", \"b\": \"red\", \"c\": \"green\", \"d\": \"yellow\"} pp.plot(t,node_color=color,start=-1,end=25,delta=1000) Out[27]: <pre>&lt;pathpyG.visualisations.network_plots.TemporalNetworkPlot at 0x7fe192f49b10&gt;</pre>"},{"location":"tutorial/visualisation/#interactiv-graph-visualization","title":"Interactiv Graph Visualization\u00b6","text":""},{"location":"tutorial/visualisation/#motivation","title":"Motivation\u00b6","text":"<p>This tutorial is specifically designed to guide you through the process of visualizing your data using <code>pathpyG</code>, an advanced data visualization tool. Data visualization is a crucial aspect of data analysis and interpretation, allowing for the transformation of complex datasets into visually appealing and easy-to-understand formats. pathpyG excels in this area by providing a range of functionalities that cater to both beginners and advanced users. Throughout this tutorial, you will be introduced to the basic and advanced features of pathpyG, empowering you to effectively visualize your data. This will not only enhance your understanding of your data but also enable you to communicate your findings more effectively to others.</p> <p>Visualization is a core concept of <code>pathpyG</code> because it bridges the gap between raw data and meaningful visual representations. We, as humans, are wired to process visual information much more rapidly compared to text or audio. This innate ability enables us to quickly identify patterns, outliers, and trends in visual data. Data visualization leverages this capability by graphically representing data, thereby facilitating the swift interpretation of large and complex datasets. Interactive visualizations further this advantage by allowing users to directly engage with the data, exploring and analyzing it in an intuitive and insightful manner. Whether it's understanding the intricate details of microscopic structures or grasping the dynamics of global phenomena, visualizations are instrumental in helping researchers and analysts gain deeper insights and effectively communicate their findings.</p>"},{"location":"tutorial/visualisation/#learning-objectives","title":"Learning objectives\u00b6","text":"<p>In this tutorial, you will learn to master the art of creating simple yet powerful interactive visualizations using <code>pathpyG</code>. You will learn the nuances of customizing the style of your visualizations, enabling you to tailor them to your specific needs and preferences. This customization extends to the aesthetics, layout, and interactive elements, ensuring that your visualizations are not only informative but also engaging. Additionally, the tutorial covers the essential skills needed to save your visualizations in various formats, making it easier to share your work across different platforms and audiences. Lastly, a significant part of the tutorial is dedicated to creating temporal visualizations. These types of visualizations are particularly useful in understanding and presenting data that changes over time, offering dynamic insights into trends and patterns that static visualizations cannot capture. By the end of this tutorial, you will have a comprehensive understanding of how to effectively use pathpyG to create and customize a wide range of visualizations.</p>"},{"location":"tutorial/visualisation/#lets-get-started","title":"Let's Get Started\u00b6","text":"<p>To embark on our journey of visualizing data with <code>pathpyG</code>, the initial step involves initializing and loading the required modules, a crucial process that sets the foundation for our data visualization work. This preparation ensures that all necessary tools and functionalities from <code>pathpyG</code> are at our disposal.</p> <p>In anticipation of enhancing our graphs with additional attributes, we also include the <code>torch</code> package in our setup. <code>torch</code> is renowned for its robust capabilities in data processing and machine learning, and its inclusion allows us to enrich our graphs with more complex and informative attributes.</p>"},{"location":"tutorial/visualisation/#the-plot-function","title":"The <code>plot</code> Function\u00b6","text":"<p>The <code>plot</code> function in <code>pathpyG</code> stands out as the simplest and most direct method for creating visualizations. Designed to encapsulate all the plotting capabilities of <code>pathpyG</code> in a single command, it streamlines the process of generating quick and efficient plots. This functionality is particularly beneficial for users who seek immediate visual feedback from their data without delving into more complex coding. The only prerequisite for using this function is the <code>Graph</code> object, which serves as the foundation for the visualization. Moreover, when working within an interactive environment, such as a <code>Jupyter notebook</code>, the <code>plot</code> function is particularly powerful. In such settings, invoking the <code>plot</code> command will automatically generate and display an interactive visualization. This feature is particularly beneficial as it allows for immediate visual feedback, making it an ideal tool for exploratory data analysis where quick and efficient visualization is key.</p>"},{"location":"tutorial/visualisation/#kwargs-in-the-plot-function","title":"<code>kwargs</code> in the <code>plot</code> function\u00b6","text":"<p>In <code>pathpyG</code>, the customization of your plot is managed through keyword arguments (kwargs), where each customization is specified as a keyword followed by its corresponding value. This approach is what gives the <code>plot</code> function its remarkable flexibility, allowing it to adapt to a wide variety of plotting requirements. Whether you're aiming for a simple graph or a complex, multi-faceted visualization, the keyword arguments provide the tools to tailor your plot precisely to your needs.</p> <p>However, this wealth of options can be somewhat overwhelming for beginners, given the extensive range of available choices. But worry not, as we will guide you through the most essential and basic options, ensuring you have a solid foundation to start from. By mastering these fundamental aspects, you'll be well on your way to effectively utilizing <code>pathpyG</code>'s plot function, gradually building up to more advanced features as you gain confidence and expertise.</p>"},{"location":"tutorial/visualisation/#plotting-backends","title":"Plotting Backends\u00b6","text":"<p>In the diverse world of data visualization, there is no one-size-fits-all technique, as different scenarios demand different approaches. Recognizing this, <code>pathpyG</code> offers a variety of plotting backends, each tailored for specific use cases, ensuring that users have the right tools for their unique requirements.</p> <ul> <li><p>For instance, <code>pathpyG</code> facilitates interactive visualizations, as previously demonstrated, which are immensely useful for dynamic exploration of data. This feature is particularly beneficial in educational settings, exploratory data analysis, and communication, where interaction with the data can lead to deeper understanding and insights.</p> </li> <li><p>On the other hand, <code>pathpyG</code> also integrates with matplotlib, a widely recognized package for creating static plots. This is especially efficient for visualizing large graphs where interactivity might be less critical.</p> </li> <li><p>Additionally, <code>pathpyG</code> caters to the academic and publication community by offering tikz plots, which are highly valued in formal publications for their precision and quality. (Note that for generating tikz plots, currently, the installation of <code>latexmk</code> is necessary to produce the corresponding <code>.tex</code> and <code>.pdf</code> files.)</p> </li> </ul> <p>Let's generate a static png image using the <code>matplotlib</code> backend:</p>"},{"location":"tutorial/visualisation/#quick-introduction-to-layouts","title":"Quick Introduction to Layouts\u00b6","text":"<p>An important aspect to consider is the layout of your plot. The previous plot we generated is static, meaning the positions of the nodes are fixed and do not change. This fixed arrangement presents a unique challenge, as finding the optimal placement for nodes and edges to convey information effectively is not a straightforward task. To assist with this, <code>pathpyG</code> supports simple layout functions designed to create visually appealing and coherent graphs. By default, nodes are assigned random locations for computational efficiency. However, this arrangement can be significantly improved with the use of the <code>layout</code> keyword in the <code>plot</code> function, allowing for more structured and meaningful representations of your graph.</p> <p>For example, <code>pathpyG</code> includes support for sophisticated layout algorithms, such as the Fruchterman-Reingold algorithm for force-directed layouts. This can be activated using the <code>\"fr\"</code> option, which applies a physics-based approach to arrange nodes and edges in a way that visually represents their relational dynamics. Such force-directed layouts are particularly useful for highlighting the underlying structure and relationships within the data.</p>"},{"location":"tutorial/visualisation/#styling-your-plots","title":"Styling Your Plots\u00b6","text":"<p>To enhance the effectiveness and appeal of our visualizations in <code>pathpyG</code>, styling of our plots becomes a key aspect. The ability to style your plots is not just about aesthetic appeal; it is about effectively conveying more information through visual means. Depending on the type of plot you are working with, there are multiple styling options available to tailor your visualization to your specific needs. The fundamental principle here is that the styles applied to your plot should not be dependent on the data of your model. In other words, you should be able to present the same data in different styles, depending on the context or the information you wish to highlight. To facilitate this, styles are organized in dictionaries, which are then incorporated into the <code>plot</code> function.</p> <p>For network plots, where the focus is on the topology of the data, there are several basic styling options you can adjust, including the <code>size</code>, <code>color</code>, and <code>opacity</code> of each node and edge object. These options provide a foundational level of customization, allowing you to make your graph more readable and visually appealing. However, the styling possibilities extend further, varying according to the specific kind of plot you are creating. To distinguish between the styling of edges and nodes, a prefix corresponding to each element type is added to the keyword, such as <code>node_size</code>. This distinction ensures that your styling choices are accurately applied to the intended elements of the graph, further enhancing the clarity and effectiveness of your visualization.</p>"},{"location":"tutorial/visualisation/#colormaps","title":"Colormaps\u00b6","text":"<p>In many instances, particularly when visualizing numerical data, the use of color gradients to represent values can greatly enhance the clarity and effectiveness of a plot. <code>pathpyG</code> addresses this need through its native support for <code>colormaps</code>. When the colors of node or edge elements are defined using <code>int</code> or <code>float</code> values, <code>pathpyG</code> automatically assigns colors based on these colormaps, effectively interpolating the correct color value for each element. By default, <code>pathpyG</code> offers a simple colormap that transitions from red to green, sufficient for many basic visualization needs. However, for more customized or advanced styling, users have the option to utilize any colormap from the extensive color palettes provided by <code>matplotlib</code> or <code>seaborn</code>. These libraries offer a wide range of color schemes, enabling you to select the perfect palette to convey the nuances of your data.</p>"},{"location":"tutorial/visualisation/#saving-plots","title":"Saving Plots\u00b6","text":"<p>In <code>pathpyG</code>, sharing your plots or incorporating them into various mediums is facilitated by the ability to save them as files. This functionality is conveniently accessed by simply adding the <code>filename</code> keyword within the plot function. When you specify a filename, <code>pathpyG</code> assigns the appropriate backend to use based on the file extension provided. For instance, if you save your file with an <code>.html</code> extension, <code>pathpyG</code> generates a standalone interactive visualization, perfect for web applications or interactive presentations. On the other hand, if you choose to save your plot as a <code>.png</code> file, a static image is created using the <code>matplotlib</code> backend, ideal for including in documents, reports, or presentations where interactivity is not required. Additionally, for those seeking to incorporate plots into academic papers or publications, saving the file with a <code>.tex</code> extension activates the <code>tikz</code> backend. This feature is particularly beneficial for creating high-quality, publication-ready figures.</p>"},{"location":"tutorial/visualisation/#larger-network-visualizations","title":"Larger Network Visualizations\u00b6","text":"<p>Having covered the basics, we are now well-prepared to venture into the realm of larger network visualizations using <code>pathpyG</code>.</p>"},{"location":"tutorial/visualisation/#temporal-network-visualizations","title":"Temporal Network Visualizations\u00b6","text":"<p>In the realm of network analysis, <code>pathpyG</code> particularly excels in handling and visualizing temporal graphs, a domain where both nodes and edges can change their properties over time. This dynamic aspect of temporal graphs adds a layer of complexity and richness to data analysis, capturing the evolution of relationships and properties within the network. <code>pathpyG</code> supports this advanced functionality, allowing users to apply the same versatile <code>plot</code> function used for static graphs to <code>TemporalGraph</code> data structures. This integration means that all the customization options, styling features, and layout choices previously explored for static network visualizations are also applicable to temporal graphs. The ability to utilize these tools in the context of temporal data opens up a world of possibilities for in-depth analysis and insightful visualization of networks where time plays a crucial role. Whether you're tracking changes in social networks, analyzing traffic patterns, or studying dynamic biological systems, <code>pathpyG</code>'s capabilities in temporal network visualization provide a powerful tool to uncover and illustrate the temporal dynamics inherent in these complex systems.</p>"},{"location":"tutorial/xx_temporal_centralities/","title":"Xx temporal centralities","text":"In\u00a0[1]: Copied! <pre>import torch\n\nimport pathpyG as pp\n\nprint('Running on', pp.config['torch']['device'])\n</pre> import torch  import pathpyG as pp  print('Running on', pp.config['torch']['device']) <pre>Running on cpu\n</pre> In\u00a0[2]: Copied! <pre># Put this as his in conftest as 'simple_paths_centralities'\npaths = pp.PathData()\npaths.add_walk(torch.tensor([[2, 1, 3], [1, 3, 5]]))  \npaths.add_walk(torch.tensor([[0, 1], [1, 3]]))  \npaths.add_walk(torch.tensor([[3], [4]]))\n\n\nsimple_paths_centralities = paths\n</pre> # Put this as his in conftest as 'simple_paths_centralities' paths = pp.PathData() paths.add_walk(torch.tensor([[2, 1, 3], [1, 3, 5]]))   paths.add_walk(torch.tensor([[0, 1], [1, 3]]))   paths.add_walk(torch.tensor([[3], [4]]))   simple_paths_centralities = paths In\u00a0[331]: Copied! <pre># paths = pp.PathData()\n# paths.add_walk(torch.tensor([[0,2,3],[2,3,4]]),freq=3) # A -&gt; C -&gt; D\n# paths.add_walk(torch.tensor([[0,2],[2,3]])) # A -&gt; C -&gt; D\n# paths.add_walk(torch.tensor([[1,2],[2,4]])) # B -&gt; C -&gt; E\n# paths.add_walk(torch.tensor([[4],[5]]))\n# paths.add_walk(torch.tensor([[1,2],[2,4]])) # B -&gt; C -&gt; E\n</pre> # paths = pp.PathData() # paths.add_walk(torch.tensor([[0,2,3],[2,3,4]]),freq=3) # A -&gt; C -&gt; D # paths.add_walk(torch.tensor([[0,2],[2,3]])) # A -&gt; C -&gt; D # paths.add_walk(torch.tensor([[1,2],[2,4]])) # B -&gt; C -&gt; E # paths.add_walk(torch.tensor([[4],[5]])) # paths.add_walk(torch.tensor([[1,2],[2,4]])) # B -&gt; C -&gt; E  In\u00a0[3]: Copied! <pre>index, edge_weights = paths.edge_index_k_weighted(k=2)\nindex, edge_weights\n</pre> index, edge_weights = paths.edge_index_k_weighted(k=2) index, edge_weights Out[3]: <pre>(tensor([[[0, 1],\n          [1, 3],\n          [2, 1]],\n \n         [[1, 3],\n          [3, 5],\n          [1, 3]]]),\n tensor([1., 1., 1.]))</pre> In\u00a0[4]: Copied! <pre>index, edge_weights = paths.edge_index_k_weighted(k=1)\n</pre> index, edge_weights = paths.edge_index_k_weighted(k=1) In\u00a0[334]: Copied! <pre>from collections import defaultdict\ndef node_traversals(paths):\n    \"\"\"Calculates the number of times any path traverses each of the nodes.\n\n    Parameters\n    ----------\n    paths: Paths\n\n    Returns\n    -------\n    dict\n    \"\"\"\n    traversals = defaultdict(lambda: 0)\n    for path_id, path_edgelist in paths.paths.items():\n        path_seq = paths.walk_to_node_seq(path_edgelist)\n        for node in path_seq:\n            traversals[node.item()] += paths.path_freq[path_id]\n    return traversals\n</pre> from collections import defaultdict def node_traversals(paths):     \"\"\"Calculates the number of times any path traverses each of the nodes.      Parameters     ----------     paths: Paths      Returns     -------     dict     \"\"\"     traversals = defaultdict(lambda: 0)     for path_id, path_edgelist in paths.paths.items():         path_seq = paths.walk_to_node_seq(path_edgelist)         for node in path_seq:             traversals[node.item()] += paths.path_freq[path_id]     return traversals    Out[334]: <pre>defaultdict(&lt;function __main__.node_traversals.&lt;locals&gt;.&lt;lambda&gt;()&gt;,\n            {2: 1, 1: 2, 3: 3, 5: 1, 0: 1, 4: 1})</pre> In\u00a0[6]: Copied! <pre>from pathpyG.algorithms.centrality import node_traversals\n</pre> from pathpyG.algorithms.centrality import node_traversals In\u00a0[7]: Copied! <pre>node_traversals(paths)\n</pre> node_traversals(paths) Out[7]: <pre>defaultdict(&lt;function pathpyG.algorithms.centrality.node_traversals.&lt;locals&gt;.&lt;lambda&gt;()&gt;,\n            {2: 1, 1: 2, 3: 3, 5: 1, 0: 1, 4: 1})</pre> In\u00a0[8]: Copied! <pre>from pathpyG.algorithms.centrality import visitation_probabilities\n</pre> from pathpyG.algorithms.centrality import visitation_probabilities In\u00a0[336]: Copied! <pre>\n</pre> Out[336]: <pre>defaultdict(&lt;function __main__.node_traversals.&lt;locals&gt;.&lt;lambda&gt;()&gt;,\n            {2: 0.1111111111111111,\n             1: 0.2222222222222222,\n             3: 0.3333333333333333,\n             5: 0.1111111111111111,\n             0: 0.1111111111111111,\n             4: 0.1111111111111111})</pre> In\u00a0[9]: Copied! <pre>def test_visitation_probabilities(simple_paths_centralities):\n    traversals_dict = visitation_probabilities(simple_paths_centralities)\n    assert set(traversals_dict.keys()) == {0,1,2,3,4,5}\n    assert traversals_dict[0] == 1/9\n    assert traversals_dict[1] == 2/9\n    assert traversals_dict[2] == 1/9\n    assert traversals_dict[3] == 3/9\n    assert traversals_dict[4] == 1/9\n    assert traversals_dict[5] == 1/9\n\ntest_visitation_probabilities(simple_paths_centralities)\n</pre> def test_visitation_probabilities(simple_paths_centralities):     traversals_dict = visitation_probabilities(simple_paths_centralities)     assert set(traversals_dict.keys()) == {0,1,2,3,4,5}     assert traversals_dict[0] == 1/9     assert traversals_dict[1] == 2/9     assert traversals_dict[2] == 1/9     assert traversals_dict[3] == 3/9     assert traversals_dict[4] == 1/9     assert traversals_dict[5] == 1/9  test_visitation_probabilities(simple_paths_centralities) <pre>\n---------------------------------------------------------------------------\nRecursionError                            Traceback (most recent call last)\nCell In[9], line 11\n      8     assert traversals_dict[4] == 1/9\n      9     assert traversals_dict[5] == 1/9\n---&gt; 11 test_visitation_probabilities(simple_paths_centralities)\n\nCell In[9], line 2, in test_visitation_probabilities(simple_paths_centralities)\n      1 def test_visitation_probabilities(simple_paths_centralities):\n----&gt; 2     traversals_dict = visitation_probabilities(simple_paths_centralities)\n      3     assert set(traversals_dict.keys()) == {0,1,2,3,4,5}\n      4     assert traversals_dict[0] == 1/9\n\nFile /workspaces/pathpyG/src/pathpyG/algorithms/centrality.py:121, in wrapper(*args, **kwargs)\n    118 visit_probabilities = node_traversals(paths)\n    120 # total number of visits\n--&gt; 121 visits = 0.0\n    122 for v in visit_probabilities:\n    123     visits += visit_probabilities[v]\n\nFile /workspaces/pathpyG/src/pathpyG/algorithms/centrality.py:121, in wrapper(*args, **kwargs)\n    118 visit_probabilities = node_traversals(paths)\n    120 # total number of visits\n--&gt; 121 visits = 0.0\n    122 for v in visit_probabilities:\n    123     visits += visit_probabilities[v]\n\n    [... skipping similar frames: wrapper at line 121 (2968 times)]\n\nFile /workspaces/pathpyG/src/pathpyG/algorithms/centrality.py:121, in wrapper(*args, **kwargs)\n    118 visit_probabilities = node_traversals(paths)\n    120 # total number of visits\n--&gt; 121 visits = 0.0\n    122 for v in visit_probabilities:\n    123     visits += visit_probabilities[v]\n\nFile /workspaces/pathpyG/src/pathpyG/algorithms/centrality.py:109, in wrapper(*args, **kwargs)\n     96 def visitation_probabilities(paths):\n     97     \"\"\"Calculates the probabilities that a randomly chosen path passes through each of\n     98     the nodes. If 5 out of 100 paths (of any length) traverse node v, node v will be\n     99     assigned a visitation probability of 0.05. This measure can be interpreted as ground\n    100     truth for the notion of importance captured by PageRank applied to a graphical\n    101     abstraction of the paths.\n    102 \n    103     Parameters\n    104     ----------\n    105     paths: Paths\n    106 \n    107     Returns\n    108     -------\n--&gt; 109     dict\n    110     \"\"\"\n    111     # if not isinstance(paths, PathData):\n    112     #    assert False, \"`paths` must be an instance of Paths\"\n    113     # Log.add('Calculating visitation probabilities...', Severity.INFO)\n   (...)\n    116     # Note: this is identical to the subpath count of zero-length paths\n    117     # (i.e. the relative frequencies of nodes across all pathways)\n    118     visit_probabilities = node_traversals(paths)\n\nRecursionError: maximum recursion depth exceeded while calling a Python object</pre> In\u00a0[338]: Copied! <pre>\n</pre> <pre>IndexError occurred. Reached maximum path length of 4\n</pre> Out[338]: <pre>defaultdict(&lt;function __main__.shortest_paths.&lt;locals&gt;.&lt;lambda&gt;()&gt;,\n            {0: defaultdict(set,\n                         {1: {tensor([0, 1])}, 3: {tensor([0, 1, 3])}}),\n             1: defaultdict(set,\n                         {3: {tensor([1, 3])}, 5: {tensor([1, 3, 5])}}),\n             2: defaultdict(set,\n                         {1: {tensor([2, 1])},\n                          3: {tensor([2, 1, 3])},\n                          5: {tensor([2, 1, 3, 5])}}),\n             3: defaultdict(set, {4: {tensor([3, 4])}, 5: {tensor([3, 5])}})})</pre> In\u00a0[339]: Copied! <pre>test_shortest_paths(paths)\n</pre>   test_shortest_paths(paths) <pre>IndexError occurred. Reached maximum path length of 4\n</pre> In\u00a0[340]: Copied! <pre># @betweenness.register(Paths)\ndef betweenness(paths, normalized=False):\n    \"\"\"Calculates the betweenness of nodes based on observed shortest paths\n    between all pairs of nodes\n\n    Parameters\n    ----------\n    paths:\n        Paths object\n    normalized: bool\n        normalize such that largest value is 1.0\n\n    Returns\n    -------\n    dict\n    \"\"\"\n    assert isinstance(paths, pp.PathData), \"argument must be an instance of pathpy.Paths\"\n    node_centralities = defaultdict(lambda: 0)\n\n    # Log.add('Calculating betweenness in paths ...', Severity.INFO)\n\n    all_paths = shortest_paths(paths)\n\n    for s in all_paths:\n        for d in all_paths[s]:\n            for p in all_paths[s][d]:\n                for x in p[1:-1]:\n                    if s != d != x:\n                        node_centralities[x.item()] += 1.0 / len(all_paths[s][d])\n    if normalized:\n        max_centr = max(node_centralities.values())\n        for v in node_centralities:\n            node_centralities[v] /= max_centr\n    # assign zero values to nodes not occurring on shortest paths\n    nodes = [v.item() for v in paths.edge_index.reshape(-1).unique(dim=0)]\n    for v in nodes:\n        node_centralities[v] += 0\n    # Log.add('finished.')\n    return node_centralities\n\nbetweenness(paths,normalized=False)\n</pre> # @betweenness.register(Paths) def betweenness(paths, normalized=False):     \"\"\"Calculates the betweenness of nodes based on observed shortest paths     between all pairs of nodes      Parameters     ----------     paths:         Paths object     normalized: bool         normalize such that largest value is 1.0      Returns     -------     dict     \"\"\"     assert isinstance(paths, pp.PathData), \"argument must be an instance of pathpy.Paths\"     node_centralities = defaultdict(lambda: 0)      # Log.add('Calculating betweenness in paths ...', Severity.INFO)      all_paths = shortest_paths(paths)      for s in all_paths:         for d in all_paths[s]:             for p in all_paths[s][d]:                 for x in p[1:-1]:                     if s != d != x:                         node_centralities[x.item()] += 1.0 / len(all_paths[s][d])     if normalized:         max_centr = max(node_centralities.values())         for v in node_centralities:             node_centralities[v] /= max_centr     # assign zero values to nodes not occurring on shortest paths     nodes = [v.item() for v in paths.edge_index.reshape(-1).unique(dim=0)]     for v in nodes:         node_centralities[v] += 0     # Log.add('finished.')     return node_centralities  betweenness(paths,normalized=False) <pre>IndexError occurred. Reached maximum path length of 4\n</pre> Out[340]: <pre>defaultdict(&lt;function __main__.betweenness.&lt;locals&gt;.&lt;lambda&gt;()&gt;,\n            {1: 3.0, 3: 2.0, 0: 0, 2: 0, 4: 0, 5: 0})</pre> In\u00a0[346]: Copied! <pre>def test_betweenness_paths(simple_paths_centralities):\n    bw = betweenness(simple_paths_centralities,normalized=False)\n    # 1 is in the shortest path between 0-5,2-3,2-5\n    assert bw[1] == 3.0\n    # 1 is in the shortest path between 2-5,1-5\n    assert bw[3] == 2.0\n\ntest_betweenness_paths(paths)\n</pre> def test_betweenness_paths(simple_paths_centralities):     bw = betweenness(simple_paths_centralities,normalized=False)     # 1 is in the shortest path between 0-5,2-3,2-5     assert bw[1] == 3.0     # 1 is in the shortest path between 2-5,1-5     assert bw[3] == 2.0  test_betweenness_paths(paths) <pre>IndexError occurred. Reached maximum path length of 4\n</pre> In\u00a0[347]: Copied! <pre>def distance_matrix(paths):\n    \"\"\"\n    Calculates shortest path distances between all pairs of\n    nodes based on the observed shortest paths (and subpaths)\n    \"\"\"\n    dist = defaultdict(lambda: defaultdict(lambda: _np.inf))\n    # Log.add('Calculating distance matrix based on empirical paths ...', Severity.INFO)\n    nodes = [v.item() for v in paths.edge_index.reshape(-1).unique(dim=0)] # NOTE: modify once set of nodes can be obtained from path obeject\n    for v in nodes:\n        dist[v][v] = 0\n\n    p_length = 1\n    index, edge_weights = paths.edge_index_k_weighted(k=p_length)\n    sources = index[0]\n    destinations = index[-1]\n    for e, (s, d) in enumerate(zip(sources, destinations)):\n        s = s.item()\n        d = d.item()\n        dist[s][d] = p_length\n        # s_p[s][d] = set({torch.tensor([s,d])})\n    p_length += 1\n    while True: # until max path length\n        try:\n            index, edge_weights = paths.edge_index_k_weighted(k=p_length)\n            sources = index[0, :, 0]\n            destinations = index[1, :, -1]\n            for e, (s, d) in enumerate(zip(sources, destinations)):\n                s = s.item()\n                d = d.item()\n                if p_length &lt; dist[s][d]:\n                    # update shortest path length\n                    dist[s][d] = p_length\n            p_length += 1\n        except IndexError:\n            print(f\"IndexError occurred. Reached maximum path length of {p_length}\")\n            break\n    return dist\ndistance_matrix(paths)\n</pre>  def distance_matrix(paths):     \"\"\"     Calculates shortest path distances between all pairs of     nodes based on the observed shortest paths (and subpaths)     \"\"\"     dist = defaultdict(lambda: defaultdict(lambda: _np.inf))     # Log.add('Calculating distance matrix based on empirical paths ...', Severity.INFO)     nodes = [v.item() for v in paths.edge_index.reshape(-1).unique(dim=0)] # NOTE: modify once set of nodes can be obtained from path obeject     for v in nodes:         dist[v][v] = 0      p_length = 1     index, edge_weights = paths.edge_index_k_weighted(k=p_length)     sources = index[0]     destinations = index[-1]     for e, (s, d) in enumerate(zip(sources, destinations)):         s = s.item()         d = d.item()         dist[s][d] = p_length         # s_p[s][d] = set({torch.tensor([s,d])})     p_length += 1     while True: # until max path length         try:             index, edge_weights = paths.edge_index_k_weighted(k=p_length)             sources = index[0, :, 0]             destinations = index[1, :, -1]             for e, (s, d) in enumerate(zip(sources, destinations)):                 s = s.item()                 d = d.item()                 if p_length &lt; dist[s][d]:                     # update shortest path length                     dist[s][d] = p_length             p_length += 1         except IndexError:             print(f\"IndexError occurred. Reached maximum path length of {p_length}\")             break     return dist distance_matrix(paths)      <pre>IndexError occurred. Reached maximum path length of 4\n</pre> Out[347]: <pre>defaultdict(&lt;function __main__.distance_matrix.&lt;locals&gt;.&lt;lambda&gt;()&gt;,\n            {0: defaultdict(&lt;function __main__.distance_matrix.&lt;locals&gt;.&lt;lambda&gt;.&lt;locals&gt;.&lt;lambda&gt;()&gt;,\n                         {0: 0, 1: 1, 3: 2}),\n             1: defaultdict(&lt;function __main__.distance_matrix.&lt;locals&gt;.&lt;lambda&gt;.&lt;locals&gt;.&lt;lambda&gt;()&gt;,\n                         {1: 0, 3: 1, 5: 2}),\n             2: defaultdict(&lt;function __main__.distance_matrix.&lt;locals&gt;.&lt;lambda&gt;.&lt;locals&gt;.&lt;lambda&gt;()&gt;,\n                         {2: 0, 1: 1, 3: 2, 5: 3}),\n             3: defaultdict(&lt;function __main__.distance_matrix.&lt;locals&gt;.&lt;lambda&gt;.&lt;locals&gt;.&lt;lambda&gt;()&gt;,\n                         {3: 0, 4: 1, 5: 1}),\n             4: defaultdict(&lt;function __main__.distance_matrix.&lt;locals&gt;.&lt;lambda&gt;.&lt;locals&gt;.&lt;lambda&gt;()&gt;,\n                         {4: 0}),\n             5: defaultdict(&lt;function __main__.distance_matrix.&lt;locals&gt;.&lt;lambda&gt;.&lt;locals&gt;.&lt;lambda&gt;()&gt;,\n                         {5: 0})})</pre> In\u00a0[352]: Copied! <pre>def test_distance_matrix_paths(simple_paths_centralities):\n    dm = distance_matrix(simple_paths_centralities)\n    assert dm[0] == {0: 0, 1: 1, 3: 2}\n    assert dm[1] == {1: 0, 3: 1, 5: 2}\n    assert dm[2] == {2: 0, 1: 1, 3: 2, 5: 3}\n    assert dm[3] == {3: 0, 4: 1, 5: 1}\n    assert dm[4] == {4: 0}\n    assert dm[5] == {5: 0}\n\ntest_distance_matrix_paths(paths)\n</pre> def test_distance_matrix_paths(simple_paths_centralities):     dm = distance_matrix(simple_paths_centralities)     assert dm[0] == {0: 0, 1: 1, 3: 2}     assert dm[1] == {1: 0, 3: 1, 5: 2}     assert dm[2] == {2: 0, 1: 1, 3: 2, 5: 3}     assert dm[3] == {3: 0, 4: 1, 5: 1}     assert dm[4] == {4: 0}     assert dm[5] == {5: 0}  test_distance_matrix_paths(paths) <pre>IndexError occurred. Reached maximum path length of 4\n</pre> In\u00a0[355]: Copied! <pre>def closeness(paths, normalized=False):\n    \"\"\"Calculates the closeness of nodes based on observed shortest paths\n    between all nodes\n\n    Parameters\n    ----------\n    paths: Paths\n    normalized: bool\n        normalize such that largest value is 1.0\n\n    Returns\n    -------\n    dict\n    \"\"\"\n    node_centralities = defaultdict(lambda: 0)\n    distances = distance_matrix(paths)\n    nodes = [v.item() for v in paths.edge_index.reshape(-1).unique(dim=0)] # NOTE: modify once set of nodes can be obtained from path obeject\n\n    for x in nodes:\n        # calculate closeness centrality of x\n        for d in nodes:\n            if x != d and distances[d][x] &lt; _np.inf:\n                node_centralities[x] += 1.0 / distances[d][x]\n\n    # assign zero values to nodes not occurring\n    \n    for v in nodes:\n        node_centralities[v] += 0.0\n\n    if normalized:\n        m = max(node_centralities.values())\n        for v in nodes:\n            node_centralities[v] /= m\n\n    return node_centralities\ncloseness(paths, normalized=False)\n</pre> def closeness(paths, normalized=False):     \"\"\"Calculates the closeness of nodes based on observed shortest paths     between all nodes      Parameters     ----------     paths: Paths     normalized: bool         normalize such that largest value is 1.0      Returns     -------     dict     \"\"\"     node_centralities = defaultdict(lambda: 0)     distances = distance_matrix(paths)     nodes = [v.item() for v in paths.edge_index.reshape(-1).unique(dim=0)] # NOTE: modify once set of nodes can be obtained from path obeject      for x in nodes:         # calculate closeness centrality of x         for d in nodes:             if x != d and distances[d][x] &lt; _np.inf:                 node_centralities[x] += 1.0 / distances[d][x]      # assign zero values to nodes not occurring          for v in nodes:         node_centralities[v] += 0.0      if normalized:         m = max(node_centralities.values())         for v in nodes:             node_centralities[v] /= m      return node_centralities closeness(paths, normalized=False) <pre>IndexError occurred. Reached maximum path length of 4\n</pre> Out[355]: <pre>defaultdict(&lt;function __main__.closeness.&lt;locals&gt;.&lt;lambda&gt;()&gt;,\n            {1: 2.0, 3: 2.0, 4: 1.0, 5: 1.8333333333333333, 0: 0.0, 2: 0.0})</pre> In\u00a0[360]: Copied! <pre>def test_closeness_paths(simple_paths_centralities):\n    c = closeness(simple_paths_centralities, normalized=False)\n    assert c[0] == 0.0\n    # 1 reachable from 0 and 2 in one step\n    assert c[1] == 1/1 + 1/1\n    assert c[2] == 0\n    # 3 reachable from 1 in one step, from 0 and 3 in two steps\n    assert c[3] == 1 + 1/2 + 1/2\n    assert c[4] == 1\n    # 5 reachable from 3 in one step, from 1 in two steps, from 2 in three steps\n    assert c[5] == 1 + 1/2 + 1/3\ntest_closeness_paths(paths)\n</pre> def test_closeness_paths(simple_paths_centralities):     c = closeness(simple_paths_centralities, normalized=False)     assert c[0] == 0.0     # 1 reachable from 0 and 2 in one step     assert c[1] == 1/1 + 1/1     assert c[2] == 0     # 3 reachable from 1 in one step, from 0 and 3 in two steps     assert c[3] == 1 + 1/2 + 1/2     assert c[4] == 1     # 5 reachable from 3 in one step, from 1 in two steps, from 2 in three steps     assert c[5] == 1 + 1/2 + 1/3 test_closeness_paths(paths) <pre>IndexError occurred. Reached maximum path length of 4\n</pre>"}]}