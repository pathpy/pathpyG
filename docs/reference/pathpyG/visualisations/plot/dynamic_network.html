<style>
.label-text {
    fill: #969595;
    font-size: 16px;
    font-family: sans-serif;
}
</style>

<div id = "x91a69b8a69fa4f9697b9b304e2a038f2"> </div>
<script charset="utf-8" src="https://d3js.org/d3.v7.min.js"></script>
<script charset="utf-8">
// Load via requireJS if available (jupyter notebook environment)
try {
    // Problem: require.config will raise an exception when called for the second time 
    require.config({
        paths: {
            d3: "https://d3js.org/d3.v7.min.js".replace(".js", "")
        }
    });
    console.log("OKAY: requireJS was detected.");
}
catch(err){
    // a reference error indicates that requireJS does not exist. 
    // other errors may occur due to multiple calls to config
    if (err instanceof ReferenceError){
        console.log("WARNING: NO requireJS was detected!");

        // Helper function that waits for d3js to be loaded
        require = function require(symbols, callback) {
            var ms = 10;
            window.setTimeout(function(t) {
                if (window[symbols[0]])
                    callback(window[symbols[0]]);
                else 
                    window.setTimeout(arguments.callee, ms);
            }, ms);
        }
    }
};
require(['d3'], function(d3){ //START
const data = {"nodes": [{"color": "#ff0000", "image": NaN, "opacity": 0.75, "size": 15.0, "start": 0, "end": 1.0, "uid": "a"}, {"color": "#ff0000", "image": NaN, "opacity": 0.75, "size": 20.0, "start": 1, "end": 4.0, "uid": "a"}, {"color": "#0000ff", "image": NaN, "opacity": 0.75, "size": 15.0, "start": 0, "end": 2.0, "uid": "b"}, {"color": "#0000ff", "image": NaN, "opacity": 0.75, "size": 7.0, "start": 2, "end": 4.0, "uid": "b"}, {"color": "#008000", "image": NaN, "opacity": 0.75, "size": 15.0, "start": 0, "end": 4.0, "uid": "c"}, {"color": "#ffa500", "image": NaN, "opacity": 0.75, "size": 15.0, "start": 0, "end": 4.0, "uid": "d"}], "edges": [{"color": "#00224d", "size": 2, "opacity": 0.7, "image": null, "start": 1, "end": 2, "uid": "a-b", "source": "a", "target": "b"}, {"color": "#35456c", "size": 2, "opacity": 0.7, "image": null, "start": 1, "end": 2, "uid": "b-c", "source": "b", "target": "c"}, {"color": "#666970", "size": 2, "opacity": 0.7, "image": null, "start": 2, "end": 3, "uid": "c-d", "source": "c", "target": "d"}, {"color": "#948e77", "size": 2, "opacity": 0.7, "image": null, "start": 2, "end": 3, "uid": "d-a", "source": "d", "target": "a"}, {"color": "#c8b765", "size": 2, "opacity": 0.7, "image": null, "start": 3, "end": 4, "uid": "a-c", "source": "a", "target": "c"}, {"color": "#fde737", "size": 2, "opacity": 0.7, "image": null, "start": 3, "end": 4, "uid": "b-d", "source": "b", "target": "d"}]}
const config = {"default_backend": "d3js", "cmap": "cividis", "layout": null, "width": 453.54330708661416, "height": 453.54330708661416, "latex_class_options": "", "margin": 0.1, "curvature": 0.25, "layout_window_size": [4, 4], "delta": 750, "separator": "->", "node": {"color": "#244a5c", "size": 15, "opacity": 0.75, "image_padding": 5}, "edge": {"color": "#4c707b", "size": 2, "opacity": 0.5}, "directed": true, "curved": false, "simulation": true, "selector": "#x91a69b8a69fa4f9697b9b304e2a038f2", "show_labels": true}
console.log('temporal Network Template');
// Useful pages
// ------------
// https://github.com/takanori-fujiwara/d3-gallery-javascript/tree/main/animation/temporal-force-directed-graph
// https://observablehq.com/@d3/temporal-force-directed-graph
// https://observablehq.com/@mbostock/scrubber
// https://plnkr.co/edit/0VxwY1Mc5UYusvhYic8u?preview
// https://stackoverflow.com/questions/42545531/making-d3-like-force-directed-graph-with-pngs


// Create function for Network Drawing
const Network = (config) => {
    console.log("Initialize Network Function");

    // Get variables from config
    const selector = config.selector;       // DOM uuid
    const width = config.width || 800;      // window width 
    const height = config.height || 600;    // window height
    const delta = config.delta || 300;      // time between frames
    const padding = (config.node && config.node.image_padding) || 5;    // distance between node and image
    const margin = config.margin || 0.1;  // margin around the plot area for fixed layout
    const xlim = [-1*margin, 1+(1*margin)]; // limits of the x-coordinates
    const ylim = [-1*margin, 1+(1*margin)]; // limits of the y-coordinates
    const arrowheadMultiplier = 4; // Multiplier for arrowhead size based on edge stroke width
    const nodeStrokeWidth = 2.5; // Stroke width around nodes
    const curveFactor = config.curvature || 0.25; // Factor to control curvature of edges (higher = more curved)

    // Initialize svg canvas
    const svg = d3.select(selector)
          .append('svg')
          .attr('width', width)
          .attr('height', height)
          .attr('viewBox', [0, 0, width, height]);
    
    // add container to store network
    let container = svg.append("g");

    // initialize link
    let link = container.append("g")
        .attr("class", "edges")
        .selectAll(".link");

    // initialize node
    let node = container.append("g")
        .attr("class", "nodes")
        .selectAll("circle.node");

    // initialize label
    let label = container.append("g")
        .attr("class", "labels")
        .selectAll(".label");

    // initialize image
    let image = container.append("g")
        .attr("class", "images")
        .selectAll(".image");

    const ticked = () => {
        // 1. Update node, label, and image positions
        node.attr("transform", d => `translate(${d.x},${d.y})`);
        label.attr("transform", d => `translate(${d.x},${d.y})`);
        image.attr("transform", d => `translate(${d.x},${d.y})`);

        // 2. Update the link paths
        link.attr('d', d => {
            // --- A. Get necessary properties ---
            const sourceRadius = d.source.size || (config.node && config.node.size) || 15;
            const targetRadius = d.target.size || (config.node && config.node.size) || 15;
            const edgeStrokeWidth = d.size || (config.edge && config.edge.size) || 2;
            const arrowheadLength = config.directed ? (edgeStrokeWidth * arrowheadMultiplier) : 0;

            const effectiveSourceRadius = sourceRadius + (nodeStrokeWidth/2);
            const effectiveTargetRadius = targetRadius + (nodeStrokeWidth/2) + arrowheadLength;

            const x1 = d.source.x, y1 = d.source.y;
            const x2 = d.target.x, y2 = d.target.y;

            const dx = x2 - x1, dy = y2 - y1;
            const distance = Math.hypot(dx, dy);

            // Don't draw if nodes are overlapping
            if (distance < effectiveSourceRadius + effectiveTargetRadius) return "";

            // --- B. Straight Line Calculation (Fast Path) ---
            if (!config.curved) {
                const sourceX = d.source.x + (dx / distance) * effectiveSourceRadius;
                const sourceY = d.source.y + (dy / distance) * effectiveSourceRadius;
                const targetX = d.target.x - (dx / distance) * effectiveTargetRadius;
                const targetY = d.target.y - (dy / distance) * effectiveTargetRadius;

                return `M${sourceX},${sourceY}L${targetX},${targetY}`;
            } else {
                // --- C. Curved Line Calculation (Quadratic BÃ©zier) ---

                // Find the midpoint, the vector between the nodes, and the distance.
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;

                // Calculate the control point (P1) for the quadratic curve.
                // This point is offset from the midpoint along a perpendicular vector.
                if (distance === 0) { // Handle case where nodes are at the same position
                    return `M${x1},${y1}`; 
                }
                // Get the normalized perpendicular vector.
                const perpX = -dy / distance;
                const perpY = dx / distance;

                // Define how much the curve should "bulge". This is your curvature factor.
                const controlPointOffset = distance * curveFactor;

                // Calculate the final control point's coordinates.
                const controlX = midX + perpX * controlPointOffset;
                const controlY = midY + perpY * controlPointOffset;

                // Shorten the curve to start and end at the node's edge, not its center.
                // To do this, we find the direction from the node's center towards the control point
                // and move the start/end point along that direction by the node's radius.

                // a. For the source node (P0 -> P1 direction)
                const dirSourceX = controlX - x1;
                const dirSourceY = controlY - y1;
                const lenSource = Math.hypot(dirSourceX, dirSourceY);
                const normDirSourceX = dirSourceX / lenSource;
                const normDirSourceY = dirSourceY / lenSource;

                // For the target node (P2 -> P1 direction)
                const dirTargetX = controlX - x2;
                const dirTargetY = controlY - y2;
                const lenTarget = Math.hypot(dirTargetX, dirTargetY);
                const normDirTargetX = dirTargetX / lenTarget;
                const normDirTargetY = dirTargetY / lenTarget;

                if (lenTarget < effectiveTargetRadius) {
                    const message = "Arrowhead length is too long for some edges. Please reduce the edge size.";
                    console.error(message);
                    const sourceX = d.source.x + (dx / distance) * effectiveSourceRadius;
                    const sourceY = d.source.y + (dy / distance) * effectiveSourceRadius;
                    const targetX = d.target.x - (dx / distance) * effectiveTargetRadius;
                    const targetY = d.target.y - (dy / distance) * effectiveTargetRadius;

                    return `M${sourceX},${sourceY}L${targetX},${targetY}`;
                }

                // The new, shortened start point (x3, y3)
                const x3 = x1 + normDirSourceX * effectiveSourceRadius;
                const y3 = y1 + normDirSourceY * effectiveSourceRadius;

                // The new, shortened end point (x4, y4)
                const x4 = x2 + normDirTargetX * effectiveTargetRadius;
                const y4 = y2 + normDirTargetY * effectiveTargetRadius;

                // Return the SVG path string for the quadratic BÃ©zier curve.
                return `M${x3},${y3} Q${controlX},${controlY} ${x4},${y4}`;
            }
        });
    };

    const simulation = d3.forceSimulation()
          .velocityDecay(0.2)
          .alphaMin(0.1)
          .force('link', d3.forceLink().id(d => d.uid))
          .on('tick', ticked);

    let currentlyDragged = null; // Remember currently dragged node during update

    // Add drag functionality to the node objects
    const drag = d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended);

    function dragstarted(event, d) {
        currentlyDragged = d;
        event.sourceEvent.stopPropagation();
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    };

    function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
    };

    function dragended(event, d) {
        currentlyDragged = null;
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    };

    /**
    * Creates a custom D3 force that repels nodes from a rectangular boundary.
    * @param {number} x0 - The left boundary.
    * @param {number} y0 - The top boundary.
    * @param {number} x1 - The right boundary.
    * @param {number} y1 - The bottom boundary.
    * @param {number} strength - The strength of the repulsion.
    */
    function forceBoundary(x0, y0, x1, y1, strength = 0.5) {
        let nodes;

        function force(alpha) {
            for (let i = 0, n = nodes.length; i < n; ++i) {
                const node = nodes[i];
                const r = node.size || (config.node && config.node.size) || 15;

                // Push node away from the left boundary
                if (node.x - r < x0) {
                    node.vx += (x0 - (node.x - r)) * strength * alpha;
                }
                // Push node away from the right boundary
                if (node.x + r > x1) {
                    node.vx += (x1 - (node.x + r)) * strength * alpha;
                }
                // Push node away from the top boundary
                if (node.y - r < y0) {
                    node.vy += (y0 - (node.y - r)) * strength * alpha;
                }
                // Push node away from the bottom boundary
                if (node.y + r > y1) {
                    node.vy += (y1 - (node.y + r)) * strength * alpha;
                }
            }
        }

        force.initialize = function(_) {
            nodes = _;
        };

        return force;
    }

    return Object.assign(svg.node(), {
        update({nodes, links}) {

            // --- DATA PREPARATION ---
            // Preserve node positions across updates
            const oldNodesMap = new Map(node.data().map(d => [d.uid, d]));
            nodes = nodes.map(newNode => {
                const oldNode = oldNodesMap.get(newNode.uid);
                // If there's an old node, preserve its position and velocity.
                // Also, preserve fixed position (fx, fy) if the user is dragging it.
                if (oldNode) {
                    newNode.x = oldNode.x;
                    newNode.y = oldNode.y;
                    newNode.vx = oldNode.vx;
                    newNode.vy = oldNode.vy;
                    if (oldNode.fx) newNode.fx = oldNode.fx;
                    if (oldNode.fy) newNode.fy = oldNode.fy;
                }
                return newNode;
            });
            links = links.map(d => ({...d}));
            
            // --- NODES (CIRCLES) ---
            // 1. Data Join
            node = container.select('.nodes').selectAll("circle.node")
                .data(nodes, d => d.uid);

            // 2. Exit Selection: Fade out and remove old nodes
            node.exit()
                .transition()
                .duration(delta / 2)
                .style("opacity", 0)
                .remove();

            // 3. Enter & Merge: Create new circles and merge with updating ones
            node = node.enter().append('circle')
                .attr("class", "node")
                .call(drag)
                .merge(node);

            // 4. Update Selection: Apply transitions to all nodes (new and existing)
            node.transition()
                .duration(delta)
                .style("r", d => (d.size || (config.node && config.node.size)) + "px") // Use fallback for size
                .style("fill", d => (d.color || (config.node && config.node.color))) // Use fallback for color
                .style("opacity", d => (d.opacity || (config.node && config.node.opacity))) // Use fallback for opacity
                .style("stroke-width", nodeStrokeWidth + "px")
                .style("stroke", "#000000");

            // --- IMAGES ---
            // 1. Data Join
            image = container.select('.images').selectAll('.image')
                .data(nodes.filter(d => d.image), d => d.uid);

            // 2. Exit Selection: Fade out and remove old images
            image.exit()
                .transition()
                .duration(delta / 2)
                .style("opacity", 0)
                .remove();

            // 3. Enter & Merge: Create new images and merge with updating ones
            image = image.enter().append('image')
                .attr("class", "image")
                .attr("xlink:href", d => d.image)
                .style("width", "0px")
                .style("height", "0px")
                .call(drag)
              .merge(image);

            // 4. Update Selection: Apply transitions to all images
            image.transition()
                .duration(delta)
                .attr("x", d => -(d.size || (config.node && config.node.size)) + padding)
                .attr("y", d => -(d.size || (config.node && config.node.size)) + padding)
                .style("width", d => 2 * (d.size || (config.node && config.node.size)) - 2 * padding + "px")
                .style("height", d => 2 * (d.size || (config.node && config.node.size)) - 2 * padding + "px");


            // --- LABELS ---
            if (config.show_labels) {
                // 1. Data Join
                label = container.select('.labels').selectAll('.label-text')
                    .data(nodes, d => d.uid);

                // 2. Exit Selection: Fade out and remove old labels
                label.exit()
                    .transition()
                    .duration(delta / 2)
                    .style("opacity", 0)
                    .remove();

                // 3. Enter & Merge: Create new text elements and merge with updating ones
                label = label.enter().append('text')
                    .attr("class", "label-text")
                    .attr("dy", ".32em")
                    .style("opacity", 0) // Start transparent to fade in
                .merge(label);

                // 4. Update Selection: Apply transitions to all labels
                label.transition()
                    .duration(delta)
                    .attr("x", d => (d.size || 15) + 5) // Use fallback for size
                    .text(d => d.uid)
                    .style("opacity", 1); // Fade in new/updating labels
            }

            // --- DYNAMIC ARROWHEAD MARKERS ---
            if (config.directed) {
                // Ensure a <defs> element exists
                const defs = container.selectAll('defs').data([1]).join('defs');

                // 1. Get a list of all unique edge colors currently in the data
                const uniqueColors = Array.from(
                    new Set(links.map(d => d.color || (config.edge && config.edge.color)))
                );

                // 2. Perform a data join to create one marker per unique color
                const markers = defs.selectAll('marker')
                    .data(uniqueColors, color => color); // Key the data by the color string itself

                // 3. Remove any markers for colors that are no longer in the data
                markers.exit().remove();

                // 4. For any new colors, create a new marker
                markers.enter().append('marker')
                    .attr('id', color => `arrowhead-${color.replace('#', '')}`) // e.g., "arrowhead-ff0000"
                    .attr('viewBox', '0 -5 10 10')
                    .attr('refX', 0)
                    .attr('refY', 0)
                    .attr('markerUnits', 'strokeWidth')
                    .attr('markerWidth', arrowheadMultiplier)
                    .attr('markerHeight', arrowheadMultiplier)
                    .attr('orient', 'auto')
                    .append('path')
                        .attr('d', 'M0,-5L10,0L0,5')
                        .style('fill', color => color); // Set the fill using the color data
            }


            // --- LINKS (EDGES) ---
            // 1. Data Join
            link = container.select(".edges").selectAll(".link")
                .data(links, d => d.uid);

            // 2. Exit Selection
            link.exit().remove();

            // 3. Enter & Merge
            link = link.enter().append("path")
                .attr("class", "link")
                .style("fill", "none")
                .merge(link);

            // 4. Update Selection
            link.transition()
                .duration(delta)
                .style("stroke", d => (d.color || (config.edge && config.edge.color)))
                .style("color", d => (d.color || (config.edge && config.edge.color))) // For arrowhead color
                .style("stroke-width", d => (d.size || (config.edge && config.edge.size)) + 'px')
                .style("opacity", d => (d.opacity || (config.edge && config.edge.opacity)));

        // Conditionally add the correct arrowhead marker
        if (config.directed) {
            link.attr('marker-end', d => {
                // Find the color for this specific link
                const color = d.color || (config.edge && config.edge.color);
                // Create the safe ID that matches the marker definition
                const safeColorId = color.replace('#', '');
                // Return the URL pointing to the specific marker
                return `url(#arrowhead-${safeColorId})`;
            });
        } else {
            link.attr('marker-end', null);
        }

            simulation.nodes(nodes);
            simulation.force("link").links(links);

            // Based on the config.simulation parameter, choose the layout type.
            if (config.simulation) {
                // TRUE: Use a dynamic spring layout (force-directed)
                simulation
                    .force('charge', d3.forceManyBody().strength(-50)) // Nodes repel each other
                    .force('center', d3.forceCenter(width/2, height/2)) // Center the graph
                    .force('x', null) // Remove the static x-force
                    .force('y', null) // Remove the static y-force
                    .force('boundary', forceBoundary(0, 0, width, height));
                
                // Adjust link force
                simulation.force("link").strength(0.1).distance(70);

            } else {
                // FALSE: Use the original fixed layout based on xpos and ypos
                simulation.force('charge', d3.forceManyBody().strength(-20)); // Weak charge to prevent some overlap
                simulation.force('center', null); // No need for centering force
                simulation.force('boundary', null); 

                // Use x/y forces to position nodes based on data
                const xScale = d3.scaleLinear().domain(xlim).range([0, width]);
                const yScale = d3.scaleLinear().domain(ylim).range([0, height]);
                simulation.force('x', d3.forceX().strength(0.1).x(d => xScale(d.xpos)));
                simulation.force('y', d3.forceY().strength(0.1).y(d => yScale(d.ypos)));
                
                // Weaken link force so it doesn't fight the x/y positioning
                simulation.force("link").strength(0);
            }

            // Restart simulation and render immediately
            simulation.alpha(1).restart();
        }
    });
}; // End Network
const scrubber = (values, {
  chartUpdate,
  format = value => value,
  initial = 0,
  delay = null,
  autoplay = true,
  loop = true,
  loopDelay = null,
  alternate = false
} = {}) => {
  values = Array.from(values);
  const form = d3.create('form')
    .style('font', '12px var(--sans-serif)')
    .style('font-variant-numeric', 'tabular-nums')
    .style('display', 'flex')
    .style('height', 33)
    .style('align-items', 'center')
    .attr('value', values[initial]);
  const formB = form.append('button')
    .attr('name', 'b')
    .attr('type', 'button')
    .style('margin-right', '0.4em')
    .style('width', '5em')
    .text('Play');

  const label = form.append('label')
    .style('display', 'flex')
    .style('align-items', 'center');
  const formI = label.append('input')
    .attr('name', 'i')
    .attr('type', 'range')
    .attr('min', 0)
    .attr('max', values.length - 1)
    .attr('value', initial)
    .attr('step', 1)
    .style('width', 180);
  const formO = label.append('output')
    .attr('name', 'o')
    .text(format(values[initial]));

  let frame = null;
  let timer = null;
  let interval = null;
  let direction = 1;

  const stop = () => {
    formB.text('Play');
    if (frame !== null) cancelAnimationFrame(frame), frame = null;
    if (timer !== null) clearTimeout(timer), timer = null;
    if (interval !== null) clearInterval(interval), interval = null;
  }

  const running = () => {
    return frame !== null || timer !== null || interval !== null;
  }

  const formIPostUpdate = (event) => {
    const index = parseInt(formI.property('value'));
    if (event && event.isTrusted && running()) stop();
    formO.property('value', format(values[index], index, values));

      chartUpdate(index);
  }

  const step = () => {
    formI.property('value', (parseInt(formI.property('value')) + direction + values.length) % values.length);
    formIPostUpdate();
  }

  const tick = () => {
    if (parseInt(formI.property('value')) === (direction > 0 ? values.length - 1 : direction < 0 ? 0 : NaN)) {
      if (!loop) return stop();
      if (alternate) direction = -direction;
      if (loopDelay !== null) {
        if (frame !== null) cancelAnimationFrame(frame), frame = null;
        if (interval !== null) clearInterval(interval), interval = null;
        timer = setTimeout(() => (step(), start()), loopDelay);
        return;
      }
    }
    if (delay === null) frame = requestAnimationFrame(tick);
    step();
  }

  const start = () => {
    formB.text('Pause');
    if (delay === null) frame = requestAnimationFrame(tick);
    else interval = setInterval(tick, delay);
  }

  formI.on('input', (event) => {
    formIPostUpdate(event);
  });
  formB.on('click', () => {
    if (running()) return stop();
    direction = alternate && parseInt(formI.property('value')) === values.length - 1 ? -1 : 1;
    formI.property('value', (parseInt(formI.property('value')) + direction) % values.length);
    formIPostUpdate();

    start();
  });

  if (autoplay) start();
  else stop();

  return form;
}


// Initialize Network
const network = Network(config);

// Function to filter elements
const contains = ({start,end}, time) => start <= time && time < end;

// Function to update network over time
const update = (index) => {
    const time = index;//times[index];
    const nodes = data.nodes.filter(d => contains(d, time));
    const links = data.edges.filter(d => contains(d, time));
    network.update({nodes,links});
};

// Range function
const range = (start, stop, step) =>
      Array.from({ length: (stop - start) / step + 1 }, (_, i) => start + i * step);

// Considered time range
times = range(d3.min(data.nodes, d => d.start),d3.max(data.nodes, d => d.end),1);

// Initiate Network
update(1);

// Add counter and start updating network
const scrubberForm = scrubber(times,{chartUpdate:update, delay: config.delta || 300});
d3.select(config.selector).append(() => scrubberForm.node());

}); //END

</script>