{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pathpyG","text":"<p>This is the index page of the pathpyG documentation.</p>"},{"location":"about/","title":"About","text":""},{"location":"about/#what-is-pathpyg","title":"What is pathpyG?","text":"<p>pathpyG is an Open Source package facilitating GPU-accelerated next-generation network analytics and graph learning for time series data on graphs.</p> <p>pathpyG is tailored to analyse time-stamped network data as well as sequential data that capture multiple short walks or paths observed in a graph or network. Examples for data that can be analysed with pathpyG include high-resolution time-stamped network data, dynamic social networks, user click streams on the Web, biological pathway data, directed acyclic graphs like citation networks, passenger trajectories in transportation networks, or trajectories of information propagation in social networks.</p> <p>pathpyG is fully integrated with jupyter, providing rich interactive visualisations of networks, temporal networks, and higher-order models. Visualisations can be exported to HTML5 files that can be shared and published on the Web.</p>"},{"location":"about/#what-is-the-science-behind-pathpyg","title":"What is the science behind pathpyG?","text":"<p>The theoretical foundation of this package, higher- and multi-order network models, was developed in the following peer-reviewed research articles:</p> <ol> <li>L Qarkaxhija, V Perri, I Scholtes: De Bruijn goes Neural: Causality-Aware Graph Neural Networks for Time Series Data on Dynamic Graphs, In Proceedings of the First Learning on Graphs Conference, PMLR 198:51:1-51:21, December 2022</li> <li>L Petrovic, I Scholtes: Learning the Markov order of paths in graphs, In Proceedings of WWW '22: The Web Conference 2022, Lyon, France, April 2022</li> <li>V Perri, I Scholtes: HOTVis: Higher-Order Time-Aware Visualisation of Dynamic Graphs, In Proceedings of the 28<sup>th</sup> International Symposium on Graph Drawing and Network Visualization (GD 2020), Vancouver, BC, Canada, September 15-18, 2020</li> <li>I Scholtes: When is a network a network? Multi-Order Graphical Model Selection in Pathways and Temporal Networks, In KDD'17 - Proceedings of the 23<sup>rd</sup> ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, Halifax, Nova Scotia, Canada, August 13-17, 2017</li> <li>I Scholtes, N Wider, A Garas: Higher-Order Aggregate Networks in the Analysis of Temporal Networks: Path structures and centralities, The European Physical Journal B, 89:61, March 2016</li> <li>I Scholtes, N Wider, R Pfitzner, A Garas, CJ Tessone, F Schweitzer: Causality-driven slow-down and speed-up of diffusion in non-Markovian temporal networks, Nature Communications, 5, September 2014</li> <li>R Pfitzner, I Scholtes, A Garas, CJ Tessone, F Schweitzer: Betweenness preference: Quantifying correlations in the topological dynamics of temporal networks, Phys Rev Lett, 110(19), 198701, May 2013</li> </ol> <p>A broader view on the importance of higher-order graph models for complex systems can be found in this overview article. </p>"},{"location":"contributing/","title":"Contributing","text":"<p>This project is open source and welcomes contributions. In the following sections, you will find information about how to contribute to this project, set up your environment correctly, how to document your code and more.</p>"},{"location":"contributing/#overview","title":"Overview","text":"<ul> <li>Setting up your environment</li> <li>Documentation</li> <li>Code Style</li> <li>Formatting</li> <li>Testing</li> <li>Benchmarking</li> </ul>"},{"location":"contributing/#setting-up-your-environment","title":"Setting up your environment","text":""},{"location":"contributing/#clone-the-repository","title":"Clone the Repository","text":"<p>The first step is to clone the repository. You can do this by running the following command: <pre><code>git clone https://github.com/pathpy/pathpyG\n</code></pre> If you do not have the rights to push to the repository, you can also fork the repository and clone your fork instead. From there you can create a pull request to the original repository.</p>"},{"location":"contributing/#installation","title":"Installation","text":"<p>To ensure version consistency, we use a Development Container for this project.   VSCode provides an easy-to-use extension for this. Check out their official documentation for more information. Once you've installed the extension successfully,   VSCode will recommend reopening the project in the Dev Container. You can also do this manually by clicking on the button in the bottom left corner of   VSCode and then selecting <code>Reopen in Container</code>.</p> Setup without Dev Containers <p>If you do not want to use Dev Containers, you can also install the dependencies into your virtual Python environment manually. We recommend that you follow the instructions provided on our getting started page. As last step, install the package in editable mode and include the dependencies necessary for testing, documentation and general development: <pre><code>pip install -e '.[dev,test,doc]'\n</code></pre></p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>This project uses <code>MkDocs</code> for documentation. It is a static site generator that creates the necessary <code>html</code>-files automatically from the <code>markdown</code>-files and  Group.svg Created using Figma 0.90  Jupyter notebooks in the <code>docs/</code>-directory and the <code>Python</code>-files in <code>src/</code>. The documentation is hosted on GitHub Pages.</p>"},{"location":"contributing/#hosting-the-documentation-locally","title":"Hosting the documentation locally","text":"<p>You can host the documentation locally with the following command: <pre><code>mkdocs serve\n</code></pre> The documentation is then available at <code>http://localhost:8000/</code>.</p> Actual Deployment <p>The development version of the documentation is deployed automatically to GitHub Pages when something is pushed to the <code>main</code>-branch. The workflow for deploying a new stable version needs to be triggered manually. You can find it in the <code>Actions</code>-tab of the repository. Both workflows use <code>mike</code> instead of <code>MkDocs</code> to enable versioning.</p>"},{"location":"contributing/#code-reference","title":"Code Reference","text":"<p>The <code>Code Reference</code> is generated automatically from the   Python source files using <code>docs/gen_ref_pages.py</code>. The docstrings should be formatted according to the Google Python Style Guide. Be sure to also use the advanced stuff like notes, tips and more. They can e.g. look as follows:</p> DocstringResult <pre><code>\"\"\"\nNote:\n    This is a note.\n\nTip: This is a heading\n    This is a tip.\n\"\"\"\n</code></pre> <p>Note</p> <p>This is a note.</p> <p>This is a heading</p> <p>This is a tip.</p> <p>See the documentation of the underlying griffe package for more details.</p> <p>To get an overview for each package, <code>mkdocstrings</code> automatically uses the docstrings from the <code>__init__.py</code> files in each package as description. Thus, do not forget to add a docstring to each <code>__init__.py</code> file. If a package starts with an underscore (<code>_</code>), the underscore will be removed from the name in the documentation. </p>"},{"location":"contributing/#replace-automatic-code-reference","title":"Replace Automatic Code Reference","text":"<p>While the docstrings include rich functionality, it is easier to write long and detailed descriptions using <code>.md</code>-files. Therefore, you can replace the automatically generated documentation for a module by adding a <code>.md</code>-file with the same name as the module in the <code>docs/reference/</code>-directory. The file will be rendered instead of the automatically generated documentation. You can find an example in <code>docs/reference/pathpyG/index.md</code>.</p> <p>Replacing package documentation in the <code>__init__.py</code>-file</p> <p>The Overview for each package can be provided in the <code>__init__.py</code>-file. If you want to replace the <code>__init__.py</code>-file to provide a better documentation using <code>markdown</code>, make sure to name the file <code>index.md</code> instead.</p>"},{"location":"contributing/#ignore-specific-py-files","title":"Ignore specific <code>.py</code>-files","text":"<p>If you want to ignore specific <code>.py</code>-files in the code reference, you can add them to <code>docs/reference/ignored_modules.yaml</code>. All files listed there will be ignored when generating the code reference. If you include all files in a package-directory, the whole package will not be shown in the documentation.</p>"},{"location":"contributing/#tutorials","title":"Tutorials","text":"<p>The tutorials are written in  Group.svg Created using Figma 0.90  Jupyter notebooks. They are located in the <code>docs/</code>-directory. You can add new tutorials by adding the notebook to the <code>docs/tutorial/</code>-directory and adding the path to the <code>mkdocs.yml</code>-file under <code>nav:</code>. The tutorials are automatically converted to <code>html</code>-files when the documentation is built.</p>"},{"location":"contributing/#adding-new-pages","title":"Adding new pages","text":"<p>You can add more pages to the documentation by adding a <code>markdown</code>-file to the <code>docs/</code>-directory and adding the path to the <code>mkdocs.yml</code>-file under <code>nav:</code>. The pages are automatically converted to <code>html</code>-files when the documentation is built. We are using Material for MkDocs as a theme. It includes many great features like annotations, code blocks, diagrams, admonitions and more. Check out their documentation for more information.</p>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We (soon) enforce code style guidelines with <code>ruff</code> and <code>mypy</code>. These packages are configured as defaults in the Dev Container setup via <code>VSCode</code> and the settings are saved in <code>pyproject.toml</code>. You can run them locally with the following commands:</p> <ul> <li><code>ruff</code>: A linter that checks for errors and code style violations.     <pre><code>ruff check . # (1)!\n</code></pre><ol> <li>This runs <code>ruff</code> as a linter on all files in the current directory. You can also run <code>ruff</code> on a single file by specifying the path to the file instead. If you want to automatically fix all issues that can be fixed automatically, you can use <code>ruff check . --fix</code>.</li> </ol> </li> <li><code>mypy</code>: A static type checker for Python.     <pre><code>mypy src/ # (1)!\n</code></pre><ol> <li>This runs <code>mypy</code> on all files in <code>src/</code>. You can also run <code>mypy</code> on a single file by specifying the path to the file instead.</li> </ol> </li> </ul>"},{"location":"contributing/#formatting","title":"Formatting","text":"<p>We use <code>ruff</code> for formatting. You can run it locally with the following command:</p> <pre><code>ruff format . # (1)!\n</code></pre> <ol> <li>This command will format all files in the current directory. You can also run <code>ruff</code> on a single file or a subdirectory by specifying the path accordingly.</li> </ol> <p>The default keyboard shortcut for formatting in <code>VSCode</code> is <code>Alt + Shift + F</code>.</p>"},{"location":"contributing/#testing","title":"Testing","text":"<p>We are using <code>pytest</code> for testing. You can run the tests locally with the following command: <pre><code>pytest\n</code></pre> The tests are located in the <code>tests/</code>-directory. We use <code>pytest-cov</code> to measure the test coverage and are aiming for 100% coverage with a hard limit of 80%. Tests will fail if the coverage drops below 80%.</p> <p>Add tests</p> <p>We are currently only at 60% coverage. So the lines above are currently pure fiction.</p> <p>Test that use a GPU are located in the <code>tests/gpu</code>-directory. They are currently disabled for CI but can be manually executed with <pre><code>pytest -m gpu\n</code></pre></p>"},{"location":"contributing/#benchmarking","title":"Benchmarking","text":"<p>For optimal runtime, we continually measure the execution time of our core functions using pytest benchmarks. These benchmarks are located in <code>tests/benchmarks/</code> and are unit-tests that utilize the <code>benchmark</code> fixture from <code>pytest-benchmark</code>. All of them are marked with the benchmark decorator (<code>@pytest.mark.benchmark</code>) to exclude them from the normal unit-tests. You can run all benchmarks in the command line using <pre><code>pytest -m benchmark\n</code></pre> If you are working on runtime improvements, you can compare the runtime of your changes to the runtime of the main branch by saving the results of each run with <pre><code>pytest -m benchmark --benchmark-autosave\n</code></pre> or with a custom name <code>&lt;custom-name&gt;</code> <pre><code>pytest -m benchmark --benchmark-save=&lt;custom-name&gt;\n</code></pre> After running the benchmarks both in your current branch and in the main branch, you can compare them as follows: <pre><code>pytest-benchmark compare # (1)!\n</code></pre></p> <ol> <li>This will compare all runs that are currently saved in <code>.benchmarks/</code>. If you want to compare specific runs, you can add the number of the runs at the end of the command. The numbering usually starts with <code>0001</code>.</li> </ol> <p>Note</p> <p>Since the runtime is strongly dependent on the underlying machine, we do not keep any up-to-date results on <code>git</code> and recommend to do any comparisons locally.</p>"},{"location":"docker_installation/","title":"Docker Installation","text":"<p>  PyTorch provides a  Docker image with PyTorch preinstalled. Using this image, the Dockerfile below creates a Docker image with PathpyG installed.</p> GPUCPU <pre><code>FROM pytorch/pytorch:2.1.0-cuda12.1-cudnn8-runtime\nWORKDIR /workspaces/pathpyG\nRUN apt-get update\nRUN apt-get -y install git\n\nRUN pip install torch==2.1.0+cu121 --index-url https://download.pytorch.org/whl/cu121\n\nRUN pip install torch_geometric&gt;=2.4.0\nRUN pip install pyg_lib torch_scatter torch_sparse torch_cluster torch_spline_conv -f https://data.pyg.org/whl/torch-2.1.0+cu121.html\nRUN pip install git+https://github.com/pathpy/pathpyG.git\n</code></pre> <pre><code>FROM pytorch/pytorch:2.1.0-cuda12.1-cudnn8-runtime\nWORKDIR /workspaces/pathpyG\nRUN apt-get update\nRUN apt-get -y install git\n\nRUN pip install torch==2.1.0+cpu --index-url https://download.pytorch.org/whl/cpu # CPU only\n\nRUN pip install torch_geometric&gt;=2.4.0\nRUN pip install pyg_lib torch_scatter torch_sparse torch_cluster torch_spline_conv -f https://data.pyg.org/whl/torch-2.1.0+cpu.html # CPU only\nRUN pip install git+https://github.com/pathpy/pathpyG.git\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":"<p>The following will guide you through the installation of the package and the first steps to use it.</p>"},{"location":"getting_started/#prerequisites","title":"Prerequisites","text":"<p>PathpyG is available for   Python versions 3.10 and above. It is not recommended to install it on your system Python. Instead, we recommend using a virtual environment such as   conda or virtualenv. You can also set up a   Docker image as described in the next section.</p>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>Once you have an environment up and running, you can install the package simply via pip. But first make sure that you installed the necessary dependencies.</p>"},{"location":"getting_started/#dependencies","title":"Dependencies","text":"<p>This package is based on   PyTorch and   PyTorch Geometric. Please install both libraries before installing PathpyG. You can follow the installation instructions in their respective documentation (  PyTorch and   PyG). Alternatively, you can install the correct versions of both libraries using <code>uv</code> to install the optional dependencies of PathpyG. You can choose between a CPU-only installation or a CUDA installation for a specific CUDA version. For example, to install the CPU-only version, run:</p> <p><pre><code>uv pip install pathpyg[cpu]\n</code></pre> Or, to install the CUDA 12.9 version, run:</p> <pre><code>uv pip install pathpyg[cu129]\n</code></pre> <p>Warning</p> <p>We currently only support PyG version 2.5.0 and above.</p>"},{"location":"getting_started/#install-stable-release","title":"Install Stable Release","text":"<p>You can install the latest stable release of PathpyG via pip:</p> <p>TODO</p> <p>This is not yet available. We will release the first stable version soon.</p> <pre><code>pip install pathpyg\n</code></pre>"},{"location":"getting_started/#install-latest-development-version","title":"Install Latest Development Version","text":"<p>If you want to install the latest development version, you can do so via pip directly from the GitHub repository:</p> <pre><code>pip install git+https://github.com/pathpy/pathpyG.git\n</code></pre>"},{"location":"getting_started/#optional-visualisation-backends","title":"Optional Visualisation Backends","text":"<p>We provide multiple visualisation backends for PathpyG. The default backend D3.js does not require any additional dependencies. We further provide a Matplotlib backend that is installed by default. Additionally, we implemented a tikz and a Manim backend that are not installed by default due to their dependencies that are required for installation. You can use the tikz backend if you have a LaTeX distribution installed on your system. </p> <p>To use the Manim backend, please refer to the Manim installation instructions for more information. Once installed, you can use the backends for visualisation by setting the <code>backend</code> in the <code>PathpyG.plot</code> function to <code>tikz</code> or <code>manim</code>:</p> Using the TikZ Backend <pre><code>import pathpyg as pp\n\ng = pp.Graph.from_edge_list([('a', 'b'),('b', 'c'),('c', 'a')])\npp.plot(g, backend='tikz')\n</code></pre> Using the Manim Backend <pre><code>import pathpyg as pp\n\nt_graph = TemporalGraph.from_edge_list([('a', 'b', 1),('b', 'a', 3), ('b', 'c', 3)])\npp.plot(t_graph, backend='manim')\n</code></pre>"},{"location":"plot_tutorial/","title":"Developing your own Plots","text":"<p>Overview</p> <p>Add a new histogram plot to pathpyG\u2019s visualisation stack, wire it into <code>pp.plot(...)</code>, and render it with Matplotlib. This guide explains the data-prep vs. rendering split and shows the minimal pieces to implement.</p> <p>This tutorial shows how to add a new plotting capability to pathpyG\u2019s visualisation backend by implementing a histogram plot. You\u2019ll learn how plot types, backends, and configuration work together, and how to add a new plot into the public <code>pp.plot(...)</code> entry point.</p> <p>What you\u2019ll do</p> <ul> <li> Understand the new visualisation architecture</li> <li> Implement a new <code>HistogramPlot</code> that prepares data</li> <li> Wire it into the plot orchestrator and select backends</li> <li> Add Matplotlib rendering support for the new type</li> <li> Use and (optionally) test your new plot</li> </ul> <p>Scope</p> <p>This guide focuses on Matplotlib for rendering histograms (a natural fit). You can add other backends later following the same pattern.</p>"},{"location":"plot_tutorial/#visualisation-architecture-at-a-glance","title":"Visualisation architecture at a glance","text":"<p>The visualisation module is built around two core abstractions and a single entry point:</p> <ul> <li> <code>PathPyPlot</code> prepares data/config for rendering. Subclass it for each plot type.</li> <li> <code>PlotBackend</code> renders a given <code>PathPyPlot</code> using a concrete engine (Matplotlib, TikZ, d3.js, Manim).</li> <li> <code>plot(...)</code> is the public API. It chooses a plot class (kind) and a backend (by argument or filename extension), instantiates both, then saves or shows.</li> </ul> <p>Reference</p> <p>See the module overview for supported backends, formats, and styling options. For existing plot types, see <code>NetworkPlot</code> (static) and <code>TemporalNetworkPlot</code> (temporal). For existing backends, see e.g. <code>MatplotlibBackend</code> which we will be using.</p>"},{"location":"plot_tutorial/#define-a-new-plot-type-histogramplot","title":"Define a new plot type: HistogramPlot","text":"<p>Start by creating a new subclass of <code>PathPyPlot</code> (e.g., in <code>src/pathpyG/visualisations/histogram_plot.py</code>). Its job is to:</p> <ul> <li>Accept the input object(s) (typically a <code>Graph</code>) and user options</li> <li>Compute or collect the values to be binned</li> <li>Populate <code>self.data</code> with a clean, backend-agnostic structure</li> <li>Update <code>self.config</code> with plot configuration (bins, labels, etc.)</li> </ul> <p>Minimal class attributes</p> <p>Inputs: <code>graph: Graph</code>, <code>key: str</code> (what to measure), <code>bins: int | sequence</code>, plus style options via <code>**kwargs</code>.</p> <p>Data format (suggested): - <code>self.data[\"hist_values\"]: list[float | int]</code> \u2014 the values to bin - optionally precomputed bins/edges (if you want backend-agnostic binning) - <code>self.config</code> should include <code>title</code>, <code>xlabel</code>, <code>ylabel</code>, and <code>bins</code></p>"},{"location":"plot_tutorial/#example-outline","title":"Example outline:","text":"<pre><code># src/pathpyG/visualisations/histogram_plot.py\nfrom __future__ import annotations\nimport logging\nfrom typing import Any\nfrom pathpyG.visualisations.pathpy_plot import PathPyPlot\nfrom pathpyG.core.graph import Graph\n\nlogger = logging.getLogger(\"root\")\n\n\nclass HistogramPlot(PathPyPlot):\n    \"\"\"Prepare data for histogram visualisation.\n\n    Collects values from a Graph according to `key` and exposes them in\n    `self.data[\"hist_values\"]` for backends to render.\n    \"\"\"\n\n    _kind = \"histogram\"\n\n    def __init__(self, graph: Graph, key: str = \"degree\", bins: int | list[int] = 10, **kwargs: Any) -&gt; None:\n        super().__init__()\n        self.graph = graph\n        # merge kwargs into config; ensure required fields are present\n        self.config.update({\n            \"bins\": bins,\n            \"title\": kwargs.pop(\"title\", f\"{key.title()} distribution\"),\n            \"xlabel\": kwargs.pop(\"xlabel\", key),\n            \"ylabel\": kwargs.pop(\"ylabel\", \"count\"),\n        })\n        self.key = key\n        self.config.update(kwargs)\n        self.generate()\n\n    def generate(self) -&gt; None:\n        # Compute values to bin based on `key`\n        if self.key in (\"degree\", \"degrees\"):\n            values = list(self.graph.degrees().values())\n        elif self.key in (\"in_degree\", \"indegree\", \"in-degrees\"):\n            values = list(self.graph.degrees(mode=\"in\").values())\n        elif self.key in (\"out_degree\", \"outdegree\", \"out-degrees\"):\n            values = list(self.graph.degrees(mode=\"out\").values())\n        else:\n            logger.error(f\"Histogram key '{self.key}' not supported.\")\n            raise KeyError(self.key)\n\n        self.data[\"hist_values\"] = values\n</code></pre> <p>Note</p> <ul> <li>Keep the class small: gather values and fill <code>self.data</code>/<code>self.config</code>.</li> <li>Choose names that are clear for backends (<code>hist_values</code>, <code>bins</code>, labels).</li> </ul>"},{"location":"plot_tutorial/#add-the-new-plot-to-the-public-api","title":"Add the new plot to the public API","text":"<p><code>plot(...)</code> uses the <code>PLOT_CLASSES</code> mapping to instantiate the right plot class for a given <code>kind</code>. Extend it with your new class:</p> <pre><code># src/pathpyG/visualisations/plot_function.py\nfrom pathpyG.visualisations.histogram_plot import HistogramPlot\n\nPLOT_CLASSES: dict = {\n    \"static\": NetworkPlot,\n    \"temporal\": TemporalNetworkPlot,\n    \"histogram\": HistogramPlot,  # add this line\n}\n</code></pre> Usage <pre><code>import pathpyG as pp\n\ng = pp.Graph.from_edge_list([(\"a\", \"b\"), (\"b\", \"c\"), (\"a\", \"c\")])\n# Matplotlib is the natural backend for histograms\npp.plot(g, kind=\"histogram\", backend=\"matplotlib\", key=\"degree\", bins=10, filename=\"degree_hist.png\")\n</code></pre> <p>Backend selection</p> <p><code>plot(...)</code> auto-selects a backend from the filename extension if you omit <code>backend</code>. For histograms, prefer PNG via Matplotlib by passing <code>filename=\"...png\"</code> or <code>backend=\"matplotlib\"</code>.</p>"},{"location":"plot_tutorial/#add-matplotlib-support-for-histogramplot","title":"Add Matplotlib support for HistogramPlot","text":"<p>Backends validate supported plot types. The Matplotlib backend currently supports <code>NetworkPlot</code> and renders nodes/edges. We\u2019ll extend it to also support <code>HistogramPlot</code>.</p> <p>Implementation approach:</p> <ol> <li>Add <code>HistogramPlot</code> to <code>SUPPORTED_KINDS</code> so the backend accepts the plot type.</li> <li>Branch in <code>to_fig()</code> (or factor out into a helper) to draw a histogram when the plot is a <code>HistogramPlot</code>.</li> </ol> <p>Sketch of the required changes (condensed for illustration):</p> <pre><code># src/pathpyG/visualisations/_matplotlib/backend.py\nfrom pathpyG.visualisations.histogram_plot import HistogramPlot\n\nSUPPORTED_KINDS = {\n    NetworkPlot: \"static\",\n    HistogramPlot: \"histogram\",  # add support\n}\n\nclass MatplotlibBackend(PlotBackend):\n    ...\n    def to_fig(self) -&gt; tuple[plt.Figure, plt.Axes]:\n        # If histogram: render using ax.hist\n        if self._kind == \"histogram\":\n            return self._to_fig_histogram()\n        # Else: existing network rendering\n        return self._to_fig_network()\n\n    def _to_fig_histogram(self) -&gt; tuple[plt.Figure, plt.Axes]:\n        fig, ax = plt.subplots(\n            figsize=(unit_str_to_float(self.config[\"width\"], \"in\"), unit_str_to_float(self.config[\"height\"], \"in\")),\n            dpi=150,\n        )\n        ax.set_axis_on()\n        ax.hist(self.data[\"hist_values\"], bins=self.config.get(\"bins\", 10), color=rgb_to_hex(self.config[\"node\"][\"color\"]), alpha=0.9)\n        ax.set_title(self.config.get(\"title\", \"Histogram\"))\n        ax.set_xlabel(self.config.get(\"xlabel\", \"value\"))\n        ax.set_ylabel(self.config.get(\"ylabel\", \"count\"))\n        return fig, ax\n\n    def _to_fig_network(self) -&gt; tuple[plt.Figure, plt.Axes]:\n        # move existing implementation of `to_fig` here\n        ...\n</code></pre> <p>Tips</p> <ul> <li>Reuse <code>unit_str_to_float</code> so sizing behaves like other plots.</li> <li>Use a default color from <code>self.config[\"node\"][\"color\"]</code> for consistency.</li> <li>Keep the new code path fully separate from the network drawing code to avoid regressions.</li> </ul> If you want web or LaTeX histograms <p>The current d3.js and TikZ backends are tailored to network visualisation (they expect <code>nodes</code>/<code>edges</code> in <code>self.data</code>). To add histogram support there, you would:</p> <ul> <li>Create a new JS or TeX template for histograms</li> <li>Extend the backend to accept <code>HistogramPlot</code> and dispatch to the new template</li> </ul> <p>Start with Matplotlib first \u2014 it's a good starting point.</p>"},{"location":"plot_tutorial/#try-it-out","title":"Try it out","text":"<p>Once you\u2019ve added the <code>HistogramPlot</code>, updated <code>PLOT_CLASSES</code>, and extended the Matplotlib backend as shown, you can create and save a histogram in a single call:</p> <pre><code>import pathpyG as pp\n\ng = pp.Graph.from_edge_list([(\"a\", \"b\"), (\"b\", \"c\"), (\"a\", \"c\"), (\"c\", \"d\")])\npp.plot(\n    g,\n    kind=\"histogram\",\n    backend=\"matplotlib\",  # or infer via filename extension\n    key=\"degree\",\n    bins=5,\n    title=\"Node Degree Distribution\",\n    filename=\"degree_hist.png\",\n)\n</code></pre> <p>In notebooks, omit <code>filename</code> to show inline.</p>"},{"location":"plot_tutorial/#testing-optional-but-recommended","title":"Testing (optional but recommended)","text":"<p>Create a small unit test to exercise the new path end-to-end:</p> <pre><code># tests/visualisations/test_histogram.py\nimport pathpyG as pp\n\ndef test_histogram_plot_matplotlib(tmp_path):\n    g = pp.Graph.from_edge_list([(\"a\", \"b\"), (\"b\", \"c\"), (\"a\", \"c\")])\n    out = tmp_path / \"deg_hist.png\"\n    pp.plot(g, kind=\"histogram\", backend=\"matplotlib\", key=\"degree\", bins=3, filename=str(out))\n    assert out.exists()\n</code></pre>"},{"location":"plot_tutorial/#where-to-look-for-guidance-and-consistency","title":"Where to look for guidance and consistency","text":"<ul> <li> Backends: see other backends like <code>Matplotlib</code> and <code>d3.js</code> for how plot instances are validated and rendered.</li> <li> Plot classes: study <code>NetworkPlot</code> and <code>TemporalNetworkPlot</code> to understand how <code>PathPyPlot</code> subclasses fill <code>self.data</code> and <code>self.config</code>.</li> <li> The module overview explains backend selection, saving, and common styling options.</li> </ul>"},{"location":"plot_tutorial/#recap","title":"Recap","text":"<ul> <li> New plots are <code>PathPyPlot</code> subclasses that prepare data and config.</li> <li> Register your plot in <code>PLOT_CLASSES</code> so <code>pp.plot(..., kind=...)</code> can instantiate it.</li> <li> Extend at least one backend to render your plot type. For histograms, Matplotlib is a clean first target.</li> <li> Keep a small, clear data contract between your plot class and backend rendering.</li> </ul> <p>With this, you have a clean, maintainable path to add new visualisations to pathpyG while leveraging the unified <code>pp.plot(...)</code> API and existing backend infrastructure.</p>"},{"location":"tutorial/","title":"Overview","text":"<p>In this tutorial, we will introduce basic concepts of pathpyG. pathpyG can be used as a wrapper around pytorch-geometric that facilitates network analysis, graph learning, and interactive data visualization. However, its real power comes into play when modelling causal path structures in time series data on networks, such as trajectories on graphs or temporal graphs with time-stamped interactions. pathpyG allows to compute causal paths in temporal graphs and model them based on higher-order De Bruijn graphs, a higher-dimensional generalization of standard graph models for relational data.</p> <p>The following introductory video explains the basic idea of higher-order De Bruijn graph models for causal path structures in time series data:</p> <p>The science behind pathpyG has been published in outlets like SIGKDD, WWW, Learning on Graphs, Nature Communications, Nature Physics, and Physical Review Letters. Please check here for more details on key scientific works that have laid the foundations for this package.</p> <p>Different from previous versions of pathpy, the latest version pathpyG fully utilizes the power of torch and tensor-based representations of sparse graph models to failitate the use of higher-order De Bruijn graph models. pathpyG's data structures naturally generalize the concepts of pytorch-geometric, which makes it easy to apply it in (temnporal) graph learning tasks.</p> <p>Finally, pathpyG comes with an implementation of De Bruijn Graph Neural Networks (DBGNN), a causality-aware deep learning architecture for temporal graph data. In the tutorial, we illustrate this temporal graph learning approach in a simple toy example.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>pathpyG<ul> <li>algorithms<ul> <li>centrality</li> <li>components</li> <li>generative_models</li> <li>lift_order</li> <li>rolling_time_window</li> <li>shortest_paths</li> <li>temporal</li> <li>weisfeiler_leman</li> </ul> </li> <li>core<ul> <li>graph</li> <li>index_map</li> <li>multi_order_model</li> <li>path_data</li> <li>temporal_graph</li> </ul> </li> <li>io<ul> <li>netzschleuder</li> <li>pandas</li> </ul> </li> <li>nn<ul> <li>dbgnn</li> </ul> </li> <li>statistics<ul> <li>clustering</li> <li>degrees</li> <li>node_similarities</li> </ul> </li> <li>utils<ul> <li>config</li> <li>convert</li> <li>dbgnn</li> <li>logger</li> <li>progress</li> </ul> </li> <li>visualisations<ul> <li>d3js<ul> <li>backend</li> </ul> </li> <li>manim<ul> <li>backend</li> <li>temporal_graph_scene</li> </ul> </li> <li>matplotlib<ul> <li>backend</li> </ul> </li> <li>tikz<ul> <li>backend</li> </ul> </li> <li>layout</li> <li>network_plot</li> <li>pathpy_plot</li> <li>plot_backend</li> <li>plot_function</li> <li>temporal_network_plot</li> <li>unfolded_network_plot</li> <li>utils</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/pathpyG/","title":"pathpyG","text":"<p>pathpyG is an Open Source package facilitating next-generation network analytics and graph learning for time series data on graphs.</p> <p>Building on the industry-proven data structures and concepts of <code>pytorch</code> and <code>torch_geometric</code>, pathpyG makes it easier than ever to apply machine learning to temporal graph data.</p> <p>pathpyG is jointly developed at University of Wuerzburg, Princeton University, and University of Zurich. The research behind pathpyG has been funded by the Swiss National Science Foundation via  grant 176938.</p>"},{"location":"reference/pathpyG/algorithms/","title":"algorithms","text":"<p>Algorithms for temporal path calculation and graph metrics.</p> <p>The functions and submodules in this module allow to compute  time-respecting or causal paths in temporal graphs and to calculate (temporal) and higher-order graph metrics like centralities.</p> Example <pre><code># Import pathpyG\nimport pathpyG as pp\n\n# Generate a toy example for a temporal graph.\ng = pp.TemporalGraph.from_edge_list([\n    ('b', 'c', 2),\n    ('a', 'b', 1),\n    ('c', 'd', 3),\n    ('d', 'a', 4),\n    ('b', 'd', 2),\n    ('d', 'a', 6),\n    ('a', 'b', 7)\n])\n\n# Extract DAG capturing causal interaction sequences in temporal graph.\ne_i = pp.algorithms.lift_order_temporal(g, delta=1)\ndag = pp.Graph.from_edge_index(e_i)\nprint(dag)\n\n# Calculate shortest time-respecting pathas\ndist, pred = pp.algorithms.temporal.temporal_shortest_paths(g, delta=1)\n</code></pre>"},{"location":"reference/pathpyG/algorithms/#pathpyG.algorithms.RollingTimeWindow","title":"<code>RollingTimeWindow</code>","text":"<p>An iterable rolling time window that can be used to perform time slice analysis of temporal graphs.</p> Source code in <code>src/pathpyG/algorithms/rolling_time_window.py</code> <pre><code>class RollingTimeWindow:\n    \"\"\"An iterable rolling time window that can be used to perform time slice analysis of temporal graphs.\"\"\"\n\n    def __init__(self, temporal_graph, window_size, step_size=1, return_window=False, weighted=True):\n        \"\"\"Initialize RollingTimeWindow.\n\n        Initialize a RollingTimeWindow instance that can be used to\n        iterate through a sequence of time-slice networks for a given\n        TemporalNetwork instance.\n\n        Args:\n            temporal_graph: TemporalGraphinstance that will be used to generate the\n                sequence of time-slice networks.\n            window_size: The width of the rolling time window used to create time-slice networks.\n            step_size: The step size in time units by which the starting\n                time of the rolling window will be incremented on each iteration.\n            return_window: Whether or not the iterator shall return the current time window as a second return value. Default is False.\n            weighted: Whether or not to return a weighted graph\n\n        Example:\n            ```py\n            tedges = [('a', 'b', 1), ('b', 'c', 5), ('c', 'd', 9), ('c', 'e', 9),\n              ('c', 'f', 11), ('f', 'a', 13), ('a', 'g', 18), ('b', 'f', 21),\n              ('a', 'g', 26), ('c', 'f', 27), ('h', 'f', 27), ('g', 'h', 28),\n              ('a', 'c', 30), ('a', 'b', 31), ('c', 'h', 32), ('f', 'h', 33),\n              ('b', 'i', 42), ('i', 'b', 42), ('c', 'i', 47), ('h', 'i', 50)]\n            t = pp.TemporalGraph.from_edge_list(tedges)\n            r = pp.algorithms.RollingTimeWindow(t, 10, 10, return_window=True)\n            for g, w in r:\n                print('Time window ', w)\n                print(g)\n                print(g.data.edge_index)\n                print('---')\n            ```\n        \"\"\"\n        self.g = temporal_graph\n        self.window_size = window_size\n        self.step_size = step_size\n        self.current_time = self.g.start_time\n        self.return_window = return_window\n        self.weighted = weighted\n\n    def __iter__(self):\n        \"\"\"Return the iterator object itself.\"\"\"\n        return self\n\n    def __next__(self):\n        \"\"\"Return the next time-slice network in the rolling time window sequence.\"\"\"\n        if self.current_time &lt;= self.g.end_time:\n            time_window = (self.current_time, self.current_time + self.window_size)\n            s = self.g.to_static_graph(weighted=self.weighted, time_window=time_window)\n            self.current_time += self.step_size\n            if self.return_window:\n                return s, time_window\n            else:\n                return s\n        else:\n            raise StopIteration()\n</code></pre>"},{"location":"reference/pathpyG/algorithms/#pathpyG.algorithms.RollingTimeWindow.__init__","title":"<code>__init__</code>","text":"<p>Initialize RollingTimeWindow.</p> <p>Initialize a RollingTimeWindow instance that can be used to iterate through a sequence of time-slice networks for a given TemporalNetwork instance.</p> <p>Parameters:</p> Name Type Description Default <code>temporal_graph</code> <p>TemporalGraphinstance that will be used to generate the sequence of time-slice networks.</p> required <code>window_size</code> <p>The width of the rolling time window used to create time-slice networks.</p> required <code>step_size</code> <p>The step size in time units by which the starting time of the rolling window will be incremented on each iteration.</p> <code>1</code> <code>return_window</code> <p>Whether or not the iterator shall return the current time window as a second return value. Default is False.</p> <code>False</code> <code>weighted</code> <p>Whether or not to return a weighted graph</p> <code>True</code> Example <pre><code>tedges = [('a', 'b', 1), ('b', 'c', 5), ('c', 'd', 9), ('c', 'e', 9),\n  ('c', 'f', 11), ('f', 'a', 13), ('a', 'g', 18), ('b', 'f', 21),\n  ('a', 'g', 26), ('c', 'f', 27), ('h', 'f', 27), ('g', 'h', 28),\n  ('a', 'c', 30), ('a', 'b', 31), ('c', 'h', 32), ('f', 'h', 33),\n  ('b', 'i', 42), ('i', 'b', 42), ('c', 'i', 47), ('h', 'i', 50)]\nt = pp.TemporalGraph.from_edge_list(tedges)\nr = pp.algorithms.RollingTimeWindow(t, 10, 10, return_window=True)\nfor g, w in r:\n    print('Time window ', w)\n    print(g)\n    print(g.data.edge_index)\n    print('---')\n</code></pre> Source code in <code>src/pathpyG/algorithms/rolling_time_window.py</code> <pre><code>def __init__(self, temporal_graph, window_size, step_size=1, return_window=False, weighted=True):\n    \"\"\"Initialize RollingTimeWindow.\n\n    Initialize a RollingTimeWindow instance that can be used to\n    iterate through a sequence of time-slice networks for a given\n    TemporalNetwork instance.\n\n    Args:\n        temporal_graph: TemporalGraphinstance that will be used to generate the\n            sequence of time-slice networks.\n        window_size: The width of the rolling time window used to create time-slice networks.\n        step_size: The step size in time units by which the starting\n            time of the rolling window will be incremented on each iteration.\n        return_window: Whether or not the iterator shall return the current time window as a second return value. Default is False.\n        weighted: Whether or not to return a weighted graph\n\n    Example:\n        ```py\n        tedges = [('a', 'b', 1), ('b', 'c', 5), ('c', 'd', 9), ('c', 'e', 9),\n          ('c', 'f', 11), ('f', 'a', 13), ('a', 'g', 18), ('b', 'f', 21),\n          ('a', 'g', 26), ('c', 'f', 27), ('h', 'f', 27), ('g', 'h', 28),\n          ('a', 'c', 30), ('a', 'b', 31), ('c', 'h', 32), ('f', 'h', 33),\n          ('b', 'i', 42), ('i', 'b', 42), ('c', 'i', 47), ('h', 'i', 50)]\n        t = pp.TemporalGraph.from_edge_list(tedges)\n        r = pp.algorithms.RollingTimeWindow(t, 10, 10, return_window=True)\n        for g, w in r:\n            print('Time window ', w)\n            print(g)\n            print(g.data.edge_index)\n            print('---')\n        ```\n    \"\"\"\n    self.g = temporal_graph\n    self.window_size = window_size\n    self.step_size = step_size\n    self.current_time = self.g.start_time\n    self.return_window = return_window\n    self.weighted = weighted\n</code></pre>"},{"location":"reference/pathpyG/algorithms/#pathpyG.algorithms.RollingTimeWindow.__iter__","title":"<code>__iter__</code>","text":"<p>Return the iterator object itself.</p> Source code in <code>src/pathpyG/algorithms/rolling_time_window.py</code> <pre><code>def __iter__(self):\n    \"\"\"Return the iterator object itself.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/pathpyG/algorithms/#pathpyG.algorithms.RollingTimeWindow.__next__","title":"<code>__next__</code>","text":"<p>Return the next time-slice network in the rolling time window sequence.</p> Source code in <code>src/pathpyG/algorithms/rolling_time_window.py</code> <pre><code>def __next__(self):\n    \"\"\"Return the next time-slice network in the rolling time window sequence.\"\"\"\n    if self.current_time &lt;= self.g.end_time:\n        time_window = (self.current_time, self.current_time + self.window_size)\n        s = self.g.to_static_graph(weighted=self.weighted, time_window=time_window)\n        self.current_time += self.step_size\n        if self.return_window:\n            return s, time_window\n        else:\n            return s\n    else:\n        raise StopIteration()\n</code></pre>"},{"location":"reference/pathpyG/algorithms/#pathpyG.algorithms.WeisfeilerLeman_test","title":"<code>WeisfeilerLeman_test</code>","text":"<p>Run Weisfeiler-Leman isomorphism test on two graphs.</p> <p>The algorithm heuristically checks whether two graphs are isomorphic. If it returns False, we can be sure that the graphs are non-isomoprhic. If the test returns True we did not find conclusive evidence that they are not isomorphic, i.e. the graphs may or may not be isomophic.</p> <p>The two graphs must have IndexMap mappings that assign different node IDs to the nodes in both graphs. The function will raise an error if the node labels of both graphs overlap.</p> <p>The function returns a tuple (bool, list, list), where the first entry is the result of the test and the two lists represent the fingerprints of the two graphs. If the test yields true the fingerprints are identical. If the test fails, the fingerprints do not correspond.</p> <p>Parameters:</p> Name Type Description Default <code>g1</code> <code>pathpyG.core.graph.Graph</code> <p>First graph.</p> required <code>g2</code> <code>pathpyG.core.graph.Graph</code> <p>Second graph.</p> required <code>features_g1</code> <code>dict | None</code> <p>Optional initial node features for graph 1.</p> <code>None</code> <code>features_g2</code> <code>dict | None</code> <p>Optional initial node features for graph 2.</p> <code>None</code> Source code in <code>src/pathpyG/algorithms/weisfeiler_leman.py</code> <pre><code>def WeisfeilerLeman_test(\n    g1: Graph, g2: Graph, features_g1: dict | None = None, features_g2: dict | None = None\n) -&gt; Tuple[bool, List[str], List[str]]:\n    \"\"\"Run Weisfeiler-Leman isomorphism test on two graphs.\n\n    The algorithm heuristically checks whether two graphs are isomorphic. If it returns False,\n    we can be sure that the graphs are non-isomoprhic. If the test returns True we did not find\n    conclusive evidence that they are not isomorphic, i.e. the graphs may or may not be isomophic.\n\n    The two graphs must have IndexMap mappings that assign different node IDs to the nodes\n    in both graphs. The function will raise an error if the node labels of both graphs overlap.\n\n    The function returns a tuple (bool, list, list), where the first entry is the result of the test\n    and the two lists represent the fingerprints of the two graphs. If the test yields true the fingerprints\n    are identical. If the test fails, the fingerprints do not correspond.\n\n    Args:\n        g1: First graph.\n        g2: Second graph.\n        features_g1: Optional initial node features for graph 1.\n        features_g2: Optional initial node features for graph 2.\n    \"\"\"\n    if g1.mapping is None or g2.mapping is None:\n        raise Exception(\"Graphs must contain IndexMap that assigns node IDs\")\n    if len(set(g1.mapping.node_ids).intersection(g2.mapping.node_ids)) &gt; 0:  # type: ignore[arg-type]\n        raise Exception(\"node identifiers of graphs must not overlap\")\n    g_combined = g1 + g2\n    # initialize labels of all nodes to zero\n    if features_g1 is None or features_g2 is None:\n        fingerprint: Dict[str | int, str] = {v: \"0\" for v in g_combined.nodes}\n    else:\n        fingerprint = features_g1.copy()\n        fingerprint.update(features_g2)\n    labels = {}\n    label_count = 1\n    stop = False\n    while not stop:\n        new_fingerprint = {}\n        for node in g_combined.nodes:\n            # create new label based on own label and sorted labels of all neighbors\n            n_label = [fingerprint[x] for x in g_combined.successors(node)]\n            n_label.sort()\n            label = str(fingerprint[node]) + str(n_label)\n            # previously unknown label\n            if label not in labels:\n                # create a new label based on next consecutive number\n                labels[label] = label_count\n                label_count += 1\n            new_fingerprint[node] = labels[label]\n        if len(set(fingerprint.values())) == len(set(new_fingerprint.values())):\n            # we processed all nodes in both graphs without encountering a new label, so we stop\n            stop = True\n        else:\n            # update fingerprint and continue\n            fingerprint = new_fingerprint.copy()  # type: ignore[assignment]\n\n    # Reduce fingerprints to nodes of g1 and g2 respectively\n    fingerprint_1 = [fingerprint[v] for v in g1.nodes]\n    fingerprint_1_sorted = fingerprint_1.copy()\n    fingerprint_1_sorted.sort()\n    fingerprint_2 = [fingerprint[v] for v in g2.nodes]\n    fingerprint_2_sorted = fingerprint_2.copy()\n    fingerprint_2_sorted.sort()\n\n    # perform WL-test\n    if fingerprint_1_sorted == fingerprint_2_sorted:\n        return True, fingerprint_1, fingerprint_2\n    return False, fingerprint_1, fingerprint_2\n</code></pre>"},{"location":"reference/pathpyG/algorithms/#pathpyG.algorithms.connected_components","title":"<code>connected_components</code>","text":"<p>Compute the connected components of a graph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The input graph.</p> required <code>connection</code> <code>str</code> <p>Type of connection to consider.  Options are \"weak\" or \"strong\". Defaults to \"weak\".</p> <code>'weak'</code> <p>Returns:</p> Type Description <code>typing.Tuple[int, numpy.ndarray]</code> <p>Tuple[int, np.ndarray]: A tuple containing the number of connected components and an array with component labels for each node.</p> Source code in <code>src/pathpyG/algorithms/components.py</code> <pre><code>def connected_components(graph: Graph, connection=\"weak\") -&gt; Tuple[int, _np.ndarray]:\n    \"\"\"Compute the connected components of a graph.\n\n    Args:\n        graph (Graph): The input graph.\n        connection (str, optional): Type of connection to consider. \n            Options are \"weak\" or \"strong\". Defaults to \"weak\".\n\n    Returns:\n        Tuple[int, np.ndarray]: A tuple containing the number of connected components and\n            an array with component labels for each node.\n    \"\"\"\n    m = graph.sparse_adj_matrix()\n    n, labels = _cc(m, directed=graph.is_directed(), connection=connection, return_labels=True)\n    return n, labels\n</code></pre>"},{"location":"reference/pathpyG/algorithms/#pathpyG.algorithms.largest_connected_component","title":"<code>largest_connected_component</code>","text":"<p>Extract the largest connected component from a graph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The input graph.</p> required <code>connection</code> <code>str</code> <p>Type of connection to consider.  Options are \"weak\" or \"strong\". Defaults to \"weak\".</p> <code>'weak'</code> <p>Returns:</p> Name Type Description <code>Graph</code> <code>pathpyG.core.graph.Graph</code> <p>A new graph instance containing only the largest connected component.</p> Source code in <code>src/pathpyG/algorithms/components.py</code> <pre><code>def largest_connected_component(graph: Graph, connection=\"weak\") -&gt; Graph:\n    \"\"\"Extract the largest connected component from a graph.\n\n    Args:\n        graph (Graph): The input graph.\n        connection (str, optional): Type of connection to consider. \n            Options are \"weak\" or \"strong\". Defaults to \"weak\".\n\n    Returns:\n        Graph: A new graph instance containing only the largest connected component.\n    \"\"\"\n    m = graph.sparse_adj_matrix()\n    _, labels = _cc(m, directed=graph.is_directed(), connection=connection, return_labels=True)\n\n    # find largest component C\n    ctr = Counter(labels.tolist())\n    x, _ = ctr.most_common(1)[0]\n    # create graph only consisting of nodes in C\n    C = []\n    for v, w in graph.edges:\n        if labels[graph.mapping.to_idx(v)] == x and labels[graph.mapping.to_idx(w)] == x:\n            C.append((v, w))\n    return Graph.from_edge_list(C, is_undirected=graph.is_undirected())\n</code></pre>"},{"location":"reference/pathpyG/algorithms/#pathpyG.algorithms.lift_order_temporal","title":"<code>lift_order_temporal</code>","text":"<p>Lift a temporal graph to a second-order temporal event graph.</p> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>pathpyG.core.temporal_graph.TemporalGraph</code> <p>Temporal graph to lift.</p> required <code>delta</code> <code>float | int</code> <p>Maximum time difference between events to consider them connected.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>ho_index</code> <p>Edge index of the second-order temporal event graph.</p> Source code in <code>src/pathpyG/algorithms/temporal.py</code> <pre><code>def lift_order_temporal(g: TemporalGraph, delta: float | int = 1):\n    \"\"\"Lift a temporal graph to a second-order temporal event graph.\n\n    Args:\n        g: Temporal graph to lift.\n        delta: Maximum time difference between events to consider them connected.\n\n    Returns:\n        ho_index: Edge index of the second-order temporal event graph.\n    \"\"\"\n    # first-order edge index\n    edge_index, timestamps = g.data.edge_index, g.data.time\n\n    delta = torch.tensor(delta, device=edge_index.device)  # type: ignore[assignment]\n    indices = torch.arange(0, edge_index.size(1), device=edge_index.device)\n\n    unique_t = torch.unique(timestamps, sorted=True)\n    second_order = []\n\n    # lift order: find possible continuations for edges in each time stamp\n    for t in tqdm(unique_t):\n        # find indices of all source edges that occur at unique timestamp t\n        src_time_mask = timestamps == t\n        src_edge_idx = indices[src_time_mask]\n\n        # find indices of all edges that can possibly continue edges occurring at time t for the given delta\n        dst_time_mask = (timestamps &gt; t) &amp; (timestamps &lt;= t + delta)\n        dst_edge_idx = indices[dst_time_mask]\n\n        if dst_edge_idx.size(0) &gt; 0 and src_edge_idx.size(0) &gt; 0:\n            # compute second-order edges between src and dst idx\n            # for all edges where dst in src_edges (edge_index[1, x[:, 0]]) matches src in dst_edges (edge_index[0, x[:, 1]])\n            x = torch.cartesian_prod(src_edge_idx, dst_edge_idx)\n            ho_edge_index = x[edge_index[1, x[:, 0]] == edge_index[0, x[:, 1]]]\n            second_order.append(ho_edge_index)\n\n    ho_index = torch.cat(second_order, dim=0).t().contiguous()\n    return ho_index\n</code></pre>"},{"location":"reference/pathpyG/algorithms/#pathpyG.algorithms.temporal_shortest_paths","title":"<code>temporal_shortest_paths</code>","text":"<p>Compute shortest time-respecting paths in a temporal graph.</p> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>pathpyG.core.temporal_graph.TemporalGraph</code> <p>Temporal graph to compute shortest paths on.</p> required <code>delta</code> <code>int</code> <p>Maximum time difference between events in a path.</p> required <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Tuple of two numpy arrays:</p> <code>numpy.ndarray</code> <ul> <li>dist: Shortest time-respecting path distances between all first-order nodes.</li> </ul> <code>typing.Tuple[numpy.ndarray, numpy.ndarray]</code> <ul> <li>pred: Predecessor matrix for shortest time-respecting paths between all first-order nodes.</li> </ul> Source code in <code>src/pathpyG/algorithms/temporal.py</code> <pre><code>def temporal_shortest_paths(g: TemporalGraph, delta: int) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Compute shortest time-respecting paths in a temporal graph.\n\n    Args:\n        g: Temporal graph to compute shortest paths on.\n        delta: Maximum time difference between events in a path.\n\n    Returns:\n        Tuple of two numpy arrays:\n        - dist: Shortest time-respecting path distances between all first-order nodes.\n        - pred: Predecessor matrix for shortest time-respecting paths between all first-order nodes.\n    \"\"\"\n    # generate temporal event DAG\n    edge_index = lift_order_temporal(g, delta)\n\n    # Add indices of first-order nodes as src and dst of paths in augmented\n    # temporal event DAG\n    src_edges_src = g.data.edge_index[0] + g.m\n    src_edges_dst = torch.arange(0, g.data.edge_index.size(1), device=g.data.edge_index.device)\n\n    dst_edges_src = torch.arange(0, g.data.edge_index.size(1), device=g.data.edge_index.device)\n    dst_edges_dst = g.data.edge_index[1] + g.m + g.n\n\n    # add edges from source to edges and from edges to destinations\n    src_edges = torch.stack([src_edges_src, src_edges_dst])\n    dst_edges = torch.stack([dst_edges_src, dst_edges_dst])\n    edge_index = torch.cat([edge_index, src_edges, dst_edges], dim=1)\n\n    # create sparse scipy matrix\n    event_graph = Graph.from_edge_index(edge_index, num_nodes=g.m + 2 * g.n)\n    m = event_graph.sparse_adj_matrix()\n\n    # print(f\"Created temporal event DAG with {event_graph.n} nodes and {event_graph.m} edges\")\n\n    # run disjktra for all source nodes\n    dist, pred = dijkstra(\n        m, directed=True, indices=np.arange(g.m, g.m + g.n), return_predecessors=True, unweighted=True\n    )\n\n    # limit to first-order destinations and correct distances\n    dist_fo = dist[:, g.m + g.n :] - 1\n    np.fill_diagonal(dist_fo, 0)\n\n    # limit to first-order destinations and correct predecessors\n    pred_fo = pred[:, g.n + g.m :]\n    pred_fo[pred_fo == -9999] = -1\n    idx_map = np.concatenate([to_numpy(g.data.edge_index[0].cpu()), [-1]])\n    pred_fo = idx_map[pred_fo]\n    np.fill_diagonal(pred_fo, np.arange(g.n))\n\n    return dist_fo, pred_fo\n</code></pre>"},{"location":"reference/pathpyG/algorithms/centrality/","title":"centrality","text":"<p>Algorithms to calculate centralities in (temporal) graphs.</p> <p>The functions and submodules in this module allow to compute  time-respecting or causal paths in temporal graphs and to calculate (temporal) and higher-order graph metrics like centralities.</p> Example <pre><code># Import pathpyG\nimport pathpyG as pp\n\n# Generate toy example for temporal graph\ng = pp.TemporalGraph.from_edge_list([\n    ('b', 'c', 2),\n    ('a', 'b', 1),\n    ('c', 'd', 3),\n    ('d', 'a', 4),\n    ('b', 'd', 2),\n    ('d', 'a', 6),\n    ('a', 'b', 7)\n])\n\nbw_t = pp.algorithms.temporal_betweenness_centrality(g, delta=1)\ncl_t = pp.algorithms.temporal_closeness_centrality(g, delta=1)\n\nstatic_graph = g.to_static_graph()\nbw_s = pp.algorithms.betweenness_centrality(static_graph)\nbw_s = pp.algorithms.closeness_centrality(static_graph)\n</code></pre>"},{"location":"reference/pathpyG/algorithms/centrality/#pathpyG.algorithms.centrality.__getattr__","title":"<code>__getattr__</code>","text":"<p>Map to corresponding functions in centrality module of networkx.</p> <p>Any call to a function that is not implemented in the module centrality and whose first argument is of type Graph will be delegated to the corresponding function in the networkx module <code>centrality</code>. Please refer to the networkx documentation for a reference of available functions.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the function that shall be called</p> required Source code in <code>src/pathpyG/algorithms/centrality.py</code> <pre><code>def __getattr__(name: str) -&gt; Any:\n    \"\"\"Map to corresponding functions in centrality module of networkx.\n\n    Any call to a function that is not implemented in the module centrality\n    and whose first argument is of type Graph will be delegated to the\n    corresponding function in the networkx module `centrality`. Please\n    refer to the [networkx documentation](https://networkx.org/documentation/stable/reference/algorithms/centrality.html)\n    for a reference of available functions.\n\n    Args:\n        name: the name of the function that shall be called\n    \"\"\"\n\n    def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n        if len(args) == 0:\n            raise RuntimeError(f\"Did not find method {name} with no arguments\")\n        if isinstance(args[0], TemporalGraph):\n            raise NotImplementedError(f\"Missing implementation of {name} for temporal graphs\")\n        # if first argument is of type Graph, delegate to networkx function\n        if isinstance(args[0], Graph):\n            g = to_networkx(args[0].data)\n            r = getattr(centrality, name)(g, *args[1:], **kwargs)\n            if name.index(\"centrality\") &gt; 0 and isinstance(r, dict):\n                return map_to_nodes(args[0], r)\n            return r\n        else:\n            return wrapper(*args, **kwargs)\n            # raise RuntimeError(f'Did not find method {name} that accepts first argument of type {type(args[0])}')\n\n    return wrapper\n</code></pre>"},{"location":"reference/pathpyG/algorithms/centrality/#pathpyG.algorithms.centrality.betweenness_centrality","title":"<code>betweenness_centrality</code>","text":"<p>Calculate the betweenness centrality of nodes based on the fast algorithm proposed by Brandes<sup>1</sup>.</p> <ol> <li> <p>U. Brandes: A faster algorithm for betweenness centrality, The Journal of Mathematical Sociology, 2001 \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p><code>Graph</code> object for which betweenness centrality will be computed</p> required <code>sources</code> <code>list[str] | None</code> <p>optional list of source nodes for BFS-based shortest path calculation</p> <code>None</code> Example <pre><code>import pathpyG as pp\ngraph = pp.Graph.from_edge_list([('a', 'b'), ('b', 'c'),\n                    ('b', 'd'), ('c', 'e'), ('d', 'e')])\nbw = pp.algorithms.betweenness_centrality(graph)\n</code></pre> Source code in <code>src/pathpyG/algorithms/centrality.py</code> <pre><code>def betweenness_centrality(graph: Graph, sources: list[str] | None = None) -&gt; dict[str, float]:\n    \"\"\"Calculate the betweenness centrality of nodes based on the fast algorithm proposed by Brandes[^1].\n\n    [^1]: *U. Brandes: A faster algorithm for betweenness centrality, The Journal of Mathematical Sociology, 2001*\n\n    Args:\n        graph: `Graph` object for which betweenness centrality will be computed\n        sources: optional list of source nodes for BFS-based shortest path calculation\n\n    Example:\n        ```py\n        import pathpyG as pp\n        graph = pp.Graph.from_edge_list([('a', 'b'), ('b', 'c'),\n                            ('b', 'd'), ('c', 'e'), ('d', 'e')])\n        bw = pp.algorithms.betweenness_centrality(graph)\n        ```\n    \"\"\"\n    bw: dict[str, float] = defaultdict(lambda: 0.0)\n\n    if sources is None:\n        sources = graph.nodes\n\n    for s in sources:\n        S = list()\n        P = defaultdict(list)\n\n        sigma = defaultdict(lambda: 0)\n        sigma[s] = 1\n\n        d = defaultdict(lambda: -1)\n        d[s] = 0\n\n        Q = [s]\n        while Q:\n            v = Q.pop(0)\n            S.append(v)\n            for w in graph.successors(v):\n                if d[w] &lt; 0:\n                    Q.append(w)\n                    d[w] = d[v] + 1\n                if d[w] == d[v] + 1:\n                    # we found shortest path from s via v to w\n                    sigma[w] = sigma[w] + sigma[v]\n                    P[w].append(v)\n        delta: dict[str, float] = defaultdict(lambda: 0.0)\n        while S:\n            w = S.pop()\n            for v in P[w]:\n                delta[v] = delta[v] + sigma[v] / sigma[w] * (1 + delta[w])\n                if v != w:\n                    bw[w] = bw[w] + delta[w]\n    return bw\n</code></pre>"},{"location":"reference/pathpyG/algorithms/centrality/#pathpyG.algorithms.centrality.map_to_nodes","title":"<code>map_to_nodes</code>","text":"<p>Map node-level centralities in dictionary to node IDs.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>Graph object</p> required <code>centralities</code> <code>typing.Dict</code> <p>dictionary mapping node indices to metrics</p> required Example <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; g = pp.Graph(torch.LongTensor([[1, 1, 2], [0, 2, 1]]),\n...                               node_id=['a', 'b', 'c'])\n&gt;&gt;&gt; c = {0: 0.5, 1: 2.7, 2: 0.3}\n&gt;&gt;&gt; c_mapped = pp.algorithms.centrality.map_to_nodes(g, c)\n&gt;&gt;&gt; print(c_mapped)\n{'a': 0.5, 'b': 2.7, 'c': 0.3}\n</code></pre> Source code in <code>src/pathpyG/algorithms/centrality.py</code> <pre><code>def map_to_nodes(graph: Graph, centralities: Dict) -&gt; Dict:\n    \"\"\"Map node-level centralities in dictionary to node IDs.\n\n    Args:\n        graph: Graph object\n        centralities: dictionary mapping node indices to metrics\n\n    Example:\n        ```pycon\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; g = pp.Graph(torch.LongTensor([[1, 1, 2], [0, 2, 1]]),\n        ...                               node_id=['a', 'b', 'c'])\n        &gt;&gt;&gt; c = {0: 0.5, 1: 2.7, 2: 0.3}\n        &gt;&gt;&gt; c_mapped = pp.algorithms.centrality.map_to_nodes(g, c)\n        &gt;&gt;&gt; print(c_mapped)\n        {'a': 0.5, 'b': 2.7, 'c': 0.3}\n        ```\n    \"\"\"\n    return {graph.mapping.to_id(i): centralities[i] for i in centralities}\n</code></pre>"},{"location":"reference/pathpyG/algorithms/centrality/#pathpyG.algorithms.centrality.path_node_traversals","title":"<code>path_node_traversals</code>","text":"<p>Calculate the number of times any path traverses each of the nodes.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>pathpyG.core.path_data.PathData</code> <p><code>PathData</code> object that contains observations of paths in a graph</p> required Source code in <code>src/pathpyG/algorithms/centrality.py</code> <pre><code>def path_node_traversals(paths: PathData) -&gt; dict:\n    \"\"\"Calculate the number of times any path traverses each of the nodes.\n\n    Args:\n        paths: `PathData` object that contains observations of paths in a graph\n    \"\"\"\n    unique_node_seq, traversal_counts = torch.unique(paths.data.node_sequence, return_counts=True)\n    return {paths.mapping.to_id(node): count.item() for node, count in zip(unique_node_seq, traversal_counts)}\n</code></pre>"},{"location":"reference/pathpyG/algorithms/centrality/#pathpyG.algorithms.centrality.path_visitation_probabilities","title":"<code>path_visitation_probabilities</code>","text":"<p>Calculate path visitation probabilities for nodes.</p> <p>Calculate the probabilities that a randomly chosen path passes through each of the nodes. If 5 out of 100 paths (of any length) traverse node v, node v will be assigned a visitation probability of 0.05. This measure can be interpreted as ground truth for the notion of importance captured by PageRank applied to a graphical abstraction of the paths.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>pathpyG.core.path_data.PathData</code> <p>PathData object that contains path data</p> required Source code in <code>src/pathpyG/algorithms/centrality.py</code> <pre><code>def path_visitation_probabilities(paths: PathData) -&gt; dict:\n    \"\"\"Calculate path visitation probabilities for nodes.\n\n    Calculate the probabilities that a randomly chosen path passes through each of\n    the nodes. If 5 out of 100 paths (of any length) traverse node v, node v will be\n    assigned a visitation probability of 0.05. This measure can be interpreted as ground\n    truth for the notion of importance captured by PageRank applied to a graphical\n    abstraction of the paths.\n\n    Args:\n        paths: PathData object that contains path data\n    \"\"\"\n    # entries capture the probability that a given node is visited on an arbitrary path\n    # Note: this is identical to the subpath count of zero-length paths\n    # (i.e. the relative frequencies of nodes across all pathways)\n    visit_probabilities = path_node_traversals(paths)\n\n    # total number of visits\n    visits = 0.0\n    for v in visit_probabilities:\n        visits += visit_probabilities[v]\n\n    for v in visit_probabilities:\n        visit_probabilities[v] /= visits\n    return visit_probabilities\n</code></pre>"},{"location":"reference/pathpyG/algorithms/centrality/#pathpyG.algorithms.centrality.temporal_betweenness_centrality","title":"<code>temporal_betweenness_centrality</code>","text":"<p>Calculate the temporal betweenness of nodes in a temporal graph.</p> <p>The temporal betweenness centrality definition is based on shortest time-respecting paths with a given maximum time difference delta, where the length of a path is given as the number of traversed edges (i.e. not the temporal duration of a path or the earliest arrival at a node).</p> <p>The algorithm is an adaptation of Brandes' fast algorithm for betweenness centrality based on a work by Buss et al.<sup>1</sup>.</p> <p>Different from the algorithm proposed above, the temporal betweenness centrality implemented in pathpyG is based on a directed acyclic event graph representation of a temporal graph and it considers a maximum waiting time of delta. The complexity is in O(nm) where n is the number of nodes in the temporal graph and m is the number of time-stamped edges.</p> <ol> <li> <p>S. Buss, H. Molter, R. Niedermeier, M. Rymar: Algorithmic Aspects of Temporal Betweenness, arXiv:2006.08668v2 \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.temporal_graph.TemporalGraph</code> <p><code>TemporalGraph</code> object for which temporal betweenness centrality will be computed</p> required <code>delta</code> <code>int</code> <p>maximum waiting time for time-respecting paths</p> <code>1</code> Example <pre><code>import pathpyG as pp\nt = pp.TemporalGraph.from_edge_list([('a', 'b', 1), ('b', 'c', 2),\n                    ('b', 'd', 2), ('c', 'e', 3), ('d', 'e', 3)])\nbw = pp.algorithms.temporal_betweenness_centrality(t, delta=1)\n</code></pre> Source code in <code>src/pathpyG/algorithms/centrality.py</code> <pre><code>def temporal_betweenness_centrality(graph: TemporalGraph, delta: int = 1) -&gt; dict[str, float]:\n    \"\"\"Calculate the temporal betweenness of nodes in a temporal graph.\n\n    The temporal betweenness centrality definition is based on shortest\n    time-respecting paths with a given maximum time difference delta, where\n    the length of a path is given as the number of traversed edges (i.e. not\n    the temporal duration of a path or the earliest arrival at a node).\n\n    The algorithm is an adaptation of Brandes' fast algorithm for betweenness\n    centrality based on a work by Buss et al.[^1].\n\n    Different from the algorithm proposed above, the temporal betweenness centrality\n    implemented in pathpyG is based on a directed acyclic event graph representation of\n    a temporal graph and it considers a maximum waiting time of delta. The complexity\n    is in O(nm) where n is the number of nodes in the temporal graph and m is the number\n    of time-stamped edges.\n\n    [^1]: *S. Buss, H. Molter, R. Niedermeier, M. Rymar: Algorithmic Aspects of Temporal Betweenness, arXiv:2006.08668v2*\n\n    Args:\n        graph: [`TemporalGraph`][pathpyG.TemporalGraph] object for which temporal betweenness centrality will be computed\n        delta: maximum waiting time for time-respecting paths\n\n    Example:\n        ```py\n        import pathpyG as pp\n        t = pp.TemporalGraph.from_edge_list([('a', 'b', 1), ('b', 'c', 2),\n                            ('b', 'd', 2), ('c', 'e', 3), ('d', 'e', 3)])\n        bw = pp.algorithms.temporal_betweenness_centrality(t, delta=1)\n        ```\n    \"\"\"\n    # generate temporal event DAG\n    edge_index = lift_order_temporal(graph, delta)\n\n    # Add indices of first-order nodes as src of paths in augmented\n    # temporal event DAG\n    src_edges_src = graph.data.edge_index[0] + graph.m\n    src_edges_dst = torch.arange(0, graph.data.edge_index.size(1))\n\n    # add edges from first-order source nodes to edge events\n    src_edges = torch.stack([src_edges_src, src_edges_dst])\n    edge_index = torch.cat([edge_index, src_edges], dim=1)\n    src_indices = torch.unique(src_edges_src).tolist()\n\n    event_graph = Graph.from_edge_index(edge_index, num_nodes=graph.m + graph.n)\n\n    e_i = to_numpy(graph.data.edge_index)\n\n    fo_nodes = dict()\n    for v in range(graph.m + graph.n):\n        if v &lt; graph.m:  # return first-order target node otherwise\n            fo_nodes[v] = e_i[1, v]\n        else:\n            fo_nodes[v] = v - graph.m\n\n    bw: defaultdict[int, float] = defaultdict(lambda: 0.0)\n\n    # for all first-order nodes\n    for s in tqdm(src_indices):\n\n        # for any given s, d[v] is the shortest path distance from s to v\n        # Note that here we calculate topological distances from sources to events (i.e. time-stamped edges)\n        delta_: defaultdict[int, float] = defaultdict(lambda: 0.0)\n\n        # for any given s, sigma[v] counts shortest paths from s to v\n        sigma: defaultdict[int, float] = defaultdict(lambda: 0.0)\n        sigma[s] = 1.0\n\n        sigma_fo: defaultdict[int, float] = defaultdict(lambda: 0.0)\n        sigma_fo[fo_nodes[s]] = 1.0\n\n        dist: defaultdict[int, int] = defaultdict(lambda: -1)\n        dist[s] = 0\n\n        dist_fo: defaultdict[int, int] = defaultdict(lambda: -1)\n        dist_fo[fo_nodes[s]] = 0\n\n        # for any given s, P[v] is the set of predecessors of v on shortest paths from s\n        P = defaultdict(set)\n\n        # Q is a queue, so we append at the right and pop from the left\n        Q: deque = deque()\n        Q.append(s)\n\n        # S is a stack, so we append at the end and pop from the end\n        S = list()\n\n        # dijkstra with path counting\n        while Q:\n            v = Q.popleft()\n            # for all successor events within delta\n            for w in event_graph.successors(v):\n\n                # we dicover w for the first time\n                if dist[w] == -1:\n                    dist[w] = dist[v] + 1\n                    if dist_fo[fo_nodes[w]] == -1:\n                        dist_fo[fo_nodes[w]] = dist[v] + 1\n                    S.append(w)\n                    Q.append(w)\n                # we found a shortest path to event w via event v\n                if dist[w] == dist[v] + 1:\n                    sigma[w] += sigma[v]\n                    P[w].add(v)\n                    # we found a shortest path to first-order node of event w\n                    if dist[w] == dist_fo[fo_nodes[w]]:\n                        sigma_fo[fo_nodes[w]] += sigma[v]\n\n        c = 0.0\n        for i in dist_fo:\n            if dist_fo[i] &gt;= 0:\n                c += 1.0\n        bw[fo_nodes[s]] = bw[fo_nodes[s]] - c + 1.0\n\n        while S:\n            w = S.pop()\n            # work backwards through paths to all targets and sum delta and sigma\n            if dist[w] == dist_fo[fo_nodes[w]]:\n                x = sigma[w] / sigma_fo[fo_nodes[w]]\n                if isnan(x):\n                    x = 0.0\n                delta_[w] += x\n            for v in P[w]:\n                x = sigma[v] / sigma[w]\n                if isnan(x):\n                    x = 0.0\n                delta_[v] += x * delta_[w]\n                bw[fo_nodes[v]] += delta_[w] * x\n\n    # map index-based centralities to node IDs\n    bw_id = defaultdict(lambda: 0.0)\n    for idx in bw:\n        bw_id[graph.mapping.to_id(idx)] = float(bw[idx])\n    return bw_id  # type: ignore[return-value]\n</code></pre>"},{"location":"reference/pathpyG/algorithms/centrality/#pathpyG.algorithms.centrality.temporal_closeness_centrality","title":"<code>temporal_closeness_centrality</code>","text":"<p>Calculates the temporal closeness centrality of nodes based on observed shortest time-respecting paths between all nodes.</p> <p>This algorithm follows the definition by M. A. Beauchamp<sup>1</sup>.</p> <ol> <li> <p>Beauchamp, M. A. An improved index of centrality. Behavioral Science 10, 161-163 (1965). \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.temporal_graph.TemporalGraph</code> <p><code>TemporalGraph</code> object for which temporal betweenness centrality will be computed</p> required <code>delta</code> <code>int</code> <p>maximum waiting time for time-respecting paths</p> required Example <pre><code>import pathpyG as pp\nt = pp.TemporalGraph.from_edge_list([('a', 'b', 1), ('b', 'c', 2),\n                    ('b', 'd', 2), ('c', 'e', 3), ('d', 'e', 3)])\ncl = pp.algorithms.temporal_closeness_centrality(t, delta=1)\n</code></pre> Source code in <code>src/pathpyG/algorithms/centrality.py</code> <pre><code>def temporal_closeness_centrality(graph: TemporalGraph, delta: int) -&gt; dict[str, float]:\n    \"\"\"Calculates the temporal closeness centrality of nodes based on observed shortest time-respecting paths between all nodes.\n\n    This algorithm follows the definition by M. A. Beauchamp[^1].\n\n    [^1]: *Beauchamp, M. A. An improved index of centrality. Behavioral Science 10, 161-163 (1965).*\n\n    Args:\n        graph: `TemporalGraph` object for which temporal betweenness centrality will be computed\n        delta: maximum waiting time for time-respecting paths\n\n    Example:\n        ```py\n        import pathpyG as pp\n        t = pp.TemporalGraph.from_edge_list([('a', 'b', 1), ('b', 'c', 2),\n                            ('b', 'd', 2), ('c', 'e', 3), ('d', 'e', 3)])\n        cl = pp.algorithms.temporal_closeness_centrality(t, delta=1)\n        ```\n    \"\"\"\n    centralities = dict()\n    dist, _ = temporal_shortest_paths(graph, delta)\n    for x in graph.nodes:\n        centralities[x] = float(sum((graph.n - 1) / dist[_np.arange(graph.n) != graph.mapping.to_idx(x), graph.mapping.to_idx(x)]))\n\n    return centralities\n</code></pre>"},{"location":"reference/pathpyG/algorithms/components/","title":"components","text":"<p>Algorithms to calculate connected components.</p>"},{"location":"reference/pathpyG/algorithms/components/#pathpyG.algorithms.components.connected_components","title":"<code>connected_components</code>","text":"<p>Compute the connected components of a graph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The input graph.</p> required <code>connection</code> <code>str</code> <p>Type of connection to consider.  Options are \"weak\" or \"strong\". Defaults to \"weak\".</p> <code>'weak'</code> <p>Returns:</p> Type Description <code>typing.Tuple[int, numpy.ndarray]</code> <p>Tuple[int, np.ndarray]: A tuple containing the number of connected components and an array with component labels for each node.</p> Source code in <code>src/pathpyG/algorithms/components.py</code> <pre><code>def connected_components(graph: Graph, connection=\"weak\") -&gt; Tuple[int, _np.ndarray]:\n    \"\"\"Compute the connected components of a graph.\n\n    Args:\n        graph (Graph): The input graph.\n        connection (str, optional): Type of connection to consider. \n            Options are \"weak\" or \"strong\". Defaults to \"weak\".\n\n    Returns:\n        Tuple[int, np.ndarray]: A tuple containing the number of connected components and\n            an array with component labels for each node.\n    \"\"\"\n    m = graph.sparse_adj_matrix()\n    n, labels = _cc(m, directed=graph.is_directed(), connection=connection, return_labels=True)\n    return n, labels\n</code></pre>"},{"location":"reference/pathpyG/algorithms/components/#pathpyG.algorithms.components.largest_connected_component","title":"<code>largest_connected_component</code>","text":"<p>Extract the largest connected component from a graph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The input graph.</p> required <code>connection</code> <code>str</code> <p>Type of connection to consider.  Options are \"weak\" or \"strong\". Defaults to \"weak\".</p> <code>'weak'</code> <p>Returns:</p> Name Type Description <code>Graph</code> <code>pathpyG.core.graph.Graph</code> <p>A new graph instance containing only the largest connected component.</p> Source code in <code>src/pathpyG/algorithms/components.py</code> <pre><code>def largest_connected_component(graph: Graph, connection=\"weak\") -&gt; Graph:\n    \"\"\"Extract the largest connected component from a graph.\n\n    Args:\n        graph (Graph): The input graph.\n        connection (str, optional): Type of connection to consider. \n            Options are \"weak\" or \"strong\". Defaults to \"weak\".\n\n    Returns:\n        Graph: A new graph instance containing only the largest connected component.\n    \"\"\"\n    m = graph.sparse_adj_matrix()\n    _, labels = _cc(m, directed=graph.is_directed(), connection=connection, return_labels=True)\n\n    # find largest component C\n    ctr = Counter(labels.tolist())\n    x, _ = ctr.most_common(1)[0]\n    # create graph only consisting of nodes in C\n    C = []\n    for v, w in graph.edges:\n        if labels[graph.mapping.to_idx(v)] == x and labels[graph.mapping.to_idx(w)] == x:\n            C.append((v, w))\n    return Graph.from_edge_list(C, is_undirected=graph.is_undirected())\n</code></pre>"},{"location":"reference/pathpyG/algorithms/generative_models/","title":"generative_models","text":"<p>Algorithms to generate random graphs.</p> <p>The functions in this module allow to generate graphs based on different probabilistic generative models.</p> Example <pre><code>import pathpyG as pp\n\ng = pp.algorithms.generative_models.erdos_renyi_gnm(n=100, m=200)\n</code></pre>"},{"location":"reference/pathpyG/algorithms/generative_models/#pathpyG.algorithms.generative_models.erdos_renyi_gnm","title":"<code>erdos_renyi_gnm</code>","text":"<p>Generate a random graph with n nodes and m edges based on the G(n,m) model by Pal Er\u00f6ds and Alfred Renyi.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>the number of nodes of the graph</p> required <code>m</code> <code>int</code> <p>the number of random directed or undirected edges to be generated</p> required <code>mapping</code> <code>pathpyG.core.index_map.IndexMap | None</code> <p>optional given mapping of n nodes to node IDs. If this is not given a mapping is created</p> <code>None</code> <code>self_loops</code> <code>bool</code> <p>whether or not to allow self-loops (v,v) to be generated</p> <code>False</code> <code>multi_edges</code> <code>bool</code> <p>whether or not multiple identical edges are allowed</p> <code>False</code> <code>directed</code> <code>bool</code> <p>whether or not to generate a directed graph</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Graph</code> <code>pathpyG.core.graph.Graph</code> <p>A random graph based on the G(n,m) model.</p> Source code in <code>src/pathpyG/algorithms/generative_models.py</code> <pre><code>def erdos_renyi_gnm(\n    n: int,\n    m: int,\n    mapping: IndexMap | None = None,\n    self_loops: bool = False,\n    multi_edges: bool = False,\n    directed: bool = False,\n) -&gt; Graph:\n    \"\"\"Generate a random graph with n nodes and m edges based on the G(n,m) model by Pal Er\u00f6ds and Alfred Renyi.\n\n    Args:\n        n: the number of nodes of the graph\n        m: the number of random directed or undirected edges to be generated\n        mapping: optional given mapping of n nodes to node IDs. If this is not given a mapping is created\n        self_loops: whether or not to allow self-loops (v,v) to be generated\n        multi_edges: whether or not multiple identical edges are allowed\n        directed: whether or not to generate a directed graph\n\n    Returns:\n        Graph: A random graph based on the G(n,m) model.\n    \"\"\"\n    if m &gt; max_edges(n, directed=directed, self_loops=self_loops, multi_edges=multi_edges):\n        logger.error(\"Given number of edges is larger than theoretical maximum\")\n        raise ValueError(\"Given number of edges is larger than theoretical maximum\")\n\n    edges = set()\n    edges_added: int = 0\n\n    if mapping is None:\n        # make sure that we have indices for all n nodes even if not all\n        # nodes have incident edges\n        mapping = IndexMap([str(i) for i in range(n)])\n\n    # Add m edges at random\n    while edges_added &lt; m:\n        # Choose two random nodes (with replacement if self-loops are included)\n        v, w = _np.random.choice(n, size=2, replace=self_loops)\n\n        # avoid multi-edges\n        if multi_edges or (mapping.to_id(v), mapping.to_id(w)) not in edges:\n            edges.add((mapping.to_id(v), mapping.to_id(w)))\n            if not directed and v != w:\n                edges.add((mapping.to_id(w), mapping.to_id(v)))\n            edges_added += 1\n\n    return Graph.from_edge_list(list(edges), is_undirected=not directed, mapping=mapping)  # type: ignore[arg-type]\n</code></pre>"},{"location":"reference/pathpyG/algorithms/generative_models/#pathpyG.algorithms.generative_models.erdos_renyi_gnm_randomize","title":"<code>erdos_renyi_gnm_randomize</code>","text":"<p>Generate a randomized version of a given graph based on the Erd\u00f6s-Renyi random graph G(n,m) model.</p> <p>Generate a random graph whose number of nodes, edges, edge directedness and node IDs match the corresponding values of a given network instance. Useful to generate a randomized version of a network.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>A given network used to determine number of nodes, edges, node uids, and edge directedness</p> required <code>self_loops</code> <code>bool</code> <p>Whether or not the generated network can contain loops.</p> <code>False</code> <code>multi_edges</code> <code>bool</code> <p>Whether or not multiple edges can be added to the same node pair</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Graph</code> <code>pathpyG.core.graph.Graph</code> <p>A randomized version of the given graph based on the G(n,m) model.</p> Example <pre><code>import pathpyG as pp\n\ng = pp.Graph.from_edge_list([(\"a\", \"b\"), (\"b\", \"c\"), (\"d\", \"e\")])\nr = pp.algorithms.generative_models.G_nm_randomize(g)\n</code></pre> Source code in <code>src/pathpyG/algorithms/generative_models.py</code> <pre><code>def erdos_renyi_gnm_randomize(graph: Graph, self_loops: bool = False, multi_edges: bool = False) -&gt; Graph:\n    \"\"\"Generate a randomized version of a given graph based on the Erd\u00f6s-Renyi random graph G(n,m) model.\n\n    Generate a random graph whose number of nodes, edges, edge directedness and node IDs\n    match the corresponding values of a given network instance. Useful to generate a randomized\n    version of a network.\n\n    Args:\n        graph: A given network used to determine number of nodes, edges, node uids, and edge directedness\n        self_loops: Whether or not the generated network can contain loops.\n        multi_edges: Whether or not multiple edges can be added to the same node pair\n\n    Returns:\n        Graph: A randomized version of the given graph based on the G(n,m) model.\n\n    Example:\n        ```py\n        import pathpyG as pp\n\n        g = pp.Graph.from_edge_list([(\"a\", \"b\"), (\"b\", \"c\"), (\"d\", \"e\")])\n        r = pp.algorithms.generative_models.G_nm_randomize(g)\n        ```\n    \"\"\"\n    return erdos_renyi_gnm(\n        graph.n,\n        graph.m,\n        directed=graph.is_directed(),\n        self_loops=self_loops,\n        multi_edges=multi_edges,\n        mapping=graph.mapping,\n    )\n</code></pre>"},{"location":"reference/pathpyG/algorithms/generative_models/#pathpyG.algorithms.generative_models.erdos_renyi_gnp","title":"<code>erdos_renyi_gnp</code>","text":"<p>Generate an Erd\u00f6s-Renyi random graph with n nodes and link probability p, using the G(n,p) model by Edgar Nelson Gilbert.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>the number of nodes of the graph</p> required <code>p</code> <code>float</code> <p>the link probability</p> required <code>mapping</code> <code>pathpyG.core.index_map.IndexMap | None</code> <p>optional given mapping of n nodes to node IDs. If this is not given a mapping is created</p> <code>None</code> <code>self_loops</code> <code>bool</code> <p>whether or not to allow self-loops (v,v) to be generated</p> <code>False</code> <code>directed</code> <code>bool</code> <p>whether or not to generate a directed graph</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Graph</code> <code>pathpyG.core.graph.Graph</code> <p>A random graph based on the G(n,p) model.</p> Source code in <code>src/pathpyG/algorithms/generative_models.py</code> <pre><code>def erdos_renyi_gnp(\n    n: int, p: float, mapping: IndexMap | None = None, self_loops: bool = False, directed: bool = False\n) -&gt; Graph:\n    \"\"\"Generate an Erd\u00f6s-Renyi random graph with n nodes and link probability p, using the G(n,p) model by Edgar Nelson Gilbert.\n\n    Args:\n        n: the number of nodes of the graph\n        p: the link probability\n        mapping: optional given mapping of n nodes to node IDs. If this is not given a mapping is created\n        self_loops: whether or not to allow self-loops (v,v) to be generated\n        directed: whether or not to generate a directed graph\n\n    Returns:\n        Graph: A random graph based on the G(n,p) model.\n    \"\"\"\n    edges = set()\n\n    if mapping is None:\n        # make sure that we have indices for all n nodes even if not all\n        # nodes have incident edges\n        mapping = IndexMap([str(i) for i in range(n)])\n\n    # fast handling of special case p = 0\n    if p == 0.0:\n        return Graph.from_edge_list([], is_undirected=not directed)\n\n    # connect pairs of nodes with probability p\n    for s in range(n):\n        if directed:\n            x = n\n        else:\n            x = s + 1\n        for t in range(x):\n            if not self_loops and t == s:\n                continue\n            if _np.random.random() &lt;= p:\n                edges.add((mapping.to_id(s), mapping.to_id(t)))\n                if not directed and s != t:\n                    edges.add((mapping.to_id(t), mapping.to_id(s)))\n\n    return Graph.from_edge_list(list(edges), is_undirected=not directed, mapping=mapping)  # type: ignore[arg-type]\n</code></pre>"},{"location":"reference/pathpyG/algorithms/generative_models/#pathpyG.algorithms.generative_models.erdos_renyi_gnp_likelihood","title":"<code>erdos_renyi_gnp_likelihood</code>","text":"<p>Calculate the likelihood of parameter p for a G(n,p) model and a given undirected graph.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>float</code> <p>The link probability.</p> required <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The undirected graph.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The likelihood of parameter p for the G(n,p) model and the given graph.</p> Source code in <code>src/pathpyG/algorithms/generative_models.py</code> <pre><code>def erdos_renyi_gnp_likelihood(p: float, graph: Graph) -&gt; float:\n    \"\"\"Calculate the likelihood of parameter p for a G(n,p) model and a given undirected graph.\n\n    Args:\n        p: The link probability.\n        graph: The undirected graph.\n\n    Returns:\n        float: The likelihood of parameter p for the G(n,p) model and the given graph.\n    \"\"\"\n    if graph.is_directed():\n        logger.error(\"erdos_renyi_gnp_likelihood does not support directed graphs\")\n        raise NotImplementedError(\"erdos_renyi_gnp_likelihood does not support directed graphs\")\n    return p**graph.n * (1 - p) ** (scipy.special.binom(graph.n, 2) - graph.m)\n</code></pre>"},{"location":"reference/pathpyG/algorithms/generative_models/#pathpyG.algorithms.generative_models.erdos_renyi_gnp_log_likelihood","title":"<code>erdos_renyi_gnp_log_likelihood</code>","text":"<p>Calculate the log-likelihood of parameter p for a G(n,p) model and a given undirected graph.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>float</code> <p>The link probability.</p> required <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The undirected graph.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The log-likelihood of parameter p for the G(n,p) model and the given graph.</p> Source code in <code>src/pathpyG/algorithms/generative_models.py</code> <pre><code>def erdos_renyi_gnp_log_likelihood(p: float, graph: Graph) -&gt; float:\n    \"\"\"Calculate the log-likelihood of parameter p for a G(n,p) model and a given undirected graph.\n\n    Args:\n        p: The link probability.\n        graph: The undirected graph.\n\n    Returns:\n        float: The log-likelihood of parameter p for the G(n,p) model and the given graph.\n    \"\"\"\n    if graph.is_directed():\n        logger.error(\"erdos_renyi_gnp_log_likelihood does not support directed graphs\")\n        raise NotImplementedError(\"erdos_renyi_gnp_log_likelihood does not support directed graphs\")\n    return graph.m * _np.log10(p) + (scipy.special.binom(graph.n, 2) - (graph.m)) * _np.log10(1 - p)\n</code></pre>"},{"location":"reference/pathpyG/algorithms/generative_models/#pathpyG.algorithms.generative_models.erdos_renyi_gnp_mle","title":"<code>erdos_renyi_gnp_mle</code>","text":"<p>Calculate the maximum likelihood estimate of parameter p for a G(n,p) model and a given undirected graph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The undirected graph.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The maximum likelihood estimate of parameter p for the G(n,p) model and the given graph.</p> Source code in <code>src/pathpyG/algorithms/generative_models.py</code> <pre><code>def erdos_renyi_gnp_mle(graph: Graph) -&gt; float:\n    \"\"\"Calculate the maximum likelihood estimate of parameter p for a G(n,p) model and a given undirected graph.\n\n    Args:\n        graph: The undirected graph.\n\n    Returns:\n        float: The maximum likelihood estimate of parameter p for the G(n,p) model and the given graph.\n    \"\"\"\n    if graph.is_directed():\n        logger.error(\"erdos_renyi_gnp_mle does not support directed graphs\")\n        raise NotImplementedError(\"erdos_renyi_gnp_mle does not support directed graphs\")\n    return graph.m / scipy.special.binom(graph.n, 2)\n</code></pre>"},{"location":"reference/pathpyG/algorithms/generative_models/#pathpyG.algorithms.generative_models.erdos_renyi_gnp_randomize","title":"<code>erdos_renyi_gnp_randomize</code>","text":"<p>Randomize a given graph based on the Erd\u00f6s-Renyi random graph G(n,p) model.</p> <p>The number of nodes, expected number of edges, edge directedness and node uids of the generated graph match the corresponding values of the graph given as parameter.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>A given network used to determine number of nodes, edges, node uids, and edge directedness</p> required <code>self_loops</code> <code>bool</code> <p>Whether or not the generated network can contain loops.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Graph</code> <code>pathpyG.core.graph.Graph</code> <p>A randomized version of the given graph based on the G(n,p) model.</p> Source code in <code>src/pathpyG/algorithms/generative_models.py</code> <pre><code>def erdos_renyi_gnp_randomize(graph: Graph, self_loops: bool = False) -&gt; Graph:\n    \"\"\"Randomize a given graph based on the Erd\u00f6s-Renyi random graph G(n,p) model.\n\n    The number of nodes, expected number of edges, edge directedness and node uids of the\n    generated graph match the corresponding values of the graph given as parameter.\n\n    Args:\n        graph: A given network used to determine number of nodes, edges, node uids, and edge directedness\n        self_loops: Whether or not the generated network can contain loops.\n\n    Returns:\n        Graph: A randomized version of the given graph based on the G(n,p) model.\n    \"\"\"\n    M = max_edges(graph.n, directed=graph.is_directed(), self_loops=self_loops)\n    p = graph.m / M\n    return erdos_renyi_gnp(n=graph.n, p=p, directed=graph.is_directed(), self_loops=self_loops, mapping=graph.mapping)\n</code></pre>"},{"location":"reference/pathpyG/algorithms/generative_models/#pathpyG.algorithms.generative_models.generate_degree_sequence","title":"<code>generate_degree_sequence</code>","text":"<p>Generates a random graphic degree sequence drawn from a given degree distribution.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of nodes for which to generate the degree sequence.</p> required <code>distribution</code> <code>typing.Dict[float, float] | scipy.stats.rv_continuous | scipy.stats.rv_discrete</code> <p>The degree distribution to draw from. Can be either a dictionary specifying a custom discrete distribution (keys are degrees, values are probabilities), or a scipy.stats.rv_continuous or scipy.stats.rv_discrete object.</p> required <code>**distribution_args</code> <code>typing.Any</code> <p>Additional keyword arguments passed to the rvs method of the distribution.</p> <code>{}</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>_np.ndarray: A graphic degree sequence drawn from the given distribution.</p> Source code in <code>src/pathpyG/algorithms/generative_models.py</code> <pre><code>def generate_degree_sequence(\n    n: int,\n    distribution: Dict[float, float] | scipy.stats.rv_continuous | scipy.stats.rv_discrete,\n    **distribution_args: Any,\n) -&gt; _np.ndarray:\n    \"\"\"Generates a random graphic degree sequence drawn from a given degree distribution.\n\n    Args:\n        n: The number of nodes for which to generate the degree sequence.\n        distribution: The degree distribution to draw from. Can be either a dictionary\n            specifying a custom discrete distribution (keys are degrees, values are probabilities),\n            or a [scipy.stats.rv_continuous][] or [scipy.stats.rv_discrete][] object.\n        **distribution_args: Additional keyword arguments passed to the rvs method of the distribution.\n\n    Returns:\n        _np.ndarray: A graphic degree sequence drawn from the given distribution.\n    \"\"\"\n    s = _np.array([1])\n    # create rv_discrete object with custom distribution and generate degree sequence\n    if isinstance(distribution, dict):\n        degrees = [k for k in distribution]\n        probs = [distribution[k] for k in degrees]\n\n        dist = scipy.stats.rv_discrete(name=\"custom\", values=(degrees, probs))\n\n        while not is_graphic_erdos_gallai(s):\n            s = dist.rvs(size=n, **distribution_args)\n        return s\n    # use scipy rv objects to generate graphic degree sequence\n    elif hasattr(distribution, \"rvs\"):\n        while not is_graphic_erdos_gallai(s):\n            s = distribution.rvs(size=n, **distribution_args)\n            # Check if the distribution is discrete\n            if s.dtype != int:\n                s = _np.rint(s)\n        return s\n    else:\n        raise NotImplementedError()\n</code></pre>"},{"location":"reference/pathpyG/algorithms/generative_models/#pathpyG.algorithms.generative_models.is_graphic_erdos_gallai","title":"<code>is_graphic_erdos_gallai</code>","text":"<p>Check Erd\u00f6s and Gallai condition.</p> <p>Checks whether the condition by Erd\u00f6s and Gallai<sup>1</sup> for a graphic degree sequence is fulfilled.</p> <ol> <li> <p>Erd\u0151s, P.; Gallai, T. (1960), \"Gr\u00e1fok el\u0151\u00edrt foksz\u00e1m\u00fa pontokkal\", Matematikai Lapok, 11: 264-274 \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>degrees</code> <code>list[int] | numpy.ndarray</code> <p>List of integer node degrees to be tested.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the degree sequence is graphic, False otherwise.</p> Source code in <code>src/pathpyG/algorithms/generative_models.py</code> <pre><code>def is_graphic_erdos_gallai(degrees: list[int] | _np.ndarray) -&gt; bool:\n    \"\"\"Check Erd\u00f6s and Gallai condition.\n\n    Checks whether the condition by Erd\u00f6s and Gallai[^1] for a graphic degree\n    sequence is fulfilled.\n\n    [^1]: *Erd\u0151s, P.; Gallai, T. (1960), \"Gr\u00e1fok el\u0151\u00edrt foksz\u00e1m\u00fa pontokkal\", Matematikai Lapok, 11: 264-274*\n\n    Args:\n        degrees: List of integer node degrees to be tested.\n\n    Returns:\n        bool: True if the degree sequence is graphic, False otherwise.\n    \"\"\"\n    degree_sequence = sorted(degrees, reverse=True)\n    S = sum(degree_sequence)\n    n = len(degree_sequence)\n    if S % 2 != 0:\n        return False\n    for r in range(1, n):\n        M = 0\n        S = 0\n        for i in range(1, r + 1):\n            S += degree_sequence[i - 1]\n        for i in range(r + 1, n + 1):\n            M += min(r, degree_sequence[i - 1])\n        if S &gt; r * (r - 1) + M:\n            return False\n    return True\n</code></pre>"},{"location":"reference/pathpyG/algorithms/generative_models/#pathpyG.algorithms.generative_models.k_regular_random","title":"<code>k_regular_random</code>","text":"<p>Generate a random graph in which all nodes have exactly degree \\(k\\).</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>degree of all nodes in the generated network.</p> required <code>n</code> <code>typing.Optional[int]</code> <p>number of nodes in the generated network.</p> <code>None</code> <code>node_ids</code> <code>typing.Optional[list]</code> <p>Optional list of node uids that will be used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Graph</code> <code>typing.Optional[pathpyG.core.graph.Graph]</code> <p>A random \\(k\\)-regular graph.</p> Source code in <code>src/pathpyG/algorithms/generative_models.py</code> <pre><code>def k_regular_random(k: int, n: Optional[int] = None, node_ids: Optional[list] = None) -&gt; Optional[Graph]:\n    \"\"\"Generate a random graph in which all nodes have exactly degree $k$.\n\n    Args:\n        k: degree of all nodes in the generated network.\n        n: number of nodes in the generated network.\n        node_ids: Optional list of node uids that will be used.\n\n    Returns:\n        Graph: A random $k$-regular graph.\n    \"\"\"\n    if k &lt; 0:\n        msg = \"Degree parameter k must be non-negative\"\n        raise ValueError(msg)\n    if n is None and node_ids is None:\n        msg = \"You must either pass a list of node ids or a number of nodes to generate\"\n        raise ValueError(msg)\n    elif n is None and node_ids is not None:\n        n = len(node_ids)\n\n    return molloy_reed([k] * n, multiedge=False, relax=False, node_ids=node_ids)  # type: ignore[operator]\n</code></pre>"},{"location":"reference/pathpyG/algorithms/generative_models/#pathpyG.algorithms.generative_models.max_edges","title":"<code>max_edges</code>","text":"<p>Returns the maximum number of edges that a directed or undirected network with n nodes can possible have (with or without loops).</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of nodes in the network</p> required <code>directed</code> <code>bool</code> <p>If True, return the maximum number of edges in a directed network.</p> <code>False</code> <code>multi_edges</code> <code>bool</code> <p>If True, multiple edges between each node pair are allowed. In this case np.inf is returned.</p> <code>False</code> <code>self_loops</code> <code>bool</code> <p>If True, include self-loops.</p> <code>False</code> <p>Returns:</p> Type Description <code>int | float</code> <p>The maximum number of edges in the network.</p> <p>Examples:</p> <p>Compute maximum number of edges in undirected network without self-loops and 100 nodes</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; print(pp.algorithms.generative_models.max_edges(100))\n4950\n</code></pre> <p>Directed networks without self-loops</p> <pre><code>&gt;&gt;&gt; print(pp.algorithms.generative_models.max_edges(100, directed=True))\n9900\n</code></pre> <p>Directed networks with self-loops</p> <pre><code>&gt;&gt;&gt; print(pp.algorithms.generative_models.max_edges(100, directed=True, self_loops=True))\n10000\n</code></pre> Source code in <code>src/pathpyG/algorithms/generative_models.py</code> <pre><code>def max_edges(n: int, directed: bool = False, multi_edges: bool = False, self_loops: bool = False) -&gt; int | float:\n    \"\"\"Returns the maximum number of edges that a directed or undirected network with n nodes can possible have (with or without loops).\n\n    Args:\n        n: The number of nodes in the network\n        directed: If True, return the maximum number of edges in a directed network.\n        multi_edges: If True, multiple edges between each node pair are allowed. In this case np.inf is returned.\n        self_loops: If True, include self-loops.\n\n    Returns:\n        The maximum number of edges in the network.\n\n    Examples:\n        Compute maximum number of edges in undirected network without self-loops and 100 nodes\n\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; print(pp.algorithms.generative_models.max_edges(100))\n        4950\n\n        Directed networks without self-loops\n\n        &gt;&gt;&gt; print(pp.algorithms.generative_models.max_edges(100, directed=True))\n        9900\n\n        Directed networks with self-loops\n\n        &gt;&gt;&gt; print(pp.algorithms.generative_models.max_edges(100, directed=True, self_loops=True))\n        10000\n    \"\"\"\n    if multi_edges:\n        return _np.inf\n    elif self_loops and directed:\n        return int(n**2)\n    elif self_loops and not directed:\n        return int(n * (n + 1) / 2)\n    elif not self_loops and not directed:\n        return int(n * (n - 1) / 2)\n    else:  # not loops and directed:\n        return int(n * (n - 1))\n</code></pre>"},{"location":"reference/pathpyG/algorithms/generative_models/#pathpyG.algorithms.generative_models.molloy_reed","title":"<code>molloy_reed</code>","text":"<p>Generate Molloy-Reed graph.</p> <p>Generates a random undirected network without self-loops, with given degree sequence based on the Molloy-Reed algorithm. The condition proposed by Erd\u00f6s and Gallai (1967) is used to test whether the degree sequence is graphic, i.e. whether a network with the given degree sequence exists.</p> <p>Parameters:</p> Name Type Description Default <code>degree_sequence</code> <code>numpy.ndarray | list[int]</code> <p>List of integer node degrees. The number of nodes of the generated network corresponds to <code>len(degree_sequence)</code>.</p> required <code>multiedge</code> <code>bool</code> <p>If True, allow multiple edges between the same node pair.</p> <code>False</code> <code>relax</code> <code>bool</code> <p>If True, we conceptually allow self-loops and multi-edges, but do not add them to the network. This implies that the generated graph may not have exactly <code>sum(degree_sequence)/2</code> edges, but it ensures that the algorithm always finishes.</p> <code>False</code> <code>node_ids </code> <p>Optional list of node IDs that will be used for Indexmapping.</p> required <p>Examples:</p> <p>Generate random undirected network with given degree sequence</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; random_network = pp.algorithms.generative_models.molloy_reed([1, 1])\n&gt;&gt;&gt; print(random_network)\nUndirected graph with 2 nodes and 1 edges\n{'Edge Attributes': {}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\n</code></pre> <p>Network generation fails for non-graphic degree sequence</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; try:\n...     random_network = pp.algorithms.generative_models.molloy_reed([1, 0])\n... except ValueError:\n...     print(\"Caught expected ValueError for non-graphic degree sequence\")\nCaught expected ValueError for non-graphic degree sequence\n</code></pre> Source code in <code>src/pathpyG/algorithms/generative_models.py</code> <pre><code>def molloy_reed(\n    degree_sequence: _np.ndarray | list[int],\n    multiedge: bool = False,\n    relax: bool = False,\n    node_ids: Optional[list] = None,\n) -&gt; Graph:\n    \"\"\"Generate Molloy-Reed graph.\n\n    Generates a random undirected network without self-loops, with given degree sequence based on\n    the Molloy-Reed algorithm. The condition proposed by Erd\u00f6s and Gallai (1967)\n    is used to test whether the degree sequence is graphic, i.e. whether a network\n    with the given degree sequence exists.\n\n    Args:\n        degree_sequence: List of integer node degrees. The number of nodes of the generated\n            network corresponds to `#!python len(degree_sequence)`.\n        multiedge: If True, allow multiple edges between the same node pair.\n        relax: If True, we conceptually allow self-loops and multi-edges, but do not\n            add them to the network. This implies that the generated graph may not\n            have exactly `#!python sum(degree_sequence)/2` edges, but it ensures that the algorithm\n            always finishes.\n        node_ids : Optional list of node IDs that will be used for Indexmapping.\n\n    Examples:\n        Generate random undirected network with given degree sequence\n\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; random_network = pp.algorithms.generative_models.molloy_reed([1, 1])\n        &gt;&gt;&gt; print(random_network)\n        Undirected graph with 2 nodes and 1 edges\n        {'Edge Attributes': {}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\n\n        Network generation fails for non-graphic degree sequence\n\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; try:\n        ...     random_network = pp.algorithms.generative_models.molloy_reed([1, 0])\n        ... except ValueError:\n        ...     print(\"Caught expected ValueError for non-graphic degree sequence\")\n        Caught expected ValueError for non-graphic degree sequence\n    \"\"\"\n    # assume that we are given a graphical degree sequence\n    if not is_graphic_erdos_gallai(degree_sequence):\n        logger.error(\"given degree sequence is not graphic\")\n        raise ValueError(\"given degree sequence is not graphic\")\n\n    # create empty network with n nodes\n    n = len(degree_sequence)\n    edges: list = []\n\n    if node_ids is None or len(node_ids) != n:\n        node_ids = []\n        for i in range(n):\n            node_ids.append(i)\n\n    # generate edge stubs based on degree sequence\n    stubs: list = []\n    for i in range(n):\n        for _ in range(int(degree_sequence[i])):\n            stubs.append(node_ids[i])\n\n    # connect randomly chosen pairs of stubs\n    while len(stubs) &gt; 0:\n        # find candidate node pair to connect\n        v, w = _np.random.choice(stubs, 2, replace=False)\n\n        # we encountered candidate edge that we cannot add\n        if v == w or (((v, w) in edges or (w, v) in edges) and not multiedge and not relax):\n            # break up random edge and add back stubs to avoid\n            # infinite loop\n            if len(edges) &gt; 0:\n                e = random.choice(edges)\n                edges.remove(e)\n                stubs.append(e[0])\n                stubs.append(e[1])\n        elif v != w:\n            edges.append((v, w))\n            stubs.remove(v)\n            stubs.remove(w)\n\n    return Graph.from_edge_list(edges).to_undirected()\n</code></pre>"},{"location":"reference/pathpyG/algorithms/generative_models/#pathpyG.algorithms.generative_models.molloy_reed_randomize","title":"<code>molloy_reed_randomize</code>","text":"<p>Generates a randomized realization of a given undirected network based on the observed degree sequence.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>A given undirected network.</p> required <p>Returns:</p> Name Type Description <code>Graph</code> <code>typing.Optional[pathpyG.core.graph.Graph]</code> <p>A randomized version of the given graph based on the Molloy-Reed model</p> Source code in <code>src/pathpyG/algorithms/generative_models.py</code> <pre><code>def molloy_reed_randomize(graph: Graph) -&gt; Optional[Graph]:\n    \"\"\"Generates a randomized realization of a given undirected network based on the observed degree sequence.\n\n    Args:\n        graph: A given undirected network.\n\n    Returns:\n        Graph: A randomized version of the given graph based on the Molloy-Reed model\n    \"\"\"\n    if graph.is_directed():\n        logger.error(\"molloy_reed_randomize is only implemented for undirected graphs\")\n        raise NotImplementedError(\"molloy_reed_randomize is only implemented for undirected graphs\")\n    # degrees are listed in order of node indices\n    degrees = degree(graph.data.edge_index[1], num_nodes=graph.n, dtype=torch.int).tolist()\n    return molloy_reed(degrees, node_ids=graph.nodes).to_undirected()\n</code></pre>"},{"location":"reference/pathpyG/algorithms/generative_models/#pathpyG.algorithms.generative_models.stochastic_block_model","title":"<code>stochastic_block_model</code>","text":"<p>Generate a random undirected graph based on the stochastic block model.</p> <p>Parameters:</p> Name Type Description Default <code>M</code> <code>numpy.matrix</code> <p>n x n stochastic block matrix, where entry M[i,j] gives probability of edge to be generated between nodes in blocks i and j</p> required <code>z</code> <code>numpy.ndarray</code> <p>n-dimensional block assignment vector, where z[i] gives block assignment of i-th node</p> required <code>mapping</code> <code>typing.Optional[pathpyG.core.index_map.IndexMap]</code> <p>optional mapping of node IDs to indices. If not given, a standard mapping based on integer IDs will be created</p> <code>None</code> Source code in <code>src/pathpyG/algorithms/generative_models.py</code> <pre><code>def stochastic_block_model(M: _np.matrix, z: _np.ndarray, mapping: Optional[IndexMap] = None) -&gt; Graph:\n    \"\"\"Generate a random undirected graph based on the stochastic block model.\n\n    Args:\n        M: n x n stochastic block matrix, where entry M[i,j] gives probability of edge to be generated\n            between nodes in blocks i and j\n        z: n-dimensional block assignment vector, where z[i] gives block assignment of i-th node\n        mapping: optional mapping of node IDs to indices. If not given, a standard\n            mapping based on integer IDs will be created\n    \"\"\"\n    # the number of nodes is implicitly given by the length of block assignment vector z\n    n = len(z)\n\n    # we can use pre-defined node names, if not given, we use contiguous numbers\n    if mapping is None:\n        mapping = IndexMap([str(i) for i in range(n)])\n\n    edges = []\n\n    # randomly generate links with probabilities given by entries of the stochastic block matrix M\n    for u in range(n):\n        for v in range(u):\n            if _np.random.random() &lt;= M[z[u], z[v]]:\n                edges.append((mapping.to_id(u), mapping.to_id(v)))\n                edges.append((mapping.to_id(v), mapping.to_id(u)))\n\n    g = Graph.from_edge_list(edges, mapping=mapping).to_undirected()  # type: ignore[arg-type]\n    return g\n</code></pre>"},{"location":"reference/pathpyG/algorithms/generative_models/#pathpyG.algorithms.generative_models.watts_strogatz","title":"<code>watts_strogatz</code>","text":"<p>Generate a Watts-Strogatz small-world graph.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of nodes in the graph.</p> required <code>s</code> <code>int</code> <p>The number of edges to attach from a new node to existing nodes.</p> required <code>p</code> <code>float</code> <p>The probability of rewiring each edge.</p> <code>0.0</code> <code>undirected</code> <code>bool</code> <p>If True, the graph will be undirected.</p> <code>True</code> <code>allow_duplicate_edges</code> <code>bool</code> <p>If True, allow duplicate edges in the graph. This is faster but may result in fewer edges than requested in the undirected case or duplicates in the directed case.</p> <code>True</code> <code>allow_self_loops</code> <code>bool</code> <p>If True, allow self-loops in the graph. This is faster but may result in fewer edges than requested in the undirected case.</p> <code>True</code> <code>mapping</code> <code>pathpyG.core.index_map.IndexMap | None</code> <p>A mapping from the node indices to node names.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Graph</code> <code>pathpyG.core.graph.Graph</code> <p>A Watts-Strogatz small-world graph.</p> <p>Examples:</p> <pre><code>g = Watts_Strogatz(100, 4, 0.1, mapping=pp.IndexMap([f\"n_{i}\" for i in range(100)])\n</code></pre> Source code in <code>src/pathpyG/algorithms/generative_models.py</code> <pre><code>def watts_strogatz(\n    n: int,\n    s: int,\n    p: float = 0.0,\n    undirected: bool = True,\n    allow_duplicate_edges: bool = True,\n    allow_self_loops: bool = True,\n    mapping: IndexMap | None = None,\n) -&gt; Graph:\n    \"\"\"Generate a Watts-Strogatz small-world graph.\n\n    Args:\n        n: The number of nodes in the graph.\n        s: The number of edges to attach from a new node to existing nodes.\n        p: The probability of rewiring each edge.\n        undirected: If True, the graph will be undirected.\n        allow_duplicate_edges: If True, allow duplicate edges in the graph.\n            This is faster but may result in fewer edges than requested in the undirected case\n            or duplicates in the directed case.\n        allow_self_loops: If True, allow self-loops in the graph.\n            This is faster but may result in fewer edges than requested in the undirected case.\n        mapping: A mapping from the node indices to node names.\n\n    Returns:\n        Graph: A Watts-Strogatz small-world graph.\n\n    Examples:\n        ```py\n        g = Watts_Strogatz(100, 4, 0.1, mapping=pp.IndexMap([f\"n_{i}\" for i in range(100)])\n        ```\n    \"\"\"\n    nodes = torch.arange(n)\n\n    # construct a ring lattice (dimension 1)\n    edges = (\n        torch.stack([torch.stack((nodes, torch.roll(nodes, shifts=-i, dims=0))) for i in range(1, s + 1)], dim=0)\n        .permute(1, 0, 2)\n        .reshape(2, -1)\n    )\n\n    if not allow_duplicate_edges:\n        if n * (n - 1) &lt; edges.shape[1]:\n            logger.error(\n                \"number of edges is greater than the number of possible edges in the graph. Set `allow_duplicate_edges=True` to allow this.\"\n            )\n            raise ValueError(\n                \"number of edges is greater than the number of possible edges in the graph. Set `allow_duplicate_edges=True` to allow this.\"\n            )\n        elif n * (n - 1) * 0.5 &lt; edges.shape[1] and p &gt; 0.3:\n            logger.info(\n                \"Avoding duplicate in graphs with high connectivity and high rewiring probability may be slow. Consider setting `allow_duplicate_edges=True`.\"\n            )\n\n    # Rewire each link with probability p\n    rand_vals = torch.rand(edges.shape[1])\n    rewire_mask = rand_vals &lt; p\n\n    # Generate random nodes excluding the current node for each edge that needs to be rewired, also avoid duplicate edges\n    edges[1, rewire_mask] = torch.randint(n, (int(rewire_mask.sum()),))\n\n    # In the undirected case, make sure the edges all point in the same direction\n    # to avoid duplicate edges pointing in opposite directions\n    if undirected:\n        edges = edges.sort(dim=0)[0]\n    final_edges = edges\n\n    if not allow_duplicate_edges:\n        # Remove duplicate edges\n        final_edges, counts = edges.unique(dim=1, return_counts=True)\n        if final_edges.shape[0] &lt; edges.shape[1]:\n            for i, edge in enumerate(final_edges[:, counts &gt; 1].T):\n                for _ in range(counts[counts &gt; 1][i] - 1):\n                    while True:\n                        new_edge = torch.tensor([edge[0], torch.randint(n, (1,))]).sort()[0].unsqueeze(1)\n                        # Check if the new edge is already in the final edges\n                        # and add it if not\n                        if (new_edge != final_edges).any(dim=0).all():\n                            final_edges = torch.cat((final_edges, new_edge), dim=1)\n                            break\n\n    if not allow_self_loops:\n        self_loop_edges = final_edges[:, final_edges[0] == final_edges[1]]\n        final_edges = final_edges[:, final_edges[0] != final_edges[1]]\n        for self_loop_edge in self_loop_edges.T:\n            while True:\n                new_edge = torch.tensor([self_loop_edge[0], torch.randint(n, (1,))]).sort()[0].unsqueeze(1)\n                # Check if the new edge is already in the final edges\n                # and add it if not\n                if (new_edge != final_edges).any(dim=0).all() and new_edge[0] != new_edge[1]:\n                    final_edges = torch.cat((final_edges, new_edge), dim=1)\n                    break\n\n    g = Graph.from_edge_index(final_edges, mapping=mapping)\n    if undirected:\n        g = g.to_undirected()\n    return g\n</code></pre>"},{"location":"reference/pathpyG/algorithms/lift_order/","title":"lift_order","text":"<p>Utility functions for lifting the order of a graph (line-graph transformation).</p>"},{"location":"reference/pathpyG/algorithms/lift_order/#pathpyG.algorithms.lift_order.aggregate_edge_index","title":"<code>aggregate_edge_index</code>","text":"<p>Aggregate the possibly duplicated edges in the (higher-order) edge index.</p> <p>Aggregate the possibly duplicated edges in the (higher-order) edge index and return a graph object containing the (higher-order) edge index without duplicates and the node sequences.</p> <p>This method can be seen as a higher-order generalization of the <code>torch_geometric.utils.coalesce</code> method. It is used for example to generate the DeBruijn graph of a given order from the corresponding line graph.</p> <p>Parameters:</p> Name Type Description Default <code>edge_index</code> <code>torch.Tensor</code> <p>The edge index of a (higher-order) graph where each source and destination node corresponds to a node which is an edge in the (k-1)-th order graph.</p> required <code>node_sequence</code> <code>torch.Tensor</code> <p>The node sequences of first order nodes that each node in the edge index corresponds to.</p> required <code>edge_weight</code> <code>torch.Tensor | None</code> <p>The edge weights corresponding to the edge index.</p> <code>None</code> <code>aggr</code> <code>str</code> <p>The aggregation method to use for the edge weights. One of \"sum\", \"mean\", \"min\", \"max\".</p> <code>'sum'</code> <p>Returns:</p> Type Description <code>pathpyG.core.graph.Graph</code> <p>A graph object containing the aggregated edge index, the node sequences, the edge weights and the inverse index.</p> Source code in <code>src/pathpyG/algorithms/lift_order.py</code> <pre><code>def aggregate_edge_index(\n    edge_index: torch.Tensor, node_sequence: torch.Tensor, edge_weight: torch.Tensor | None = None, aggr: str = \"sum\"\n) -&gt; Graph:\n    \"\"\"Aggregate the possibly duplicated edges in the (higher-order) edge index.\n\n    Aggregate the possibly duplicated edges in the (higher-order) edge index and return a graph object\n    containing the (higher-order) edge index without duplicates and the node sequences.\n\n    This method can be seen as a higher-order generalization of the `torch_geometric.utils.coalesce` method.\n    It is used for example to generate the DeBruijn graph of a given order from the corresponding line graph.\n\n    Args:\n        edge_index: The edge index of a (higher-order) graph where each source and destination node\n            corresponds to a node which is an edge in the (k-1)-th order graph.\n        node_sequence: The node sequences of first order nodes that each node in the edge index corresponds to.\n        edge_weight: The edge weights corresponding to the edge index.\n        aggr: The aggregation method to use for the edge weights. One of \"sum\", \"mean\", \"min\", \"max\".\n\n    Returns:\n        A graph object containing the aggregated edge index, the node sequences, the edge weights and the inverse index.\n    \"\"\"\n    if edge_weight is None:\n        edge_weight = torch.ones(edge_index.size(1), device=edge_index.device)\n\n    unique_nodes, inverse_idx = torch.unique(node_sequence, dim=0, return_inverse=True)\n    # If first order, then the indices in the node sequence are the inverse idx we would need already\n    if node_sequence.size(1) == 1:\n        mapped_edge_index = node_sequence.squeeze()[edge_index]\n    else:\n        mapped_edge_index = inverse_idx[edge_index]\n    aggregated_edge_index, edge_weight = coalesce(\n        mapped_edge_index,\n        edge_attr=edge_weight,\n        num_nodes=unique_nodes.size(0),\n        reduce=aggr,\n    )\n    data = Data(\n        edge_index=aggregated_edge_index,\n        num_nodes=unique_nodes.size(0),\n        node_sequence=unique_nodes,\n        edge_weight=edge_weight,\n        inverse_idx=inverse_idx,\n    )\n    return Graph(data)\n</code></pre>"},{"location":"reference/pathpyG/algorithms/lift_order/#pathpyG.algorithms.lift_order.aggregate_node_attributes","title":"<code>aggregate_node_attributes</code>","text":"<p>Aggregate the node attributes of each pair of nodes in the edge index.</p> <p>This method aggregates the node attributes of each pair of nodes in the edge index using the aggregation method specified. The method returns an attribute for each edge. The aggregation methods are:</p> <ul> <li>\"src\": Use the attribute of the source node for each edge.</li> <li>\"dst\": Use the attribute of the destination node for each edge.</li> <li>\"max\": Use the maximum of the attributes of the source and destination nodes for each edge.</li> <li>\"mul\": Use the product of the attributes of the source and destination nodes for each edge.</li> <li>\"add\": Use the sum of the attributes of the source and destination nodes for each edge.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>edge_index</code> <code>torch.Tensor</code> <p>The edge index of the graph.</p> required <code>node_attribute</code> <code>torch.Tensor</code> <p>The node attribute tensor.</p> required <code>aggr</code> <code>str</code> <p>The aggregation method to use. One of \"src\", \"dst\", \"max\", \"mul\" or \"add\".</p> <code>'src'</code> <p>Returns:</p> Type Description <code>torch.Tensor</code> <p>The aggregated node attributes for each edge.</p> Source code in <code>src/pathpyG/algorithms/lift_order.py</code> <pre><code>def aggregate_node_attributes(\n    edge_index: torch.Tensor, node_attribute: torch.Tensor, aggr: str = \"src\"\n) -&gt; torch.Tensor:\n    \"\"\"Aggregate the node attributes of each pair of nodes in the edge index.\n\n    This method aggregates the node attributes of each pair of nodes in the edge index\n    using the aggregation method specified. The method returns an attribute for each edge.\n    The aggregation methods are:\n\n    - \"src\": Use the attribute of the source node for each edge.\n    - \"dst\": Use the attribute of the destination node for each edge.\n    - \"max\": Use the maximum of the attributes of the source and destination nodes for each edge.\n    - \"mul\": Use the product of the attributes of the source and destination nodes for each edge.\n    - \"add\": Use the sum of the attributes of the source and destination nodes for each edge.\n\n    Args:\n        edge_index: The edge index of the graph.\n        node_attribute: The node attribute tensor.\n        aggr: The aggregation method to use. One of \"src\", \"dst\", \"max\", \"mul\" or \"add\".\n\n    Returns:\n        The aggregated node attributes for each edge.\n    \"\"\"\n    if aggr == \"src\":\n        aggr_attributes = node_attribute[edge_index[0]]\n    elif aggr == \"dst\":\n        aggr_attributes = node_attribute[edge_index[1]]\n    elif aggr == \"max\":\n        aggr_attributes = torch.maximum(node_attribute[edge_index[0]], node_attribute[edge_index[1]])\n    elif aggr == \"mul\":\n        aggr_attributes = node_attribute[edge_index[0]] * node_attribute[edge_index[1]]\n    elif aggr == \"add\":\n        aggr_attributes = node_attribute[edge_index[0]] + node_attribute[edge_index[1]]\n    else:\n        raise ValueError(f\"Unknown aggregation method {aggr}\")\n    return aggr_attributes\n</code></pre>"},{"location":"reference/pathpyG/algorithms/lift_order/#pathpyG.algorithms.lift_order.lift_order_edge_index","title":"<code>lift_order_edge_index</code>","text":"<p>Line graph transformation.</p> <p>Do a line graph transformation on the edge index to lift the order of the graph by one. Assumes that the edge index is sorted.</p> <p>Parameters:</p> Name Type Description Default <code>edge_index</code> <code>torch.Tensor</code> <p>A sorted edge index tensor of shape (2, num_edges).</p> required <code>num_nodes</code> <code>int | None</code> <p>The number of nodes in the graph. If not given, it will be inferred from the edge index (maximum node index + 1).</p> <code>None</code> <p>Returns:</p> Type Description <code>torch.Tensor</code> <p>The edge index of the lifted (line) graph.</p> Source code in <code>src/pathpyG/algorithms/lift_order.py</code> <pre><code>def lift_order_edge_index(edge_index: torch.Tensor, num_nodes: int | None = None) -&gt; torch.Tensor:\n    \"\"\"Line graph transformation.\n\n    Do a line graph transformation on the edge index to lift the order of the graph by one.\n    Assumes that the edge index is sorted.\n\n    Args:\n        edge_index: A **sorted** edge index tensor of shape (2, num_edges).\n        num_nodes: The number of nodes in the graph. If not given,\n            it will be inferred from the edge index (maximum node index + 1).\n\n    Returns:\n        The edge index of the lifted (line) graph.\n    \"\"\"\n    if num_nodes is None:\n        num_nodes = int(edge_index.max()) + 1\n\n    outdegree = degree(edge_index[0], dtype=torch.long, num_nodes=num_nodes)\n    # Map outdegree to each destination node to create an edge for each combination\n    # of incoming and outgoing edges for each destination node\n    outdegree_per_dst = outdegree[edge_index[1]]\n    # Create sources of the new higher-order edges\n    ho_edge_srcs = torch.repeat_interleave(outdegree_per_dst)\n\n    # Create destination nodes that start the indexing after the cumulative sum of the outdegree\n    # of all previous nodes in the ordered sequence of nodes\n    ptrs = cumsum(outdegree, dim=0)[:-1]\n    ho_edge_dsts = torch.repeat_interleave(ptrs[edge_index[1]], outdegree_per_dst)\n    idx_correction = torch.arange(ho_edge_srcs.size(0), dtype=torch.long, device=edge_index.device)\n    idx_correction -= cumsum(outdegree_per_dst, dim=0)[ho_edge_srcs]\n    ho_edge_dsts += idx_correction\n    return torch.stack([ho_edge_srcs, ho_edge_dsts], dim=0)\n</code></pre>"},{"location":"reference/pathpyG/algorithms/lift_order/#pathpyG.algorithms.lift_order.lift_order_edge_index_weighted","title":"<code>lift_order_edge_index_weighted</code>","text":"<p>Weighted line graph transformation.</p> <p>Do a line graph transformation on the edge index to lift the order of the graph by one. Additionally, aggregate the edge weights of the (k-1)-th order graph to the (k)-th order graph. Assumes that the edge index is sorted.</p> <p>Parameters:</p> Name Type Description Default <code>edge_index</code> <code>torch.Tensor</code> <p>A sorted edge index tensor of shape (2, num_edges).</p> required <code>edge_weight</code> <code>torch.Tensor</code> <p>The edge weights of the (k-1)th order graph.</p> required <code>num_nodes</code> <code>int | None</code> <p>The number of nodes in the graph.</p> <code>None</code> <code>aggr</code> <code>str</code> <p>The aggregation method to use. One of \"src\", \"dst\", \"max\", \"mul\" or \"add\".</p> <code>'src'</code> <p>Returns:</p> Type Description <code>tuple[torch.Tensor, torch.Tensor]</code> <p>A tuple containing the edge index of the lifted (line) graph and the aggregated edge weights.</p> Source code in <code>src/pathpyG/algorithms/lift_order.py</code> <pre><code>def lift_order_edge_index_weighted(\n    edge_index: torch.Tensor, edge_weight: torch.Tensor, num_nodes: int | None = None, aggr: str = \"src\"\n) -&gt; tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"Weighted line graph transformation.\n\n    Do a line graph transformation on the edge index to lift the order of the graph by one.\n    Additionally, aggregate the edge weights of the (k-1)-th order graph to the (k)-th order graph.\n    Assumes that the edge index is sorted.\n\n    Args:\n        edge_index: A **sorted** edge index tensor of shape (2, num_edges).\n        edge_weight: The edge weights of the (k-1)th order graph.\n        num_nodes: The number of nodes in the graph.\n        aggr: The aggregation method to use. One of \"src\", \"dst\", \"max\", \"mul\" or \"add\".\n\n    Returns:\n        A tuple containing the edge index of the lifted (line) graph and the aggregated edge weights.\n    \"\"\"\n    if num_nodes is None:\n        num_nodes = int(edge_index.max()) + 1\n\n    ho_index = lift_order_edge_index(edge_index, num_nodes)\n    ho_edge_weight = aggregate_node_attributes(ho_index, edge_weight, aggr)\n\n    return ho_index, ho_edge_weight\n</code></pre>"},{"location":"reference/pathpyG/algorithms/rolling_time_window/","title":"rolling_time_window","text":"<p>Iterator interface for rolling time window analysis in temporal graphs.</p>"},{"location":"reference/pathpyG/algorithms/rolling_time_window/#pathpyG.algorithms.rolling_time_window.RollingTimeWindow","title":"<code>RollingTimeWindow</code>","text":"<p>An iterable rolling time window that can be used to perform time slice analysis of temporal graphs.</p> Source code in <code>src/pathpyG/algorithms/rolling_time_window.py</code> <pre><code>class RollingTimeWindow:\n    \"\"\"An iterable rolling time window that can be used to perform time slice analysis of temporal graphs.\"\"\"\n\n    def __init__(self, temporal_graph, window_size, step_size=1, return_window=False, weighted=True):\n        \"\"\"Initialize RollingTimeWindow.\n\n        Initialize a RollingTimeWindow instance that can be used to\n        iterate through a sequence of time-slice networks for a given\n        TemporalNetwork instance.\n\n        Args:\n            temporal_graph: TemporalGraphinstance that will be used to generate the\n                sequence of time-slice networks.\n            window_size: The width of the rolling time window used to create time-slice networks.\n            step_size: The step size in time units by which the starting\n                time of the rolling window will be incremented on each iteration.\n            return_window: Whether or not the iterator shall return the current time window as a second return value. Default is False.\n            weighted: Whether or not to return a weighted graph\n\n        Example:\n            ```py\n            tedges = [('a', 'b', 1), ('b', 'c', 5), ('c', 'd', 9), ('c', 'e', 9),\n              ('c', 'f', 11), ('f', 'a', 13), ('a', 'g', 18), ('b', 'f', 21),\n              ('a', 'g', 26), ('c', 'f', 27), ('h', 'f', 27), ('g', 'h', 28),\n              ('a', 'c', 30), ('a', 'b', 31), ('c', 'h', 32), ('f', 'h', 33),\n              ('b', 'i', 42), ('i', 'b', 42), ('c', 'i', 47), ('h', 'i', 50)]\n            t = pp.TemporalGraph.from_edge_list(tedges)\n            r = pp.algorithms.RollingTimeWindow(t, 10, 10, return_window=True)\n            for g, w in r:\n                print('Time window ', w)\n                print(g)\n                print(g.data.edge_index)\n                print('---')\n            ```\n        \"\"\"\n        self.g = temporal_graph\n        self.window_size = window_size\n        self.step_size = step_size\n        self.current_time = self.g.start_time\n        self.return_window = return_window\n        self.weighted = weighted\n\n    def __iter__(self):\n        \"\"\"Return the iterator object itself.\"\"\"\n        return self\n\n    def __next__(self):\n        \"\"\"Return the next time-slice network in the rolling time window sequence.\"\"\"\n        if self.current_time &lt;= self.g.end_time:\n            time_window = (self.current_time, self.current_time + self.window_size)\n            s = self.g.to_static_graph(weighted=self.weighted, time_window=time_window)\n            self.current_time += self.step_size\n            if self.return_window:\n                return s, time_window\n            else:\n                return s\n        else:\n            raise StopIteration()\n</code></pre>"},{"location":"reference/pathpyG/algorithms/rolling_time_window/#pathpyG.algorithms.rolling_time_window.RollingTimeWindow.__init__","title":"<code>__init__</code>","text":"<p>Initialize RollingTimeWindow.</p> <p>Initialize a RollingTimeWindow instance that can be used to iterate through a sequence of time-slice networks for a given TemporalNetwork instance.</p> <p>Parameters:</p> Name Type Description Default <code>temporal_graph</code> <p>TemporalGraphinstance that will be used to generate the sequence of time-slice networks.</p> required <code>window_size</code> <p>The width of the rolling time window used to create time-slice networks.</p> required <code>step_size</code> <p>The step size in time units by which the starting time of the rolling window will be incremented on each iteration.</p> <code>1</code> <code>return_window</code> <p>Whether or not the iterator shall return the current time window as a second return value. Default is False.</p> <code>False</code> <code>weighted</code> <p>Whether or not to return a weighted graph</p> <code>True</code> Example <pre><code>tedges = [('a', 'b', 1), ('b', 'c', 5), ('c', 'd', 9), ('c', 'e', 9),\n  ('c', 'f', 11), ('f', 'a', 13), ('a', 'g', 18), ('b', 'f', 21),\n  ('a', 'g', 26), ('c', 'f', 27), ('h', 'f', 27), ('g', 'h', 28),\n  ('a', 'c', 30), ('a', 'b', 31), ('c', 'h', 32), ('f', 'h', 33),\n  ('b', 'i', 42), ('i', 'b', 42), ('c', 'i', 47), ('h', 'i', 50)]\nt = pp.TemporalGraph.from_edge_list(tedges)\nr = pp.algorithms.RollingTimeWindow(t, 10, 10, return_window=True)\nfor g, w in r:\n    print('Time window ', w)\n    print(g)\n    print(g.data.edge_index)\n    print('---')\n</code></pre> Source code in <code>src/pathpyG/algorithms/rolling_time_window.py</code> <pre><code>def __init__(self, temporal_graph, window_size, step_size=1, return_window=False, weighted=True):\n    \"\"\"Initialize RollingTimeWindow.\n\n    Initialize a RollingTimeWindow instance that can be used to\n    iterate through a sequence of time-slice networks for a given\n    TemporalNetwork instance.\n\n    Args:\n        temporal_graph: TemporalGraphinstance that will be used to generate the\n            sequence of time-slice networks.\n        window_size: The width of the rolling time window used to create time-slice networks.\n        step_size: The step size in time units by which the starting\n            time of the rolling window will be incremented on each iteration.\n        return_window: Whether or not the iterator shall return the current time window as a second return value. Default is False.\n        weighted: Whether or not to return a weighted graph\n\n    Example:\n        ```py\n        tedges = [('a', 'b', 1), ('b', 'c', 5), ('c', 'd', 9), ('c', 'e', 9),\n          ('c', 'f', 11), ('f', 'a', 13), ('a', 'g', 18), ('b', 'f', 21),\n          ('a', 'g', 26), ('c', 'f', 27), ('h', 'f', 27), ('g', 'h', 28),\n          ('a', 'c', 30), ('a', 'b', 31), ('c', 'h', 32), ('f', 'h', 33),\n          ('b', 'i', 42), ('i', 'b', 42), ('c', 'i', 47), ('h', 'i', 50)]\n        t = pp.TemporalGraph.from_edge_list(tedges)\n        r = pp.algorithms.RollingTimeWindow(t, 10, 10, return_window=True)\n        for g, w in r:\n            print('Time window ', w)\n            print(g)\n            print(g.data.edge_index)\n            print('---')\n        ```\n    \"\"\"\n    self.g = temporal_graph\n    self.window_size = window_size\n    self.step_size = step_size\n    self.current_time = self.g.start_time\n    self.return_window = return_window\n    self.weighted = weighted\n</code></pre>"},{"location":"reference/pathpyG/algorithms/rolling_time_window/#pathpyG.algorithms.rolling_time_window.RollingTimeWindow.__iter__","title":"<code>__iter__</code>","text":"<p>Return the iterator object itself.</p> Source code in <code>src/pathpyG/algorithms/rolling_time_window.py</code> <pre><code>def __iter__(self):\n    \"\"\"Return the iterator object itself.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/pathpyG/algorithms/rolling_time_window/#pathpyG.algorithms.rolling_time_window.RollingTimeWindow.__next__","title":"<code>__next__</code>","text":"<p>Return the next time-slice network in the rolling time window sequence.</p> Source code in <code>src/pathpyG/algorithms/rolling_time_window.py</code> <pre><code>def __next__(self):\n    \"\"\"Return the next time-slice network in the rolling time window sequence.\"\"\"\n    if self.current_time &lt;= self.g.end_time:\n        time_window = (self.current_time, self.current_time + self.window_size)\n        s = self.g.to_static_graph(weighted=self.weighted, time_window=time_window)\n        self.current_time += self.step_size\n        if self.return_window:\n            return s, time_window\n        else:\n            return s\n    else:\n        raise StopIteration()\n</code></pre>"},{"location":"reference/pathpyG/algorithms/shortest_paths/","title":"shortest_paths","text":"<p>Algorithms to calculate shortest paths in static networks.</p> <p>The functions  in this module allow to compute shortest paths in static networks.</p>"},{"location":"reference/pathpyG/algorithms/shortest_paths/#pathpyG.algorithms.shortest_paths.avg_path_length","title":"<code>avg_path_length</code>","text":"<p>Compute the average path length of the graph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>Input graph.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The average path length of the graph.</p> Source code in <code>src/pathpyG/algorithms/shortest_paths.py</code> <pre><code>def avg_path_length(graph: Graph) -&gt; float:\n    \"\"\"Compute the average path length of the graph.\n\n    Args:\n        graph (Graph): Input graph.\n\n    Returns:\n        float: The average path length of the graph.\n    \"\"\"\n    m = graph.sparse_adj_matrix()\n    dist = dijkstra(m, directed=graph.is_directed(), return_predecessors=False, unweighted=True)\n    return _np.sum(dist) / (graph.n * (graph.n - 1))\n</code></pre>"},{"location":"reference/pathpyG/algorithms/shortest_paths/#pathpyG.algorithms.shortest_paths.diameter","title":"<code>diameter</code>","text":"<p>Compute the diameter of the graph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>Input graph.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The diameter of the graph.</p> Source code in <code>src/pathpyG/algorithms/shortest_paths.py</code> <pre><code>def diameter(graph: Graph) -&gt; float:\n    \"\"\"Compute the diameter of the graph.\n\n    Args:\n        graph (Graph): Input graph.\n\n    Returns:\n        float: The diameter of the graph.\n    \"\"\"\n    m = graph.sparse_adj_matrix()\n    dist = dijkstra(m, directed=graph.is_directed(), return_predecessors=False, unweighted=True)\n    return _np.max(dist)\n</code></pre>"},{"location":"reference/pathpyG/algorithms/shortest_paths/#pathpyG.algorithms.shortest_paths.shortest_paths_dijkstra","title":"<code>shortest_paths_dijkstra</code>","text":"<p>Compute shortest paths using Dijkstra's algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>Input graph.</p> required <p>Returns:</p> Type Description <code>tuple[numpy.ndarray, numpy.ndarray]</code> <p>tuple[np.ndarray, np.ndarray]: A tuple containing the distance matrix and the predecessor matrix.</p> Source code in <code>src/pathpyG/algorithms/shortest_paths.py</code> <pre><code>def shortest_paths_dijkstra(graph: Graph) -&gt; tuple[_np.ndarray, _np.ndarray]:\n    \"\"\"Compute shortest paths using Dijkstra's algorithm.\n\n    Args:\n        graph (Graph): Input graph.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing the distance matrix and the predecessor matrix.\n    \"\"\"\n    m = graph.sparse_adj_matrix()\n    dist, pred = dijkstra(m, directed=graph.is_directed(), return_predecessors=True, unweighted=True)\n    return dist, pred\n</code></pre>"},{"location":"reference/pathpyG/algorithms/temporal/","title":"temporal","text":"<p>Algorithms for the analysis of time-respecting paths in temporal graphs.</p>"},{"location":"reference/pathpyG/algorithms/temporal/#pathpyG.algorithms.temporal.lift_order_temporal","title":"<code>lift_order_temporal</code>","text":"<p>Lift a temporal graph to a second-order temporal event graph.</p> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>pathpyG.core.temporal_graph.TemporalGraph</code> <p>Temporal graph to lift.</p> required <code>delta</code> <code>float | int</code> <p>Maximum time difference between events to consider them connected.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>ho_index</code> <p>Edge index of the second-order temporal event graph.</p> Source code in <code>src/pathpyG/algorithms/temporal.py</code> <pre><code>def lift_order_temporal(g: TemporalGraph, delta: float | int = 1):\n    \"\"\"Lift a temporal graph to a second-order temporal event graph.\n\n    Args:\n        g: Temporal graph to lift.\n        delta: Maximum time difference between events to consider them connected.\n\n    Returns:\n        ho_index: Edge index of the second-order temporal event graph.\n    \"\"\"\n    # first-order edge index\n    edge_index, timestamps = g.data.edge_index, g.data.time\n\n    delta = torch.tensor(delta, device=edge_index.device)  # type: ignore[assignment]\n    indices = torch.arange(0, edge_index.size(1), device=edge_index.device)\n\n    unique_t = torch.unique(timestamps, sorted=True)\n    second_order = []\n\n    # lift order: find possible continuations for edges in each time stamp\n    for t in tqdm(unique_t):\n        # find indices of all source edges that occur at unique timestamp t\n        src_time_mask = timestamps == t\n        src_edge_idx = indices[src_time_mask]\n\n        # find indices of all edges that can possibly continue edges occurring at time t for the given delta\n        dst_time_mask = (timestamps &gt; t) &amp; (timestamps &lt;= t + delta)\n        dst_edge_idx = indices[dst_time_mask]\n\n        if dst_edge_idx.size(0) &gt; 0 and src_edge_idx.size(0) &gt; 0:\n            # compute second-order edges between src and dst idx\n            # for all edges where dst in src_edges (edge_index[1, x[:, 0]]) matches src in dst_edges (edge_index[0, x[:, 1]])\n            x = torch.cartesian_prod(src_edge_idx, dst_edge_idx)\n            ho_edge_index = x[edge_index[1, x[:, 0]] == edge_index[0, x[:, 1]]]\n            second_order.append(ho_edge_index)\n\n    ho_index = torch.cat(second_order, dim=0).t().contiguous()\n    return ho_index\n</code></pre>"},{"location":"reference/pathpyG/algorithms/temporal/#pathpyG.algorithms.temporal.temporal_shortest_paths","title":"<code>temporal_shortest_paths</code>","text":"<p>Compute shortest time-respecting paths in a temporal graph.</p> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>pathpyG.core.temporal_graph.TemporalGraph</code> <p>Temporal graph to compute shortest paths on.</p> required <code>delta</code> <code>int</code> <p>Maximum time difference between events in a path.</p> required <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Tuple of two numpy arrays:</p> <code>numpy.ndarray</code> <ul> <li>dist: Shortest time-respecting path distances between all first-order nodes.</li> </ul> <code>typing.Tuple[numpy.ndarray, numpy.ndarray]</code> <ul> <li>pred: Predecessor matrix for shortest time-respecting paths between all first-order nodes.</li> </ul> Source code in <code>src/pathpyG/algorithms/temporal.py</code> <pre><code>def temporal_shortest_paths(g: TemporalGraph, delta: int) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Compute shortest time-respecting paths in a temporal graph.\n\n    Args:\n        g: Temporal graph to compute shortest paths on.\n        delta: Maximum time difference between events in a path.\n\n    Returns:\n        Tuple of two numpy arrays:\n        - dist: Shortest time-respecting path distances between all first-order nodes.\n        - pred: Predecessor matrix for shortest time-respecting paths between all first-order nodes.\n    \"\"\"\n    # generate temporal event DAG\n    edge_index = lift_order_temporal(g, delta)\n\n    # Add indices of first-order nodes as src and dst of paths in augmented\n    # temporal event DAG\n    src_edges_src = g.data.edge_index[0] + g.m\n    src_edges_dst = torch.arange(0, g.data.edge_index.size(1), device=g.data.edge_index.device)\n\n    dst_edges_src = torch.arange(0, g.data.edge_index.size(1), device=g.data.edge_index.device)\n    dst_edges_dst = g.data.edge_index[1] + g.m + g.n\n\n    # add edges from source to edges and from edges to destinations\n    src_edges = torch.stack([src_edges_src, src_edges_dst])\n    dst_edges = torch.stack([dst_edges_src, dst_edges_dst])\n    edge_index = torch.cat([edge_index, src_edges, dst_edges], dim=1)\n\n    # create sparse scipy matrix\n    event_graph = Graph.from_edge_index(edge_index, num_nodes=g.m + 2 * g.n)\n    m = event_graph.sparse_adj_matrix()\n\n    # print(f\"Created temporal event DAG with {event_graph.n} nodes and {event_graph.m} edges\")\n\n    # run disjktra for all source nodes\n    dist, pred = dijkstra(\n        m, directed=True, indices=np.arange(g.m, g.m + g.n), return_predecessors=True, unweighted=True\n    )\n\n    # limit to first-order destinations and correct distances\n    dist_fo = dist[:, g.m + g.n :] - 1\n    np.fill_diagonal(dist_fo, 0)\n\n    # limit to first-order destinations and correct predecessors\n    pred_fo = pred[:, g.n + g.m :]\n    pred_fo[pred_fo == -9999] = -1\n    idx_map = np.concatenate([to_numpy(g.data.edge_index[0].cpu()), [-1]])\n    pred_fo = idx_map[pred_fo]\n    np.fill_diagonal(pred_fo, np.arange(g.n))\n\n    return dist_fo, pred_fo\n</code></pre>"},{"location":"reference/pathpyG/algorithms/weisfeiler_leman/","title":"weisfeiler_leman","text":"<p>\"Weisfeiler-Leman isomorphism test algorithm implementation.</p>"},{"location":"reference/pathpyG/algorithms/weisfeiler_leman/#pathpyG.algorithms.weisfeiler_leman.WeisfeilerLeman_test","title":"<code>WeisfeilerLeman_test</code>","text":"<p>Run Weisfeiler-Leman isomorphism test on two graphs.</p> <p>The algorithm heuristically checks whether two graphs are isomorphic. If it returns False, we can be sure that the graphs are non-isomoprhic. If the test returns True we did not find conclusive evidence that they are not isomorphic, i.e. the graphs may or may not be isomophic.</p> <p>The two graphs must have IndexMap mappings that assign different node IDs to the nodes in both graphs. The function will raise an error if the node labels of both graphs overlap.</p> <p>The function returns a tuple (bool, list, list), where the first entry is the result of the test and the two lists represent the fingerprints of the two graphs. If the test yields true the fingerprints are identical. If the test fails, the fingerprints do not correspond.</p> <p>Parameters:</p> Name Type Description Default <code>g1</code> <code>pathpyG.core.graph.Graph</code> <p>First graph.</p> required <code>g2</code> <code>pathpyG.core.graph.Graph</code> <p>Second graph.</p> required <code>features_g1</code> <code>dict | None</code> <p>Optional initial node features for graph 1.</p> <code>None</code> <code>features_g2</code> <code>dict | None</code> <p>Optional initial node features for graph 2.</p> <code>None</code> Source code in <code>src/pathpyG/algorithms/weisfeiler_leman.py</code> <pre><code>def WeisfeilerLeman_test(\n    g1: Graph, g2: Graph, features_g1: dict | None = None, features_g2: dict | None = None\n) -&gt; Tuple[bool, List[str], List[str]]:\n    \"\"\"Run Weisfeiler-Leman isomorphism test on two graphs.\n\n    The algorithm heuristically checks whether two graphs are isomorphic. If it returns False,\n    we can be sure that the graphs are non-isomoprhic. If the test returns True we did not find\n    conclusive evidence that they are not isomorphic, i.e. the graphs may or may not be isomophic.\n\n    The two graphs must have IndexMap mappings that assign different node IDs to the nodes\n    in both graphs. The function will raise an error if the node labels of both graphs overlap.\n\n    The function returns a tuple (bool, list, list), where the first entry is the result of the test\n    and the two lists represent the fingerprints of the two graphs. If the test yields true the fingerprints\n    are identical. If the test fails, the fingerprints do not correspond.\n\n    Args:\n        g1: First graph.\n        g2: Second graph.\n        features_g1: Optional initial node features for graph 1.\n        features_g2: Optional initial node features for graph 2.\n    \"\"\"\n    if g1.mapping is None or g2.mapping is None:\n        raise Exception(\"Graphs must contain IndexMap that assigns node IDs\")\n    if len(set(g1.mapping.node_ids).intersection(g2.mapping.node_ids)) &gt; 0:  # type: ignore[arg-type]\n        raise Exception(\"node identifiers of graphs must not overlap\")\n    g_combined = g1 + g2\n    # initialize labels of all nodes to zero\n    if features_g1 is None or features_g2 is None:\n        fingerprint: Dict[str | int, str] = {v: \"0\" for v in g_combined.nodes}\n    else:\n        fingerprint = features_g1.copy()\n        fingerprint.update(features_g2)\n    labels = {}\n    label_count = 1\n    stop = False\n    while not stop:\n        new_fingerprint = {}\n        for node in g_combined.nodes:\n            # create new label based on own label and sorted labels of all neighbors\n            n_label = [fingerprint[x] for x in g_combined.successors(node)]\n            n_label.sort()\n            label = str(fingerprint[node]) + str(n_label)\n            # previously unknown label\n            if label not in labels:\n                # create a new label based on next consecutive number\n                labels[label] = label_count\n                label_count += 1\n            new_fingerprint[node] = labels[label]\n        if len(set(fingerprint.values())) == len(set(new_fingerprint.values())):\n            # we processed all nodes in both graphs without encountering a new label, so we stop\n            stop = True\n        else:\n            # update fingerprint and continue\n            fingerprint = new_fingerprint.copy()  # type: ignore[assignment]\n\n    # Reduce fingerprints to nodes of g1 and g2 respectively\n    fingerprint_1 = [fingerprint[v] for v in g1.nodes]\n    fingerprint_1_sorted = fingerprint_1.copy()\n    fingerprint_1_sorted.sort()\n    fingerprint_2 = [fingerprint[v] for v in g2.nodes]\n    fingerprint_2_sorted = fingerprint_2.copy()\n    fingerprint_2_sorted.sort()\n\n    # perform WL-test\n    if fingerprint_1_sorted == fingerprint_2_sorted:\n        return True, fingerprint_1, fingerprint_2\n    return False, fingerprint_1, fingerprint_2\n</code></pre>"},{"location":"reference/pathpyG/core/","title":"core","text":"<p>Core classes for (temporal) graphs, paths, and higher-order De Bruijn graphs.</p> <p>The classes in the <code>core</code> module can be used to implement integrated pipelines to preprocess time-stamped network data, do inference and model selection of higher-order De Bruijn graph models and address temporal graph learning tasks based on time-aware graph neural networks.</p> Example <pre><code>import pathpyG as pp\n\n# Generate toy example temporal graph\ng = pp.TemporalGraph.from_edge_list([\n    ('b', 'c', 2),\n    ('a', 'b', 1),\n    ('c', 'd', 3),\n    ('d', 'a', 4),\n    ('b', 'd', 2),\n    ('d', 'a', 6),\n    ('a', 'b', 7)],\n    device='cuda'\n)\n\n# Create Multi-Order model that models time-respecting paths\nm = pp.MultiOrderModel.from_temporal_graph(g, delta=1, max_order=3)\nprint(m.layers[1])\nprint(m.layers[2])\nprint(m.layers[3])\n</code></pre>"},{"location":"reference/pathpyG/core/graph/","title":"graph","text":"<p>Graph module of pathpyG core package.</p>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph","title":"<code>Graph</code>","text":"<p>A graph object storing nodes, edges, and attributes.</p> <p>An object than be be used to store directed or undirected graphs with node and edge attributes. Data on nodes and edges are stored in an underlying instance of <code>torch_geometric.data.Data</code>.</p> Info <p>The <code>data</code> attribute is a PyG Data object that contains the following attributes:</p> <ul> <li><code>edge_index</code>: Edge index of the graph. Entries correspond to indices in the node sequence.</li> <li><code>node_sequence</code>: Node sequence tensor of shape <code>(num_nodes, order)</code> where each entry     corresponds to the index of first-order nodes in the underlying graph and mapping. For first-order graphs,     the indices in the node sequence is identical to the indices in the edge index. For higher-order graphs,     the node sequence contains tuples of node indices representing higher-order nodes that correspond to paths in     the underlying first-order graph.</li> </ul> <p>Attributes:</p> Name Type Description <code>data</code> <code>torch_geometric.data.Data</code> <p>PyG Data object containing edges and attributes.</p> <code>mapping</code> <code>pathpyG.core.index_map.IndexMap</code> <p>Mapping from node IDs to indices.</p> <code>edge_to_index</code> <code>dict</code> <p>Mapping from edge tuples to their indices.</p> <code>row_ptr</code> <code>torch.Tensor</code> <p>CSR row pointer for efficient successor retrieval.</p> <code>col</code> <code>torch.Tensor</code> <p>CSR column indices for efficient successor retrieval.</p> <code>col_ptr</code> <code>torch.Tensor</code> <p>CSC column pointer for efficient predecessor retrieval.</p> <code>row</code> <code>torch.Tensor</code> <p>CSC row indices for efficient predecessor retrieval.</p> Source code in <code>src/pathpyG/core/graph.py</code> <pre><code>class Graph:\n    \"\"\"A graph object storing nodes, edges, and attributes.\n\n    An object than be be used to store directed or undirected graphs with node\n    and edge attributes. Data on nodes and edges are stored in an underlying instance of\n    [`torch_geometric.data.Data`][torch_geometric.data.Data].\n\n    Info:\n        The `data` attribute is a PyG Data object that contains the following attributes:\n\n        - `edge_index`: [Edge index][torch_geometric.EdgeIndex] of the graph. Entries correspond to indices in the node sequence.\n        - `node_sequence`: Node sequence [tensor][torch.Tensor] of shape `(num_nodes, order)` where each entry\n            corresponds to the index of first-order nodes in the underlying graph and mapping. For first-order graphs,\n            the indices in the node sequence is identical to the indices in the edge index. For higher-order graphs,\n            the node sequence contains tuples of node indices representing higher-order nodes that correspond to paths in\n            the underlying first-order graph.\n\n    Attributes:\n        data (Data): PyG Data object containing edges and attributes.\n        mapping (IndexMap): Mapping from node IDs to indices.\n        edge_to_index (dict): Mapping from edge tuples to their indices.\n        row_ptr (torch.Tensor): CSR row pointer for efficient successor retrieval.\n        col (torch.Tensor): CSR column indices for efficient successor retrieval.\n        col_ptr (torch.Tensor): CSC column pointer for efficient predecessor retrieval.\n        row (torch.Tensor): CSC row indices for efficient predecessor retrieval.\n    \"\"\"\n\n    def __init__(self, data: Data, mapping: Optional[IndexMap] = None):\n        \"\"\"Generate graph instance from a pyG `Data` object.\n\n        Generate a Graph instance from a `torch_geometric.Data` object that contains an EdgeIndex as well as\n        optional node-, edge- or graph-level attributes. An optional mapping can be used to transparently map\n        node indices to string identifiers.\n\n        Args:\n            data: A pyG Data object containing an EdgeIndex and additional attributes\n            mapping: `IndexMap` object that maps node indices to string identifiers\n\n        Example:\n            ```py\n            import pathpyG as pp\n            from torch_geometric.data import Data\n            from torch_geometric import EdgeIndex\n\n            data = Data(edge_index=EdgeIndex([[1, 1, 2], [0, 2, 1]], sparse_size=(3, 3)))\n            g = pp.Graph(data)\n\n            g = pp.Graph(data, mapping=pp.IndexMap([\"a\", \"b\", \"c\"]))\n            ```\n        \"\"\"\n        if mapping is None:\n            self.mapping = IndexMap()\n        else:\n            self.mapping = mapping\n\n        # set num_nodes property\n        if \"num_nodes\" not in data and \"edge_index\" in data:\n            data.num_nodes = data.edge_index.max().item() + 1\n            logger.debug(\"Inferred number of nodes from edge_index, n = %s\", data.num_nodes)\n\n        # turn edge index tensor into EdgeIndex object\n        if not isinstance(data.edge_index, EdgeIndex):\n            data.edge_index = EdgeIndex(data=data.edge_index, sparse_size=(data.num_nodes, data.num_nodes))\n\n        if (\n            data.edge_index.get_sparse_size(dim=0) != data.num_nodes\n            or data.edge_index.get_sparse_size(dim=1) != data.num_nodes\n        ):\n            logger.error(\"Sparse size of edge_index does not match number of nodes, n = %s\", data.num_nodes)\n            raise ValueError(\"sparse size of EdgeIndex must match number of nodes!\")\n\n        self.data = data\n\n        # sort EdgeIndex and validate\n        data.edge_index, sorted_idx = data.edge_index.sort_by(\"row\")\n        for edge_attr in self.edge_attrs():\n            data[edge_attr] = self.data[edge_attr][sorted_idx]\n\n        data.edge_index.validate()\n\n        # create mapping between edge tuples and edge indices\n        self.edge_to_index = {\n            (e[0].item(), e[1].item()): i for i, e in enumerate([e for e in self.data.edge_index.t()])\n        }\n\n        ((self.row_ptr, self.col), _) = self.data.edge_index.get_csr()\n        ((self.col_ptr, self.row), _) = self.data.edge_index.get_csc()\n\n        # create node_sequence mapping for higher-order graphs\n        if \"node_sequence\" not in self.data:\n            self.data.node_sequence = torch.arange(data.num_nodes).reshape(-1, 1)\n\n    @staticmethod\n    def from_edge_index(\n        edge_index: torch.Tensor, mapping: Optional[IndexMap] = None, num_nodes: int | None = None\n    ) -&gt; Graph:\n        \"\"\"Construct a graph from a [Tensor][torch.Tensor] containing an edge index.\n\n        An optional mapping can be used to transparently map node indices to string identifiers.\n\n        Args:\n            edge_index:  torch.Tensor or torch_geometric.EdgeIndex object containing an edge_index\n            mapping: `IndexMap` object that maps node indices to string identifiers\n            num_nodes: optional number of nodes (default: None). If None, the number of nodes will be\n                inferred based on the maximum node index in the edge index, i.e. there will be no isolated nodes.\n\n        Examples:\n            You can create a graph from an edge index tensor as follows:\n\n            &gt;&gt;&gt; import torch\n            &gt;&gt;&gt; import pathpyG as pp\n            &gt;&gt;&gt; g = pp.Graph.from_edge_index(torch.LongTensor([[1, 1, 2], [0, 2, 1]]))\n            &gt;&gt;&gt; print(g)\n            Directed graph with 3 nodes and 3 edges ...\n\n            You can also include a mapping of node IDs:\n\n            &gt;&gt;&gt; g = pp.Graph.from_edge_index(torch.LongTensor([[1, 1, 2], [0, 2, 1]]),\n            ...                              mapping=pp.IndexMap(['a', 'b', 'c']))\n            &gt;&gt;&gt; print(g.mapping)\n            a -&gt; 0\n            b -&gt; 1\n            c -&gt; 2\n        \"\"\"\n        if not num_nodes:\n            d = Data(edge_index=edge_index)\n        else:\n            if mapping is not None and mapping.num_ids() != num_nodes:\n                logger.error(\"Number of node IDs in mapping must match num_nodes\")\n                raise ValueError(\"Number of node IDs in mapping must match num_nodes\")\n            d = Data(edge_index=edge_index, num_nodes=num_nodes)\n        return Graph(d, mapping=mapping)\n\n    @staticmethod\n    def from_edge_list(\n        edge_list: Iterable[Tuple[str, str]],\n        is_undirected: bool = False,\n        mapping: Optional[IndexMap] = None,\n        device: Optional[torch.device] = None,\n    ) -&gt; Graph:\n        \"\"\"Generate a Graph based on an edge list.\n\n        Edges can be given as string or integer tuples. If strings are used and no mapping is given,\n        a mapping of node IDs to indices will be automatically created based on a lexicographic ordering of\n        node IDs.\n\n        Args:\n            edge_list: Iterable of edges represented as tuples\n            is_undirected: Whether the edge list contains all bidorectional edges\n            mapping: optional mapping of string IDs to node indices\n            device: optional torch device where tensors shall be stored\n\n        Examples:\n            &gt;&gt;&gt; import pathpyG as pp\n            &gt;&gt;&gt; l = [(\"a\", \"b\"), (\"a\", \"c\"), (\"b\", \"c\")]\n            &gt;&gt;&gt; g = pp.Graph.from_edge_list(l)\n            &gt;&gt;&gt; print(list(g.edges))\n            [('a', 'b'), ('a', 'c'), ('b', 'c')]\n        \"\"\"\n        # handle empty graph\n        if len(edge_list) == 0:  # type: ignore[arg-type]\n            return Graph(\n                Data(edge_index=torch.tensor([[], []], dtype=torch.int32, device=device), num_nodes=0),\n                mapping=IndexMap(),\n            )\n\n        if mapping is None:\n            edge_array = np.array(edge_list)\n            node_ids = np.unique(edge_array)\n            if np.issubdtype(node_ids.dtype, str) and np.char.isnumeric(node_ids).all():\n                node_ids = np.sort(node_ids.astype(int)).astype(str)\n            mapping = IndexMap(node_ids)\n\n        num_nodes = mapping.num_ids()\n\n        edge_index = EdgeIndex(\n            mapping.to_idxs(edge_list, device=device).T.contiguous(),  # type: ignore[arg-type]\n            sparse_size=(num_nodes, num_nodes),\n            is_undirected=is_undirected,\n        )\n        return Graph(Data(edge_index=edge_index, num_nodes=num_nodes), mapping=mapping)\n\n    def to_undirected(self) -&gt; Graph:\n        \"\"\"Return an undirected version of this directed graph.\n\n        This method creates a new undirected Graph from the current graph instance by\n        adding all directed edges in opposite direction.\n\n        Examples:\n            &gt;&gt;&gt; import pathpyG as pp\n            &gt;&gt;&gt; g = pp.Graph.from_edge_list([(\"a\", \"b\"), (\"b\", \"c\"), (\"c\", \"a\")])\n            &gt;&gt;&gt; g_u = g.to_undirected()\n            &gt;&gt;&gt; print(g_u)\n            Undirected graph with 3 nodes and 3 edges\n            {'Edge Attributes': {}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\n        \"\"\"\n        # create undirected edge index by coalescing the directed edges and keep\n        # track of the original edge index for the edge attributes\n        attr_idx = torch.arange(self.data.num_edges, device=self.data.edge_index.device)\n        edge_index, attr_idx = to_undirected(\n            self.data.edge_index,\n            edge_attr=attr_idx,\n            num_nodes=self.data.num_nodes,\n            reduce=\"min\",\n        )\n\n        data = Data(\n            edge_index=EdgeIndex(\n                data=edge_index, sparse_size=(self.data.num_nodes, self.data.num_nodes), is_undirected=True\n            ),\n            num_nodes=self.data.num_nodes,\n        )\n        # Note that while the torch_geometric.transforms.ToUndirected function would do this automatically,\n        # we do it manually since the transform cannot handle numpy arrays as edge attributes.\n        # make sure to copy all node and (undirected) edge attributes\n        for node_attr in self.node_attrs():\n            data[node_attr] = self.data[node_attr]\n        for edge_attr in self.edge_attrs():\n            if edge_attr != \"edge_index\":\n                data[edge_attr] = self.data[edge_attr][attr_idx]\n\n        return Graph(data, self.mapping)\n\n    def to_weighted_graph(self) -&gt; Graph:\n        \"\"\"Coalesces multi-edges to single-edges with an additional weight attribute.\n\n        If the graph contains multiple edges between the same nodes, this method will coalesce\n        them into a single edge with an additional weight attribute called `edge_weight` that\n        contains the number of coalesced edges. The method returns a new graph instance with\n        the coalesced edges.\n\n        Returns:\n            Graph: Graph with coalesced edges\n        \"\"\"\n        i, w = torch_geometric.utils.coalesce(\n            self.data.edge_index.as_tensor(), torch.ones(self.m, device=self.data.edge_index.device)\n        )\n        return Graph(Data(edge_index=i, edge_weight=w, num_nodes=self.data.num_nodes), mapping=self.mapping)\n\n    @property\n    def device(self) -&gt; torch.device:\n        \"\"\"Return the device on which the graph is stored.\"\"\"\n        return self.data.edge_index.device\n\n    def to(self, device: torch.device) -&gt; Graph:\n        \"\"\"Move all tensors to the given device.\n\n        Args:\n            device: torch device to which all tensors shall be moved\n\n        Returns:\n            Graph: self\n        \"\"\"\n        self.data.edge_index = self.data.edge_index.to(device)\n        self.data.node_sequence = self.data.node_sequence.to(device)\n        for attr in self.node_attrs():\n            if isinstance(self.data[attr], torch.Tensor):\n                self.data[attr] = self.data[attr].to(device)\n        for attr in self.edge_attrs():\n            if isinstance(self.data[attr], torch.Tensor):\n                self.data[attr] = self.data[attr].to(device)\n\n        self.row = self.row.to(device)\n        self.row_ptr = self.row_ptr.to(device)\n        self.col = self.col.to(device)\n        self.col_ptr = self.col_ptr.to(device)\n\n        return self\n\n    def node_attrs(self) -&gt; List[str]:\n        \"\"\"Return a list of node attributes.\n\n        This method returns a list containing the names of all node-level attributes,\n        ignoring the special `node_sequence` attribute.\n\n        Returns:\n            list: list of node attributes\n        \"\"\"\n        attrs = []\n        for k in self.data.keys():\n            if k != \"node_sequence\" and k.startswith(\"node_\"):\n                attrs.append(k)\n        return attrs\n\n    def edge_attrs(self) -&gt; List[str]:\n        \"\"\"Return a list of edge attributes.\n\n        This method returns a list containing the names of all edge-level attributes,\n        ignoring the special `edge_index` attribute.\n\n        Returns:\n            list: list of edge attributes\n        \"\"\"\n        attrs = []\n        for k in self.data.keys():\n            if k != \"edge_index\" and k.startswith(\"edge_\"):\n                attrs.append(k)\n        return attrs\n\n    @property\n    def nodes(self) -&gt; list:\n        \"\"\"Return indices or IDs of all nodes in the graph.\n\n        This method returns a list object that contains all nodes.\n        If an IndexMap is used, nodes are returned as string IDs.\n        If no IndexMap is used, nodes are returned as integer indices.\n\n        Returns:\n            list: list of all nodes using IDs or indices (if no mapping is used)\n        \"\"\"\n        node_list = self.mapping.to_ids(np.arange(self.n)).tolist()\n        if self.order &gt; 1:\n            return list(map(tuple, node_list))\n        return node_list\n\n    @property\n    def edges(self) -&gt; list:\n        \"\"\"Return all edges in the graph.\n\n        This method returns a list object that contains all edges, where each\n        edge is a tuple of two elements. If an IndexMap is used to map node\n        indices to string IDs, edges are returned as tuples of string IDs.\n        If no mapping is used, edges are returned as tuples of integer indices.\n\n        Returns:\n            list: list object yielding all edges using IDs or indices (if no mapping is used)\n        \"\"\"\n        edge_list = self.mapping.to_ids(self.data.edge_index.t()).tolist()\n        if self.order &gt; 1:\n            return [tuple(map(tuple, x)) for x in edge_list]\n        return list(map(tuple, edge_list))\n\n    def get_successors(self, row_idx: int) -&gt; torch.Tensor:\n        \"\"\"Return a tensor containing the indices of all successor nodes for a given node identified by an index.\n\n        Args:\n            row_idx:   Index of node for which predecessors shall be returned.\n\n        Returns:\n            tensor: tensor containing indices of all successor nodes of the node indexed by `row_idx`\n        \"\"\"\n        if row_idx + 1 &lt; self.row_ptr.size(0):\n            row_start = self.row_ptr[row_idx]\n            row_end = self.row_ptr[row_idx + 1]\n            return self.col[row_start:row_end]\n        else:\n            return torch.tensor([], device=self.data.edge_index.device)\n\n    def get_predecessors(self, col_idx: int) -&gt; torch.Tensor:\n        \"\"\"Return a tensor containing the indices of all predecessor nodes for a given node identified by an index.\n\n        Args:\n            col_idx:   Index of node for which predecessors shall be returned.\n\n        Returns:\n            tensor: tensor containing indices of all predecessor nodes of the node indexed by `col_idx`\n        \"\"\"\n        if col_idx + 1 &lt; self.col_ptr.size(0):\n            col_start = self.col_ptr[col_idx]\n            col_end = self.col_ptr[col_idx + 1]\n            return self.row[col_start:col_end]\n        else:\n            return torch.tensor([], device=self.data.edge_index.device)\n\n    def successors(self, node: Union[int, str] | tuple) -&gt; list:\n        \"\"\"Return all successors of a given node.\n\n        This method returns a generator object that yields all successors of a\n        given node. If an IndexMap is used, successors are returned\n        as string IDs. If no mapping is used, successors are returned as indices.\n\n        Args:\n            node:   Index or string ID of node for which successors shall be returned.\n\n        Returns:\n            list: list with all successors of the node identified\n                by `node` using ID or index (if no mapping is used)\n        \"\"\"\n        node_list = self.mapping.to_ids(self.get_successors(self.mapping.to_idx(node))).tolist()  # type: ignore\n\n        if self.order &gt; 1:\n            return list(map(tuple, node_list))\n        return node_list\n\n    def predecessors(self, node: Union[str, int] | tuple) -&gt; list:\n        \"\"\"Return the predecessors of a given node.\n\n        This method returns a generator object that yields all predecessors of a\n        given node. If a `node_id` mapping is used, predecessors will be returned\n        as string IDs. If no mapping is used, predecessors are returned as indices.\n\n        Args:\n            node:   Index or string ID of node for which predecessors shall be returned.\n\n        Returns:\n            list: list with all predecessors of the node identified\n                by `node` using ID or index (if no mapping is used)\n        \"\"\"\n        node_list = self.mapping.to_ids(self.get_predecessors(self.mapping.to_idx(node))).tolist()  # type: ignore\n\n        if self.order &gt; 1:\n            return list(map(tuple, node_list))\n        return node_list\n\n    def is_edge(self, v: Union[str, int], w: Union[str, int]) -&gt; bool:\n        \"\"\"Return whether edge $(v,w)$ exists in the graph.\n\n        If an index to ID mapping is used, nodes are assumed to be string IDs. If no\n        mapping is used, nodes are assumed to be integer indices.\n\n        Args:\n            v: source node of edge as integer index or string ID\n            w: target node of edge as integer index or string ID\n\n        Returns:\n            bool: True if edge exists, False otherwise\n        \"\"\"\n        row = self.mapping.to_idx(v)\n        row_start = self.row_ptr[row]\n        row_end = self.row_ptr[row + 1]  # type: ignore[operator]\n\n        return self.mapping.to_idx(w) in self.col[row_start:row_end]\n\n    def sparse_adj_matrix(self, edge_attr: Any = None) -&gt; Any:\n        \"\"\"Return sparse adjacency matrix representation of (weighted) graph.\n\n        Args:\n            edge_attr: the edge attribute that shall be used as edge weight\n\n        Returns:\n            scipy.sparse.coo_matrix: sparse adjacency matrix representation of graph\n        \"\"\"\n        if edge_attr is None:\n            return torch_geometric.utils.to_scipy_sparse_matrix(self.data.edge_index.as_tensor(), num_nodes=self.n)\n        else:\n            return torch_geometric.utils.to_scipy_sparse_matrix(\n                self.data.edge_index.as_tensor(), edge_attr=self.data[edge_attr], num_nodes=self.n\n            )\n\n    @property\n    def in_degrees(self) -&gt; Dict[str, float]:\n        \"\"\"Return unweighted in-degrees of nodes in directed network.\n\n        Returns:\n            dict: dictionary containing in-degrees of nodes\n        \"\"\"\n        return self.degrees(mode=\"in\")  # type: ignore[return-value]\n\n    @property\n    def out_degrees(self) -&gt; Dict[str, float]:\n        \"\"\"Return unweighted out-degrees of nodes in directed network.\n\n        Returns:\n            dict: dictionary containing out-degrees of nodes\n        \"\"\"\n        return self.degrees(mode=\"out\")  # type: ignore[return-value]\n\n    def degrees(\n        self, mode: str = \"in\", edge_attr: str | None = None, return_tensor: bool = False\n    ) -&gt; Union[Dict[str, float], torch.Tensor]:\n        \"\"\"Return (weighted) degrees of nodes.\n\n        Args:\n            mode: `in` or `out` to calculate in- or out-degree for\n                directed networks.\n            edge_attr: Optional numerical edge attribute that will\n                be used to compute weighted degrees\n            return_tensor: if True the function returns a degree tensor, if False (default)\n                a dictionary will be returned that can be indexed by nodes\n        Returns:\n            dict: dictionary containing node degrees\n        \"\"\"\n        if mode == \"in\":\n            if not edge_attr:\n                d = torch_geometric.utils.degree(self.data.edge_index[1], num_nodes=self.n, dtype=torch.int)\n            else:\n                edge_weight = getattr(self.data, edge_attr, None)\n                d = scatter(edge_weight, self.data.edge_index[1], dim=0, dim_size=self.data.num_nodes, reduce=\"sum\")\n        else:\n            if not edge_attr:\n                d = torch_geometric.utils.degree(self.data.edge_index[0], num_nodes=self.n, dtype=torch.int)\n            else:\n                edge_weight = getattr(self.data, edge_attr, None)\n                d = scatter(edge_weight, self.data.edge_index[0], dim=0, dim_size=self.data.num_nodes, reduce=\"sum\")\n        if return_tensor:\n            return d\n        else:\n            return {str(self.mapping.to_id(i)): d[i].item() for i in range(self.n)}\n\n    def transition_probabilities(self, edge_attr: str | None = None) -&gt; torch.Tensor:\n        \"\"\"Compute transition probabilities based on (weighted) outdegrees.\n\n        Args:\n            edge_attr: Optional name of numerical edge attribute that will\n               be used to calculate weighted out-degrees for the visitation probabilities.\n\n        Returns:\n            tensor: Transition probabilities.\n        \"\"\"\n        weighted_outdegree = self.degrees(mode=\"out\", edge_attr=edge_attr, return_tensor=True)\n        source_ids = self.data.edge_index[0]\n        edge_weight = torch.ones(self.data.num_edges, device=self.data.edge_index.device)\n        if edge_attr is not None:\n            edge_weight = getattr(self.data, edge_attr, None)  # type: ignore[assignment]\n        return edge_weight / weighted_outdegree[source_ids]\n\n    def laplacian(self, normalization: Any = None, edge_attr: str | None = None) -&gt; Any:\n        \"\"\"Return Laplacian matrix for a given graph.\n\n        This wrapper method will use [`torch_geometric.utils.get_laplacian`][torch_geometric.utils.get_laplacian]\n        to return a Laplcian matrix representation of a given graph.\n\n        Args:\n            normalization: normalization parameter passed to pyG `get_laplacian`\n                function\n            edge_attr: optinal name of numerical edge attribute that shall\n                be passed to pyG `get_laplacian` function as edge weight\n\n        Returns:\n            scipy.sparse.coo_matrix: Laplacian matrix representation of graph\n        \"\"\"\n        if edge_attr is None:\n            index, weight = torch_geometric.utils.get_laplacian(\n                self.data.edge_index.as_tensor(), normalization=normalization\n            )\n            return torch_geometric.utils.to_scipy_sparse_matrix(index, weight)\n        else:\n            index, weight = torch_geometric.utils.get_laplacian(\n                self.data.edge_index.as_tensor(),\n                normalization=normalization,\n                edge_weight=self.data[edge_attr],\n            )\n            return torch_geometric.utils.to_scipy_sparse_matrix(index, weight)\n\n    def __getitem__(self, key: Union[tuple, str]) -&gt; Any:\n        \"\"\"Return node, edge, or graph attribute.\n\n        Args:\n            key: name of attribute to be returned\n        \"\"\"\n        if not isinstance(key, tuple):\n            if key in self.data.keys():\n                return self.data[key]\n            else:\n                raise KeyError(key + \" is not a graph attribute\")\n        elif key[0] in self.node_attrs():\n            return self.data[key[0]][self.mapping.to_idx(key[1])]\n        elif key[0] in self.edge_attrs():\n            return self.data[key[0]][self.edge_to_index[self.mapping.to_idx(key[1]), self.mapping.to_idx(key[2])]]\n        else:\n            raise KeyError(key[0] + \" is not a node or edge attribute\")\n\n    def __setitem__(self, key: str, val: torch.Tensor) -&gt; None:\n        \"\"\"Store node, edge, or graph attribute.\n\n        Args:\n            key: name of attribute to be stored\n            val: value of attribute\n        \"\"\"\n        if not isinstance(key, tuple):\n            if key.startswith(\"node_\"):\n                if val.size(0) != self.n:\n                    raise ValueError(\"Attribute must have same length as number of nodes\")\n                self.data[key] = val\n            elif key.startswith(\"edge_\"):\n                if val.size(0) != self.m:\n                    raise ValueError(\"Attribute must have same length as number of edges\")\n                self.data[key] = val\n            else:\n                self.data[key] = val\n        elif key[0].startswith(\"node_\"):\n            if key[0] not in self.data.keys():\n                raise KeyError(\n                    \"Attribute does not yet exist. Setting the value of a specific node attribute\"\n                    + \"requires that the attribute already exists.\"\n                )\n            self.data[key[0]][self.mapping.to_idx(key[1])] = val\n        elif key[0].startswith(\"edge_\"):\n            if key[0] not in self.data.keys():\n                raise KeyError(\n                    \"Attribute does not yet exist. Setting the value of a specific node attribute\"\n                    + \"requires that the attribute already exists.\"\n                )\n            self.data[key[0]][self.edge_to_index[self.mapping.to_idx(key[1]), self.mapping.to_idx(key[2])]] = val\n        else:\n            raise KeyError(\"node and edge specific attributes should be prefixed with 'node_' or 'edge_'\")\n\n    @property\n    def n(self) -&gt; int:\n        \"\"\"Return number of nodes.\n\n        Returns:\n            int: number of nodes in the graph\n        \"\"\"\n        return self.data.num_nodes\n\n    @property\n    def m(self) -&gt; int:\n        \"\"\"Return number of edges.\n\n        Returns the number of edges in the graph. For an undirected graph, the number of\n        undirected edges (accounting for self-loops) is returned, i.e. in an undirected\n        graph the directed edges (a,b) and (b,a) will be counted only once.\n\n        Returns:\n            int: number of edges in the graph\n        \"\"\"\n        if self.is_directed():\n            return self.data.num_edges\n        else:\n            num_self_loops = (self.data.edge_index[0] == self.data.edge_index[1]).sum().item()\n            num_edges_wo_self_loops = self.data.edge_index.size(1) - int(num_self_loops)\n            return int(num_edges_wo_self_loops / 2 + num_self_loops)\n\n    @property\n    def order(self) -&gt; int:\n        \"\"\"Return order of graph.\n\n        Returns:\n            int: order of the (De Bruijn) graph\n        \"\"\"\n        return self.data.node_sequence.size(1)\n\n    def is_directed(self) -&gt; bool:\n        \"\"\"Return whether graph is directed.\n\n        Returns:\n            bool: True if graph is directed, False otherwise\n        \"\"\"\n        return not self.data.edge_index.is_undirected\n\n    def is_undirected(self) -&gt; bool:\n        \"\"\"Return whether graph is undirected.\n\n        Returns:\n            bool: True if graph is undirected, False otherwise\n        \"\"\"\n        return self.data.edge_index.is_undirected\n\n    def has_self_loops(self) -&gt; bool:\n        \"\"\"Return whether graph contains self-loops.\n\n        Returns:\n            bool: True if graph contains self-loops, False otherwise\n        \"\"\"\n        return self.data.has_self_loops()\n\n    def __add__(self, other: Graph, reduce: str = \"sum\") -&gt; Graph:\n        \"\"\"Combine Graph object with other Graph object.\n\n        The semantics of this operation depends on the optional IndexMap\n        of both graphs. If no IndexMap is included, the two underlying data objects\n        are concatenated, thus merging edges from both graphs while leaving node indices\n        unchanged. If both graphs include IndexMaps that assign node IDs to indices,\n        indices will be adjusted, creating a new mapping for the union of node Ids in both graphs.\n\n        Node IDs of graphs to be combined can be disjoint, partly overlapping or non-overlapping.\n\n        Args:\n            other: Other graph to be combined with this graph\n            reduce: Reduction method for node attributes of nodes that are present in both graphs.\n                Can be one of \"sum\", \"mean\", \"mul\", \"min\", \"max\". Default is \"sum\".\n\n        Examples:\n            Adding two graphs without node IDs:\n\n            &gt;&gt;&gt; import pathpyG as pp\n            &gt;&gt;&gt; g1 = pp.Graph.from_edge_index(torch.tensor([[0, 1, 1], [1, 2, 3]]))\n            &gt;&gt;&gt; g2 = pp.Graph.from_edge_index(torch.tensor([[0, 2, 3], [3, 2, 1]]))\n            &gt;&gt;&gt; print(g1 + g2)\n            Directed graph with 4 nodes and 6 edges\n            {   'Edge Attributes': {},\n                'Graph Attributes': {'node_sequence': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([8, 1])\", 'num_nodes': \"&lt;class 'int'&gt;\"},\n                'Node Attributes': {}}\n\n            Adding two graphs with identical node IDs:\n\n            &gt;&gt;&gt; g1 = pp.Graph.from_edge_list([(\"a\", \"b\"), (\"b\", \"c\")])\n            &gt;&gt;&gt; g2 = pp.Graph.from_edge_list([(\"a\", \"c\"), (\"c\", \"b\")])\n            &gt;&gt;&gt; print(g1 + g2)\n            Directed graph with 3 nodes and 4 edges\n            {   'Edge Attributes': {},\n                'Graph Attributes': {'node_sequence': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([6, 1])\", 'num_nodes': \"&lt;class 'int'&gt;\"},\n                'Node Attributes': {}}\n\n            Adding two graphs with non-overlapping node IDs:\n\n            &gt;&gt;&gt; g1 = pp.Graph.from_edge_list([(\"a\", \"b\"), (\"b\", \"c\")])\n            &gt;&gt;&gt; g2 = pp.Graph.from_edge_list([(\"c\", \"d\"), (\"d\", \"e\")])\n            &gt;&gt;&gt; print(g1 + g2)\n            Directed graph with 5 nodes and 4 edges\n            {   'Edge Attributes': {},\n                'Graph Attributes': {'node_sequence': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([6, 1])\", 'num_nodes': \"&lt;class 'int'&gt;\"},\n                'Node Attributes': {}}\n\n            Adding two graphs with partly overlapping node IDs:\n\n            &gt;&gt;&gt; g1 = pp.Graph.from_edge_list([(\"a\", \"b\"), (\"b\", \"c\")])\n            &gt;&gt;&gt; g2 = pp.Graph.from_edge_list([(\"b\", \"d\"), (\"d\", \"e\")])\n            &gt;&gt;&gt; print(g1 + g2)\n            Directed graph with 5 nodes and 4 edges\n            {   'Edge Attributes': {},\n                'Graph Attributes': {'node_sequence': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([6, 1])\", 'num_nodes': \"&lt;class 'int'&gt;\"},\n                'Node Attributes': {}}\n        \"\"\"\n        d1 = self.data.clone()\n        m1 = self.mapping\n\n        d2 = other.data.clone()\n        m2 = other.mapping\n\n        nodes = np.concatenate([m1.to_ids(np.arange(self.n)), m2.to_ids(np.arange(other.n))])\n        mapping = IndexMap(np.unique(nodes, axis=0).tolist())\n        d1.edge_index = mapping.to_idxs(m1.to_ids(d1.edge_index), device=d1.edge_index.device)\n        d2.edge_index = mapping.to_idxs(m2.to_ids(d2.edge_index), device=d2.edge_index.device)\n\n        d = d1.concat(d2)\n        d.num_nodes = mapping.num_ids()\n        d.edge_index = EdgeIndex(d.edge_index, sparse_size=(d.num_nodes, d.num_nodes))\n\n        # For higher-order graphs, we need to update the inverse_idx attribute\n        if \"inverse_idx\" in d:\n            d.inverse_idx = mapping.to_idxs(\n                np.concatenate([m1.to_ids(d1.inverse_idx), m2.to_ids(d2.inverse_idx)]),\n                device=d.inverse_idx.device,\n            )\n\n        # If both graphs contain node attributes, reduce them using the specified method\n        for k in d1.keys():\n            if k != \"node_sequence\" and k.startswith(\"node_\"):\n                if isinstance(d[k], torch.Tensor):\n                    d[k] = torch_geometric.utils.scatter(\n                        d[k],\n                        mapping.to_idxs(\n                            np.concatenate([m1.to_ids(np.arange(self.n)), m2.to_ids(np.arange(other.n))]),\n                            device=d[k].device,\n                        ),\n                        dim_size=d.num_nodes,\n                        reduce=reduce,\n                    )\n                else:\n                    raise ValueError(\"Node attribute \" + k + \" is not a tensor and cannot be reduced.\")\n        return Graph(d, mapping=mapping)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the graph.\"\"\"\n        attr = self.data.to_dict()\n        attr_types = {}\n        for k in attr:\n            t = type(attr[k])\n            if t == torch.Tensor:\n                attr_types[k] = str(t) + \" -&gt; \" + str(attr[k].size())\n            else:\n                attr_types[k] = str(t)\n\n        from pprint import pformat\n\n        if self.is_undirected():\n            s = \"Undirected graph with {0} nodes and {1} edges\\n\".format(self.n, self.m)\n        else:\n            s = \"Directed graph with {0} nodes and {1} edges\\n\".format(self.n, self.m)\n\n        attribute_info: dict[str, dict[str, str]] = {\n            \"Node Attributes\": {},\n            \"Edge Attributes\": {},\n            \"Graph Attributes\": {},\n        }\n        for a in self.node_attrs():\n            attribute_info[\"Node Attributes\"][a] = attr_types[a]\n        for a in self.edge_attrs():\n            attribute_info[\"Edge Attributes\"][a] = attr_types[a]\n        for a in self.data.keys():\n            if not self.data.is_node_attr(a) and not self.data.is_edge_attr(a):\n                attribute_info[\"Graph Attributes\"][a] = attr_types[a]\n        s += pformat(attribute_info, indent=4, width=160)\n        return s\n</code></pre>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.device","title":"<code>device</code>  <code>property</code>","text":"<p>Return the device on which the graph is stored.</p>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.edges","title":"<code>edges</code>  <code>property</code>","text":"<p>Return all edges in the graph.</p> <p>This method returns a list object that contains all edges, where each edge is a tuple of two elements. If an IndexMap is used to map node indices to string IDs, edges are returned as tuples of string IDs. If no mapping is used, edges are returned as tuples of integer indices.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list object yielding all edges using IDs or indices (if no mapping is used)</p>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.in_degrees","title":"<code>in_degrees</code>  <code>property</code>","text":"<p>Return unweighted in-degrees of nodes in directed network.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>typing.Dict[str, float]</code> <p>dictionary containing in-degrees of nodes</p>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.m","title":"<code>m</code>  <code>property</code>","text":"<p>Return number of edges.</p> <p>Returns the number of edges in the graph. For an undirected graph, the number of undirected edges (accounting for self-loops) is returned, i.e. in an undirected graph the directed edges (a,b) and (b,a) will be counted only once.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>number of edges in the graph</p>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.n","title":"<code>n</code>  <code>property</code>","text":"<p>Return number of nodes.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>number of nodes in the graph</p>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.nodes","title":"<code>nodes</code>  <code>property</code>","text":"<p>Return indices or IDs of all nodes in the graph.</p> <p>This method returns a list object that contains all nodes. If an IndexMap is used, nodes are returned as string IDs. If no IndexMap is used, nodes are returned as integer indices.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list of all nodes using IDs or indices (if no mapping is used)</p>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.order","title":"<code>order</code>  <code>property</code>","text":"<p>Return order of graph.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>order of the (De Bruijn) graph</p>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.out_degrees","title":"<code>out_degrees</code>  <code>property</code>","text":"<p>Return unweighted out-degrees of nodes in directed network.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>typing.Dict[str, float]</code> <p>dictionary containing out-degrees of nodes</p>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.__add__","title":"<code>__add__</code>","text":"<p>Combine Graph object with other Graph object.</p> <p>The semantics of this operation depends on the optional IndexMap of both graphs. If no IndexMap is included, the two underlying data objects are concatenated, thus merging edges from both graphs while leaving node indices unchanged. If both graphs include IndexMaps that assign node IDs to indices, indices will be adjusted, creating a new mapping for the union of node Ids in both graphs.</p> <p>Node IDs of graphs to be combined can be disjoint, partly overlapping or non-overlapping.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>pathpyG.core.graph.Graph</code> <p>Other graph to be combined with this graph</p> required <code>reduce</code> <code>str</code> <p>Reduction method for node attributes of nodes that are present in both graphs. Can be one of \"sum\", \"mean\", \"mul\", \"min\", \"max\". Default is \"sum\".</p> <code>'sum'</code> <p>Examples:</p> <p>Adding two graphs without node IDs:</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; g1 = pp.Graph.from_edge_index(torch.tensor([[0, 1, 1], [1, 2, 3]]))\n&gt;&gt;&gt; g2 = pp.Graph.from_edge_index(torch.tensor([[0, 2, 3], [3, 2, 1]]))\n&gt;&gt;&gt; print(g1 + g2)\nDirected graph with 4 nodes and 6 edges\n{   'Edge Attributes': {},\n    'Graph Attributes': {'node_sequence': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([8, 1])\", 'num_nodes': \"&lt;class 'int'&gt;\"},\n    'Node Attributes': {}}\n</code></pre> <p>Adding two graphs with identical node IDs:</p> <pre><code>&gt;&gt;&gt; g1 = pp.Graph.from_edge_list([(\"a\", \"b\"), (\"b\", \"c\")])\n&gt;&gt;&gt; g2 = pp.Graph.from_edge_list([(\"a\", \"c\"), (\"c\", \"b\")])\n&gt;&gt;&gt; print(g1 + g2)\nDirected graph with 3 nodes and 4 edges\n{   'Edge Attributes': {},\n    'Graph Attributes': {'node_sequence': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([6, 1])\", 'num_nodes': \"&lt;class 'int'&gt;\"},\n    'Node Attributes': {}}\n</code></pre> <p>Adding two graphs with non-overlapping node IDs:</p> <pre><code>&gt;&gt;&gt; g1 = pp.Graph.from_edge_list([(\"a\", \"b\"), (\"b\", \"c\")])\n&gt;&gt;&gt; g2 = pp.Graph.from_edge_list([(\"c\", \"d\"), (\"d\", \"e\")])\n&gt;&gt;&gt; print(g1 + g2)\nDirected graph with 5 nodes and 4 edges\n{   'Edge Attributes': {},\n    'Graph Attributes': {'node_sequence': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([6, 1])\", 'num_nodes': \"&lt;class 'int'&gt;\"},\n    'Node Attributes': {}}\n</code></pre> <p>Adding two graphs with partly overlapping node IDs:</p> <pre><code>&gt;&gt;&gt; g1 = pp.Graph.from_edge_list([(\"a\", \"b\"), (\"b\", \"c\")])\n&gt;&gt;&gt; g2 = pp.Graph.from_edge_list([(\"b\", \"d\"), (\"d\", \"e\")])\n&gt;&gt;&gt; print(g1 + g2)\nDirected graph with 5 nodes and 4 edges\n{   'Edge Attributes': {},\n    'Graph Attributes': {'node_sequence': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([6, 1])\", 'num_nodes': \"&lt;class 'int'&gt;\"},\n    'Node Attributes': {}}\n</code></pre> Source code in <code>src/pathpyG/core/graph.py</code> <pre><code>def __add__(self, other: Graph, reduce: str = \"sum\") -&gt; Graph:\n    \"\"\"Combine Graph object with other Graph object.\n\n    The semantics of this operation depends on the optional IndexMap\n    of both graphs. If no IndexMap is included, the two underlying data objects\n    are concatenated, thus merging edges from both graphs while leaving node indices\n    unchanged. If both graphs include IndexMaps that assign node IDs to indices,\n    indices will be adjusted, creating a new mapping for the union of node Ids in both graphs.\n\n    Node IDs of graphs to be combined can be disjoint, partly overlapping or non-overlapping.\n\n    Args:\n        other: Other graph to be combined with this graph\n        reduce: Reduction method for node attributes of nodes that are present in both graphs.\n            Can be one of \"sum\", \"mean\", \"mul\", \"min\", \"max\". Default is \"sum\".\n\n    Examples:\n        Adding two graphs without node IDs:\n\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; g1 = pp.Graph.from_edge_index(torch.tensor([[0, 1, 1], [1, 2, 3]]))\n        &gt;&gt;&gt; g2 = pp.Graph.from_edge_index(torch.tensor([[0, 2, 3], [3, 2, 1]]))\n        &gt;&gt;&gt; print(g1 + g2)\n        Directed graph with 4 nodes and 6 edges\n        {   'Edge Attributes': {},\n            'Graph Attributes': {'node_sequence': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([8, 1])\", 'num_nodes': \"&lt;class 'int'&gt;\"},\n            'Node Attributes': {}}\n\n        Adding two graphs with identical node IDs:\n\n        &gt;&gt;&gt; g1 = pp.Graph.from_edge_list([(\"a\", \"b\"), (\"b\", \"c\")])\n        &gt;&gt;&gt; g2 = pp.Graph.from_edge_list([(\"a\", \"c\"), (\"c\", \"b\")])\n        &gt;&gt;&gt; print(g1 + g2)\n        Directed graph with 3 nodes and 4 edges\n        {   'Edge Attributes': {},\n            'Graph Attributes': {'node_sequence': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([6, 1])\", 'num_nodes': \"&lt;class 'int'&gt;\"},\n            'Node Attributes': {}}\n\n        Adding two graphs with non-overlapping node IDs:\n\n        &gt;&gt;&gt; g1 = pp.Graph.from_edge_list([(\"a\", \"b\"), (\"b\", \"c\")])\n        &gt;&gt;&gt; g2 = pp.Graph.from_edge_list([(\"c\", \"d\"), (\"d\", \"e\")])\n        &gt;&gt;&gt; print(g1 + g2)\n        Directed graph with 5 nodes and 4 edges\n        {   'Edge Attributes': {},\n            'Graph Attributes': {'node_sequence': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([6, 1])\", 'num_nodes': \"&lt;class 'int'&gt;\"},\n            'Node Attributes': {}}\n\n        Adding two graphs with partly overlapping node IDs:\n\n        &gt;&gt;&gt; g1 = pp.Graph.from_edge_list([(\"a\", \"b\"), (\"b\", \"c\")])\n        &gt;&gt;&gt; g2 = pp.Graph.from_edge_list([(\"b\", \"d\"), (\"d\", \"e\")])\n        &gt;&gt;&gt; print(g1 + g2)\n        Directed graph with 5 nodes and 4 edges\n        {   'Edge Attributes': {},\n            'Graph Attributes': {'node_sequence': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([6, 1])\", 'num_nodes': \"&lt;class 'int'&gt;\"},\n            'Node Attributes': {}}\n    \"\"\"\n    d1 = self.data.clone()\n    m1 = self.mapping\n\n    d2 = other.data.clone()\n    m2 = other.mapping\n\n    nodes = np.concatenate([m1.to_ids(np.arange(self.n)), m2.to_ids(np.arange(other.n))])\n    mapping = IndexMap(np.unique(nodes, axis=0).tolist())\n    d1.edge_index = mapping.to_idxs(m1.to_ids(d1.edge_index), device=d1.edge_index.device)\n    d2.edge_index = mapping.to_idxs(m2.to_ids(d2.edge_index), device=d2.edge_index.device)\n\n    d = d1.concat(d2)\n    d.num_nodes = mapping.num_ids()\n    d.edge_index = EdgeIndex(d.edge_index, sparse_size=(d.num_nodes, d.num_nodes))\n\n    # For higher-order graphs, we need to update the inverse_idx attribute\n    if \"inverse_idx\" in d:\n        d.inverse_idx = mapping.to_idxs(\n            np.concatenate([m1.to_ids(d1.inverse_idx), m2.to_ids(d2.inverse_idx)]),\n            device=d.inverse_idx.device,\n        )\n\n    # If both graphs contain node attributes, reduce them using the specified method\n    for k in d1.keys():\n        if k != \"node_sequence\" and k.startswith(\"node_\"):\n            if isinstance(d[k], torch.Tensor):\n                d[k] = torch_geometric.utils.scatter(\n                    d[k],\n                    mapping.to_idxs(\n                        np.concatenate([m1.to_ids(np.arange(self.n)), m2.to_ids(np.arange(other.n))]),\n                        device=d[k].device,\n                    ),\n                    dim_size=d.num_nodes,\n                    reduce=reduce,\n                )\n            else:\n                raise ValueError(\"Node attribute \" + k + \" is not a tensor and cannot be reduced.\")\n    return Graph(d, mapping=mapping)\n</code></pre>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.__getitem__","title":"<code>__getitem__</code>","text":"<p>Return node, edge, or graph attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>typing.Union[tuple, str]</code> <p>name of attribute to be returned</p> required Source code in <code>src/pathpyG/core/graph.py</code> <pre><code>def __getitem__(self, key: Union[tuple, str]) -&gt; Any:\n    \"\"\"Return node, edge, or graph attribute.\n\n    Args:\n        key: name of attribute to be returned\n    \"\"\"\n    if not isinstance(key, tuple):\n        if key in self.data.keys():\n            return self.data[key]\n        else:\n            raise KeyError(key + \" is not a graph attribute\")\n    elif key[0] in self.node_attrs():\n        return self.data[key[0]][self.mapping.to_idx(key[1])]\n    elif key[0] in self.edge_attrs():\n        return self.data[key[0]][self.edge_to_index[self.mapping.to_idx(key[1]), self.mapping.to_idx(key[2])]]\n    else:\n        raise KeyError(key[0] + \" is not a node or edge attribute\")\n</code></pre>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.__init__","title":"<code>__init__</code>","text":"<p>Generate graph instance from a pyG <code>Data</code> object.</p> <p>Generate a Graph instance from a <code>torch_geometric.Data</code> object that contains an EdgeIndex as well as optional node-, edge- or graph-level attributes. An optional mapping can be used to transparently map node indices to string identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>torch_geometric.data.Data</code> <p>A pyG Data object containing an EdgeIndex and additional attributes</p> required <code>mapping</code> <code>typing.Optional[pathpyG.core.index_map.IndexMap]</code> <p><code>IndexMap</code> object that maps node indices to string identifiers</p> <code>None</code> Example <pre><code>import pathpyG as pp\nfrom torch_geometric.data import Data\nfrom torch_geometric import EdgeIndex\n\ndata = Data(edge_index=EdgeIndex([[1, 1, 2], [0, 2, 1]], sparse_size=(3, 3)))\ng = pp.Graph(data)\n\ng = pp.Graph(data, mapping=pp.IndexMap([\"a\", \"b\", \"c\"]))\n</code></pre> Source code in <code>src/pathpyG/core/graph.py</code> <pre><code>def __init__(self, data: Data, mapping: Optional[IndexMap] = None):\n    \"\"\"Generate graph instance from a pyG `Data` object.\n\n    Generate a Graph instance from a `torch_geometric.Data` object that contains an EdgeIndex as well as\n    optional node-, edge- or graph-level attributes. An optional mapping can be used to transparently map\n    node indices to string identifiers.\n\n    Args:\n        data: A pyG Data object containing an EdgeIndex and additional attributes\n        mapping: `IndexMap` object that maps node indices to string identifiers\n\n    Example:\n        ```py\n        import pathpyG as pp\n        from torch_geometric.data import Data\n        from torch_geometric import EdgeIndex\n\n        data = Data(edge_index=EdgeIndex([[1, 1, 2], [0, 2, 1]], sparse_size=(3, 3)))\n        g = pp.Graph(data)\n\n        g = pp.Graph(data, mapping=pp.IndexMap([\"a\", \"b\", \"c\"]))\n        ```\n    \"\"\"\n    if mapping is None:\n        self.mapping = IndexMap()\n    else:\n        self.mapping = mapping\n\n    # set num_nodes property\n    if \"num_nodes\" not in data and \"edge_index\" in data:\n        data.num_nodes = data.edge_index.max().item() + 1\n        logger.debug(\"Inferred number of nodes from edge_index, n = %s\", data.num_nodes)\n\n    # turn edge index tensor into EdgeIndex object\n    if not isinstance(data.edge_index, EdgeIndex):\n        data.edge_index = EdgeIndex(data=data.edge_index, sparse_size=(data.num_nodes, data.num_nodes))\n\n    if (\n        data.edge_index.get_sparse_size(dim=0) != data.num_nodes\n        or data.edge_index.get_sparse_size(dim=1) != data.num_nodes\n    ):\n        logger.error(\"Sparse size of edge_index does not match number of nodes, n = %s\", data.num_nodes)\n        raise ValueError(\"sparse size of EdgeIndex must match number of nodes!\")\n\n    self.data = data\n\n    # sort EdgeIndex and validate\n    data.edge_index, sorted_idx = data.edge_index.sort_by(\"row\")\n    for edge_attr in self.edge_attrs():\n        data[edge_attr] = self.data[edge_attr][sorted_idx]\n\n    data.edge_index.validate()\n\n    # create mapping between edge tuples and edge indices\n    self.edge_to_index = {\n        (e[0].item(), e[1].item()): i for i, e in enumerate([e for e in self.data.edge_index.t()])\n    }\n\n    ((self.row_ptr, self.col), _) = self.data.edge_index.get_csr()\n    ((self.col_ptr, self.row), _) = self.data.edge_index.get_csc()\n\n    # create node_sequence mapping for higher-order graphs\n    if \"node_sequence\" not in self.data:\n        self.data.node_sequence = torch.arange(data.num_nodes).reshape(-1, 1)\n</code></pre>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.__setitem__","title":"<code>__setitem__</code>","text":"<p>Store node, edge, or graph attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>name of attribute to be stored</p> required <code>val</code> <code>torch.Tensor</code> <p>value of attribute</p> required Source code in <code>src/pathpyG/core/graph.py</code> <pre><code>def __setitem__(self, key: str, val: torch.Tensor) -&gt; None:\n    \"\"\"Store node, edge, or graph attribute.\n\n    Args:\n        key: name of attribute to be stored\n        val: value of attribute\n    \"\"\"\n    if not isinstance(key, tuple):\n        if key.startswith(\"node_\"):\n            if val.size(0) != self.n:\n                raise ValueError(\"Attribute must have same length as number of nodes\")\n            self.data[key] = val\n        elif key.startswith(\"edge_\"):\n            if val.size(0) != self.m:\n                raise ValueError(\"Attribute must have same length as number of edges\")\n            self.data[key] = val\n        else:\n            self.data[key] = val\n    elif key[0].startswith(\"node_\"):\n        if key[0] not in self.data.keys():\n            raise KeyError(\n                \"Attribute does not yet exist. Setting the value of a specific node attribute\"\n                + \"requires that the attribute already exists.\"\n            )\n        self.data[key[0]][self.mapping.to_idx(key[1])] = val\n    elif key[0].startswith(\"edge_\"):\n        if key[0] not in self.data.keys():\n            raise KeyError(\n                \"Attribute does not yet exist. Setting the value of a specific node attribute\"\n                + \"requires that the attribute already exists.\"\n            )\n        self.data[key[0]][self.edge_to_index[self.mapping.to_idx(key[1]), self.mapping.to_idx(key[2])]] = val\n    else:\n        raise KeyError(\"node and edge specific attributes should be prefixed with 'node_' or 'edge_'\")\n</code></pre>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.__str__","title":"<code>__str__</code>","text":"<p>Return a string representation of the graph.</p> Source code in <code>src/pathpyG/core/graph.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the graph.\"\"\"\n    attr = self.data.to_dict()\n    attr_types = {}\n    for k in attr:\n        t = type(attr[k])\n        if t == torch.Tensor:\n            attr_types[k] = str(t) + \" -&gt; \" + str(attr[k].size())\n        else:\n            attr_types[k] = str(t)\n\n    from pprint import pformat\n\n    if self.is_undirected():\n        s = \"Undirected graph with {0} nodes and {1} edges\\n\".format(self.n, self.m)\n    else:\n        s = \"Directed graph with {0} nodes and {1} edges\\n\".format(self.n, self.m)\n\n    attribute_info: dict[str, dict[str, str]] = {\n        \"Node Attributes\": {},\n        \"Edge Attributes\": {},\n        \"Graph Attributes\": {},\n    }\n    for a in self.node_attrs():\n        attribute_info[\"Node Attributes\"][a] = attr_types[a]\n    for a in self.edge_attrs():\n        attribute_info[\"Edge Attributes\"][a] = attr_types[a]\n    for a in self.data.keys():\n        if not self.data.is_node_attr(a) and not self.data.is_edge_attr(a):\n            attribute_info[\"Graph Attributes\"][a] = attr_types[a]\n    s += pformat(attribute_info, indent=4, width=160)\n    return s\n</code></pre>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.degrees","title":"<code>degrees</code>","text":"<p>Return (weighted) degrees of nodes.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p><code>in</code> or <code>out</code> to calculate in- or out-degree for directed networks.</p> <code>'in'</code> <code>edge_attr</code> <code>str | None</code> <p>Optional numerical edge attribute that will be used to compute weighted degrees</p> <code>None</code> <code>return_tensor</code> <code>bool</code> <p>if True the function returns a degree tensor, if False (default) a dictionary will be returned that can be indexed by nodes</p> <code>False</code> <p>Returns:     dict: dictionary containing node degrees</p> Source code in <code>src/pathpyG/core/graph.py</code> <pre><code>def degrees(\n    self, mode: str = \"in\", edge_attr: str | None = None, return_tensor: bool = False\n) -&gt; Union[Dict[str, float], torch.Tensor]:\n    \"\"\"Return (weighted) degrees of nodes.\n\n    Args:\n        mode: `in` or `out` to calculate in- or out-degree for\n            directed networks.\n        edge_attr: Optional numerical edge attribute that will\n            be used to compute weighted degrees\n        return_tensor: if True the function returns a degree tensor, if False (default)\n            a dictionary will be returned that can be indexed by nodes\n    Returns:\n        dict: dictionary containing node degrees\n    \"\"\"\n    if mode == \"in\":\n        if not edge_attr:\n            d = torch_geometric.utils.degree(self.data.edge_index[1], num_nodes=self.n, dtype=torch.int)\n        else:\n            edge_weight = getattr(self.data, edge_attr, None)\n            d = scatter(edge_weight, self.data.edge_index[1], dim=0, dim_size=self.data.num_nodes, reduce=\"sum\")\n    else:\n        if not edge_attr:\n            d = torch_geometric.utils.degree(self.data.edge_index[0], num_nodes=self.n, dtype=torch.int)\n        else:\n            edge_weight = getattr(self.data, edge_attr, None)\n            d = scatter(edge_weight, self.data.edge_index[0], dim=0, dim_size=self.data.num_nodes, reduce=\"sum\")\n    if return_tensor:\n        return d\n    else:\n        return {str(self.mapping.to_id(i)): d[i].item() for i in range(self.n)}\n</code></pre>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.edge_attrs","title":"<code>edge_attrs</code>","text":"<p>Return a list of edge attributes.</p> <p>This method returns a list containing the names of all edge-level attributes, ignoring the special <code>edge_index</code> attribute.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>typing.List[str]</code> <p>list of edge attributes</p> Source code in <code>src/pathpyG/core/graph.py</code> <pre><code>def edge_attrs(self) -&gt; List[str]:\n    \"\"\"Return a list of edge attributes.\n\n    This method returns a list containing the names of all edge-level attributes,\n    ignoring the special `edge_index` attribute.\n\n    Returns:\n        list: list of edge attributes\n    \"\"\"\n    attrs = []\n    for k in self.data.keys():\n        if k != \"edge_index\" and k.startswith(\"edge_\"):\n            attrs.append(k)\n    return attrs\n</code></pre>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.from_edge_index","title":"<code>from_edge_index</code>  <code>staticmethod</code>","text":"<p>Construct a graph from a Tensor containing an edge index.</p> <p>An optional mapping can be used to transparently map node indices to string identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>edge_index</code> <code>torch.Tensor</code> <p>torch.Tensor or torch_geometric.EdgeIndex object containing an edge_index</p> required <code>mapping</code> <code>typing.Optional[pathpyG.core.index_map.IndexMap]</code> <p><code>IndexMap</code> object that maps node indices to string identifiers</p> <code>None</code> <code>num_nodes</code> <code>int | None</code> <p>optional number of nodes (default: None). If None, the number of nodes will be inferred based on the maximum node index in the edge index, i.e. there will be no isolated nodes.</p> <code>None</code> <p>Examples:</p> <p>You can create a graph from an edge index tensor as follows:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; g = pp.Graph.from_edge_index(torch.LongTensor([[1, 1, 2], [0, 2, 1]]))\n&gt;&gt;&gt; print(g)\nDirected graph with 3 nodes and 3 edges ...\n</code></pre> <p>You can also include a mapping of node IDs:</p> <pre><code>&gt;&gt;&gt; g = pp.Graph.from_edge_index(torch.LongTensor([[1, 1, 2], [0, 2, 1]]),\n...                              mapping=pp.IndexMap(['a', 'b', 'c']))\n&gt;&gt;&gt; print(g.mapping)\na -&gt; 0\nb -&gt; 1\nc -&gt; 2\n</code></pre> Source code in <code>src/pathpyG/core/graph.py</code> <pre><code>@staticmethod\ndef from_edge_index(\n    edge_index: torch.Tensor, mapping: Optional[IndexMap] = None, num_nodes: int | None = None\n) -&gt; Graph:\n    \"\"\"Construct a graph from a [Tensor][torch.Tensor] containing an edge index.\n\n    An optional mapping can be used to transparently map node indices to string identifiers.\n\n    Args:\n        edge_index:  torch.Tensor or torch_geometric.EdgeIndex object containing an edge_index\n        mapping: `IndexMap` object that maps node indices to string identifiers\n        num_nodes: optional number of nodes (default: None). If None, the number of nodes will be\n            inferred based on the maximum node index in the edge index, i.e. there will be no isolated nodes.\n\n    Examples:\n        You can create a graph from an edge index tensor as follows:\n\n        &gt;&gt;&gt; import torch\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; g = pp.Graph.from_edge_index(torch.LongTensor([[1, 1, 2], [0, 2, 1]]))\n        &gt;&gt;&gt; print(g)\n        Directed graph with 3 nodes and 3 edges ...\n\n        You can also include a mapping of node IDs:\n\n        &gt;&gt;&gt; g = pp.Graph.from_edge_index(torch.LongTensor([[1, 1, 2], [0, 2, 1]]),\n        ...                              mapping=pp.IndexMap(['a', 'b', 'c']))\n        &gt;&gt;&gt; print(g.mapping)\n        a -&gt; 0\n        b -&gt; 1\n        c -&gt; 2\n    \"\"\"\n    if not num_nodes:\n        d = Data(edge_index=edge_index)\n    else:\n        if mapping is not None and mapping.num_ids() != num_nodes:\n            logger.error(\"Number of node IDs in mapping must match num_nodes\")\n            raise ValueError(\"Number of node IDs in mapping must match num_nodes\")\n        d = Data(edge_index=edge_index, num_nodes=num_nodes)\n    return Graph(d, mapping=mapping)\n</code></pre>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.from_edge_list","title":"<code>from_edge_list</code>  <code>staticmethod</code>","text":"<p>Generate a Graph based on an edge list.</p> <p>Edges can be given as string or integer tuples. If strings are used and no mapping is given, a mapping of node IDs to indices will be automatically created based on a lexicographic ordering of node IDs.</p> <p>Parameters:</p> Name Type Description Default <code>edge_list</code> <code>typing.Iterable[typing.Tuple[str, str]]</code> <p>Iterable of edges represented as tuples</p> required <code>is_undirected</code> <code>bool</code> <p>Whether the edge list contains all bidorectional edges</p> <code>False</code> <code>mapping</code> <code>typing.Optional[pathpyG.core.index_map.IndexMap]</code> <p>optional mapping of string IDs to node indices</p> <code>None</code> <code>device</code> <code>typing.Optional[torch.device]</code> <p>optional torch device where tensors shall be stored</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; l = [(\"a\", \"b\"), (\"a\", \"c\"), (\"b\", \"c\")]\n&gt;&gt;&gt; g = pp.Graph.from_edge_list(l)\n&gt;&gt;&gt; print(list(g.edges))\n[('a', 'b'), ('a', 'c'), ('b', 'c')]\n</code></pre> Source code in <code>src/pathpyG/core/graph.py</code> <pre><code>@staticmethod\ndef from_edge_list(\n    edge_list: Iterable[Tuple[str, str]],\n    is_undirected: bool = False,\n    mapping: Optional[IndexMap] = None,\n    device: Optional[torch.device] = None,\n) -&gt; Graph:\n    \"\"\"Generate a Graph based on an edge list.\n\n    Edges can be given as string or integer tuples. If strings are used and no mapping is given,\n    a mapping of node IDs to indices will be automatically created based on a lexicographic ordering of\n    node IDs.\n\n    Args:\n        edge_list: Iterable of edges represented as tuples\n        is_undirected: Whether the edge list contains all bidorectional edges\n        mapping: optional mapping of string IDs to node indices\n        device: optional torch device where tensors shall be stored\n\n    Examples:\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; l = [(\"a\", \"b\"), (\"a\", \"c\"), (\"b\", \"c\")]\n        &gt;&gt;&gt; g = pp.Graph.from_edge_list(l)\n        &gt;&gt;&gt; print(list(g.edges))\n        [('a', 'b'), ('a', 'c'), ('b', 'c')]\n    \"\"\"\n    # handle empty graph\n    if len(edge_list) == 0:  # type: ignore[arg-type]\n        return Graph(\n            Data(edge_index=torch.tensor([[], []], dtype=torch.int32, device=device), num_nodes=0),\n            mapping=IndexMap(),\n        )\n\n    if mapping is None:\n        edge_array = np.array(edge_list)\n        node_ids = np.unique(edge_array)\n        if np.issubdtype(node_ids.dtype, str) and np.char.isnumeric(node_ids).all():\n            node_ids = np.sort(node_ids.astype(int)).astype(str)\n        mapping = IndexMap(node_ids)\n\n    num_nodes = mapping.num_ids()\n\n    edge_index = EdgeIndex(\n        mapping.to_idxs(edge_list, device=device).T.contiguous(),  # type: ignore[arg-type]\n        sparse_size=(num_nodes, num_nodes),\n        is_undirected=is_undirected,\n    )\n    return Graph(Data(edge_index=edge_index, num_nodes=num_nodes), mapping=mapping)\n</code></pre>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.get_predecessors","title":"<code>get_predecessors</code>","text":"<p>Return a tensor containing the indices of all predecessor nodes for a given node identified by an index.</p> <p>Parameters:</p> Name Type Description Default <code>col_idx</code> <code>int</code> <p>Index of node for which predecessors shall be returned.</p> required <p>Returns:</p> Name Type Description <code>tensor</code> <code>torch.Tensor</code> <p>tensor containing indices of all predecessor nodes of the node indexed by <code>col_idx</code></p> Source code in <code>src/pathpyG/core/graph.py</code> <pre><code>def get_predecessors(self, col_idx: int) -&gt; torch.Tensor:\n    \"\"\"Return a tensor containing the indices of all predecessor nodes for a given node identified by an index.\n\n    Args:\n        col_idx:   Index of node for which predecessors shall be returned.\n\n    Returns:\n        tensor: tensor containing indices of all predecessor nodes of the node indexed by `col_idx`\n    \"\"\"\n    if col_idx + 1 &lt; self.col_ptr.size(0):\n        col_start = self.col_ptr[col_idx]\n        col_end = self.col_ptr[col_idx + 1]\n        return self.row[col_start:col_end]\n    else:\n        return torch.tensor([], device=self.data.edge_index.device)\n</code></pre>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.get_successors","title":"<code>get_successors</code>","text":"<p>Return a tensor containing the indices of all successor nodes for a given node identified by an index.</p> <p>Parameters:</p> Name Type Description Default <code>row_idx</code> <code>int</code> <p>Index of node for which predecessors shall be returned.</p> required <p>Returns:</p> Name Type Description <code>tensor</code> <code>torch.Tensor</code> <p>tensor containing indices of all successor nodes of the node indexed by <code>row_idx</code></p> Source code in <code>src/pathpyG/core/graph.py</code> <pre><code>def get_successors(self, row_idx: int) -&gt; torch.Tensor:\n    \"\"\"Return a tensor containing the indices of all successor nodes for a given node identified by an index.\n\n    Args:\n        row_idx:   Index of node for which predecessors shall be returned.\n\n    Returns:\n        tensor: tensor containing indices of all successor nodes of the node indexed by `row_idx`\n    \"\"\"\n    if row_idx + 1 &lt; self.row_ptr.size(0):\n        row_start = self.row_ptr[row_idx]\n        row_end = self.row_ptr[row_idx + 1]\n        return self.col[row_start:row_end]\n    else:\n        return torch.tensor([], device=self.data.edge_index.device)\n</code></pre>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.has_self_loops","title":"<code>has_self_loops</code>","text":"<p>Return whether graph contains self-loops.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if graph contains self-loops, False otherwise</p> Source code in <code>src/pathpyG/core/graph.py</code> <pre><code>def has_self_loops(self) -&gt; bool:\n    \"\"\"Return whether graph contains self-loops.\n\n    Returns:\n        bool: True if graph contains self-loops, False otherwise\n    \"\"\"\n    return self.data.has_self_loops()\n</code></pre>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.is_directed","title":"<code>is_directed</code>","text":"<p>Return whether graph is directed.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if graph is directed, False otherwise</p> Source code in <code>src/pathpyG/core/graph.py</code> <pre><code>def is_directed(self) -&gt; bool:\n    \"\"\"Return whether graph is directed.\n\n    Returns:\n        bool: True if graph is directed, False otherwise\n    \"\"\"\n    return not self.data.edge_index.is_undirected\n</code></pre>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.is_edge","title":"<code>is_edge</code>","text":"<p>Return whether edge \\((v,w)\\) exists in the graph.</p> <p>If an index to ID mapping is used, nodes are assumed to be string IDs. If no mapping is used, nodes are assumed to be integer indices.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>typing.Union[str, int]</code> <p>source node of edge as integer index or string ID</p> required <code>w</code> <code>typing.Union[str, int]</code> <p>target node of edge as integer index or string ID</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if edge exists, False otherwise</p> Source code in <code>src/pathpyG/core/graph.py</code> <pre><code>def is_edge(self, v: Union[str, int], w: Union[str, int]) -&gt; bool:\n    \"\"\"Return whether edge $(v,w)$ exists in the graph.\n\n    If an index to ID mapping is used, nodes are assumed to be string IDs. If no\n    mapping is used, nodes are assumed to be integer indices.\n\n    Args:\n        v: source node of edge as integer index or string ID\n        w: target node of edge as integer index or string ID\n\n    Returns:\n        bool: True if edge exists, False otherwise\n    \"\"\"\n    row = self.mapping.to_idx(v)\n    row_start = self.row_ptr[row]\n    row_end = self.row_ptr[row + 1]  # type: ignore[operator]\n\n    return self.mapping.to_idx(w) in self.col[row_start:row_end]\n</code></pre>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.is_undirected","title":"<code>is_undirected</code>","text":"<p>Return whether graph is undirected.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if graph is undirected, False otherwise</p> Source code in <code>src/pathpyG/core/graph.py</code> <pre><code>def is_undirected(self) -&gt; bool:\n    \"\"\"Return whether graph is undirected.\n\n    Returns:\n        bool: True if graph is undirected, False otherwise\n    \"\"\"\n    return self.data.edge_index.is_undirected\n</code></pre>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.laplacian","title":"<code>laplacian</code>","text":"<p>Return Laplacian matrix for a given graph.</p> <p>This wrapper method will use <code>torch_geometric.utils.get_laplacian</code> to return a Laplcian matrix representation of a given graph.</p> <p>Parameters:</p> Name Type Description Default <code>normalization</code> <code>typing.Any</code> <p>normalization parameter passed to pyG <code>get_laplacian</code> function</p> <code>None</code> <code>edge_attr</code> <code>str | None</code> <p>optinal name of numerical edge attribute that shall be passed to pyG <code>get_laplacian</code> function as edge weight</p> <code>None</code> <p>Returns:</p> Type Description <code>typing.Any</code> <p>scipy.sparse.coo_matrix: Laplacian matrix representation of graph</p> Source code in <code>src/pathpyG/core/graph.py</code> <pre><code>def laplacian(self, normalization: Any = None, edge_attr: str | None = None) -&gt; Any:\n    \"\"\"Return Laplacian matrix for a given graph.\n\n    This wrapper method will use [`torch_geometric.utils.get_laplacian`][torch_geometric.utils.get_laplacian]\n    to return a Laplcian matrix representation of a given graph.\n\n    Args:\n        normalization: normalization parameter passed to pyG `get_laplacian`\n            function\n        edge_attr: optinal name of numerical edge attribute that shall\n            be passed to pyG `get_laplacian` function as edge weight\n\n    Returns:\n        scipy.sparse.coo_matrix: Laplacian matrix representation of graph\n    \"\"\"\n    if edge_attr is None:\n        index, weight = torch_geometric.utils.get_laplacian(\n            self.data.edge_index.as_tensor(), normalization=normalization\n        )\n        return torch_geometric.utils.to_scipy_sparse_matrix(index, weight)\n    else:\n        index, weight = torch_geometric.utils.get_laplacian(\n            self.data.edge_index.as_tensor(),\n            normalization=normalization,\n            edge_weight=self.data[edge_attr],\n        )\n        return torch_geometric.utils.to_scipy_sparse_matrix(index, weight)\n</code></pre>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.node_attrs","title":"<code>node_attrs</code>","text":"<p>Return a list of node attributes.</p> <p>This method returns a list containing the names of all node-level attributes, ignoring the special <code>node_sequence</code> attribute.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>typing.List[str]</code> <p>list of node attributes</p> Source code in <code>src/pathpyG/core/graph.py</code> <pre><code>def node_attrs(self) -&gt; List[str]:\n    \"\"\"Return a list of node attributes.\n\n    This method returns a list containing the names of all node-level attributes,\n    ignoring the special `node_sequence` attribute.\n\n    Returns:\n        list: list of node attributes\n    \"\"\"\n    attrs = []\n    for k in self.data.keys():\n        if k != \"node_sequence\" and k.startswith(\"node_\"):\n            attrs.append(k)\n    return attrs\n</code></pre>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.predecessors","title":"<code>predecessors</code>","text":"<p>Return the predecessors of a given node.</p> <p>This method returns a generator object that yields all predecessors of a given node. If a <code>node_id</code> mapping is used, predecessors will be returned as string IDs. If no mapping is used, predecessors are returned as indices.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>typing.Union[str, int] | tuple</code> <p>Index or string ID of node for which predecessors shall be returned.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list with all predecessors of the node identified by <code>node</code> using ID or index (if no mapping is used)</p> Source code in <code>src/pathpyG/core/graph.py</code> <pre><code>def predecessors(self, node: Union[str, int] | tuple) -&gt; list:\n    \"\"\"Return the predecessors of a given node.\n\n    This method returns a generator object that yields all predecessors of a\n    given node. If a `node_id` mapping is used, predecessors will be returned\n    as string IDs. If no mapping is used, predecessors are returned as indices.\n\n    Args:\n        node:   Index or string ID of node for which predecessors shall be returned.\n\n    Returns:\n        list: list with all predecessors of the node identified\n            by `node` using ID or index (if no mapping is used)\n    \"\"\"\n    node_list = self.mapping.to_ids(self.get_predecessors(self.mapping.to_idx(node))).tolist()  # type: ignore\n\n    if self.order &gt; 1:\n        return list(map(tuple, node_list))\n    return node_list\n</code></pre>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.sparse_adj_matrix","title":"<code>sparse_adj_matrix</code>","text":"<p>Return sparse adjacency matrix representation of (weighted) graph.</p> <p>Parameters:</p> Name Type Description Default <code>edge_attr</code> <code>typing.Any</code> <p>the edge attribute that shall be used as edge weight</p> <code>None</code> <p>Returns:</p> Type Description <code>typing.Any</code> <p>scipy.sparse.coo_matrix: sparse adjacency matrix representation of graph</p> Source code in <code>src/pathpyG/core/graph.py</code> <pre><code>def sparse_adj_matrix(self, edge_attr: Any = None) -&gt; Any:\n    \"\"\"Return sparse adjacency matrix representation of (weighted) graph.\n\n    Args:\n        edge_attr: the edge attribute that shall be used as edge weight\n\n    Returns:\n        scipy.sparse.coo_matrix: sparse adjacency matrix representation of graph\n    \"\"\"\n    if edge_attr is None:\n        return torch_geometric.utils.to_scipy_sparse_matrix(self.data.edge_index.as_tensor(), num_nodes=self.n)\n    else:\n        return torch_geometric.utils.to_scipy_sparse_matrix(\n            self.data.edge_index.as_tensor(), edge_attr=self.data[edge_attr], num_nodes=self.n\n        )\n</code></pre>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.successors","title":"<code>successors</code>","text":"<p>Return all successors of a given node.</p> <p>This method returns a generator object that yields all successors of a given node. If an IndexMap is used, successors are returned as string IDs. If no mapping is used, successors are returned as indices.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>typing.Union[int, str] | tuple</code> <p>Index or string ID of node for which successors shall be returned.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list with all successors of the node identified by <code>node</code> using ID or index (if no mapping is used)</p> Source code in <code>src/pathpyG/core/graph.py</code> <pre><code>def successors(self, node: Union[int, str] | tuple) -&gt; list:\n    \"\"\"Return all successors of a given node.\n\n    This method returns a generator object that yields all successors of a\n    given node. If an IndexMap is used, successors are returned\n    as string IDs. If no mapping is used, successors are returned as indices.\n\n    Args:\n        node:   Index or string ID of node for which successors shall be returned.\n\n    Returns:\n        list: list with all successors of the node identified\n            by `node` using ID or index (if no mapping is used)\n    \"\"\"\n    node_list = self.mapping.to_ids(self.get_successors(self.mapping.to_idx(node))).tolist()  # type: ignore\n\n    if self.order &gt; 1:\n        return list(map(tuple, node_list))\n    return node_list\n</code></pre>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.to","title":"<code>to</code>","text":"<p>Move all tensors to the given device.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>torch.device</code> <p>torch device to which all tensors shall be moved</p> required <p>Returns:</p> Name Type Description <code>Graph</code> <code>pathpyG.core.graph.Graph</code> <p>self</p> Source code in <code>src/pathpyG/core/graph.py</code> <pre><code>def to(self, device: torch.device) -&gt; Graph:\n    \"\"\"Move all tensors to the given device.\n\n    Args:\n        device: torch device to which all tensors shall be moved\n\n    Returns:\n        Graph: self\n    \"\"\"\n    self.data.edge_index = self.data.edge_index.to(device)\n    self.data.node_sequence = self.data.node_sequence.to(device)\n    for attr in self.node_attrs():\n        if isinstance(self.data[attr], torch.Tensor):\n            self.data[attr] = self.data[attr].to(device)\n    for attr in self.edge_attrs():\n        if isinstance(self.data[attr], torch.Tensor):\n            self.data[attr] = self.data[attr].to(device)\n\n    self.row = self.row.to(device)\n    self.row_ptr = self.row_ptr.to(device)\n    self.col = self.col.to(device)\n    self.col_ptr = self.col_ptr.to(device)\n\n    return self\n</code></pre>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.to_undirected","title":"<code>to_undirected</code>","text":"<p>Return an undirected version of this directed graph.</p> <p>This method creates a new undirected Graph from the current graph instance by adding all directed edges in opposite direction.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; g = pp.Graph.from_edge_list([(\"a\", \"b\"), (\"b\", \"c\"), (\"c\", \"a\")])\n&gt;&gt;&gt; g_u = g.to_undirected()\n&gt;&gt;&gt; print(g_u)\nUndirected graph with 3 nodes and 3 edges\n{'Edge Attributes': {}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\n</code></pre> Source code in <code>src/pathpyG/core/graph.py</code> <pre><code>def to_undirected(self) -&gt; Graph:\n    \"\"\"Return an undirected version of this directed graph.\n\n    This method creates a new undirected Graph from the current graph instance by\n    adding all directed edges in opposite direction.\n\n    Examples:\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; g = pp.Graph.from_edge_list([(\"a\", \"b\"), (\"b\", \"c\"), (\"c\", \"a\")])\n        &gt;&gt;&gt; g_u = g.to_undirected()\n        &gt;&gt;&gt; print(g_u)\n        Undirected graph with 3 nodes and 3 edges\n        {'Edge Attributes': {}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\n    \"\"\"\n    # create undirected edge index by coalescing the directed edges and keep\n    # track of the original edge index for the edge attributes\n    attr_idx = torch.arange(self.data.num_edges, device=self.data.edge_index.device)\n    edge_index, attr_idx = to_undirected(\n        self.data.edge_index,\n        edge_attr=attr_idx,\n        num_nodes=self.data.num_nodes,\n        reduce=\"min\",\n    )\n\n    data = Data(\n        edge_index=EdgeIndex(\n            data=edge_index, sparse_size=(self.data.num_nodes, self.data.num_nodes), is_undirected=True\n        ),\n        num_nodes=self.data.num_nodes,\n    )\n    # Note that while the torch_geometric.transforms.ToUndirected function would do this automatically,\n    # we do it manually since the transform cannot handle numpy arrays as edge attributes.\n    # make sure to copy all node and (undirected) edge attributes\n    for node_attr in self.node_attrs():\n        data[node_attr] = self.data[node_attr]\n    for edge_attr in self.edge_attrs():\n        if edge_attr != \"edge_index\":\n            data[edge_attr] = self.data[edge_attr][attr_idx]\n\n    return Graph(data, self.mapping)\n</code></pre>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.to_weighted_graph","title":"<code>to_weighted_graph</code>","text":"<p>Coalesces multi-edges to single-edges with an additional weight attribute.</p> <p>If the graph contains multiple edges between the same nodes, this method will coalesce them into a single edge with an additional weight attribute called <code>edge_weight</code> that contains the number of coalesced edges. The method returns a new graph instance with the coalesced edges.</p> <p>Returns:</p> Name Type Description <code>Graph</code> <code>pathpyG.core.graph.Graph</code> <p>Graph with coalesced edges</p> Source code in <code>src/pathpyG/core/graph.py</code> <pre><code>def to_weighted_graph(self) -&gt; Graph:\n    \"\"\"Coalesces multi-edges to single-edges with an additional weight attribute.\n\n    If the graph contains multiple edges between the same nodes, this method will coalesce\n    them into a single edge with an additional weight attribute called `edge_weight` that\n    contains the number of coalesced edges. The method returns a new graph instance with\n    the coalesced edges.\n\n    Returns:\n        Graph: Graph with coalesced edges\n    \"\"\"\n    i, w = torch_geometric.utils.coalesce(\n        self.data.edge_index.as_tensor(), torch.ones(self.m, device=self.data.edge_index.device)\n    )\n    return Graph(Data(edge_index=i, edge_weight=w, num_nodes=self.data.num_nodes), mapping=self.mapping)\n</code></pre>"},{"location":"reference/pathpyG/core/graph/#pathpyG.core.graph.Graph.transition_probabilities","title":"<code>transition_probabilities</code>","text":"<p>Compute transition probabilities based on (weighted) outdegrees.</p> <p>Parameters:</p> Name Type Description Default <code>edge_attr</code> <code>str | None</code> <p>Optional name of numerical edge attribute that will be used to calculate weighted out-degrees for the visitation probabilities.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tensor</code> <code>torch.Tensor</code> <p>Transition probabilities.</p> Source code in <code>src/pathpyG/core/graph.py</code> <pre><code>def transition_probabilities(self, edge_attr: str | None = None) -&gt; torch.Tensor:\n    \"\"\"Compute transition probabilities based on (weighted) outdegrees.\n\n    Args:\n        edge_attr: Optional name of numerical edge attribute that will\n           be used to calculate weighted out-degrees for the visitation probabilities.\n\n    Returns:\n        tensor: Transition probabilities.\n    \"\"\"\n    weighted_outdegree = self.degrees(mode=\"out\", edge_attr=edge_attr, return_tensor=True)\n    source_ids = self.data.edge_index[0]\n    edge_weight = torch.ones(self.data.num_edges, device=self.data.edge_index.device)\n    if edge_attr is not None:\n        edge_weight = getattr(self.data, edge_attr, None)  # type: ignore[assignment]\n    return edge_weight / weighted_outdegree[source_ids]\n</code></pre>"},{"location":"reference/pathpyG/core/index_map/","title":"index_map","text":"<p>IndexMap class for mapping node indices to IDs.</p>"},{"location":"reference/pathpyG/core/index_map/#pathpyG.core.index_map.IndexMap","title":"<code>IndexMap</code>","text":"<p>Maps node indices to IDs.</p> <p>This class keeps a mapping from any node ID, e.g. names (strings) or higher-order IDs (tuples), to an index of the corresponding node in the initial list of IDs, enabling fast lookup of node IDs from a <code>Data</code> object.</p> <p>Attributes:</p> Name Type Description <code>node_ids</code> <code>numpy.ndarray | None</code> <p><code>numpy.ndarray</code> storing the node IDs, enabling fast lookup of multiple node IDs from indices.</p> <code>id_to_idx</code> <code>dict</code> <p><code>dict</code> mapping each node ID to its index.</p> <code>id_shape</code> <code>tuple</code> <p><code>tuple</code> storing the shape of the ID. The default shape is (-1,) for first-order IDs. For higher-order IDs, the shape will be <code>(-1, k)</code> with order <code>k</code>.</p> <p>Examples:</p> <p>Initialize an <code>IndexMap</code> object with a list of string IDs:</p> <pre><code>&gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n&gt;&gt;&gt; print(index_map)\nA -&gt; 0\nB -&gt; 1\nC -&gt; 2\n</code></pre> <p>Add additional IDs to the mapping:</p> <pre><code>&gt;&gt;&gt; index_map.add_id(\"D\")\n&gt;&gt;&gt; print(index_map.to_idx(\"D\"))\n3\n</code></pre> <p>Map indices to IDs. Use <code>to_id</code> for single indices and <code>to_ids</code> for multiple indices. Note that the shape of the given index list will be preserved in the output:</p> <pre><code>&gt;&gt;&gt; print(index_map.to_id(1))\nB\n&gt;&gt;&gt; print(index_map.to_ids([0, 2]))\n['A' 'C']\n</code></pre> <p>Map IDs to indices. Works analogously to the reversed mapping and can, e.g., be used to create an <code>edge_index</code> tensor from a list of edges given by source and destination node IDs:</p> <pre><code>&gt;&gt;&gt; edge_index = index_map.to_idxs([[\"A\", \"B\"], [\"B\", \"C\"], [\"C\", \"D\"]]).T\n</code></pre> <p>Create a higher-order ID mapping:</p> <pre><code>&gt;&gt;&gt; index_map = IndexMap([(\"A\", \"B\"), (\"A\", \"C\"), (\"B\", \"C\")])\n&gt;&gt;&gt; print(index_map)\n('A', 'B') -&gt; 0\n('A', 'C') -&gt; 1\n('B', 'C') -&gt; 2\n</code></pre> <p>The methods above work analogously for higher-order IDs:</p> <pre><code>&gt;&gt;&gt; print(index_map.to_id(1))\n('A', 'C')\n&gt;&gt;&gt; print(index_map.to_ids([[0], [2]]))\n[[['A' 'B']]\n [['B' 'C']]]\n</code></pre> Source code in <code>src/pathpyG/core/index_map.py</code> <pre><code>class IndexMap:\n    \"\"\"Maps node indices to IDs.\n\n    This class keeps a mapping from any node ID, e.g. names (strings) or higher-order IDs (tuples),\n    to an index of the corresponding node in the initial list of IDs, enabling fast lookup of node IDs\n    from a [`Data`][torch_geometric.data.Data] object.\n\n    Attributes:\n        node_ids: [`numpy.ndarray`][numpy.ndarray] storing the node IDs, enabling fast lookup of multiple node IDs from indices.\n        id_to_idx: [`dict`][dict] mapping each node ID to its index.\n        id_shape: [`tuple`][tuple] storing the shape of the ID. The default shape is (-1,) for first-order IDs.\n            For higher-order IDs, the shape will be `(-1, k)` with order `k`.\n\n    Examples:\n        Initialize an `IndexMap` object with a list of string IDs:\n\n        &gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n        &gt;&gt;&gt; print(index_map)\n        A -&gt; 0\n        B -&gt; 1\n        C -&gt; 2\n\n        Add additional IDs to the mapping:\n\n        &gt;&gt;&gt; index_map.add_id(\"D\")\n        &gt;&gt;&gt; print(index_map.to_idx(\"D\"))\n        3\n\n        Map indices to IDs. Use `to_id` for single indices and `to_ids` for multiple indices.\n        Note that the shape of the given index list will be preserved in the output:\n\n        &gt;&gt;&gt; print(index_map.to_id(1))\n        B\n        &gt;&gt;&gt; print(index_map.to_ids([0, 2]))\n        ['A' 'C']\n\n        Map IDs to indices. Works analogously to the reversed mapping and can, e.g., be used to\n        create an `edge_index` tensor from a list of edges given by source and destination node IDs:\n\n        &gt;&gt;&gt; edge_index = index_map.to_idxs([[\"A\", \"B\"], [\"B\", \"C\"], [\"C\", \"D\"]]).T\n\n        Create a higher-order ID mapping:\n\n        &gt;&gt;&gt; index_map = IndexMap([(\"A\", \"B\"), (\"A\", \"C\"), (\"B\", \"C\")])\n        &gt;&gt;&gt; print(index_map)\n        ('A', 'B') -&gt; 0\n        ('A', 'C') -&gt; 1\n        ('B', 'C') -&gt; 2\n\n        The methods above work analogously for higher-order IDs:\n\n        &gt;&gt;&gt; print(index_map.to_id(1))\n        ('A', 'C')\n        &gt;&gt;&gt; print(index_map.to_ids([[0], [2]]))\n        [[['A' 'B']]\n         [['B' 'C']]]\n    \"\"\"\n\n    def __init__(self, node_ids: Union[List[str], List[tuple], None] = None) -&gt; None:\n        \"\"\"Initialize mapping from indices to node IDs.\n\n        The mapping will keep the ordering of the IDs as provided by `node_ids`. If the IDs are not unique,\n        an error will be raised.\n\n        Args:\n            node_ids: List of node IDs to initialize mapping.\n\n        Raises:\n            ValueError: If IDs are not unique.\n\n        Examples:\n            Initialize an `IndexMap` object with a list of string IDs:\n\n            &gt;&gt;&gt; index_map = IndexMap([\"A\", \"C\", \"B\"])\n            &gt;&gt;&gt; print(index_map)\n            A -&gt; 0\n            C -&gt; 1\n            B -&gt; 2\n\n            Handle non-unique IDs and sort IDs lexicographically:\n\n            &gt;&gt;&gt; node_ids = [\"A\", \"C\", \"B\", \"A\"]\n            &gt;&gt;&gt; index_map = IndexMap(np.unique(node_ids))\n            &gt;&gt;&gt; print(index_map)\n            A -&gt; 0\n            B -&gt; 1\n            C -&gt; 2\n        \"\"\"\n        self.node_ids: np.ndarray | None = None\n        self.id_to_idx: dict = {}\n        self.id_shape: tuple = (-1,)  # If the index map is higher order, this will be the shape of the ID\n        if node_ids is not None:\n            self.add_ids(node_ids)\n\n    @property\n    def has_ids(self) -&gt; bool:\n        \"\"\"Return whether mapping has IDs.\n\n        Returns:\n            Whether mapping has IDs.\n\n        Examples:\n            Check if mapping has IDs:\n\n            &gt;&gt;&gt; index_map = IndexMap()\n            &gt;&gt;&gt; print(index_map.has_ids)\n            False\n\n            &gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n            &gt;&gt;&gt; print(index_map.has_ids)\n            True\n        \"\"\"\n        return self.node_ids is not None\n\n    def num_ids(self) -&gt; int:\n        \"\"\"Return number of IDs. If mapping is not defined, return 0.\n\n        Returns:\n            Number of IDs.\n\n        Examples:\n            Get number of IDs:\n\n            &gt;&gt;&gt; index_map = IndexMap()\n            &gt;&gt;&gt; print(index_map.num_ids())\n            0\n\n            &gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n            &gt;&gt;&gt; print(index_map.num_ids())\n            3\n\n            &gt;&gt;&gt; index_map = IndexMap([(\"A\", \"B\"), (\"A\", \"C\"), (\"B\", \"C\")])\n            &gt;&gt;&gt; print(index_map.num_ids())\n            3\n        \"\"\"\n        if self.node_ids is None:\n            return 0\n        else:\n            return len(self.node_ids)\n\n    def add_id(self, node_id: str | tuple | list) -&gt; None:\n        \"\"\"Assigns additional ID to the next consecutive index.\n\n        Args:\n            node_id: ID to assign.\n\n        Raises:\n            ValueError: If ID is already present in the mapping.\n\n        Examples:\n            Add an additional ID to the mapping:\n\n            &gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n            &gt;&gt;&gt; index_map.add_id(\"D\")\n            &gt;&gt;&gt; print(index_map)\n            A -&gt; 0\n            B -&gt; 1\n            C -&gt; 2\n            D -&gt; 3\n        \"\"\"\n        if node_id not in self.id_to_idx:\n            idx = self.num_ids()\n            if isinstance(node_id, (list, tuple)):\n                node_id_arr = to_numpy(node_id)\n                self.id_shape = (-1, *node_id_arr.shape)\n                node_id_arr = node_id_arr.reshape(1, *node_id_arr.shape)\n            else:\n                node_id_arr = to_numpy([node_id])\n            self.node_ids = np.concatenate((self.node_ids, node_id_arr)) if self.node_ids is not None else node_id_arr\n            self.id_to_idx[node_id] = idx\n        else:\n            raise ValueError(\"ID already present in the mapping.\")\n\n    def add_ids(self, node_ids: list | np.ndarray) -&gt; None:\n        \"\"\"Assigns additional IDs to next consecutive indices. The order of IDs is preserved.\n\n        Args:\n            node_ids: IDs to assign\n\n        Raises:\n            ValueError: If IDs are not unique or already present in the mapping.\n\n        Examples:\n            Add additional IDs to the mapping:\n\n            &gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n            &gt;&gt;&gt; index_map.add_ids([\"E\", \"D\"])\n            &gt;&gt;&gt; print(index_map)\n            A -&gt; 0\n            B -&gt; 1\n            C -&gt; 2\n            E -&gt; 3\n            D -&gt; 4\n        \"\"\"\n        cur_num_ids = self.num_ids()\n        if isinstance(node_ids, list) and isinstance(node_ids[0], (list, tuple)):\n            self.id_shape = (-1, *to_numpy(node_ids[0]).shape)\n\n        if not isinstance(node_ids, np.ndarray):\n            node_ids = to_numpy(node_ids)\n\n        all_ids = np.concatenate((self.node_ids, node_ids)) if self.node_ids is not None else node_ids\n        unique_ids = np.unique(all_ids, axis=0 if self.id_shape != (-1,) else None)\n\n        if len(unique_ids) != len(all_ids):\n            raise ValueError(\"IDs are not unique or already present in the mapping.\")\n\n        self.node_ids = all_ids\n        self.id_to_idx.update(\n            {tuple(v.tolist()) if self.id_shape != (-1,) else v: i + cur_num_ids for i, v in enumerate(node_ids)}\n        )\n\n    def to_id(self, idx: int) -&gt; Union[int, str, tuple]:\n        \"\"\"Map index to ID if mapping is defined, return index otherwise.\n\n        Args:\n            idx: Index to map.\n\n        Returns:\n            ID if mapping is defined, index otherwise.\n\n        Examples:\n            Map index to ID:\n\n            &gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n            &gt;&gt;&gt; print(index_map.to_id(1))\n            B\n\n            No mapping defined:\n\n            &gt;&gt;&gt; index_map = IndexMap()\n            &gt;&gt;&gt; print(index_map.to_id(1))\n            1\n        \"\"\"\n        if self.has_ids:\n            if self.id_shape == (-1,):\n                if isinstance(self.node_ids, np.ndarray) and self.node_ids.dtype.type is np.str_:\n                    return str(self.node_ids[idx])\n                else:\n                    return self.node_ids[idx]  # type: ignore\n            else:\n                return tuple(self.node_ids[idx].tolist())  # type: ignore\n        else:\n            return idx\n\n    def to_ids(self, idxs: list | tuple | np.ndarray) -&gt; np.ndarray:\n        \"\"\"Map list of indices to IDs if mapping is defined, return indices otherwise.\n\n        The shape of the given index list will be preserved in the output.\n\n        Args:\n            idxs: Indices to map.\n\n        Returns:\n            IDs if mapping is defined, indices otherwise.\n\n        Examples:\n            Map list of indices to IDs:\n\n            &gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n            &gt;&gt;&gt; print(index_map.to_ids([0, 2]))\n            ['A' 'C']\n\n            No mapping defined:\n\n            &gt;&gt;&gt; index_map = IndexMap()\n            &gt;&gt;&gt; print(index_map.to_ids(torch.tensor([0, 2])))\n            tensor([0, 2])\n\n            Map edge_index tensor to array of edges:\n\n            &gt;&gt;&gt; edge_index = torch.tensor([[0, 2, 2, 3], [1, 1, 3, 0]])\n            &gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\", \"D\"])\n            &gt;&gt;&gt; print(index_map.to_ids(edge_index.T))\n            [['A' 'B']\n             ['C' 'B']\n             ['C' 'D']\n             ['D' 'A']]\n        \"\"\"\n        if self.node_ids is not None:\n            if not isinstance(idxs, np.ndarray):\n                idxs = to_numpy(idxs)\n            return self.node_ids[idxs]\n        else:\n            return idxs  # type: ignore[return-value]\n\n    def to_idx(self, node: str | int | tuple[str] | tuple[int]) -&gt; int | tuple[int]:\n        \"\"\"Map argument (ID or index) to index if mapping is defined, return argument otherwise.\n\n        Args:\n            node: ID or index to map.\n\n        Returns:\n            Index if mapping is defined, argument otherwise.\n\n        Examples:\n            Map ID to index:\n\n            &gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n            &gt;&gt;&gt; print(index_map.to_idx(\"B\"))\n            1\n\n            No mapping defined:\n\n            &gt;&gt;&gt; index_map = IndexMap()\n            &gt;&gt;&gt; print(index_map.to_idx(1))\n            1\n        \"\"\"\n        n: str | int | tuple[str] | tuple[int] = node\n        if self.has_ids:\n            if self.id_shape != (-1,):\n                n = tuple(n)  # type: ignore[arg-type,assignment]\n            return self.id_to_idx[n]\n        else:\n            return n  # type: ignore[return-value]\n\n    def to_idxs(self, nodes: list | tuple | np.ndarray, device: Optional[torch.device] = None) -&gt; torch.Tensor:\n        \"\"\"Map list of arguments (IDs or indices) to indices if mapping is defined, return argument otherwise.\n\n        The shape of the given argument list will be preserved in the output.\n\n        Args:\n            nodes: IDs or indices to map.\n            device: Device on which to create the output tensor.\n\n        Returns:\n            Indices if mapping is defined, arguments otherwise.\n\n        Examples:\n            Map list of IDs to indices:\n\n            &gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n            &gt;&gt;&gt; print(index_map.to_idxs([\"B\", \"A\"]))\n            tensor([1, 0])\n\n            No mapping defined:\n\n            &gt;&gt;&gt; index_map = IndexMap()\n            &gt;&gt;&gt; print(index_map.to_idxs(torch.tensor([1, 0])))\n            tensor([1, 0])\n\n            Map list of edges to edge_index tensor:\n\n            &gt;&gt;&gt; edges = [[\"A\", \"B\"], [\"B\", \"C\"], [\"C\", \"D\"]]\n            &gt;&gt;&gt; index_map = IndexMap(np.unique(edges))\n            &gt;&gt;&gt; print(index_map.to_idxs(edges).T)\n            tensor([[0, 1, 2],\n                    [1, 2, 3]])\n        \"\"\"\n        if self.has_ids:\n            if not isinstance(nodes, np.ndarray):\n                nodes = to_numpy(nodes)\n\n            shape = nodes.shape\n            if self.id_shape == (-1,):\n                return torch.tensor([self.id_to_idx[node] for node in nodes.flatten()], device=device).reshape(shape)\n            else:\n                return torch.tensor(\n                    [self.id_to_idx[tuple(node.tolist())] for node in nodes.reshape(self.id_shape)], device=device\n                ).reshape(shape[: -len(self.id_shape) + 1])\n        else:\n            return torch.tensor(nodes, device=device)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return string representation of the mapping.\n\n        Returns:\n            String representation of the mapping.\n\n        Examples:\n            Print string representation of the mapping:\n\n            &gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n            &gt;&gt;&gt; print(index_map)\n            A -&gt; 0\n            B -&gt; 1\n            C -&gt; 2\n        \"\"\"\n        s = \"\"\n        for v in self.id_to_idx:\n            s += str(v) + \" -&gt; \" + str(self.to_idx(v)) + \"\\n\"\n        return s\n</code></pre>"},{"location":"reference/pathpyG/core/index_map/#pathpyG.core.index_map.IndexMap.has_ids","title":"<code>has_ids</code>  <code>property</code>","text":"<p>Return whether mapping has IDs.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether mapping has IDs.</p> <p>Examples:</p> <p>Check if mapping has IDs:</p> <pre><code>&gt;&gt;&gt; index_map = IndexMap()\n&gt;&gt;&gt; print(index_map.has_ids)\nFalse\n</code></pre> <pre><code>&gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n&gt;&gt;&gt; print(index_map.has_ids)\nTrue\n</code></pre>"},{"location":"reference/pathpyG/core/index_map/#pathpyG.core.index_map.IndexMap.__init__","title":"<code>__init__</code>","text":"<p>Initialize mapping from indices to node IDs.</p> <p>The mapping will keep the ordering of the IDs as provided by <code>node_ids</code>. If the IDs are not unique, an error will be raised.</p> <p>Parameters:</p> Name Type Description Default <code>node_ids</code> <code>typing.Union[typing.List[str], typing.List[tuple], None]</code> <p>List of node IDs to initialize mapping.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If IDs are not unique.</p> <p>Examples:</p> <p>Initialize an <code>IndexMap</code> object with a list of string IDs:</p> <pre><code>&gt;&gt;&gt; index_map = IndexMap([\"A\", \"C\", \"B\"])\n&gt;&gt;&gt; print(index_map)\nA -&gt; 0\nC -&gt; 1\nB -&gt; 2\n</code></pre> <p>Handle non-unique IDs and sort IDs lexicographically:</p> <pre><code>&gt;&gt;&gt; node_ids = [\"A\", \"C\", \"B\", \"A\"]\n&gt;&gt;&gt; index_map = IndexMap(np.unique(node_ids))\n&gt;&gt;&gt; print(index_map)\nA -&gt; 0\nB -&gt; 1\nC -&gt; 2\n</code></pre> Source code in <code>src/pathpyG/core/index_map.py</code> <pre><code>def __init__(self, node_ids: Union[List[str], List[tuple], None] = None) -&gt; None:\n    \"\"\"Initialize mapping from indices to node IDs.\n\n    The mapping will keep the ordering of the IDs as provided by `node_ids`. If the IDs are not unique,\n    an error will be raised.\n\n    Args:\n        node_ids: List of node IDs to initialize mapping.\n\n    Raises:\n        ValueError: If IDs are not unique.\n\n    Examples:\n        Initialize an `IndexMap` object with a list of string IDs:\n\n        &gt;&gt;&gt; index_map = IndexMap([\"A\", \"C\", \"B\"])\n        &gt;&gt;&gt; print(index_map)\n        A -&gt; 0\n        C -&gt; 1\n        B -&gt; 2\n\n        Handle non-unique IDs and sort IDs lexicographically:\n\n        &gt;&gt;&gt; node_ids = [\"A\", \"C\", \"B\", \"A\"]\n        &gt;&gt;&gt; index_map = IndexMap(np.unique(node_ids))\n        &gt;&gt;&gt; print(index_map)\n        A -&gt; 0\n        B -&gt; 1\n        C -&gt; 2\n    \"\"\"\n    self.node_ids: np.ndarray | None = None\n    self.id_to_idx: dict = {}\n    self.id_shape: tuple = (-1,)  # If the index map is higher order, this will be the shape of the ID\n    if node_ids is not None:\n        self.add_ids(node_ids)\n</code></pre>"},{"location":"reference/pathpyG/core/index_map/#pathpyG.core.index_map.IndexMap.__str__","title":"<code>__str__</code>","text":"<p>Return string representation of the mapping.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the mapping.</p> <p>Examples:</p> <p>Print string representation of the mapping:</p> <pre><code>&gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n&gt;&gt;&gt; print(index_map)\nA -&gt; 0\nB -&gt; 1\nC -&gt; 2\n</code></pre> Source code in <code>src/pathpyG/core/index_map.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return string representation of the mapping.\n\n    Returns:\n        String representation of the mapping.\n\n    Examples:\n        Print string representation of the mapping:\n\n        &gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n        &gt;&gt;&gt; print(index_map)\n        A -&gt; 0\n        B -&gt; 1\n        C -&gt; 2\n    \"\"\"\n    s = \"\"\n    for v in self.id_to_idx:\n        s += str(v) + \" -&gt; \" + str(self.to_idx(v)) + \"\\n\"\n    return s\n</code></pre>"},{"location":"reference/pathpyG/core/index_map/#pathpyG.core.index_map.IndexMap.add_id","title":"<code>add_id</code>","text":"<p>Assigns additional ID to the next consecutive index.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str | tuple | list</code> <p>ID to assign.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If ID is already present in the mapping.</p> <p>Examples:</p> <p>Add an additional ID to the mapping:</p> <pre><code>&gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n&gt;&gt;&gt; index_map.add_id(\"D\")\n&gt;&gt;&gt; print(index_map)\nA -&gt; 0\nB -&gt; 1\nC -&gt; 2\nD -&gt; 3\n</code></pre> Source code in <code>src/pathpyG/core/index_map.py</code> <pre><code>def add_id(self, node_id: str | tuple | list) -&gt; None:\n    \"\"\"Assigns additional ID to the next consecutive index.\n\n    Args:\n        node_id: ID to assign.\n\n    Raises:\n        ValueError: If ID is already present in the mapping.\n\n    Examples:\n        Add an additional ID to the mapping:\n\n        &gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n        &gt;&gt;&gt; index_map.add_id(\"D\")\n        &gt;&gt;&gt; print(index_map)\n        A -&gt; 0\n        B -&gt; 1\n        C -&gt; 2\n        D -&gt; 3\n    \"\"\"\n    if node_id not in self.id_to_idx:\n        idx = self.num_ids()\n        if isinstance(node_id, (list, tuple)):\n            node_id_arr = to_numpy(node_id)\n            self.id_shape = (-1, *node_id_arr.shape)\n            node_id_arr = node_id_arr.reshape(1, *node_id_arr.shape)\n        else:\n            node_id_arr = to_numpy([node_id])\n        self.node_ids = np.concatenate((self.node_ids, node_id_arr)) if self.node_ids is not None else node_id_arr\n        self.id_to_idx[node_id] = idx\n    else:\n        raise ValueError(\"ID already present in the mapping.\")\n</code></pre>"},{"location":"reference/pathpyG/core/index_map/#pathpyG.core.index_map.IndexMap.add_ids","title":"<code>add_ids</code>","text":"<p>Assigns additional IDs to next consecutive indices. The order of IDs is preserved.</p> <p>Parameters:</p> Name Type Description Default <code>node_ids</code> <code>list | numpy.ndarray</code> <p>IDs to assign</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If IDs are not unique or already present in the mapping.</p> <p>Examples:</p> <p>Add additional IDs to the mapping:</p> <pre><code>&gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n&gt;&gt;&gt; index_map.add_ids([\"E\", \"D\"])\n&gt;&gt;&gt; print(index_map)\nA -&gt; 0\nB -&gt; 1\nC -&gt; 2\nE -&gt; 3\nD -&gt; 4\n</code></pre> Source code in <code>src/pathpyG/core/index_map.py</code> <pre><code>def add_ids(self, node_ids: list | np.ndarray) -&gt; None:\n    \"\"\"Assigns additional IDs to next consecutive indices. The order of IDs is preserved.\n\n    Args:\n        node_ids: IDs to assign\n\n    Raises:\n        ValueError: If IDs are not unique or already present in the mapping.\n\n    Examples:\n        Add additional IDs to the mapping:\n\n        &gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n        &gt;&gt;&gt; index_map.add_ids([\"E\", \"D\"])\n        &gt;&gt;&gt; print(index_map)\n        A -&gt; 0\n        B -&gt; 1\n        C -&gt; 2\n        E -&gt; 3\n        D -&gt; 4\n    \"\"\"\n    cur_num_ids = self.num_ids()\n    if isinstance(node_ids, list) and isinstance(node_ids[0], (list, tuple)):\n        self.id_shape = (-1, *to_numpy(node_ids[0]).shape)\n\n    if not isinstance(node_ids, np.ndarray):\n        node_ids = to_numpy(node_ids)\n\n    all_ids = np.concatenate((self.node_ids, node_ids)) if self.node_ids is not None else node_ids\n    unique_ids = np.unique(all_ids, axis=0 if self.id_shape != (-1,) else None)\n\n    if len(unique_ids) != len(all_ids):\n        raise ValueError(\"IDs are not unique or already present in the mapping.\")\n\n    self.node_ids = all_ids\n    self.id_to_idx.update(\n        {tuple(v.tolist()) if self.id_shape != (-1,) else v: i + cur_num_ids for i, v in enumerate(node_ids)}\n    )\n</code></pre>"},{"location":"reference/pathpyG/core/index_map/#pathpyG.core.index_map.IndexMap.num_ids","title":"<code>num_ids</code>","text":"<p>Return number of IDs. If mapping is not defined, return 0.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of IDs.</p> <p>Examples:</p> <p>Get number of IDs:</p> <pre><code>&gt;&gt;&gt; index_map = IndexMap()\n&gt;&gt;&gt; print(index_map.num_ids())\n0\n</code></pre> <pre><code>&gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n&gt;&gt;&gt; print(index_map.num_ids())\n3\n</code></pre> <pre><code>&gt;&gt;&gt; index_map = IndexMap([(\"A\", \"B\"), (\"A\", \"C\"), (\"B\", \"C\")])\n&gt;&gt;&gt; print(index_map.num_ids())\n3\n</code></pre> Source code in <code>src/pathpyG/core/index_map.py</code> <pre><code>def num_ids(self) -&gt; int:\n    \"\"\"Return number of IDs. If mapping is not defined, return 0.\n\n    Returns:\n        Number of IDs.\n\n    Examples:\n        Get number of IDs:\n\n        &gt;&gt;&gt; index_map = IndexMap()\n        &gt;&gt;&gt; print(index_map.num_ids())\n        0\n\n        &gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n        &gt;&gt;&gt; print(index_map.num_ids())\n        3\n\n        &gt;&gt;&gt; index_map = IndexMap([(\"A\", \"B\"), (\"A\", \"C\"), (\"B\", \"C\")])\n        &gt;&gt;&gt; print(index_map.num_ids())\n        3\n    \"\"\"\n    if self.node_ids is None:\n        return 0\n    else:\n        return len(self.node_ids)\n</code></pre>"},{"location":"reference/pathpyG/core/index_map/#pathpyG.core.index_map.IndexMap.to_id","title":"<code>to_id</code>","text":"<p>Map index to ID if mapping is defined, return index otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Index to map.</p> required <p>Returns:</p> Type Description <code>typing.Union[int, str, tuple]</code> <p>ID if mapping is defined, index otherwise.</p> <p>Examples:</p> <p>Map index to ID:</p> <pre><code>&gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n&gt;&gt;&gt; print(index_map.to_id(1))\nB\n</code></pre> <p>No mapping defined:</p> <pre><code>&gt;&gt;&gt; index_map = IndexMap()\n&gt;&gt;&gt; print(index_map.to_id(1))\n1\n</code></pre> Source code in <code>src/pathpyG/core/index_map.py</code> <pre><code>def to_id(self, idx: int) -&gt; Union[int, str, tuple]:\n    \"\"\"Map index to ID if mapping is defined, return index otherwise.\n\n    Args:\n        idx: Index to map.\n\n    Returns:\n        ID if mapping is defined, index otherwise.\n\n    Examples:\n        Map index to ID:\n\n        &gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n        &gt;&gt;&gt; print(index_map.to_id(1))\n        B\n\n        No mapping defined:\n\n        &gt;&gt;&gt; index_map = IndexMap()\n        &gt;&gt;&gt; print(index_map.to_id(1))\n        1\n    \"\"\"\n    if self.has_ids:\n        if self.id_shape == (-1,):\n            if isinstance(self.node_ids, np.ndarray) and self.node_ids.dtype.type is np.str_:\n                return str(self.node_ids[idx])\n            else:\n                return self.node_ids[idx]  # type: ignore\n        else:\n            return tuple(self.node_ids[idx].tolist())  # type: ignore\n    else:\n        return idx\n</code></pre>"},{"location":"reference/pathpyG/core/index_map/#pathpyG.core.index_map.IndexMap.to_ids","title":"<code>to_ids</code>","text":"<p>Map list of indices to IDs if mapping is defined, return indices otherwise.</p> <p>The shape of the given index list will be preserved in the output.</p> <p>Parameters:</p> Name Type Description Default <code>idxs</code> <code>list | tuple | numpy.ndarray</code> <p>Indices to map.</p> required <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>IDs if mapping is defined, indices otherwise.</p> <p>Examples:</p> <p>Map list of indices to IDs:</p> <pre><code>&gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n&gt;&gt;&gt; print(index_map.to_ids([0, 2]))\n['A' 'C']\n</code></pre> <p>No mapping defined:</p> <pre><code>&gt;&gt;&gt; index_map = IndexMap()\n&gt;&gt;&gt; print(index_map.to_ids(torch.tensor([0, 2])))\ntensor([0, 2])\n</code></pre> <p>Map edge_index tensor to array of edges:</p> <pre><code>&gt;&gt;&gt; edge_index = torch.tensor([[0, 2, 2, 3], [1, 1, 3, 0]])\n&gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\", \"D\"])\n&gt;&gt;&gt; print(index_map.to_ids(edge_index.T))\n[['A' 'B']\n ['C' 'B']\n ['C' 'D']\n ['D' 'A']]\n</code></pre> Source code in <code>src/pathpyG/core/index_map.py</code> <pre><code>def to_ids(self, idxs: list | tuple | np.ndarray) -&gt; np.ndarray:\n    \"\"\"Map list of indices to IDs if mapping is defined, return indices otherwise.\n\n    The shape of the given index list will be preserved in the output.\n\n    Args:\n        idxs: Indices to map.\n\n    Returns:\n        IDs if mapping is defined, indices otherwise.\n\n    Examples:\n        Map list of indices to IDs:\n\n        &gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n        &gt;&gt;&gt; print(index_map.to_ids([0, 2]))\n        ['A' 'C']\n\n        No mapping defined:\n\n        &gt;&gt;&gt; index_map = IndexMap()\n        &gt;&gt;&gt; print(index_map.to_ids(torch.tensor([0, 2])))\n        tensor([0, 2])\n\n        Map edge_index tensor to array of edges:\n\n        &gt;&gt;&gt; edge_index = torch.tensor([[0, 2, 2, 3], [1, 1, 3, 0]])\n        &gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\", \"D\"])\n        &gt;&gt;&gt; print(index_map.to_ids(edge_index.T))\n        [['A' 'B']\n         ['C' 'B']\n         ['C' 'D']\n         ['D' 'A']]\n    \"\"\"\n    if self.node_ids is not None:\n        if not isinstance(idxs, np.ndarray):\n            idxs = to_numpy(idxs)\n        return self.node_ids[idxs]\n    else:\n        return idxs  # type: ignore[return-value]\n</code></pre>"},{"location":"reference/pathpyG/core/index_map/#pathpyG.core.index_map.IndexMap.to_idx","title":"<code>to_idx</code>","text":"<p>Map argument (ID or index) to index if mapping is defined, return argument otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str | int | tuple[str] | tuple[int]</code> <p>ID or index to map.</p> required <p>Returns:</p> Type Description <code>int | tuple[int]</code> <p>Index if mapping is defined, argument otherwise.</p> <p>Examples:</p> <p>Map ID to index:</p> <pre><code>&gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n&gt;&gt;&gt; print(index_map.to_idx(\"B\"))\n1\n</code></pre> <p>No mapping defined:</p> <pre><code>&gt;&gt;&gt; index_map = IndexMap()\n&gt;&gt;&gt; print(index_map.to_idx(1))\n1\n</code></pre> Source code in <code>src/pathpyG/core/index_map.py</code> <pre><code>def to_idx(self, node: str | int | tuple[str] | tuple[int]) -&gt; int | tuple[int]:\n    \"\"\"Map argument (ID or index) to index if mapping is defined, return argument otherwise.\n\n    Args:\n        node: ID or index to map.\n\n    Returns:\n        Index if mapping is defined, argument otherwise.\n\n    Examples:\n        Map ID to index:\n\n        &gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n        &gt;&gt;&gt; print(index_map.to_idx(\"B\"))\n        1\n\n        No mapping defined:\n\n        &gt;&gt;&gt; index_map = IndexMap()\n        &gt;&gt;&gt; print(index_map.to_idx(1))\n        1\n    \"\"\"\n    n: str | int | tuple[str] | tuple[int] = node\n    if self.has_ids:\n        if self.id_shape != (-1,):\n            n = tuple(n)  # type: ignore[arg-type,assignment]\n        return self.id_to_idx[n]\n    else:\n        return n  # type: ignore[return-value]\n</code></pre>"},{"location":"reference/pathpyG/core/index_map/#pathpyG.core.index_map.IndexMap.to_idxs","title":"<code>to_idxs</code>","text":"<p>Map list of arguments (IDs or indices) to indices if mapping is defined, return argument otherwise.</p> <p>The shape of the given argument list will be preserved in the output.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list | tuple | numpy.ndarray</code> <p>IDs or indices to map.</p> required <code>device</code> <code>typing.Optional[torch.device]</code> <p>Device on which to create the output tensor.</p> <code>None</code> <p>Returns:</p> Type Description <code>torch.Tensor</code> <p>Indices if mapping is defined, arguments otherwise.</p> <p>Examples:</p> <p>Map list of IDs to indices:</p> <pre><code>&gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n&gt;&gt;&gt; print(index_map.to_idxs([\"B\", \"A\"]))\ntensor([1, 0])\n</code></pre> <p>No mapping defined:</p> <pre><code>&gt;&gt;&gt; index_map = IndexMap()\n&gt;&gt;&gt; print(index_map.to_idxs(torch.tensor([1, 0])))\ntensor([1, 0])\n</code></pre> <p>Map list of edges to edge_index tensor:</p> <pre><code>&gt;&gt;&gt; edges = [[\"A\", \"B\"], [\"B\", \"C\"], [\"C\", \"D\"]]\n&gt;&gt;&gt; index_map = IndexMap(np.unique(edges))\n&gt;&gt;&gt; print(index_map.to_idxs(edges).T)\ntensor([[0, 1, 2],\n        [1, 2, 3]])\n</code></pre> Source code in <code>src/pathpyG/core/index_map.py</code> <pre><code>def to_idxs(self, nodes: list | tuple | np.ndarray, device: Optional[torch.device] = None) -&gt; torch.Tensor:\n    \"\"\"Map list of arguments (IDs or indices) to indices if mapping is defined, return argument otherwise.\n\n    The shape of the given argument list will be preserved in the output.\n\n    Args:\n        nodes: IDs or indices to map.\n        device: Device on which to create the output tensor.\n\n    Returns:\n        Indices if mapping is defined, arguments otherwise.\n\n    Examples:\n        Map list of IDs to indices:\n\n        &gt;&gt;&gt; index_map = IndexMap([\"A\", \"B\", \"C\"])\n        &gt;&gt;&gt; print(index_map.to_idxs([\"B\", \"A\"]))\n        tensor([1, 0])\n\n        No mapping defined:\n\n        &gt;&gt;&gt; index_map = IndexMap()\n        &gt;&gt;&gt; print(index_map.to_idxs(torch.tensor([1, 0])))\n        tensor([1, 0])\n\n        Map list of edges to edge_index tensor:\n\n        &gt;&gt;&gt; edges = [[\"A\", \"B\"], [\"B\", \"C\"], [\"C\", \"D\"]]\n        &gt;&gt;&gt; index_map = IndexMap(np.unique(edges))\n        &gt;&gt;&gt; print(index_map.to_idxs(edges).T)\n        tensor([[0, 1, 2],\n                [1, 2, 3]])\n    \"\"\"\n    if self.has_ids:\n        if not isinstance(nodes, np.ndarray):\n            nodes = to_numpy(nodes)\n\n        shape = nodes.shape\n        if self.id_shape == (-1,):\n            return torch.tensor([self.id_to_idx[node] for node in nodes.flatten()], device=device).reshape(shape)\n        else:\n            return torch.tensor(\n                [self.id_to_idx[tuple(node.tolist())] for node in nodes.reshape(self.id_shape)], device=device\n            ).reshape(shape[: -len(self.id_shape) + 1])\n    else:\n        return torch.tensor(nodes, device=device)\n</code></pre>"},{"location":"reference/pathpyG/core/multi_order_model/","title":"multi_order_model","text":"<p>MultiOrderModel module.</p>"},{"location":"reference/pathpyG/core/multi_order_model/#pathpyG.core.multi_order_model.MultiOrderModel","title":"<code>MultiOrderModel</code>","text":"<p>MultiOrderModel based on torch_geometric.data.Data.</p> <p>This class stores multiple higher-order De Bruijn graphs as layers in a dictionary. Each layer corresponds to a De Bruijn graph of order k, where k is the key in the dictionary. Each graph layer is represented as a pathpyG.Graph object. This class provides methods to search for the optimal order of the model based on likelihood ratio tests, as well as methods to compute the log-likelihood of observed paths given the model.</p> <p>Attributes:</p> Name Type Description <code>layers</code> <code>dict[int, pathpyG.core.graph.Graph]</code> <p>A dictionary mapping the order k to the corresponding higher-order De Bruijn graph of order k.</p> <p>Examples:</p> <p>Example where the optimal order is 1:</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; paths = PathData(IndexMap(list(\"abcde\")))\n&gt;&gt;&gt; paths.append_walk((\"a\", \"c\", \"d\"), weight=3)\n&gt;&gt;&gt; paths.append_walk((\"b\", \"c\", \"e\"), weight=3)\n&gt;&gt;&gt; m = MultiOrderModel.from_path_data(paths, max_order=2)\n&gt;&gt;&gt; print(m.estimate_order(paths, max_order=2))\n1\n</code></pre> <p>Example where the optimal order is 2:</p> <pre><code>&gt;&gt;&gt; paths = PathData(IndexMap(list(\"abcde\")))\n&gt;&gt;&gt; paths.append_walk((\"a\", \"c\", \"d\"), weight=4)\n&gt;&gt;&gt; paths.append_walk((\"b\", \"c\", \"e\"), weight=4)\n&gt;&gt;&gt; m = MultiOrderModel.from_path_data(paths, max_order=2)\n&gt;&gt;&gt; print(m.estimate_order(paths, max_order=2))\n2\n</code></pre> Source code in <code>src/pathpyG/core/multi_order_model.py</code> <pre><code>class MultiOrderModel:\n    \"\"\"MultiOrderModel based on [torch_geometric.data.Data][].\n\n    This class stores multiple higher-order De Bruijn graphs as layers in a dictionary.\n    Each layer corresponds to a De Bruijn graph of order k, where k is the key in the dictionary.\n    Each graph layer is represented as a [pathpyG.Graph][] object.\n    This class provides methods to search for the optimal order of the model based on likelihood ratio tests,\n    as well as methods to compute the log-likelihood of observed paths given the model.\n\n    Attributes:\n        layers (dict[int, Graph]): A dictionary mapping the order k to the corresponding\n            higher-order De Bruijn graph of order k.\n\n    Examples:\n        Example where the optimal order is 1:\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; paths = PathData(IndexMap(list(\"abcde\")))\n        &gt;&gt;&gt; paths.append_walk((\"a\", \"c\", \"d\"), weight=3)\n        &gt;&gt;&gt; paths.append_walk((\"b\", \"c\", \"e\"), weight=3)\n        &gt;&gt;&gt; m = MultiOrderModel.from_path_data(paths, max_order=2)\n        &gt;&gt;&gt; print(m.estimate_order(paths, max_order=2))\n        1\n\n        Example where the optimal order is 2:\n        &gt;&gt;&gt; paths = PathData(IndexMap(list(\"abcde\")))\n        &gt;&gt;&gt; paths.append_walk((\"a\", \"c\", \"d\"), weight=4)\n        &gt;&gt;&gt; paths.append_walk((\"b\", \"c\", \"e\"), weight=4)\n        &gt;&gt;&gt; m = MultiOrderModel.from_path_data(paths, max_order=2)\n        &gt;&gt;&gt; print(m.estimate_order(paths, max_order=2))\n        2\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize an empty MultiOrderModel.\"\"\"\n        self.layers: dict[int, Graph] = {}\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the higher-order graph.\"\"\"\n        max_order = max(list(self.layers.keys())) if self.layers else 0\n        s = f\"MultiOrderModel with max. order {max_order}\"\n        return s\n\n    def to(self, device: torch.device) -&gt; \"MultiOrderModel\":\n        \"\"\"Convert the graph layers to the given device.\n\n        Args:\n            device: The device to convert the graph layers to.\n\n        Returns: The MultiOrderModel with graph layers on the given device.\n        \"\"\"\n        for g in self.layers.values():\n            g.to(device)\n        return self\n\n    @staticmethod\n    def iterate_lift_order(\n        edge_index: torch.Tensor,\n        node_sequence: torch.Tensor,\n        mapping: IndexMap,\n        edge_weight: torch.Tensor | None = None,\n        aggr: str = \"src\",\n        save: bool = True,\n    ) -&gt; tuple[torch.Tensor, torch.Tensor, torch.Tensor | None, Graph | None]:\n        \"\"\"Lift order by one and save the result in the layers dictionary of the object.\n\n        This is a helper function that should not be called directly.\n        Only use for edge_indices after the special cases have been handled e.g.\n        in the from_temporal_graph (filtering non-time-respecting paths of order 2).\n\n        Args:\n            edge_index: The edge index of the (k-1)-th order graph.\n            node_sequence: The node sequences of the (k-1)-th order graph.\n            mapping: The [IndexMap][pathpyG.IndexMap] mapping higher-order nodes to first-order nodes.\n            edge_weight: The edge weights of the (k-1)-th order graph.\n            k: The order of the graph that should be computed.\n            aggr: The aggregation method to use. One of \"src\", \"dst\", \"max\", \"mul\".\n            save: Whether to compute the aggregated graph and later save it in the layers dictionary.\n        \"\"\"\n        # Lift order\n        if edge_weight is None:\n            ho_index = lift_order_edge_index(edge_index, num_nodes=node_sequence.size(0))\n        else:\n            ho_index, edge_weight = lift_order_edge_index_weighted(\n                edge_index, edge_weight=edge_weight, num_nodes=node_sequence.size(0), aggr=aggr\n            )\n        node_sequence = torch.cat([node_sequence[edge_index[0]], node_sequence[edge_index[1]][:, -1:]], dim=1)\n\n        # Aggregate\n        if save:\n            gk = aggregate_edge_index(ho_index, node_sequence, edge_weight)\n            gk.mapping = IndexMap([tuple(mapping.to_ids(v.cpu())) for v in gk.data.node_sequence])\n        else:\n            gk = None\n        return ho_index, node_sequence, edge_weight, gk\n\n    @staticmethod\n    def from_temporal_graph(\n        g: TemporalGraph,\n        delta: float | int = 1,\n        max_order: int = 1,\n        weight: str = \"edge_weight\",\n        cached: bool = True,\n        event_graph: Optional[torch.Tensor] = None,\n    ) -&gt; \"MultiOrderModel\":\n        \"\"\"Creates multiple higher-order De Bruijn graph models for paths in a temporal graph.\n\n        Args:\n            g: The temporal graph.\n            delta: The maximum time difference between two consecutive edges in a path.\n            max_order: The maximum order of the MultiOrderModel that should be computed.\n            weight: The edge attribute to use as edge weight.\n            cached: Whether to save the aggregated higher-order graphs smaller than max order in the MultiOrderModel.\n            event_graph: precomputed event graph edge index for given delta to be used for model generation. Useful to prevent the same event graph\n            from being computed twice.\n\n        Returns:\n            MultiOrderModel: A multi-order model where each layer is a De Bruijn graph with order k.\n        \"\"\"\n        m = MultiOrderModel()\n        if not g.data.is_sorted_by_time():\n            data = g.data.sort_by_time()\n        else:\n            data = g.data\n        edge_index = data.edge_index\n        node_sequence = torch.arange(data.num_nodes, device=edge_index.device).unsqueeze(1)\n        if weight in data:\n            edge_weight = data[weight]\n        else:\n            edge_weight = torch.ones(edge_index.size(1), device=edge_index.device)\n        if cached or max_order == 1:\n            m.layers[1] = aggregate_edge_index(\n                edge_index=edge_index, node_sequence=node_sequence, edge_weight=edge_weight\n            )\n            m.layers[1].mapping = g.mapping\n\n        if max_order &gt; 1:\n            node_sequence = torch.cat([node_sequence[edge_index[0]], node_sequence[edge_index[1]][:, -1:]], dim=1)\n            if event_graph is None:\n                edge_index = lift_order_temporal(g, delta)\n            else:\n                edge_index = event_graph\n            edge_weight = aggregate_node_attributes(edge_index, edge_weight, \"src\")\n\n            # Aggregate\n            if cached or max_order == 2:\n                m.layers[2] = aggregate_edge_index(\n                    edge_index=edge_index, node_sequence=node_sequence, edge_weight=edge_weight\n                )\n                m.layers[2].mapping = IndexMap(\n                    [tuple(g.mapping.to_ids(v.cpu())) for v in m.layers[2].data.node_sequence]\n                )\n\n            for k in range(3, max_order + 1):\n                edge_index, node_sequence, edge_weight, gk = MultiOrderModel.iterate_lift_order(\n                    edge_index=edge_index,\n                    node_sequence=node_sequence,\n                    mapping=g.mapping,\n                    edge_weight=edge_weight,\n                    aggr=\"src\",\n                    save=cached or k == max_order,\n                )\n                if cached or k == max_order:\n                    m.layers[k] = gk  # type: ignore[assignment]\n        return m\n\n    @staticmethod\n    def from_path_data(\n        path_data: PathData, max_order: int = 1, mode: str = \"propagation\", cached: bool = True\n    ) -&gt; \"MultiOrderModel\":\n        \"\"\"Creates multiple higher-order De Bruijn graphs modelling paths in [PathData][pathpyG.PathData].\n\n        Args:\n            path_data: [PathData][pathpyG.PathData] object containing paths as list of [Data][torch_geometric.data.Data] objects\n                with sorted edge indices, node sequences and num_nodes.\n            max_order: The maximum order of the [MultiOrderModel][pathpyG.MultiOrderModel] that should be computed\n            mode: The process that we assume. Can be \"diffusion\" or \"propagation\".\n            cached: Whether to save the aggregated higher-order graphs smaller than max order\n                in the [MultiOrderModel][pathpyG.MultiOrderModel].\n\n        Returns:\n            MultiOrderModel: The MultiOrderModel.\n        \"\"\"\n        m = MultiOrderModel()\n\n        # We assume that paths are sorted\n        path_graph = path_data.data\n        edge_index = path_graph.edge_index\n        node_sequence = path_graph.node_sequence\n        edge_weight = path_graph.dag_weight.repeat_interleave(path_graph.dag_num_edges)\n        if mode == \"diffusion\":\n            edge_weight = (\n                edge_weight / degree(edge_index[0], dtype=torch.long, num_nodes=node_sequence.size(0))[edge_index[0]]\n            )\n            aggr = \"mul\"\n        elif mode == \"propagation\":\n            aggr = \"src\"\n\n        m.layers[1] = aggregate_edge_index(edge_index=edge_index, node_sequence=node_sequence, edge_weight=edge_weight)\n        m.layers[1].mapping = path_data.mapping\n\n        for k in range(2, max_order + 1):\n            edge_index, node_sequence, edge_weight, gk = MultiOrderModel.iterate_lift_order(\n                edge_index=edge_index,\n                node_sequence=node_sequence,\n                mapping=m.layers[1].mapping,\n                edge_weight=edge_weight,\n                aggr=aggr,\n                save=cached or k == max_order,\n            )\n            if cached or k == max_order:\n                m.layers[k] = gk  # type: ignore[assignment]\n\n        return m\n\n    def get_mon_dof(self, max_order: Optional[int] = None, assumption: str = \"paths\") -&gt; int:\n        \"\"\"Calculate the degrees of freedom of the multi-order model.\n\n        The degrees of freedom for the kth layer of a multi-order model. This depends on the number of different paths of exactly length `k` in the graph.\n        Therefore, we can obtain these values by summing the entries of the `k`-th power of the binary adjacency matrix of the graph.\n        Finally, we must consider that, due the conservation of probablility, all non-zero rows of the transition matrix of the higher-order network must sum to one.\n        This poses one additional constraint per row that respects the condition, which should be removed from the total count of degrees of freedom.\n\n        Args:\n            m (MultiOrderModel): The multi-order model.\n            max_order (int, optional): The maximum order up to which model layers\n                shall be taken into account. Defaults to None, meaning it considers\n                all available layers.\n            assumption (str, optional): If set to 'paths', only paths in the\n                first-order network topology will be considered for the degree of\n                freedom calculation. If set to 'ngrams', all possible n-grams will\n                be considered, independent of whether they are valid paths in the\n                first-order network or not. Defaults to 'paths'.\n\n        Returns:\n            int: The degrees of freedom for the multi-order model.\n\n        Raises:\n            ValueError: If max_order is larger than the maximum order of\n                the multi-order network.\n            ValueError: If the assumption is not 'paths' or 'ngrams'.\n        \"\"\"\n        if max_order is None:\n            max_order = max(self.layers)\n\n        if max_order &gt; max(self.layers):\n            logger.error(\"max_order cannot be larger than maximum order of multi-order network\")\n            raise ValueError(\"max_order cannot be larger than maximum order of multi-order network\")\n\n        dof = self.layers[1].data.num_nodes - 1  # Degrees of freedom for zeroth order\n\n        if assumption == \"paths\":\n            # COMPUTING CONTRIBUTION FROM NUM PATHS AND NONZERO OUTDEGREES SEPARATELY\n            # TODO: CAN IT BE DONE TOGETHER?\n\n            edge_index = self.layers[1].data.edge_index\n            # Adding dof from Number of paths of length k\n            for k in range(1, max_order + 1):\n                if k &gt; 1:\n                    num_nodes = 0 if edge_index.numel() == 0 else edge_index.max().item() + 1\n                    edge_index = lift_order_edge_index(edge_index, num_nodes)\n                # counting number of len k paths\n                num_len_k_paths = edge_index.shape[1]  # edge_index.max().item() +1  # Number of paths of length k\n                dof += num_len_k_paths\n\n            # removing dof from total probability of nonzero degree nodes\n            for k in range(1, max_order + 1):\n                if k == 1:\n                    # edge_index of temporal graph is sorted by time by default\n                    # For matrix multiplication, we need to sort it by row\n                    edge_index_adj = self.layers[1].data.edge_index.sort_by(\"row\")[0]\n                    edge_index = edge_index_adj\n                else:\n                    edge_index, _ = edge_index.matmul(edge_index_adj)\n                num_nonzero_outdegrees = torch.unique(edge_index[0]).size(0)\n                dof -= num_nonzero_outdegrees\n\n        elif assumption == \"ngrams\":\n            for order in range(1, max_order + 1):\n                dof += (self.layers[1].data.num_nodes ** order) * (self.layers[1].data.num_nodes - 1)\n        else:\n            logger.error(\"Unknown assumption %s. Only 'path' and 'ngram' are accepted.\", assumption)\n            raise ValueError(f\"Unknown assumption {assumption}. Only 'path' and 'ngram' are accepted.\")\n\n        return int(dof)\n\n    def get_zeroth_order_log_likelihood(self, dag_graph: Data) -&gt; float:\n        \"\"\"Compute the zeroth order log likelihood.\n\n        Args:\n            dag_graph (Data): Input DAG graph data.\n\n        Returns:\n            float: Zeroth order log likelihood.\n        \"\"\"\n        # Get frequencies\n        # getting the index of the last edge of each path (to be used to extract weights)\n        frequencies = dag_graph.dag_weight\n\n        # Get ixs starting nodes\n        # Q: Is dag_graph.path_index[:-1] enough to get the start_ixs?\n        mask = torch.ones(dag_graph.num_nodes, dtype=bool)  # type: ignore[call-overload]\n        mask[dag_graph.edge_index[1]] = False\n        start_ixs = dag_graph.node_sequence.squeeze()[mask]\n\n        # Compute node emission probabilities\n        # TODO: modify once we have zeroth order in mon\n        _, counts = torch.unique(dag_graph.node_sequence, return_counts=True)\n        # WARNING: Only works if all nodes in the first-order graph are also in `node_sequence`\n        # Otherwise the missing nodes will not be included in `counts` which can lead to elements at the wrong index.\n        node_emission_probabilities = counts / counts.sum()\n        return torch.mul(frequencies, torch.log(node_emission_probabilities[start_ixs])).sum().item()\n\n    def get_intermediate_order_log_likelihood(self, dag_graph: Data, order: int) -&gt; float:\n        \"\"\"Compute the intermediate order log likelihood.\n\n        Args:\n            m (MultiOrderModel): Multi-order model.\n            dag_graph (Data): Input DAG graph data.\n            order (int): Order of the intermediate log likelihood.\n\n        Returns:\n            float: Intermediate order log likelihood.\n        \"\"\"\n        # Get frequencies\n        frequencies = dag_graph.dag_weight\n        path_lengths = dag_graph.dag_num_nodes\n        # paths shrink by 'order' if we encode them using higher-order nodes\n        paths_lenghts_ho = path_lengths - order\n        # selecting only path that didn t shrink to zero due to higher-order transformation\n        paths_lenghts_ho_filtered = paths_lenghts_ho[paths_lenghts_ho &gt; 0]\n        frequencies = frequencies[paths_lenghts_ho &gt; 0]\n        # start index of the path in the higher order space\n        ixs_start_paths_ho = cumsum(paths_lenghts_ho_filtered)[:-1]\n\n        transition_probabilities = self.layers[order].transition_probabilities()[\n            self.layers[order + 1].data.inverse_idx[ixs_start_paths_ho]\n        ]\n\n        log_transition_probabilities = torch.log(transition_probabilities)\n        llh_by_subpath = torch.mul(frequencies, log_transition_probabilities)\n        return llh_by_subpath.sum().item()\n\n    def get_mon_log_likelihood(self, dag_graph: Data, max_order: int = 1) -&gt; float:\n        \"\"\"Compute the likelihood of the walks given a multi-order model.\n\n        Args:\n            m (MultiOrderModel): The multi-order model.\n            dag_graph (Data): Dataset containing the walks.\n            max_order (int, optional): The maximum order up to which model layers\n                shall be taken into account. Defaults to 1.\n\n        Returns:\n            float: The log likelihood of the walks given the multi-order model.\n        \"\"\"\n        llh = 0.0\n\n        # Adding likelihood of zeroth order\n        llh += self.get_zeroth_order_log_likelihood(dag_graph)\n\n        # Adding the likelihood for all the intermediate orders\n        for order in range(1, max_order):\n            llh += self.get_intermediate_order_log_likelihood(dag_graph, order)\n\n        # Adding the likelihood of highest/stationary order\n        if max_order &gt; 0:\n            transition_probabilities = self.layers[max_order].transition_probabilities(edge_attr=\"edge_weight\")\n            log_transition_probabilities = torch.log(transition_probabilities)\n            llh_by_subpath = log_transition_probabilities * self.layers[max_order].data.edge_weight\n            llh += llh_by_subpath.sum().item()\n        else:\n            # Compute likelihood for zeroth order (to be modified)\n            # TODO: modify once we have zeroth order in mon\n            # (then won t need to compute emission probs from dag_graph -- which also hinders us from computing the lh that a new set of paths was generated by the model)\n            frequencies = dag_graph.dag_weight\n            counts = torch.bincount(\n                dag_graph.node_sequence.squeeze(), frequencies.repeat_interleave(dag_graph.dag_num_nodes)\n            )\n            node_emission_probabilities = counts / counts.sum()\n            llh = torch.mul(torch.log(node_emission_probabilities), counts).sum().item()\n\n        return llh\n\n    def likelihood_ratio_test(\n        self,\n        dag_graph: Data,\n        max_order_null: int = 0,\n        max_order: int = 1,\n        assumption: str = \"paths\",\n        significance_threshold: float = 0.01,\n    ) -&gt; tuple:\n        \"\"\"Perform a likelihood ratio test to compare two models of different order.\n\n        Args:\n            dag_graph (Data): The input DAG graph data.\n            max_order_null (int, optional): The maximum order of the null hypothesis model.\n                Defaults to 0.\n            max_order (int, optional): The maximum order of the alternative hypothesis model.\n                Defaults to 1.\n            assumption (str, optional): The assumption to use for the degrees of freedom calculation.\n                Can be 'paths' or 'ngrams'. Defaults to 'paths'.\n            significance_threshold (float, optional): The significance threshold for the test.\n                Defaults to 0.01.\n\n        Returns:\n            tuple: A tuple containing a boolean indicating whether the null hypothesis is rejected\n                and the p-value of the test.\n        \"\"\"\n        if max_order_null &gt;= max_order:\n            logger.error(\"order of null hypothesis must be smaller than order of alternative hypothesis\")\n            raise ValueError(\"order of null hypothesis must be smaller than order of alternative hypothesis\")\n        if max_order &gt; max(self.layers):\n            logger.error(\"order of hypotheses must be smaller than max. order of MultiOrderModel\")\n            raise ValueError(\n                f\"order of hypotheses ({max_order_null} and {max_order}) must be smaller than max. order of MultiOrderModel {max(self.layers)}\"\n            )\n        # let L0 be the likelihood for the null model and L1 be the likelihood for the alternative model\n\n        # we first compute a test statistic x = -2 * log (L0/L1) = -2 * (log L0 - log L1)\n        x = -2 * (\n            self.get_mon_log_likelihood(dag_graph, max_order=max_order_null)\n            - self.get_mon_log_likelihood(dag_graph, max_order=max_order)\n        )\n\n        # we calculate the additional degrees of freedom in the alternative model\n        dof_diff = self.get_mon_dof(max_order, assumption=assumption) - self.get_mon_dof(\n            max_order_null, assumption=assumption\n        )\n\n        # if the p-value is *below* the significance threshold, we reject the null hypothesis\n        p = 1 - chi2.cdf(x, dof_diff)\n        return (p &lt; significance_threshold), p\n\n    def estimate_order(\n        self, dag_data: PathData, max_order: Optional[int] = None, significance_threshold: float = 0.01\n    ) -&gt; int:\n        \"\"\"Estimate the optimal maximum order of the multi-order network model.\n\n        Selects the optimal maximum order of a multi-order network model for the\n        observed paths, based on a likelihood ratio test with p-value threshold of p\n        By default, all orders up to the maximum order of the multi-order model will be tested.\n\n        Args:\n            dag_data: The path statistics data for which to estimate the optimal order.\n            max_order (int, optional): The maximum order to consider during the estimation process.\n                If not provided, the maximum order of the multi-order model is used.\n            significance_threshold (float, optional): The p-value threshold for the likelihood ratio test.\n                An order is accepted if the improvement in likelihood is significant at this threshold.\n\n        Returns:\n            int: The estimated optimal maximum order for the multi-order network model.\n\n        Raises:\n            ValueError: If the provided max_order is larger than the maximum order of the multi-order model\n                or if the input does not have the same set of nodes as the multi-order network\n        \"\"\"\n        if max_order is None:\n            max_order = max(self.layers)\n        if max_order &gt; max(self.layers):\n            logger.error(\"max_order cannot be larger than maximum order of multi-order network\")\n            raise ValueError(\"max_order cannot be larger than maximum order of multi-order network\")\n        if max_order &lt;= 1:\n            logger.error(\"max_order must be larger than one\")\n            raise ValueError(\"max_order must be larger than one\")\n        if set(dag_data.mapping.node_ids).intersection(set(self.layers[1].mapping.node_ids)) != set(  # type: ignore[arg-type]\n            dag_data.mapping.node_ids  # type: ignore[arg-type]\n        ):\n            logger.error(\"Input paths do not have same set of nodes as multi-order network\")\n            raise ValueError(\"Input paths do not have same set of nodes as multi-order network\")\n\n        max_accepted_order = 1\n        dag_graph = dag_data.data\n\n        # Test for highest order that passes\n        # likelihood ratio test against null model\n        for k in range(2, max_order + 1):\n            if self.likelihood_ratio_test(\n                dag_graph, max_order_null=k - 1, max_order=k, significance_threshold=significance_threshold\n            )[0]:\n                max_accepted_order = k\n\n        return max_accepted_order\n\n    def to_dbgnn_data(self, max_order: int = 2, mapping: str = \"last\") -&gt; Data:\n        \"\"\"Convert the MultiOrderModel to a De Bruijn graph for the given maximum order that can be used in the [DBGNN][pathpyG.nn.dbgnn.DBGNN]-model.\n\n        Args:\n            max_order: The maximum order of the De Bruijn graph to be computed.\n            mapping: The mapping to use for the bipartite edge index. One of \"last\", \"first\", or \"both\".\n\n        Returns:\n            Data: The De Bruijn graph data.\n        \"\"\"\n        if max_order not in self.layers:\n            logger.error(\"Higher-order graph of specified order not found.\")\n            raise ValueError(f\"Higher-order graph of order {max_order} not found.\")\n\n        g = self.layers[1]\n        g_max_order = self.layers[max_order]\n        num_nodes = g.data.num_nodes\n        num_ho_nodes = g_max_order.data.num_nodes\n        if g.data.x is not None:\n            x = g.data.x\n        else:\n            x = torch.eye(num_nodes, num_nodes, device=g.data.edge_index.device)\n        x_max_order = torch.eye(num_ho_nodes, num_ho_nodes, device=g_max_order.data.edge_index.device)\n        edge_index = g.data.edge_index\n        edge_index_max_order = g_max_order.data.edge_index\n        edge_weight = g.data.edge_weight\n        edge_weight_max_order = g_max_order.data.edge_weight\n        bipartite_edge_index = generate_bipartite_edge_index(g, g_max_order, mapping=mapping, device=edge_index.device)\n\n        if g.data.y is not None:\n            y = g.data.y\n\n        return Data(\n            num_nodes=num_nodes,\n            num_ho_nodes=num_ho_nodes,\n            x=x,\n            x_h=x_max_order,\n            edge_index=edge_index,\n            edge_index_higher_order=edge_index_max_order,\n            edge_weights=edge_weight.float(),\n            edge_weights_higher_order=edge_weight_max_order.float(),\n            bipartite_edge_index=bipartite_edge_index,\n            y=y if \"y\" in locals() else None,\n        )\n</code></pre>"},{"location":"reference/pathpyG/core/multi_order_model/#pathpyG.core.multi_order_model.MultiOrderModel.__init__","title":"<code>__init__</code>","text":"<p>Initialize an empty MultiOrderModel.</p> Source code in <code>src/pathpyG/core/multi_order_model.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize an empty MultiOrderModel.\"\"\"\n    self.layers: dict[int, Graph] = {}\n</code></pre>"},{"location":"reference/pathpyG/core/multi_order_model/#pathpyG.core.multi_order_model.MultiOrderModel.__str__","title":"<code>__str__</code>","text":"<p>Return a string representation of the higher-order graph.</p> Source code in <code>src/pathpyG/core/multi_order_model.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the higher-order graph.\"\"\"\n    max_order = max(list(self.layers.keys())) if self.layers else 0\n    s = f\"MultiOrderModel with max. order {max_order}\"\n    return s\n</code></pre>"},{"location":"reference/pathpyG/core/multi_order_model/#pathpyG.core.multi_order_model.MultiOrderModel.estimate_order","title":"<code>estimate_order</code>","text":"<p>Estimate the optimal maximum order of the multi-order network model.</p> <p>Selects the optimal maximum order of a multi-order network model for the observed paths, based on a likelihood ratio test with p-value threshold of p By default, all orders up to the maximum order of the multi-order model will be tested.</p> <p>Parameters:</p> Name Type Description Default <code>dag_data</code> <code>pathpyG.core.path_data.PathData</code> <p>The path statistics data for which to estimate the optimal order.</p> required <code>max_order</code> <code>int</code> <p>The maximum order to consider during the estimation process. If not provided, the maximum order of the multi-order model is used.</p> <code>None</code> <code>significance_threshold</code> <code>float</code> <p>The p-value threshold for the likelihood ratio test. An order is accepted if the improvement in likelihood is significant at this threshold.</p> <code>0.01</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The estimated optimal maximum order for the multi-order network model.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided max_order is larger than the maximum order of the multi-order model or if the input does not have the same set of nodes as the multi-order network</p> Source code in <code>src/pathpyG/core/multi_order_model.py</code> <pre><code>def estimate_order(\n    self, dag_data: PathData, max_order: Optional[int] = None, significance_threshold: float = 0.01\n) -&gt; int:\n    \"\"\"Estimate the optimal maximum order of the multi-order network model.\n\n    Selects the optimal maximum order of a multi-order network model for the\n    observed paths, based on a likelihood ratio test with p-value threshold of p\n    By default, all orders up to the maximum order of the multi-order model will be tested.\n\n    Args:\n        dag_data: The path statistics data for which to estimate the optimal order.\n        max_order (int, optional): The maximum order to consider during the estimation process.\n            If not provided, the maximum order of the multi-order model is used.\n        significance_threshold (float, optional): The p-value threshold for the likelihood ratio test.\n            An order is accepted if the improvement in likelihood is significant at this threshold.\n\n    Returns:\n        int: The estimated optimal maximum order for the multi-order network model.\n\n    Raises:\n        ValueError: If the provided max_order is larger than the maximum order of the multi-order model\n            or if the input does not have the same set of nodes as the multi-order network\n    \"\"\"\n    if max_order is None:\n        max_order = max(self.layers)\n    if max_order &gt; max(self.layers):\n        logger.error(\"max_order cannot be larger than maximum order of multi-order network\")\n        raise ValueError(\"max_order cannot be larger than maximum order of multi-order network\")\n    if max_order &lt;= 1:\n        logger.error(\"max_order must be larger than one\")\n        raise ValueError(\"max_order must be larger than one\")\n    if set(dag_data.mapping.node_ids).intersection(set(self.layers[1].mapping.node_ids)) != set(  # type: ignore[arg-type]\n        dag_data.mapping.node_ids  # type: ignore[arg-type]\n    ):\n        logger.error(\"Input paths do not have same set of nodes as multi-order network\")\n        raise ValueError(\"Input paths do not have same set of nodes as multi-order network\")\n\n    max_accepted_order = 1\n    dag_graph = dag_data.data\n\n    # Test for highest order that passes\n    # likelihood ratio test against null model\n    for k in range(2, max_order + 1):\n        if self.likelihood_ratio_test(\n            dag_graph, max_order_null=k - 1, max_order=k, significance_threshold=significance_threshold\n        )[0]:\n            max_accepted_order = k\n\n    return max_accepted_order\n</code></pre>"},{"location":"reference/pathpyG/core/multi_order_model/#pathpyG.core.multi_order_model.MultiOrderModel.from_path_data","title":"<code>from_path_data</code>  <code>staticmethod</code>","text":"<p>Creates multiple higher-order De Bruijn graphs modelling paths in PathData.</p> <p>Parameters:</p> Name Type Description Default <code>path_data</code> <code>pathpyG.core.path_data.PathData</code> <p>PathData object containing paths as list of Data objects with sorted edge indices, node sequences and num_nodes.</p> required <code>max_order</code> <code>int</code> <p>The maximum order of the MultiOrderModel that should be computed</p> <code>1</code> <code>mode</code> <code>str</code> <p>The process that we assume. Can be \"diffusion\" or \"propagation\".</p> <code>'propagation'</code> <code>cached</code> <code>bool</code> <p>Whether to save the aggregated higher-order graphs smaller than max order in the MultiOrderModel.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>MultiOrderModel</code> <code>pathpyG.core.multi_order_model.MultiOrderModel</code> <p>The MultiOrderModel.</p> Source code in <code>src/pathpyG/core/multi_order_model.py</code> <pre><code>@staticmethod\ndef from_path_data(\n    path_data: PathData, max_order: int = 1, mode: str = \"propagation\", cached: bool = True\n) -&gt; \"MultiOrderModel\":\n    \"\"\"Creates multiple higher-order De Bruijn graphs modelling paths in [PathData][pathpyG.PathData].\n\n    Args:\n        path_data: [PathData][pathpyG.PathData] object containing paths as list of [Data][torch_geometric.data.Data] objects\n            with sorted edge indices, node sequences and num_nodes.\n        max_order: The maximum order of the [MultiOrderModel][pathpyG.MultiOrderModel] that should be computed\n        mode: The process that we assume. Can be \"diffusion\" or \"propagation\".\n        cached: Whether to save the aggregated higher-order graphs smaller than max order\n            in the [MultiOrderModel][pathpyG.MultiOrderModel].\n\n    Returns:\n        MultiOrderModel: The MultiOrderModel.\n    \"\"\"\n    m = MultiOrderModel()\n\n    # We assume that paths are sorted\n    path_graph = path_data.data\n    edge_index = path_graph.edge_index\n    node_sequence = path_graph.node_sequence\n    edge_weight = path_graph.dag_weight.repeat_interleave(path_graph.dag_num_edges)\n    if mode == \"diffusion\":\n        edge_weight = (\n            edge_weight / degree(edge_index[0], dtype=torch.long, num_nodes=node_sequence.size(0))[edge_index[0]]\n        )\n        aggr = \"mul\"\n    elif mode == \"propagation\":\n        aggr = \"src\"\n\n    m.layers[1] = aggregate_edge_index(edge_index=edge_index, node_sequence=node_sequence, edge_weight=edge_weight)\n    m.layers[1].mapping = path_data.mapping\n\n    for k in range(2, max_order + 1):\n        edge_index, node_sequence, edge_weight, gk = MultiOrderModel.iterate_lift_order(\n            edge_index=edge_index,\n            node_sequence=node_sequence,\n            mapping=m.layers[1].mapping,\n            edge_weight=edge_weight,\n            aggr=aggr,\n            save=cached or k == max_order,\n        )\n        if cached or k == max_order:\n            m.layers[k] = gk  # type: ignore[assignment]\n\n    return m\n</code></pre>"},{"location":"reference/pathpyG/core/multi_order_model/#pathpyG.core.multi_order_model.MultiOrderModel.from_temporal_graph","title":"<code>from_temporal_graph</code>  <code>staticmethod</code>","text":"<p>Creates multiple higher-order De Bruijn graph models for paths in a temporal graph.</p> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>pathpyG.core.temporal_graph.TemporalGraph</code> <p>The temporal graph.</p> required <code>delta</code> <code>float | int</code> <p>The maximum time difference between two consecutive edges in a path.</p> <code>1</code> <code>max_order</code> <code>int</code> <p>The maximum order of the MultiOrderModel that should be computed.</p> <code>1</code> <code>weight</code> <code>str</code> <p>The edge attribute to use as edge weight.</p> <code>'edge_weight'</code> <code>cached</code> <code>bool</code> <p>Whether to save the aggregated higher-order graphs smaller than max order in the MultiOrderModel.</p> <code>True</code> <code>event_graph</code> <code>typing.Optional[torch.Tensor]</code> <p>precomputed event graph edge index for given delta to be used for model generation. Useful to prevent the same event graph</p> <code>None</code> <p>Returns:</p> Name Type Description <code>MultiOrderModel</code> <code>pathpyG.core.multi_order_model.MultiOrderModel</code> <p>A multi-order model where each layer is a De Bruijn graph with order k.</p> Source code in <code>src/pathpyG/core/multi_order_model.py</code> <pre><code>@staticmethod\ndef from_temporal_graph(\n    g: TemporalGraph,\n    delta: float | int = 1,\n    max_order: int = 1,\n    weight: str = \"edge_weight\",\n    cached: bool = True,\n    event_graph: Optional[torch.Tensor] = None,\n) -&gt; \"MultiOrderModel\":\n    \"\"\"Creates multiple higher-order De Bruijn graph models for paths in a temporal graph.\n\n    Args:\n        g: The temporal graph.\n        delta: The maximum time difference between two consecutive edges in a path.\n        max_order: The maximum order of the MultiOrderModel that should be computed.\n        weight: The edge attribute to use as edge weight.\n        cached: Whether to save the aggregated higher-order graphs smaller than max order in the MultiOrderModel.\n        event_graph: precomputed event graph edge index for given delta to be used for model generation. Useful to prevent the same event graph\n        from being computed twice.\n\n    Returns:\n        MultiOrderModel: A multi-order model where each layer is a De Bruijn graph with order k.\n    \"\"\"\n    m = MultiOrderModel()\n    if not g.data.is_sorted_by_time():\n        data = g.data.sort_by_time()\n    else:\n        data = g.data\n    edge_index = data.edge_index\n    node_sequence = torch.arange(data.num_nodes, device=edge_index.device).unsqueeze(1)\n    if weight in data:\n        edge_weight = data[weight]\n    else:\n        edge_weight = torch.ones(edge_index.size(1), device=edge_index.device)\n    if cached or max_order == 1:\n        m.layers[1] = aggregate_edge_index(\n            edge_index=edge_index, node_sequence=node_sequence, edge_weight=edge_weight\n        )\n        m.layers[1].mapping = g.mapping\n\n    if max_order &gt; 1:\n        node_sequence = torch.cat([node_sequence[edge_index[0]], node_sequence[edge_index[1]][:, -1:]], dim=1)\n        if event_graph is None:\n            edge_index = lift_order_temporal(g, delta)\n        else:\n            edge_index = event_graph\n        edge_weight = aggregate_node_attributes(edge_index, edge_weight, \"src\")\n\n        # Aggregate\n        if cached or max_order == 2:\n            m.layers[2] = aggregate_edge_index(\n                edge_index=edge_index, node_sequence=node_sequence, edge_weight=edge_weight\n            )\n            m.layers[2].mapping = IndexMap(\n                [tuple(g.mapping.to_ids(v.cpu())) for v in m.layers[2].data.node_sequence]\n            )\n\n        for k in range(3, max_order + 1):\n            edge_index, node_sequence, edge_weight, gk = MultiOrderModel.iterate_lift_order(\n                edge_index=edge_index,\n                node_sequence=node_sequence,\n                mapping=g.mapping,\n                edge_weight=edge_weight,\n                aggr=\"src\",\n                save=cached or k == max_order,\n            )\n            if cached or k == max_order:\n                m.layers[k] = gk  # type: ignore[assignment]\n    return m\n</code></pre>"},{"location":"reference/pathpyG/core/multi_order_model/#pathpyG.core.multi_order_model.MultiOrderModel.get_intermediate_order_log_likelihood","title":"<code>get_intermediate_order_log_likelihood</code>","text":"<p>Compute the intermediate order log likelihood.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>pathpyG.core.multi_order_model.MultiOrderModel</code> <p>Multi-order model.</p> required <code>dag_graph</code> <code>torch_geometric.data.Data</code> <p>Input DAG graph data.</p> required <code>order</code> <code>int</code> <p>Order of the intermediate log likelihood.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Intermediate order log likelihood.</p> Source code in <code>src/pathpyG/core/multi_order_model.py</code> <pre><code>def get_intermediate_order_log_likelihood(self, dag_graph: Data, order: int) -&gt; float:\n    \"\"\"Compute the intermediate order log likelihood.\n\n    Args:\n        m (MultiOrderModel): Multi-order model.\n        dag_graph (Data): Input DAG graph data.\n        order (int): Order of the intermediate log likelihood.\n\n    Returns:\n        float: Intermediate order log likelihood.\n    \"\"\"\n    # Get frequencies\n    frequencies = dag_graph.dag_weight\n    path_lengths = dag_graph.dag_num_nodes\n    # paths shrink by 'order' if we encode them using higher-order nodes\n    paths_lenghts_ho = path_lengths - order\n    # selecting only path that didn t shrink to zero due to higher-order transformation\n    paths_lenghts_ho_filtered = paths_lenghts_ho[paths_lenghts_ho &gt; 0]\n    frequencies = frequencies[paths_lenghts_ho &gt; 0]\n    # start index of the path in the higher order space\n    ixs_start_paths_ho = cumsum(paths_lenghts_ho_filtered)[:-1]\n\n    transition_probabilities = self.layers[order].transition_probabilities()[\n        self.layers[order + 1].data.inverse_idx[ixs_start_paths_ho]\n    ]\n\n    log_transition_probabilities = torch.log(transition_probabilities)\n    llh_by_subpath = torch.mul(frequencies, log_transition_probabilities)\n    return llh_by_subpath.sum().item()\n</code></pre>"},{"location":"reference/pathpyG/core/multi_order_model/#pathpyG.core.multi_order_model.MultiOrderModel.get_mon_dof","title":"<code>get_mon_dof</code>","text":"<p>Calculate the degrees of freedom of the multi-order model.</p> <p>The degrees of freedom for the kth layer of a multi-order model. This depends on the number of different paths of exactly length <code>k</code> in the graph. Therefore, we can obtain these values by summing the entries of the <code>k</code>-th power of the binary adjacency matrix of the graph. Finally, we must consider that, due the conservation of probablility, all non-zero rows of the transition matrix of the higher-order network must sum to one. This poses one additional constraint per row that respects the condition, which should be removed from the total count of degrees of freedom.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>pathpyG.core.multi_order_model.MultiOrderModel</code> <p>The multi-order model.</p> required <code>max_order</code> <code>int</code> <p>The maximum order up to which model layers shall be taken into account. Defaults to None, meaning it considers all available layers.</p> <code>None</code> <code>assumption</code> <code>str</code> <p>If set to 'paths', only paths in the first-order network topology will be considered for the degree of freedom calculation. If set to 'ngrams', all possible n-grams will be considered, independent of whether they are valid paths in the first-order network or not. Defaults to 'paths'.</p> <code>'paths'</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The degrees of freedom for the multi-order model.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If max_order is larger than the maximum order of the multi-order network.</p> <code>ValueError</code> <p>If the assumption is not 'paths' or 'ngrams'.</p> Source code in <code>src/pathpyG/core/multi_order_model.py</code> <pre><code>def get_mon_dof(self, max_order: Optional[int] = None, assumption: str = \"paths\") -&gt; int:\n    \"\"\"Calculate the degrees of freedom of the multi-order model.\n\n    The degrees of freedom for the kth layer of a multi-order model. This depends on the number of different paths of exactly length `k` in the graph.\n    Therefore, we can obtain these values by summing the entries of the `k`-th power of the binary adjacency matrix of the graph.\n    Finally, we must consider that, due the conservation of probablility, all non-zero rows of the transition matrix of the higher-order network must sum to one.\n    This poses one additional constraint per row that respects the condition, which should be removed from the total count of degrees of freedom.\n\n    Args:\n        m (MultiOrderModel): The multi-order model.\n        max_order (int, optional): The maximum order up to which model layers\n            shall be taken into account. Defaults to None, meaning it considers\n            all available layers.\n        assumption (str, optional): If set to 'paths', only paths in the\n            first-order network topology will be considered for the degree of\n            freedom calculation. If set to 'ngrams', all possible n-grams will\n            be considered, independent of whether they are valid paths in the\n            first-order network or not. Defaults to 'paths'.\n\n    Returns:\n        int: The degrees of freedom for the multi-order model.\n\n    Raises:\n        ValueError: If max_order is larger than the maximum order of\n            the multi-order network.\n        ValueError: If the assumption is not 'paths' or 'ngrams'.\n    \"\"\"\n    if max_order is None:\n        max_order = max(self.layers)\n\n    if max_order &gt; max(self.layers):\n        logger.error(\"max_order cannot be larger than maximum order of multi-order network\")\n        raise ValueError(\"max_order cannot be larger than maximum order of multi-order network\")\n\n    dof = self.layers[1].data.num_nodes - 1  # Degrees of freedom for zeroth order\n\n    if assumption == \"paths\":\n        # COMPUTING CONTRIBUTION FROM NUM PATHS AND NONZERO OUTDEGREES SEPARATELY\n        # TODO: CAN IT BE DONE TOGETHER?\n\n        edge_index = self.layers[1].data.edge_index\n        # Adding dof from Number of paths of length k\n        for k in range(1, max_order + 1):\n            if k &gt; 1:\n                num_nodes = 0 if edge_index.numel() == 0 else edge_index.max().item() + 1\n                edge_index = lift_order_edge_index(edge_index, num_nodes)\n            # counting number of len k paths\n            num_len_k_paths = edge_index.shape[1]  # edge_index.max().item() +1  # Number of paths of length k\n            dof += num_len_k_paths\n\n        # removing dof from total probability of nonzero degree nodes\n        for k in range(1, max_order + 1):\n            if k == 1:\n                # edge_index of temporal graph is sorted by time by default\n                # For matrix multiplication, we need to sort it by row\n                edge_index_adj = self.layers[1].data.edge_index.sort_by(\"row\")[0]\n                edge_index = edge_index_adj\n            else:\n                edge_index, _ = edge_index.matmul(edge_index_adj)\n            num_nonzero_outdegrees = torch.unique(edge_index[0]).size(0)\n            dof -= num_nonzero_outdegrees\n\n    elif assumption == \"ngrams\":\n        for order in range(1, max_order + 1):\n            dof += (self.layers[1].data.num_nodes ** order) * (self.layers[1].data.num_nodes - 1)\n    else:\n        logger.error(\"Unknown assumption %s. Only 'path' and 'ngram' are accepted.\", assumption)\n        raise ValueError(f\"Unknown assumption {assumption}. Only 'path' and 'ngram' are accepted.\")\n\n    return int(dof)\n</code></pre>"},{"location":"reference/pathpyG/core/multi_order_model/#pathpyG.core.multi_order_model.MultiOrderModel.get_mon_log_likelihood","title":"<code>get_mon_log_likelihood</code>","text":"<p>Compute the likelihood of the walks given a multi-order model.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>pathpyG.core.multi_order_model.MultiOrderModel</code> <p>The multi-order model.</p> required <code>dag_graph</code> <code>torch_geometric.data.Data</code> <p>Dataset containing the walks.</p> required <code>max_order</code> <code>int</code> <p>The maximum order up to which model layers shall be taken into account. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The log likelihood of the walks given the multi-order model.</p> Source code in <code>src/pathpyG/core/multi_order_model.py</code> <pre><code>def get_mon_log_likelihood(self, dag_graph: Data, max_order: int = 1) -&gt; float:\n    \"\"\"Compute the likelihood of the walks given a multi-order model.\n\n    Args:\n        m (MultiOrderModel): The multi-order model.\n        dag_graph (Data): Dataset containing the walks.\n        max_order (int, optional): The maximum order up to which model layers\n            shall be taken into account. Defaults to 1.\n\n    Returns:\n        float: The log likelihood of the walks given the multi-order model.\n    \"\"\"\n    llh = 0.0\n\n    # Adding likelihood of zeroth order\n    llh += self.get_zeroth_order_log_likelihood(dag_graph)\n\n    # Adding the likelihood for all the intermediate orders\n    for order in range(1, max_order):\n        llh += self.get_intermediate_order_log_likelihood(dag_graph, order)\n\n    # Adding the likelihood of highest/stationary order\n    if max_order &gt; 0:\n        transition_probabilities = self.layers[max_order].transition_probabilities(edge_attr=\"edge_weight\")\n        log_transition_probabilities = torch.log(transition_probabilities)\n        llh_by_subpath = log_transition_probabilities * self.layers[max_order].data.edge_weight\n        llh += llh_by_subpath.sum().item()\n    else:\n        # Compute likelihood for zeroth order (to be modified)\n        # TODO: modify once we have zeroth order in mon\n        # (then won t need to compute emission probs from dag_graph -- which also hinders us from computing the lh that a new set of paths was generated by the model)\n        frequencies = dag_graph.dag_weight\n        counts = torch.bincount(\n            dag_graph.node_sequence.squeeze(), frequencies.repeat_interleave(dag_graph.dag_num_nodes)\n        )\n        node_emission_probabilities = counts / counts.sum()\n        llh = torch.mul(torch.log(node_emission_probabilities), counts).sum().item()\n\n    return llh\n</code></pre>"},{"location":"reference/pathpyG/core/multi_order_model/#pathpyG.core.multi_order_model.MultiOrderModel.get_zeroth_order_log_likelihood","title":"<code>get_zeroth_order_log_likelihood</code>","text":"<p>Compute the zeroth order log likelihood.</p> <p>Parameters:</p> Name Type Description Default <code>dag_graph</code> <code>torch_geometric.data.Data</code> <p>Input DAG graph data.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Zeroth order log likelihood.</p> Source code in <code>src/pathpyG/core/multi_order_model.py</code> <pre><code>def get_zeroth_order_log_likelihood(self, dag_graph: Data) -&gt; float:\n    \"\"\"Compute the zeroth order log likelihood.\n\n    Args:\n        dag_graph (Data): Input DAG graph data.\n\n    Returns:\n        float: Zeroth order log likelihood.\n    \"\"\"\n    # Get frequencies\n    # getting the index of the last edge of each path (to be used to extract weights)\n    frequencies = dag_graph.dag_weight\n\n    # Get ixs starting nodes\n    # Q: Is dag_graph.path_index[:-1] enough to get the start_ixs?\n    mask = torch.ones(dag_graph.num_nodes, dtype=bool)  # type: ignore[call-overload]\n    mask[dag_graph.edge_index[1]] = False\n    start_ixs = dag_graph.node_sequence.squeeze()[mask]\n\n    # Compute node emission probabilities\n    # TODO: modify once we have zeroth order in mon\n    _, counts = torch.unique(dag_graph.node_sequence, return_counts=True)\n    # WARNING: Only works if all nodes in the first-order graph are also in `node_sequence`\n    # Otherwise the missing nodes will not be included in `counts` which can lead to elements at the wrong index.\n    node_emission_probabilities = counts / counts.sum()\n    return torch.mul(frequencies, torch.log(node_emission_probabilities[start_ixs])).sum().item()\n</code></pre>"},{"location":"reference/pathpyG/core/multi_order_model/#pathpyG.core.multi_order_model.MultiOrderModel.iterate_lift_order","title":"<code>iterate_lift_order</code>  <code>staticmethod</code>","text":"<p>Lift order by one and save the result in the layers dictionary of the object.</p> <p>This is a helper function that should not be called directly. Only use for edge_indices after the special cases have been handled e.g. in the from_temporal_graph (filtering non-time-respecting paths of order 2).</p> <p>Parameters:</p> Name Type Description Default <code>edge_index</code> <code>torch.Tensor</code> <p>The edge index of the (k-1)-th order graph.</p> required <code>node_sequence</code> <code>torch.Tensor</code> <p>The node sequences of the (k-1)-th order graph.</p> required <code>mapping</code> <code>pathpyG.core.index_map.IndexMap</code> <p>The IndexMap mapping higher-order nodes to first-order nodes.</p> required <code>edge_weight</code> <code>torch.Tensor | None</code> <p>The edge weights of the (k-1)-th order graph.</p> <code>None</code> <code>k</code> <p>The order of the graph that should be computed.</p> required <code>aggr</code> <code>str</code> <p>The aggregation method to use. One of \"src\", \"dst\", \"max\", \"mul\".</p> <code>'src'</code> <code>save</code> <code>bool</code> <p>Whether to compute the aggregated graph and later save it in the layers dictionary.</p> <code>True</code> Source code in <code>src/pathpyG/core/multi_order_model.py</code> <pre><code>@staticmethod\ndef iterate_lift_order(\n    edge_index: torch.Tensor,\n    node_sequence: torch.Tensor,\n    mapping: IndexMap,\n    edge_weight: torch.Tensor | None = None,\n    aggr: str = \"src\",\n    save: bool = True,\n) -&gt; tuple[torch.Tensor, torch.Tensor, torch.Tensor | None, Graph | None]:\n    \"\"\"Lift order by one and save the result in the layers dictionary of the object.\n\n    This is a helper function that should not be called directly.\n    Only use for edge_indices after the special cases have been handled e.g.\n    in the from_temporal_graph (filtering non-time-respecting paths of order 2).\n\n    Args:\n        edge_index: The edge index of the (k-1)-th order graph.\n        node_sequence: The node sequences of the (k-1)-th order graph.\n        mapping: The [IndexMap][pathpyG.IndexMap] mapping higher-order nodes to first-order nodes.\n        edge_weight: The edge weights of the (k-1)-th order graph.\n        k: The order of the graph that should be computed.\n        aggr: The aggregation method to use. One of \"src\", \"dst\", \"max\", \"mul\".\n        save: Whether to compute the aggregated graph and later save it in the layers dictionary.\n    \"\"\"\n    # Lift order\n    if edge_weight is None:\n        ho_index = lift_order_edge_index(edge_index, num_nodes=node_sequence.size(0))\n    else:\n        ho_index, edge_weight = lift_order_edge_index_weighted(\n            edge_index, edge_weight=edge_weight, num_nodes=node_sequence.size(0), aggr=aggr\n        )\n    node_sequence = torch.cat([node_sequence[edge_index[0]], node_sequence[edge_index[1]][:, -1:]], dim=1)\n\n    # Aggregate\n    if save:\n        gk = aggregate_edge_index(ho_index, node_sequence, edge_weight)\n        gk.mapping = IndexMap([tuple(mapping.to_ids(v.cpu())) for v in gk.data.node_sequence])\n    else:\n        gk = None\n    return ho_index, node_sequence, edge_weight, gk\n</code></pre>"},{"location":"reference/pathpyG/core/multi_order_model/#pathpyG.core.multi_order_model.MultiOrderModel.likelihood_ratio_test","title":"<code>likelihood_ratio_test</code>","text":"<p>Perform a likelihood ratio test to compare two models of different order.</p> <p>Parameters:</p> Name Type Description Default <code>dag_graph</code> <code>torch_geometric.data.Data</code> <p>The input DAG graph data.</p> required <code>max_order_null</code> <code>int</code> <p>The maximum order of the null hypothesis model. Defaults to 0.</p> <code>0</code> <code>max_order</code> <code>int</code> <p>The maximum order of the alternative hypothesis model. Defaults to 1.</p> <code>1</code> <code>assumption</code> <code>str</code> <p>The assumption to use for the degrees of freedom calculation. Can be 'paths' or 'ngrams'. Defaults to 'paths'.</p> <code>'paths'</code> <code>significance_threshold</code> <code>float</code> <p>The significance threshold for the test. Defaults to 0.01.</p> <code>0.01</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing a boolean indicating whether the null hypothesis is rejected and the p-value of the test.</p> Source code in <code>src/pathpyG/core/multi_order_model.py</code> <pre><code>def likelihood_ratio_test(\n    self,\n    dag_graph: Data,\n    max_order_null: int = 0,\n    max_order: int = 1,\n    assumption: str = \"paths\",\n    significance_threshold: float = 0.01,\n) -&gt; tuple:\n    \"\"\"Perform a likelihood ratio test to compare two models of different order.\n\n    Args:\n        dag_graph (Data): The input DAG graph data.\n        max_order_null (int, optional): The maximum order of the null hypothesis model.\n            Defaults to 0.\n        max_order (int, optional): The maximum order of the alternative hypothesis model.\n            Defaults to 1.\n        assumption (str, optional): The assumption to use for the degrees of freedom calculation.\n            Can be 'paths' or 'ngrams'. Defaults to 'paths'.\n        significance_threshold (float, optional): The significance threshold for the test.\n            Defaults to 0.01.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the null hypothesis is rejected\n            and the p-value of the test.\n    \"\"\"\n    if max_order_null &gt;= max_order:\n        logger.error(\"order of null hypothesis must be smaller than order of alternative hypothesis\")\n        raise ValueError(\"order of null hypothesis must be smaller than order of alternative hypothesis\")\n    if max_order &gt; max(self.layers):\n        logger.error(\"order of hypotheses must be smaller than max. order of MultiOrderModel\")\n        raise ValueError(\n            f\"order of hypotheses ({max_order_null} and {max_order}) must be smaller than max. order of MultiOrderModel {max(self.layers)}\"\n        )\n    # let L0 be the likelihood for the null model and L1 be the likelihood for the alternative model\n\n    # we first compute a test statistic x = -2 * log (L0/L1) = -2 * (log L0 - log L1)\n    x = -2 * (\n        self.get_mon_log_likelihood(dag_graph, max_order=max_order_null)\n        - self.get_mon_log_likelihood(dag_graph, max_order=max_order)\n    )\n\n    # we calculate the additional degrees of freedom in the alternative model\n    dof_diff = self.get_mon_dof(max_order, assumption=assumption) - self.get_mon_dof(\n        max_order_null, assumption=assumption\n    )\n\n    # if the p-value is *below* the significance threshold, we reject the null hypothesis\n    p = 1 - chi2.cdf(x, dof_diff)\n    return (p &lt; significance_threshold), p\n</code></pre>"},{"location":"reference/pathpyG/core/multi_order_model/#pathpyG.core.multi_order_model.MultiOrderModel.to","title":"<code>to</code>","text":"<p>Convert the graph layers to the given device.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>torch.device</code> <p>The device to convert the graph layers to.</p> required <p>Returns: The MultiOrderModel with graph layers on the given device.</p> Source code in <code>src/pathpyG/core/multi_order_model.py</code> <pre><code>def to(self, device: torch.device) -&gt; \"MultiOrderModel\":\n    \"\"\"Convert the graph layers to the given device.\n\n    Args:\n        device: The device to convert the graph layers to.\n\n    Returns: The MultiOrderModel with graph layers on the given device.\n    \"\"\"\n    for g in self.layers.values():\n        g.to(device)\n    return self\n</code></pre>"},{"location":"reference/pathpyG/core/multi_order_model/#pathpyG.core.multi_order_model.MultiOrderModel.to_dbgnn_data","title":"<code>to_dbgnn_data</code>","text":"<p>Convert the MultiOrderModel to a De Bruijn graph for the given maximum order that can be used in the DBGNN-model.</p> <p>Parameters:</p> Name Type Description Default <code>max_order</code> <code>int</code> <p>The maximum order of the De Bruijn graph to be computed.</p> <code>2</code> <code>mapping</code> <code>str</code> <p>The mapping to use for the bipartite edge index. One of \"last\", \"first\", or \"both\".</p> <code>'last'</code> <p>Returns:</p> Name Type Description <code>Data</code> <code>torch_geometric.data.Data</code> <p>The De Bruijn graph data.</p> Source code in <code>src/pathpyG/core/multi_order_model.py</code> <pre><code>def to_dbgnn_data(self, max_order: int = 2, mapping: str = \"last\") -&gt; Data:\n    \"\"\"Convert the MultiOrderModel to a De Bruijn graph for the given maximum order that can be used in the [DBGNN][pathpyG.nn.dbgnn.DBGNN]-model.\n\n    Args:\n        max_order: The maximum order of the De Bruijn graph to be computed.\n        mapping: The mapping to use for the bipartite edge index. One of \"last\", \"first\", or \"both\".\n\n    Returns:\n        Data: The De Bruijn graph data.\n    \"\"\"\n    if max_order not in self.layers:\n        logger.error(\"Higher-order graph of specified order not found.\")\n        raise ValueError(f\"Higher-order graph of order {max_order} not found.\")\n\n    g = self.layers[1]\n    g_max_order = self.layers[max_order]\n    num_nodes = g.data.num_nodes\n    num_ho_nodes = g_max_order.data.num_nodes\n    if g.data.x is not None:\n        x = g.data.x\n    else:\n        x = torch.eye(num_nodes, num_nodes, device=g.data.edge_index.device)\n    x_max_order = torch.eye(num_ho_nodes, num_ho_nodes, device=g_max_order.data.edge_index.device)\n    edge_index = g.data.edge_index\n    edge_index_max_order = g_max_order.data.edge_index\n    edge_weight = g.data.edge_weight\n    edge_weight_max_order = g_max_order.data.edge_weight\n    bipartite_edge_index = generate_bipartite_edge_index(g, g_max_order, mapping=mapping, device=edge_index.device)\n\n    if g.data.y is not None:\n        y = g.data.y\n\n    return Data(\n        num_nodes=num_nodes,\n        num_ho_nodes=num_ho_nodes,\n        x=x,\n        x_h=x_max_order,\n        edge_index=edge_index,\n        edge_index_higher_order=edge_index_max_order,\n        edge_weights=edge_weight.float(),\n        edge_weights_higher_order=edge_weight_max_order.float(),\n        bipartite_edge_index=bipartite_edge_index,\n        y=y if \"y\" in locals() else None,\n    )\n</code></pre>"},{"location":"reference/pathpyG/core/path_data/","title":"path_data","text":"<p>Module for storing path data in a PyTorch Geometric Data object.</p>"},{"location":"reference/pathpyG/core/path_data/#pathpyG.core.path_data.PathData","title":"<code>PathData</code>","text":"<p>Class that can be used to store multiple observations of node sequences representing paths or walks.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>torch_geometric.data.Data</code> <p>PyG Data object containing paths and attributes.</p> <code>mapping</code> <code>pathpyG.core.index_map.IndexMap</code> <p>Mapping from node IDs to indices.</p> Info <p>The <code>data</code> attribute is a PyG Data object that contains the following attributes:</p> <ul> <li><code>edge_index</code>: Edge index (as Tensor) of all stored paths concatenated to a graph with multiple components.     Each node is mapped to a unique index so that it is possible to store multiple paths with the same nodes     in different paths and repeating nodes in the same path without ambiguity.</li> <li><code>node_sequence</code>: Node sequence tensor of shape <code>(total_nodes, 1)</code> where each entry corresponds     to the index of the node in the underlying graph and mapping.</li> <li><code>dag_weight</code>: Tensor of shape <code>(num_paths,)</code> containing the weight of each stored path.</li> <li><code>dag_num_edges</code>: Tensor of shape <code>(num_paths,)</code> containing the number of edges in each stored path.</li> <li><code>dag_num_nodes</code>: Tensor of shape <code>(num_paths,)</code> containing the number of nodes in each stored path.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; # Generate toy example graph\n&gt;&gt;&gt; g = pp.Graph.from_edge_list([('a', 'c'),\n...                      ('b', 'c'),\n...                      ('c', 'd'),\n...                      ('c', 'e')])\n&gt;&gt;&gt; # Store observations of walks using the index mapping\n&gt;&gt;&gt; # from the graph above\n&gt;&gt;&gt; paths = pp.PathData(g.mapping)\n&gt;&gt;&gt; paths.append_walk((\"a\", \"c\", \"d\"), weight=2.0)\n&gt;&gt;&gt; paths.append_walk((\"b\", \"c\", \"e\"), weight=2.0)\n&gt;&gt;&gt; print(paths)\nPathData with 2 paths with total weight 4.0\n</code></pre> Source code in <code>src/pathpyG/core/path_data.py</code> <pre><code>class PathData:\n    \"\"\"Class that can be used to store multiple observations of node sequences representing paths or walks.\n\n    Attributes:\n        data (Data): PyG Data object containing paths and attributes.\n        mapping (IndexMap): Mapping from node IDs to indices.\n\n    Info:\n        The `data` attribute is a PyG Data object that contains the following attributes:\n\n        - `edge_index`: Edge index (as [Tensor][torch.Tensor]) of all stored paths concatenated to a graph with multiple components.\n            Each node is mapped to a unique index so that it is possible to store multiple paths with the same nodes\n            in different paths and repeating nodes in the same path without ambiguity.\n        - `node_sequence`: Node sequence [tensor][torch.Tensor] of shape `(total_nodes, 1)` where each entry corresponds\n            to the index of the node in the underlying graph and mapping.\n        - `dag_weight`: [Tensor][torch.Tensor] of shape `(num_paths,)` containing the weight of each stored path.\n        - `dag_num_edges`: [Tensor][torch.Tensor] of shape `(num_paths,)` containing the number of edges in each stored path.\n        - `dag_num_nodes`: [Tensor][torch.Tensor] of shape `(num_paths,)` containing the number of nodes in each stored path.\n\n    Examples:\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; # Generate toy example graph\n        &gt;&gt;&gt; g = pp.Graph.from_edge_list([('a', 'c'),\n        ...                      ('b', 'c'),\n        ...                      ('c', 'd'),\n        ...                      ('c', 'e')])\n        &gt;&gt;&gt; # Store observations of walks using the index mapping\n        &gt;&gt;&gt; # from the graph above\n        &gt;&gt;&gt; paths = pp.PathData(g.mapping)\n        &gt;&gt;&gt; paths.append_walk((\"a\", \"c\", \"d\"), weight=2.0)\n        &gt;&gt;&gt; paths.append_walk((\"b\", \"c\", \"e\"), weight=2.0)\n        &gt;&gt;&gt; print(paths)\n        PathData with 2 paths with total weight 4.0\n    \"\"\"\n\n    def __init__(self, mapping: IndexMap | None = None, device: torch.device | None = None) -&gt; None:\n        \"\"\"Initialize an empty PathData object.\n\n        Args:\n            mapping: IndexMap object to map node IDs to indices and vice versa. If None, a new IndexMap will be created.\n            device: Device to store the data on. If None, the default device will be used.\n        \"\"\"\n        if mapping:\n            self.mapping = mapping\n        else:\n            self.mapping = IndexMap()\n        self.data: Data = Data(\n            edge_index=torch.empty((2, 0), dtype=torch.long, device=device),\n            node_sequence=torch.empty((0, 1), dtype=torch.long, device=device),\n            dag_weight=torch.empty(0, dtype=torch.float, device=device),\n            dag_num_edges=torch.empty(0, dtype=torch.long, device=device),\n            dag_num_nodes=torch.empty(0, dtype=torch.long, device=device),\n        )\n        self.data.num_nodes = 0\n\n    @property\n    def num_paths(self) -&gt; int:\n        \"\"\"Return the number of stored paths.\"\"\"\n        return len(self.data.dag_num_edges)\n\n    def _append_data(\n        self,\n        edge_index: torch.Tensor,\n        node_sequence: torch.Tensor,\n        weights: torch.Tensor,\n        num_edges: torch.Tensor,\n        num_nodes: torch.Tensor,\n    ) -&gt; None:\n        \"\"\"Append an edge_index and a node_sequence to the PathData object and reassign the indices so that there is no overlap.\n\n        Args:\n            edge_index: Edge index of the new path(s)\n            node_sequence: Node sequence of the new path(s)\n            weights: Weights of the new path(s)\n            num_edges: Number of edges in the new path(s)\n            num_nodes: Number of nodes in the new path(s)\n        \"\"\"\n        new_edge_index = edge_index + self.data.num_nodes\n        self.data.edge_index = torch.cat([self.data.edge_index, new_edge_index], dim=1)\n        self.data.node_sequence = torch.cat([self.data.node_sequence, node_sequence])\n        self.data.dag_weight = torch.cat([self.data.dag_weight, weights])\n        self.data.dag_num_edges = torch.cat([self.data.dag_num_edges, num_edges])\n        self.data.dag_num_nodes = torch.cat([self.data.dag_num_nodes, num_nodes])\n        self.data.num_nodes += num_nodes.sum().item()\n\n    def to(self, device: torch.device) -&gt; \"PathData\":\n        \"\"\"Moves all paths to the given device.\"\"\"\n        self.data = self.data.to(device)\n        return self\n\n    def append_walk(self, node_seq: list | tuple, weight: float = 1.0) -&gt; None:\n        \"\"\"Add an observation of a walk based on a list or tuple of node IDs or indices.\n\n        Args:\n            node_seq: List or tuple of node IDs\n            weight: Weight of the walk\n\n        Examples:\n            &gt;&gt;&gt; import pathpyG as pp\n            &gt;&gt;&gt; mapping = pp.IndexMap([\"a\", \"b\", \"c\", \"d\", \"e\"])\n            &gt;&gt;&gt; walks = pp.PathData(mapping)\n            &gt;&gt;&gt; walks.append_walk((\"a\", \"c\", \"d\"), weight=2.0)\n            &gt;&gt;&gt; walks.append_walk((\"b\", \"c\", \"e\"), weight=1.0)\n        \"\"\"\n        idx_seq = self.mapping.to_idxs(node_seq, device=self.data.edge_index.device).unsqueeze(1)\n        idx = torch.arange(len(node_seq), device=self.data.edge_index.device)\n        edge_index = torch.stack([idx[:-1], idx[1:]])\n\n        self._append_data(\n            edge_index=edge_index,\n            node_sequence=idx_seq,\n            weights=torch.tensor([weight], device=self.data.edge_index.device),\n            num_edges=torch.tensor([edge_index.shape[1]], device=self.data.edge_index.device),\n            num_nodes=torch.tensor([len(node_seq)], device=self.data.edge_index.device),\n        )\n\n    def append_walks(self, node_seqs: list | tuple, weights: list | tuple) -&gt; None:\n        \"\"\"Add multiple observations of walks based on lists or tuples of node IDs or indices.\n\n        Args:\n            node_seqs: List or tuple of lists or tuples of node IDs\n            weights: List or tuple of weights for each walk\n\n        Examples:\n            &gt;&gt;&gt; import pathpyG as pp\n            &gt;&gt;&gt; mapping = pp.IndexMap([\"a\", \"b\", \"c\", \"d\", \"e\"])\n            &gt;&gt;&gt; walks = pp.PathData(mapping)\n            &gt;&gt;&gt; walks.append_walks([[\"a\", \"c\", \"d\"], [\"b\", \"c\", \"e\"]], [2.0, 1.0])\n        \"\"\"\n        idx_seqs = torch.cat(\n            [self.mapping.to_idxs(seq, device=self.data.edge_index.device) for seq in node_seqs]\n        ).unsqueeze(1)\n        dag_num_nodes = torch.tensor([len(seq) for seq in node_seqs], device=self.data.edge_index.device)\n\n        big_idx = torch.arange(dag_num_nodes.sum().item(), device=self.data.edge_index.device)\n        big_edge_index = torch.stack([big_idx[:-1], big_idx[1:]])\n\n        # remove the edges that connect different walks\n        mask = torch.ones(big_edge_index.size(1), dtype=torch.bool, device=self.data.edge_index.device)\n        cum_sum = cumsum(dag_num_nodes, 0)\n        mask[cum_sum[1:-1] - 1] = False\n        big_edge_index = big_edge_index[:, mask]\n\n        self._append_data(\n            edge_index=big_edge_index,\n            node_sequence=idx_seqs,\n            weights=torch.tensor(weights, device=self.data.edge_index.device),\n            num_edges=dag_num_nodes - 1,\n            num_nodes=dag_num_nodes,\n        )\n\n    def get_walk(self, i: int) -&gt; tuple:\n        \"\"\"Return the i-th walk (based on when it was appended) as a tuple of node IDs.\n\n        Args:\n            i: Index of the walk to retrieve\n\n        Returns:\n            Tuple of node IDs representing the i-th walk\n\n        Examples:\n            &gt;&gt;&gt; import pathpyG as pp\n            &gt;&gt;&gt; mapping = pp.IndexMap([\"a\", \"b\", \"c\", \"d\", \"e\"])\n            &gt;&gt;&gt; walks = pp.PathData(mapping)\n            &gt;&gt;&gt; walks.append_walk((\"a\", \"c\", \"d\"), weight=2.0)\n            &gt;&gt;&gt; walks.get_walk(0)\n            ('a', 'c', 'd')\n        \"\"\"\n        start = self.data.dag_num_nodes[:i].sum().item()\n        end = start + self.data.dag_num_nodes[i].item()\n        return tuple(self.mapping.to_ids(self.data.node_sequence[start:end].squeeze()).tolist())\n\n    def map_node_seq(self, node_seq: list | tuple) -&gt; list:\n        \"\"\"Map a sequence of node indices (e.g. representing a higher-order node) to node IDs.\n\n        Args:\n            node_seq: List or tuple of node indices\n\n        Returns:\n            List of node IDs corresponding to the input node indices\n\n        Examples:\n            &gt;&gt;&gt; import pathpyG as pp\n            &gt;&gt;&gt; mapping = pp.IndexMap([\"a\", \"b\", \"c\", \"d\", \"e\"])\n            &gt;&gt;&gt; walks = pp.PathData(mapping)\n            &gt;&gt;&gt; walks.map_node_seq([0, 2, 3])\n            ['a', 'c', 'd']\n        \"\"\"\n        return self.mapping.to_ids(node_seq).tolist()\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the PathData object.\"\"\"\n        weight = self.data.dag_weight.sum().item()\n        s = f\"PathData with {self.num_paths} paths with total weight {weight}\"\n        return s\n</code></pre>"},{"location":"reference/pathpyG/core/path_data/#pathpyG.core.path_data.PathData.num_paths","title":"<code>num_paths</code>  <code>property</code>","text":"<p>Return the number of stored paths.</p>"},{"location":"reference/pathpyG/core/path_data/#pathpyG.core.path_data.PathData.__init__","title":"<code>__init__</code>","text":"<p>Initialize an empty PathData object.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>pathpyG.core.index_map.IndexMap | None</code> <p>IndexMap object to map node IDs to indices and vice versa. If None, a new IndexMap will be created.</p> <code>None</code> <code>device</code> <code>torch.device | None</code> <p>Device to store the data on. If None, the default device will be used.</p> <code>None</code> Source code in <code>src/pathpyG/core/path_data.py</code> <pre><code>def __init__(self, mapping: IndexMap | None = None, device: torch.device | None = None) -&gt; None:\n    \"\"\"Initialize an empty PathData object.\n\n    Args:\n        mapping: IndexMap object to map node IDs to indices and vice versa. If None, a new IndexMap will be created.\n        device: Device to store the data on. If None, the default device will be used.\n    \"\"\"\n    if mapping:\n        self.mapping = mapping\n    else:\n        self.mapping = IndexMap()\n    self.data: Data = Data(\n        edge_index=torch.empty((2, 0), dtype=torch.long, device=device),\n        node_sequence=torch.empty((0, 1), dtype=torch.long, device=device),\n        dag_weight=torch.empty(0, dtype=torch.float, device=device),\n        dag_num_edges=torch.empty(0, dtype=torch.long, device=device),\n        dag_num_nodes=torch.empty(0, dtype=torch.long, device=device),\n    )\n    self.data.num_nodes = 0\n</code></pre>"},{"location":"reference/pathpyG/core/path_data/#pathpyG.core.path_data.PathData.__str__","title":"<code>__str__</code>","text":"<p>Return a string representation of the PathData object.</p> Source code in <code>src/pathpyG/core/path_data.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the PathData object.\"\"\"\n    weight = self.data.dag_weight.sum().item()\n    s = f\"PathData with {self.num_paths} paths with total weight {weight}\"\n    return s\n</code></pre>"},{"location":"reference/pathpyG/core/path_data/#pathpyG.core.path_data.PathData.append_walk","title":"<code>append_walk</code>","text":"<p>Add an observation of a walk based on a list or tuple of node IDs or indices.</p> <p>Parameters:</p> Name Type Description Default <code>node_seq</code> <code>list | tuple</code> <p>List or tuple of node IDs</p> required <code>weight</code> <code>float</code> <p>Weight of the walk</p> <code>1.0</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; mapping = pp.IndexMap([\"a\", \"b\", \"c\", \"d\", \"e\"])\n&gt;&gt;&gt; walks = pp.PathData(mapping)\n&gt;&gt;&gt; walks.append_walk((\"a\", \"c\", \"d\"), weight=2.0)\n&gt;&gt;&gt; walks.append_walk((\"b\", \"c\", \"e\"), weight=1.0)\n</code></pre> Source code in <code>src/pathpyG/core/path_data.py</code> <pre><code>def append_walk(self, node_seq: list | tuple, weight: float = 1.0) -&gt; None:\n    \"\"\"Add an observation of a walk based on a list or tuple of node IDs or indices.\n\n    Args:\n        node_seq: List or tuple of node IDs\n        weight: Weight of the walk\n\n    Examples:\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; mapping = pp.IndexMap([\"a\", \"b\", \"c\", \"d\", \"e\"])\n        &gt;&gt;&gt; walks = pp.PathData(mapping)\n        &gt;&gt;&gt; walks.append_walk((\"a\", \"c\", \"d\"), weight=2.0)\n        &gt;&gt;&gt; walks.append_walk((\"b\", \"c\", \"e\"), weight=1.0)\n    \"\"\"\n    idx_seq = self.mapping.to_idxs(node_seq, device=self.data.edge_index.device).unsqueeze(1)\n    idx = torch.arange(len(node_seq), device=self.data.edge_index.device)\n    edge_index = torch.stack([idx[:-1], idx[1:]])\n\n    self._append_data(\n        edge_index=edge_index,\n        node_sequence=idx_seq,\n        weights=torch.tensor([weight], device=self.data.edge_index.device),\n        num_edges=torch.tensor([edge_index.shape[1]], device=self.data.edge_index.device),\n        num_nodes=torch.tensor([len(node_seq)], device=self.data.edge_index.device),\n    )\n</code></pre>"},{"location":"reference/pathpyG/core/path_data/#pathpyG.core.path_data.PathData.append_walks","title":"<code>append_walks</code>","text":"<p>Add multiple observations of walks based on lists or tuples of node IDs or indices.</p> <p>Parameters:</p> Name Type Description Default <code>node_seqs</code> <code>list | tuple</code> <p>List or tuple of lists or tuples of node IDs</p> required <code>weights</code> <code>list | tuple</code> <p>List or tuple of weights for each walk</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; mapping = pp.IndexMap([\"a\", \"b\", \"c\", \"d\", \"e\"])\n&gt;&gt;&gt; walks = pp.PathData(mapping)\n&gt;&gt;&gt; walks.append_walks([[\"a\", \"c\", \"d\"], [\"b\", \"c\", \"e\"]], [2.0, 1.0])\n</code></pre> Source code in <code>src/pathpyG/core/path_data.py</code> <pre><code>def append_walks(self, node_seqs: list | tuple, weights: list | tuple) -&gt; None:\n    \"\"\"Add multiple observations of walks based on lists or tuples of node IDs or indices.\n\n    Args:\n        node_seqs: List or tuple of lists or tuples of node IDs\n        weights: List or tuple of weights for each walk\n\n    Examples:\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; mapping = pp.IndexMap([\"a\", \"b\", \"c\", \"d\", \"e\"])\n        &gt;&gt;&gt; walks = pp.PathData(mapping)\n        &gt;&gt;&gt; walks.append_walks([[\"a\", \"c\", \"d\"], [\"b\", \"c\", \"e\"]], [2.0, 1.0])\n    \"\"\"\n    idx_seqs = torch.cat(\n        [self.mapping.to_idxs(seq, device=self.data.edge_index.device) for seq in node_seqs]\n    ).unsqueeze(1)\n    dag_num_nodes = torch.tensor([len(seq) for seq in node_seqs], device=self.data.edge_index.device)\n\n    big_idx = torch.arange(dag_num_nodes.sum().item(), device=self.data.edge_index.device)\n    big_edge_index = torch.stack([big_idx[:-1], big_idx[1:]])\n\n    # remove the edges that connect different walks\n    mask = torch.ones(big_edge_index.size(1), dtype=torch.bool, device=self.data.edge_index.device)\n    cum_sum = cumsum(dag_num_nodes, 0)\n    mask[cum_sum[1:-1] - 1] = False\n    big_edge_index = big_edge_index[:, mask]\n\n    self._append_data(\n        edge_index=big_edge_index,\n        node_sequence=idx_seqs,\n        weights=torch.tensor(weights, device=self.data.edge_index.device),\n        num_edges=dag_num_nodes - 1,\n        num_nodes=dag_num_nodes,\n    )\n</code></pre>"},{"location":"reference/pathpyG/core/path_data/#pathpyG.core.path_data.PathData.get_walk","title":"<code>get_walk</code>","text":"<p>Return the i-th walk (based on when it was appended) as a tuple of node IDs.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int</code> <p>Index of the walk to retrieve</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of node IDs representing the i-th walk</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; mapping = pp.IndexMap([\"a\", \"b\", \"c\", \"d\", \"e\"])\n&gt;&gt;&gt; walks = pp.PathData(mapping)\n&gt;&gt;&gt; walks.append_walk((\"a\", \"c\", \"d\"), weight=2.0)\n&gt;&gt;&gt; walks.get_walk(0)\n('a', 'c', 'd')\n</code></pre> Source code in <code>src/pathpyG/core/path_data.py</code> <pre><code>def get_walk(self, i: int) -&gt; tuple:\n    \"\"\"Return the i-th walk (based on when it was appended) as a tuple of node IDs.\n\n    Args:\n        i: Index of the walk to retrieve\n\n    Returns:\n        Tuple of node IDs representing the i-th walk\n\n    Examples:\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; mapping = pp.IndexMap([\"a\", \"b\", \"c\", \"d\", \"e\"])\n        &gt;&gt;&gt; walks = pp.PathData(mapping)\n        &gt;&gt;&gt; walks.append_walk((\"a\", \"c\", \"d\"), weight=2.0)\n        &gt;&gt;&gt; walks.get_walk(0)\n        ('a', 'c', 'd')\n    \"\"\"\n    start = self.data.dag_num_nodes[:i].sum().item()\n    end = start + self.data.dag_num_nodes[i].item()\n    return tuple(self.mapping.to_ids(self.data.node_sequence[start:end].squeeze()).tolist())\n</code></pre>"},{"location":"reference/pathpyG/core/path_data/#pathpyG.core.path_data.PathData.map_node_seq","title":"<code>map_node_seq</code>","text":"<p>Map a sequence of node indices (e.g. representing a higher-order node) to node IDs.</p> <p>Parameters:</p> Name Type Description Default <code>node_seq</code> <code>list | tuple</code> <p>List or tuple of node indices</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of node IDs corresponding to the input node indices</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; mapping = pp.IndexMap([\"a\", \"b\", \"c\", \"d\", \"e\"])\n&gt;&gt;&gt; walks = pp.PathData(mapping)\n&gt;&gt;&gt; walks.map_node_seq([0, 2, 3])\n['a', 'c', 'd']\n</code></pre> Source code in <code>src/pathpyG/core/path_data.py</code> <pre><code>def map_node_seq(self, node_seq: list | tuple) -&gt; list:\n    \"\"\"Map a sequence of node indices (e.g. representing a higher-order node) to node IDs.\n\n    Args:\n        node_seq: List or tuple of node indices\n\n    Returns:\n        List of node IDs corresponding to the input node indices\n\n    Examples:\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; mapping = pp.IndexMap([\"a\", \"b\", \"c\", \"d\", \"e\"])\n        &gt;&gt;&gt; walks = pp.PathData(mapping)\n        &gt;&gt;&gt; walks.map_node_seq([0, 2, 3])\n        ['a', 'c', 'd']\n    \"\"\"\n    return self.mapping.to_ids(node_seq).tolist()\n</code></pre>"},{"location":"reference/pathpyG/core/path_data/#pathpyG.core.path_data.PathData.to","title":"<code>to</code>","text":"<p>Moves all paths to the given device.</p> Source code in <code>src/pathpyG/core/path_data.py</code> <pre><code>def to(self, device: torch.device) -&gt; \"PathData\":\n    \"\"\"Moves all paths to the given device.\"\"\"\n    self.data = self.data.to(device)\n    return self\n</code></pre>"},{"location":"reference/pathpyG/core/temporal_graph/","title":"temporal_graph","text":"<p>Temporal Graph class for handling time-stamped edges.</p>"},{"location":"reference/pathpyG/core/temporal_graph/#pathpyG.core.temporal_graph.TemporalGraph","title":"<code>TemporalGraph</code>","text":"<p>               Bases: <code>pathpyG.Graph</code></p> <p>Class representing a temporal graph with time-stamped edges.</p> Info <p>The <code>data</code> attribute is a PyG Data object that contains the following attributes:</p> <ul> <li><code>edge_index</code>: Edge index tensor of shape <code>(2, num_edges)</code> representing directed edges.</li> <li><code>time</code>: Tensor of shape <code>(num_edges,)</code> containing timestamps for each edge.</li> </ul> <p>Attributes:</p> Name Type Description <code>data</code> <code>torch_geometric.data.Data</code> <p>PyG Data object containing temporal edges and attributes.</p> <code>mapping</code> <code>pathpyG.core.index_map.IndexMap</code> <p>Mapping from node IDs to indices.</p> <code>edge_to_index</code> <code>dict</code> <p>Mapping from edge tuples to their indices.</p> <code>tedge_to_index</code> <code>dict</code> <p>Mapping from temporal edge tuples to their indices.</p> Source code in <code>src/pathpyG/core/temporal_graph.py</code> <pre><code>class TemporalGraph(Graph):\n    \"\"\"Class representing a temporal graph with time-stamped edges.\n\n    Info:\n        The [`data`][torch_geometric.data.Data] attribute is a PyG Data object that contains the following attributes:\n\n        - `edge_index`: [Edge index][torch_geometric.EdgeIndex] tensor of shape `(2, num_edges)` representing directed edges.\n        - `time`: [Tensor][torch.Tensor] of shape `(num_edges,)` containing timestamps for each edge.\n\n    Attributes:\n        data (Data): PyG Data object containing temporal edges and attributes.\n        mapping (IndexMap): Mapping from node IDs to indices.\n        edge_to_index (dict): Mapping from edge tuples to their indices.\n        tedge_to_index (dict): Mapping from temporal edge tuples to their indices.\n    \"\"\"\n\n    def __init__(self, data: Data, mapping: IndexMap | None = None) -&gt; None:\n        \"\"\"Creates an instance of a temporal graph from a `TemporalData` object.\n\n        Args:\n            data: PyG `Data` object containing edges saved in `edge_index` and timestamps in `time`.\n            mapping: Optional mapping from node IDs to indices.\n\n        Example:\n            ```py\n            from pytorch_geometric.data import TemporalData\n            import pathpyG as pp\n\n            d = Data(edge_index=[[0, 0, 1], [1, 2, 2]], time=[0, 1, 2])\n            t = pp.TemporalGraph(d, mapping)\n            print(t)\n            ```\n        \"\"\"\n        self.data = data\n        if not isinstance(self.data.edge_index, EdgeIndex):\n            self.data.edge_index = EdgeIndex(\n                data=self.data.edge_index.contiguous(), sparse_size=(self.data.num_nodes, self.data.num_nodes)\n            )\n\n        # reorder temporal data\n        # Note that we do not use `torch_geometric.self.data.Data.sort_by_time` because it cannot sort numpy arrays`\n        sorted_idx = torch.argsort(self.data.time)\n        for edge_attr in set(self.data.edge_attrs()).union(set([\"time\"])):\n            if edge_attr == \"edge_index\":\n                self.data.edge_index = self.data.edge_index[:, sorted_idx]\n            else:\n                self.data[edge_attr] = self.data[edge_attr][sorted_idx]\n\n        if mapping is not None:\n            self.mapping = mapping\n        else:\n            self.mapping = IndexMap()\n\n        # create mapping between edge index and edge tuples\n        self.edge_to_index = {(e[0].item(), e[1].item()): i for i, e in enumerate(self.data.edge_index.t())}\n        self.tedge_to_index = {\n            (e[0].item(), e[1].item(), t.item()): i\n            for i, (e, t) in enumerate(zip([e for e in self.data.edge_index.t()], self.data.time))\n        }\n\n    @staticmethod\n    def from_edge_list(  # type: ignore[override]\n        edge_list, num_nodes: Optional[int] = None, device: Optional[torch.device] = None\n    ) -&gt; \"TemporalGraph\":\n        \"\"\"Create a temporal graph from a list of tuples containing edges with timestamps.\n\n        Args:\n            edge_list: A list of tuples in the format (source, destination, timestamp).\n            num_nodes: Optional number of nodes in the graph. If not provided, it will be inferred.\n            device: The device on which to create the tensors (CPU or GPU).\n\n        Returns:\n            TemporalGraph: An instance of the TemporalGraph class.\n\n        Examples:\n            Create a temporal graph from an edge list:\n\n            &gt;&gt;&gt; import pathpyG as pp\n            &gt;&gt;&gt; edge_list = [(\"a\", \"b\", 1), (\"b\", \"c\", 2), (\"c\", \"a\", 3)]\n            &gt;&gt;&gt; g = pp.TemporalGraph.from_edge_list(edge_list)\n        \"\"\"\n        if len(edge_list) == 0:\n            return TemporalGraph(\n                data=Data(\n                    edge_index=torch.empty((2, 0), dtype=torch.long, device=device),\n                    time=torch.empty((0,), dtype=torch.long, device=device),\n                    num_nodes=num_nodes,\n                ),\n            )\n\n        edge_array = np.array(edge_list)\n\n        # Convert timestamps to tensor\n        if isinstance(edge_list[0][2], int):\n            ts = torch.tensor(edge_array[:, 2].astype(np.int_), device=device)\n        else:\n            ts = torch.tensor(edge_array[:, 2].astype(np.double), device=device)\n\n        index_map = IndexMap(np.unique(edge_array[:, :2]))\n        edge_index = index_map.to_idxs(edge_array[:, :2].T, device=device)\n\n        if not num_nodes:\n            num_nodes = index_map.num_ids()\n\n        return TemporalGraph(\n            data=Data(\n                edge_index=edge_index,\n                time=ts,\n                num_nodes=num_nodes,\n            ),\n            mapping=index_map,\n        )\n\n    @property\n    def temporal_edges(self) -&gt; list:\n        \"\"\"Return all temporal edges as a list of tuples (source, destination, timestamp).\n\n        Returns:\n            list: A list of tuples representing temporal edges in the format (source, destination, timestamp).\n\n        Examples:\n            Get the list of temporal edges:\n\n            &gt;&gt;&gt; import pathpyG as pp\n            &gt;&gt;&gt; g = pp.TemporalGraph.from_edge_list([(\"a\", \"b\", 1), (\"b\", \"c\", 2), (\"c\", \"a\", 3)])\n            &gt;&gt;&gt; print(g.temporal_edges)\n            [('a', 'b', 1), ('b', 'c', 2), ('c', 'a', 3)]\n\n            Iterate over temporal edges:\n            &gt;&gt;&gt; for edge in g.temporal_edges:\n            ...     print(edge)\n            ('a', 'b', 1)\n            ('b', 'c', 2)\n            ('c', 'a', 3)\n        \"\"\"\n        edge_ids = self.mapping.to_ids(self.data.edge_index)\n        if isinstance(edge_ids, torch.Tensor):\n            edge_ids = to_numpy(edge_ids)\n        edge_ids = edge_ids.tolist()\n        times = to_numpy(self.data.time).tolist()\n        return list(zip(edge_ids[0], edge_ids[1], times))\n\n    def to(self, device: torch.device) -&gt; \"TemporalGraph\":\n        \"\"\"Moves all graph data to the specified device (CPU or GPU).\n\n        Args:\n            device: The target device to move the graph data to.\n\n        Returns:\n            TemporalGraph: A new TemporalGraph instance with data on the specified device.\n        \"\"\"\n        self.data.edge_index = self.data.edge_index.to(device)\n        self.data.time = self.data.time.to(device)\n        for attr in self.node_attrs():\n            if isinstance(self.data[attr], torch.Tensor):\n                self.data[attr] = self.data[attr].to(device)\n        for attr in self.edge_attrs():\n            if isinstance(self.data[attr], torch.Tensor):\n                self.data[attr] = self.data[attr].to(device)\n        return self\n\n    @property\n    def order(self) -&gt; int:\n        \"\"\"Return order 1, since all temporal graphs must be order one.\"\"\"\n        return 1\n\n    @property\n    def start_time(self) -&gt; Union[int, float]:\n        \"\"\"Return the timestamp of the first event in the temporal graph.\"\"\"\n        return self.data.time.min().item()\n\n    @property\n    def end_time(self) -&gt; Union[int, float]:\n        \"\"\"Return the timestamp of the last event in the temporal graph.\"\"\"\n        return self.data.time.max().item()\n\n    def shuffle_time(self) -&gt; None:\n        \"\"\"Randomly shuffle the temporal order of edges by randomly permuting timestamps.\"\"\"\n        self.data.time = self.data.time[torch.randperm(len(self.data.time))]\n\n    def to_static_graph(self, weighted: bool = False, time_window: Optional[Tuple[int, int]] = None) -&gt; Graph:\n        \"\"\"Return weighted time-aggregated instance of [`Graph`][pathpyG.Graph] graph.\n\n        Args:\n            weighted: whether or not to return a weighted time-aggregated graph\n            time_window: A tuple with start and end time of the aggregation window\n\n        Returns:\n            Graph: A static graph object\n        \"\"\"\n        if time_window is not None:\n            idx = (self.data.time &gt;= time_window[0]).logical_and(self.data.time &lt; time_window[1]).nonzero().ravel()\n            edge_index = self.data.edge_index[:, idx]\n        else:\n            edge_index = self.data.edge_index\n\n        n = edge_index.max().item() + 1\n\n        if weighted:\n            i, w = torch_geometric.utils.coalesce(\n                edge_index.as_tensor(), torch.ones(edge_index.size(1), device=self.data.edge_index.device)\n            )\n            return Graph(Data(edge_index=EdgeIndex(data=i, sparse_size=(n, n)), edge_weight=w), self.mapping)\n        else:\n            return Graph.from_edge_index(EdgeIndex(data=edge_index, sparse_size=(n, n)), self.mapping)\n\n    def to_undirected(self) -&gt; \"TemporalGraph\":\n        \"\"\"Return an undirected version of a directed graph.\n\n        This method transforms the current graph instance into an undirected graph by\n        adding all directed edges in opposite direction.\n\n        Warning:\n            This method duplicates all temporal edges in the graph, which can lead to duplicated\n            edges if the original graph already contains bidirectional edges. As of now, edge attributes will\n            **not** be duplicated for the new edges.\n\n        Example:\n            ```py\n            import pathpyG as pp\n\n            g = pp.TemporalGraph.from_edge_list([(\"a\", \"b\", 1), (\"b\", \"c\", 2), (\"c\", \"a\", 3)])\n            g_u = g.to_undirected()\n            print(g_u)\n            ```\n        \"\"\"\n        # TODO: Handle edge attributes for new edges\n        rev_edge_index = self.data.edge_index.flip([0])\n        edge_index = torch.cat([self.data.edge_index, rev_edge_index], dim=1)\n        times = torch.cat([self.data.time, self.data.time])\n        return TemporalGraph(data=Data(edge_index=edge_index, time=times), mapping=self.mapping)\n\n    def get_batch(self, start_idx: int, end_idx: int) -&gt; \"TemporalGraph\":\n        \"\"\"Return a batch of temporal edges based on start and end indices.\n\n        Return an instance of the TemporalGraph that captures all time-stamped\n        edges in a given batch defined by start and (non-inclusive) end, where start\n        and end refer to the index of the first and last event in the time-ordered list of events.\n\n        Args:\n            start_idx: The starting index of the batch (inclusive).\n            end_idx: The ending index of the batch (exclusive).\n\n        Examples:\n            Get a batch of temporal edges:\n\n            &gt;&gt;&gt; import pathpyG as pp\n            &gt;&gt;&gt; g = pp.TemporalGraph.from_edge_list([(\"a\", \"b\", 1), (\"b\", \"c\", 2), (\"c\", \"a\", 3)])\n            &gt;&gt;&gt; batch = g.get_batch(0, 2)\n            &gt;&gt;&gt; print(batch.temporal_edges)\n            [('a', 'b', 1), ('b', 'c', 2)]\n        \"\"\"\n        # Create new Data object with the selected batch of edges and times\n        data = Data(edge_index=self.data.edge_index[:, start_idx:end_idx], time=self.data.time[start_idx:end_idx])\n\n        # Copy all node attributes\n        for node_attr in self.node_attrs():\n            data[node_attr] = self.data[node_attr]\n        # Copy only edge attributes for the selected batch\n        for edge_attr in self.edge_attrs():\n            data[edge_attr] = self.data[edge_attr][start_idx:end_idx]\n\n        return TemporalGraph(\n            data=data,\n            mapping=self.mapping,\n        )\n\n    def get_window(self, start_time: int, end_time: int) -&gt; \"TemporalGraph\":\n        \"\"\"Return a time window of temporal edges based on start and end timestamps.\n\n        Return an instance of the TemporalGraph that captures all time-stamped\n        edges in a given time window defined by start and (non-inclusive) end, where start\n        and end refer to the time stamps.\n\n        Args:\n            start_time: The starting timestamp of the window (inclusive).\n            end_time: The ending timestamp of the window (exclusive).\n\n        Examples:\n            Get a time window of temporal edges:\n\n            &gt;&gt;&gt; import pathpyG as pp\n            &gt;&gt;&gt; g = pp.TemporalGraph.from_edge_list([(\"a\", \"b\", 1), (\"b\", \"c\", 2), (\"c\", \"a\", 3)])\n            &gt;&gt;&gt; window = g.get_window(0, 2)\n            &gt;&gt;&gt; print(window.temporal_edges)\n            [('a', 'b', 1)]\n        \"\"\"\n        # While there is a PyG function `Data.snapshot`,\n        # we do it manually since it cannot handle numpy arrays as edge attributes.\n        edge_mask = (self.data.time &gt;= start_time).logical_and(self.data.time &lt; end_time)\n        # Create a new Data object with the selected edges and times\n        data = Data(\n            edge_index=self.data.edge_index[:, edge_mask],\n            time=self.data.time[edge_mask],\n        )\n        # Copy all node attributes\n        for node_attr in self.node_attrs():\n            data[node_attr] = self.data[node_attr]\n        # Copy only edge attributes for the selected edges\n        for edge_attr in self.edge_attrs():\n            data[edge_attr] = self.data[edge_attr][edge_mask]\n\n        return TemporalGraph(data=data, mapping=self.mapping)\n\n    def __getitem__(self, key: Union[tuple, str]) -&gt; Any:\n        \"\"\"Return node, edge, temporal edge, or graph attribute.\n\n        Args:\n            key: name of attribute to be returned\n        \"\"\"\n        if not isinstance(key, tuple):\n            if key in self.data.keys():\n                return self.data[key]\n            else:\n                raise KeyError(key + \" is not a graph attribute\")\n        elif key[0] in self.node_attrs():\n            return self.data[key[0]][self.mapping.to_idx(key[1])]\n        elif key[0] in self.edge_attrs():\n            # TODO: Get item for non-temporal edges will only return the last occurence of the edge\n            #       This is a limitation and should be fixed in the future.\n            if len(key) == 3:\n                return self.data[key[0]][self.edge_to_index[self.mapping.to_idx(key[1]), self.mapping.to_idx(key[2])]]\n            else:\n                return self.data[key[0]][\n                    self.tedge_to_index[self.mapping.to_idx(key[1]), self.mapping.to_idx(key[2]), key[3]]\n                ]\n        else:\n            raise KeyError(key[0] + \" is not a node or edge attribute\")\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the graph.\"\"\"\n        s = \"Temporal Graph with {0} nodes, {1} unique edges and {2} events in [{3}, {4}]\\n\".format(\n            self.data.num_nodes,\n            self.data.edge_index.unique(dim=1).size(dim=1),\n            self.data.edge_index.size(1),\n            self.start_time,\n            self.end_time,\n        )\n\n        attr = self.data.to_dict()\n        attr_types = {}\n        for k in attr:\n            t = type(attr[k])\n            if t == torch.Tensor:\n                attr_types[k] = str(t) + \" -&gt; \" + str(attr[k].size())\n            else:\n                attr_types[k] = str(t)\n\n        from pprint import pformat\n\n        attribute_info: dict[str, dict[str, Any]] = {\n            \"Node Attributes\": {},\n            \"Edge Attributes\": {},\n            \"Graph Attributes\": {},\n        }\n        for a in self.node_attrs():\n            attribute_info[\"Node Attributes\"][a] = attr_types[a]\n        for a in self.edge_attrs():\n            attribute_info[\"Edge Attributes\"][a] = attr_types[a]\n        for a in self.data.keys():\n            if not self.data.is_node_attr(a) and not self.data.is_edge_attr(a):\n                attribute_info[\"Graph Attributes\"][a] = attr_types[a]\n        s += pformat(attribute_info, indent=4, width=160)\n        return s\n</code></pre>"},{"location":"reference/pathpyG/core/temporal_graph/#pathpyG.core.temporal_graph.TemporalGraph.end_time","title":"<code>end_time</code>  <code>property</code>","text":"<p>Return the timestamp of the last event in the temporal graph.</p>"},{"location":"reference/pathpyG/core/temporal_graph/#pathpyG.core.temporal_graph.TemporalGraph.order","title":"<code>order</code>  <code>property</code>","text":"<p>Return order 1, since all temporal graphs must be order one.</p>"},{"location":"reference/pathpyG/core/temporal_graph/#pathpyG.core.temporal_graph.TemporalGraph.start_time","title":"<code>start_time</code>  <code>property</code>","text":"<p>Return the timestamp of the first event in the temporal graph.</p>"},{"location":"reference/pathpyG/core/temporal_graph/#pathpyG.core.temporal_graph.TemporalGraph.temporal_edges","title":"<code>temporal_edges</code>  <code>property</code>","text":"<p>Return all temporal edges as a list of tuples (source, destination, timestamp).</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of tuples representing temporal edges in the format (source, destination, timestamp).</p> <p>Examples:</p> <p>Get the list of temporal edges:</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; g = pp.TemporalGraph.from_edge_list([(\"a\", \"b\", 1), (\"b\", \"c\", 2), (\"c\", \"a\", 3)])\n&gt;&gt;&gt; print(g.temporal_edges)\n[('a', 'b', 1), ('b', 'c', 2), ('c', 'a', 3)]\n</code></pre> <p>Iterate over temporal edges:</p> <pre><code>&gt;&gt;&gt; for edge in g.temporal_edges:\n...     print(edge)\n('a', 'b', 1)\n('b', 'c', 2)\n('c', 'a', 3)\n</code></pre>"},{"location":"reference/pathpyG/core/temporal_graph/#pathpyG.core.temporal_graph.TemporalGraph.__getitem__","title":"<code>__getitem__</code>","text":"<p>Return node, edge, temporal edge, or graph attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>typing.Union[tuple, str]</code> <p>name of attribute to be returned</p> required Source code in <code>src/pathpyG/core/temporal_graph.py</code> <pre><code>def __getitem__(self, key: Union[tuple, str]) -&gt; Any:\n    \"\"\"Return node, edge, temporal edge, or graph attribute.\n\n    Args:\n        key: name of attribute to be returned\n    \"\"\"\n    if not isinstance(key, tuple):\n        if key in self.data.keys():\n            return self.data[key]\n        else:\n            raise KeyError(key + \" is not a graph attribute\")\n    elif key[0] in self.node_attrs():\n        return self.data[key[0]][self.mapping.to_idx(key[1])]\n    elif key[0] in self.edge_attrs():\n        # TODO: Get item for non-temporal edges will only return the last occurence of the edge\n        #       This is a limitation and should be fixed in the future.\n        if len(key) == 3:\n            return self.data[key[0]][self.edge_to_index[self.mapping.to_idx(key[1]), self.mapping.to_idx(key[2])]]\n        else:\n            return self.data[key[0]][\n                self.tedge_to_index[self.mapping.to_idx(key[1]), self.mapping.to_idx(key[2]), key[3]]\n            ]\n    else:\n        raise KeyError(key[0] + \" is not a node or edge attribute\")\n</code></pre>"},{"location":"reference/pathpyG/core/temporal_graph/#pathpyG.core.temporal_graph.TemporalGraph.__init__","title":"<code>__init__</code>","text":"<p>Creates an instance of a temporal graph from a <code>TemporalData</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>torch_geometric.data.Data</code> <p>PyG <code>Data</code> object containing edges saved in <code>edge_index</code> and timestamps in <code>time</code>.</p> required <code>mapping</code> <code>pathpyG.core.index_map.IndexMap | None</code> <p>Optional mapping from node IDs to indices.</p> <code>None</code> Example <pre><code>from pytorch_geometric.data import TemporalData\nimport pathpyG as pp\n\nd = Data(edge_index=[[0, 0, 1], [1, 2, 2]], time=[0, 1, 2])\nt = pp.TemporalGraph(d, mapping)\nprint(t)\n</code></pre> Source code in <code>src/pathpyG/core/temporal_graph.py</code> <pre><code>def __init__(self, data: Data, mapping: IndexMap | None = None) -&gt; None:\n    \"\"\"Creates an instance of a temporal graph from a `TemporalData` object.\n\n    Args:\n        data: PyG `Data` object containing edges saved in `edge_index` and timestamps in `time`.\n        mapping: Optional mapping from node IDs to indices.\n\n    Example:\n        ```py\n        from pytorch_geometric.data import TemporalData\n        import pathpyG as pp\n\n        d = Data(edge_index=[[0, 0, 1], [1, 2, 2]], time=[0, 1, 2])\n        t = pp.TemporalGraph(d, mapping)\n        print(t)\n        ```\n    \"\"\"\n    self.data = data\n    if not isinstance(self.data.edge_index, EdgeIndex):\n        self.data.edge_index = EdgeIndex(\n            data=self.data.edge_index.contiguous(), sparse_size=(self.data.num_nodes, self.data.num_nodes)\n        )\n\n    # reorder temporal data\n    # Note that we do not use `torch_geometric.self.data.Data.sort_by_time` because it cannot sort numpy arrays`\n    sorted_idx = torch.argsort(self.data.time)\n    for edge_attr in set(self.data.edge_attrs()).union(set([\"time\"])):\n        if edge_attr == \"edge_index\":\n            self.data.edge_index = self.data.edge_index[:, sorted_idx]\n        else:\n            self.data[edge_attr] = self.data[edge_attr][sorted_idx]\n\n    if mapping is not None:\n        self.mapping = mapping\n    else:\n        self.mapping = IndexMap()\n\n    # create mapping between edge index and edge tuples\n    self.edge_to_index = {(e[0].item(), e[1].item()): i for i, e in enumerate(self.data.edge_index.t())}\n    self.tedge_to_index = {\n        (e[0].item(), e[1].item(), t.item()): i\n        for i, (e, t) in enumerate(zip([e for e in self.data.edge_index.t()], self.data.time))\n    }\n</code></pre>"},{"location":"reference/pathpyG/core/temporal_graph/#pathpyG.core.temporal_graph.TemporalGraph.__str__","title":"<code>__str__</code>","text":"<p>Return a string representation of the graph.</p> Source code in <code>src/pathpyG/core/temporal_graph.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the graph.\"\"\"\n    s = \"Temporal Graph with {0} nodes, {1} unique edges and {2} events in [{3}, {4}]\\n\".format(\n        self.data.num_nodes,\n        self.data.edge_index.unique(dim=1).size(dim=1),\n        self.data.edge_index.size(1),\n        self.start_time,\n        self.end_time,\n    )\n\n    attr = self.data.to_dict()\n    attr_types = {}\n    for k in attr:\n        t = type(attr[k])\n        if t == torch.Tensor:\n            attr_types[k] = str(t) + \" -&gt; \" + str(attr[k].size())\n        else:\n            attr_types[k] = str(t)\n\n    from pprint import pformat\n\n    attribute_info: dict[str, dict[str, Any]] = {\n        \"Node Attributes\": {},\n        \"Edge Attributes\": {},\n        \"Graph Attributes\": {},\n    }\n    for a in self.node_attrs():\n        attribute_info[\"Node Attributes\"][a] = attr_types[a]\n    for a in self.edge_attrs():\n        attribute_info[\"Edge Attributes\"][a] = attr_types[a]\n    for a in self.data.keys():\n        if not self.data.is_node_attr(a) and not self.data.is_edge_attr(a):\n            attribute_info[\"Graph Attributes\"][a] = attr_types[a]\n    s += pformat(attribute_info, indent=4, width=160)\n    return s\n</code></pre>"},{"location":"reference/pathpyG/core/temporal_graph/#pathpyG.core.temporal_graph.TemporalGraph.from_edge_list","title":"<code>from_edge_list</code>  <code>staticmethod</code>","text":"<p>Create a temporal graph from a list of tuples containing edges with timestamps.</p> <p>Parameters:</p> Name Type Description Default <code>edge_list</code> <p>A list of tuples in the format (source, destination, timestamp).</p> required <code>num_nodes</code> <code>typing.Optional[int]</code> <p>Optional number of nodes in the graph. If not provided, it will be inferred.</p> <code>None</code> <code>device</code> <code>typing.Optional[torch.device]</code> <p>The device on which to create the tensors (CPU or GPU).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TemporalGraph</code> <code>pathpyG.core.temporal_graph.TemporalGraph</code> <p>An instance of the TemporalGraph class.</p> <p>Examples:</p> <p>Create a temporal graph from an edge list:</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; edge_list = [(\"a\", \"b\", 1), (\"b\", \"c\", 2), (\"c\", \"a\", 3)]\n&gt;&gt;&gt; g = pp.TemporalGraph.from_edge_list(edge_list)\n</code></pre> Source code in <code>src/pathpyG/core/temporal_graph.py</code> <pre><code>@staticmethod\ndef from_edge_list(  # type: ignore[override]\n    edge_list, num_nodes: Optional[int] = None, device: Optional[torch.device] = None\n) -&gt; \"TemporalGraph\":\n    \"\"\"Create a temporal graph from a list of tuples containing edges with timestamps.\n\n    Args:\n        edge_list: A list of tuples in the format (source, destination, timestamp).\n        num_nodes: Optional number of nodes in the graph. If not provided, it will be inferred.\n        device: The device on which to create the tensors (CPU or GPU).\n\n    Returns:\n        TemporalGraph: An instance of the TemporalGraph class.\n\n    Examples:\n        Create a temporal graph from an edge list:\n\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; edge_list = [(\"a\", \"b\", 1), (\"b\", \"c\", 2), (\"c\", \"a\", 3)]\n        &gt;&gt;&gt; g = pp.TemporalGraph.from_edge_list(edge_list)\n    \"\"\"\n    if len(edge_list) == 0:\n        return TemporalGraph(\n            data=Data(\n                edge_index=torch.empty((2, 0), dtype=torch.long, device=device),\n                time=torch.empty((0,), dtype=torch.long, device=device),\n                num_nodes=num_nodes,\n            ),\n        )\n\n    edge_array = np.array(edge_list)\n\n    # Convert timestamps to tensor\n    if isinstance(edge_list[0][2], int):\n        ts = torch.tensor(edge_array[:, 2].astype(np.int_), device=device)\n    else:\n        ts = torch.tensor(edge_array[:, 2].astype(np.double), device=device)\n\n    index_map = IndexMap(np.unique(edge_array[:, :2]))\n    edge_index = index_map.to_idxs(edge_array[:, :2].T, device=device)\n\n    if not num_nodes:\n        num_nodes = index_map.num_ids()\n\n    return TemporalGraph(\n        data=Data(\n            edge_index=edge_index,\n            time=ts,\n            num_nodes=num_nodes,\n        ),\n        mapping=index_map,\n    )\n</code></pre>"},{"location":"reference/pathpyG/core/temporal_graph/#pathpyG.core.temporal_graph.TemporalGraph.get_batch","title":"<code>get_batch</code>","text":"<p>Return a batch of temporal edges based on start and end indices.</p> <p>Return an instance of the TemporalGraph that captures all time-stamped edges in a given batch defined by start and (non-inclusive) end, where start and end refer to the index of the first and last event in the time-ordered list of events.</p> <p>Parameters:</p> Name Type Description Default <code>start_idx</code> <code>int</code> <p>The starting index of the batch (inclusive).</p> required <code>end_idx</code> <code>int</code> <p>The ending index of the batch (exclusive).</p> required <p>Examples:</p> <p>Get a batch of temporal edges:</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; g = pp.TemporalGraph.from_edge_list([(\"a\", \"b\", 1), (\"b\", \"c\", 2), (\"c\", \"a\", 3)])\n&gt;&gt;&gt; batch = g.get_batch(0, 2)\n&gt;&gt;&gt; print(batch.temporal_edges)\n[('a', 'b', 1), ('b', 'c', 2)]\n</code></pre> Source code in <code>src/pathpyG/core/temporal_graph.py</code> <pre><code>def get_batch(self, start_idx: int, end_idx: int) -&gt; \"TemporalGraph\":\n    \"\"\"Return a batch of temporal edges based on start and end indices.\n\n    Return an instance of the TemporalGraph that captures all time-stamped\n    edges in a given batch defined by start and (non-inclusive) end, where start\n    and end refer to the index of the first and last event in the time-ordered list of events.\n\n    Args:\n        start_idx: The starting index of the batch (inclusive).\n        end_idx: The ending index of the batch (exclusive).\n\n    Examples:\n        Get a batch of temporal edges:\n\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; g = pp.TemporalGraph.from_edge_list([(\"a\", \"b\", 1), (\"b\", \"c\", 2), (\"c\", \"a\", 3)])\n        &gt;&gt;&gt; batch = g.get_batch(0, 2)\n        &gt;&gt;&gt; print(batch.temporal_edges)\n        [('a', 'b', 1), ('b', 'c', 2)]\n    \"\"\"\n    # Create new Data object with the selected batch of edges and times\n    data = Data(edge_index=self.data.edge_index[:, start_idx:end_idx], time=self.data.time[start_idx:end_idx])\n\n    # Copy all node attributes\n    for node_attr in self.node_attrs():\n        data[node_attr] = self.data[node_attr]\n    # Copy only edge attributes for the selected batch\n    for edge_attr in self.edge_attrs():\n        data[edge_attr] = self.data[edge_attr][start_idx:end_idx]\n\n    return TemporalGraph(\n        data=data,\n        mapping=self.mapping,\n    )\n</code></pre>"},{"location":"reference/pathpyG/core/temporal_graph/#pathpyG.core.temporal_graph.TemporalGraph.get_window","title":"<code>get_window</code>","text":"<p>Return a time window of temporal edges based on start and end timestamps.</p> <p>Return an instance of the TemporalGraph that captures all time-stamped edges in a given time window defined by start and (non-inclusive) end, where start and end refer to the time stamps.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>int</code> <p>The starting timestamp of the window (inclusive).</p> required <code>end_time</code> <code>int</code> <p>The ending timestamp of the window (exclusive).</p> required <p>Examples:</p> <p>Get a time window of temporal edges:</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; g = pp.TemporalGraph.from_edge_list([(\"a\", \"b\", 1), (\"b\", \"c\", 2), (\"c\", \"a\", 3)])\n&gt;&gt;&gt; window = g.get_window(0, 2)\n&gt;&gt;&gt; print(window.temporal_edges)\n[('a', 'b', 1)]\n</code></pre> Source code in <code>src/pathpyG/core/temporal_graph.py</code> <pre><code>def get_window(self, start_time: int, end_time: int) -&gt; \"TemporalGraph\":\n    \"\"\"Return a time window of temporal edges based on start and end timestamps.\n\n    Return an instance of the TemporalGraph that captures all time-stamped\n    edges in a given time window defined by start and (non-inclusive) end, where start\n    and end refer to the time stamps.\n\n    Args:\n        start_time: The starting timestamp of the window (inclusive).\n        end_time: The ending timestamp of the window (exclusive).\n\n    Examples:\n        Get a time window of temporal edges:\n\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; g = pp.TemporalGraph.from_edge_list([(\"a\", \"b\", 1), (\"b\", \"c\", 2), (\"c\", \"a\", 3)])\n        &gt;&gt;&gt; window = g.get_window(0, 2)\n        &gt;&gt;&gt; print(window.temporal_edges)\n        [('a', 'b', 1)]\n    \"\"\"\n    # While there is a PyG function `Data.snapshot`,\n    # we do it manually since it cannot handle numpy arrays as edge attributes.\n    edge_mask = (self.data.time &gt;= start_time).logical_and(self.data.time &lt; end_time)\n    # Create a new Data object with the selected edges and times\n    data = Data(\n        edge_index=self.data.edge_index[:, edge_mask],\n        time=self.data.time[edge_mask],\n    )\n    # Copy all node attributes\n    for node_attr in self.node_attrs():\n        data[node_attr] = self.data[node_attr]\n    # Copy only edge attributes for the selected edges\n    for edge_attr in self.edge_attrs():\n        data[edge_attr] = self.data[edge_attr][edge_mask]\n\n    return TemporalGraph(data=data, mapping=self.mapping)\n</code></pre>"},{"location":"reference/pathpyG/core/temporal_graph/#pathpyG.core.temporal_graph.TemporalGraph.shuffle_time","title":"<code>shuffle_time</code>","text":"<p>Randomly shuffle the temporal order of edges by randomly permuting timestamps.</p> Source code in <code>src/pathpyG/core/temporal_graph.py</code> <pre><code>def shuffle_time(self) -&gt; None:\n    \"\"\"Randomly shuffle the temporal order of edges by randomly permuting timestamps.\"\"\"\n    self.data.time = self.data.time[torch.randperm(len(self.data.time))]\n</code></pre>"},{"location":"reference/pathpyG/core/temporal_graph/#pathpyG.core.temporal_graph.TemporalGraph.to","title":"<code>to</code>","text":"<p>Moves all graph data to the specified device (CPU or GPU).</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>torch.device</code> <p>The target device to move the graph data to.</p> required <p>Returns:</p> Name Type Description <code>TemporalGraph</code> <code>pathpyG.core.temporal_graph.TemporalGraph</code> <p>A new TemporalGraph instance with data on the specified device.</p> Source code in <code>src/pathpyG/core/temporal_graph.py</code> <pre><code>def to(self, device: torch.device) -&gt; \"TemporalGraph\":\n    \"\"\"Moves all graph data to the specified device (CPU or GPU).\n\n    Args:\n        device: The target device to move the graph data to.\n\n    Returns:\n        TemporalGraph: A new TemporalGraph instance with data on the specified device.\n    \"\"\"\n    self.data.edge_index = self.data.edge_index.to(device)\n    self.data.time = self.data.time.to(device)\n    for attr in self.node_attrs():\n        if isinstance(self.data[attr], torch.Tensor):\n            self.data[attr] = self.data[attr].to(device)\n    for attr in self.edge_attrs():\n        if isinstance(self.data[attr], torch.Tensor):\n            self.data[attr] = self.data[attr].to(device)\n    return self\n</code></pre>"},{"location":"reference/pathpyG/core/temporal_graph/#pathpyG.core.temporal_graph.TemporalGraph.to_static_graph","title":"<code>to_static_graph</code>","text":"<p>Return weighted time-aggregated instance of <code>Graph</code> graph.</p> <p>Parameters:</p> Name Type Description Default <code>weighted</code> <code>bool</code> <p>whether or not to return a weighted time-aggregated graph</p> <code>False</code> <code>time_window</code> <code>typing.Optional[typing.Tuple[int, int]]</code> <p>A tuple with start and end time of the aggregation window</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Graph</code> <code>pathpyG.Graph</code> <p>A static graph object</p> Source code in <code>src/pathpyG/core/temporal_graph.py</code> <pre><code>def to_static_graph(self, weighted: bool = False, time_window: Optional[Tuple[int, int]] = None) -&gt; Graph:\n    \"\"\"Return weighted time-aggregated instance of [`Graph`][pathpyG.Graph] graph.\n\n    Args:\n        weighted: whether or not to return a weighted time-aggregated graph\n        time_window: A tuple with start and end time of the aggregation window\n\n    Returns:\n        Graph: A static graph object\n    \"\"\"\n    if time_window is not None:\n        idx = (self.data.time &gt;= time_window[0]).logical_and(self.data.time &lt; time_window[1]).nonzero().ravel()\n        edge_index = self.data.edge_index[:, idx]\n    else:\n        edge_index = self.data.edge_index\n\n    n = edge_index.max().item() + 1\n\n    if weighted:\n        i, w = torch_geometric.utils.coalesce(\n            edge_index.as_tensor(), torch.ones(edge_index.size(1), device=self.data.edge_index.device)\n        )\n        return Graph(Data(edge_index=EdgeIndex(data=i, sparse_size=(n, n)), edge_weight=w), self.mapping)\n    else:\n        return Graph.from_edge_index(EdgeIndex(data=edge_index, sparse_size=(n, n)), self.mapping)\n</code></pre>"},{"location":"reference/pathpyG/core/temporal_graph/#pathpyG.core.temporal_graph.TemporalGraph.to_undirected","title":"<code>to_undirected</code>","text":"<p>Return an undirected version of a directed graph.</p> <p>This method transforms the current graph instance into an undirected graph by adding all directed edges in opposite direction.</p> Warning <p>This method duplicates all temporal edges in the graph, which can lead to duplicated edges if the original graph already contains bidirectional edges. As of now, edge attributes will not be duplicated for the new edges.</p> Example <pre><code>import pathpyG as pp\n\ng = pp.TemporalGraph.from_edge_list([(\"a\", \"b\", 1), (\"b\", \"c\", 2), (\"c\", \"a\", 3)])\ng_u = g.to_undirected()\nprint(g_u)\n</code></pre> Source code in <code>src/pathpyG/core/temporal_graph.py</code> <pre><code>def to_undirected(self) -&gt; \"TemporalGraph\":\n    \"\"\"Return an undirected version of a directed graph.\n\n    This method transforms the current graph instance into an undirected graph by\n    adding all directed edges in opposite direction.\n\n    Warning:\n        This method duplicates all temporal edges in the graph, which can lead to duplicated\n        edges if the original graph already contains bidirectional edges. As of now, edge attributes will\n        **not** be duplicated for the new edges.\n\n    Example:\n        ```py\n        import pathpyG as pp\n\n        g = pp.TemporalGraph.from_edge_list([(\"a\", \"b\", 1), (\"b\", \"c\", 2), (\"c\", \"a\", 3)])\n        g_u = g.to_undirected()\n        print(g_u)\n        ```\n    \"\"\"\n    # TODO: Handle edge attributes for new edges\n    rev_edge_index = self.data.edge_index.flip([0])\n    edge_index = torch.cat([self.data.edge_index, rev_edge_index], dim=1)\n    times = torch.cat([self.data.time, self.data.time])\n    return TemporalGraph(data=Data(edge_index=edge_index, time=times), mapping=self.mapping)\n</code></pre>"},{"location":"reference/pathpyG/io/","title":"io","text":"<p>PathpyG input/output module.</p>"},{"location":"reference/pathpyG/io/#pathpyG.io.add_edge_attributes","title":"<code>add_edge_attributes</code>","text":"<p>Add (temporal) edge attributes from pandas.DataFrame to existing graph.</p> <p>Edge attributes are mapped based on source/target node IDs in columns <code>v</code> and <code>w</code>, and edge attributes x are given in columns <code>edge_x</code>. If <code>time_attr</code> is not None, the dataframe is expected to contain temporal data with a timestamp in a column named as specified in <code>time_attr</code>.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pandas.DataFrame</code> <p>A DataFrame with rows containing edges and optional edge attributes.</p> required <code>g</code> <code>pathpyG.core.graph.Graph</code> <p>The graph to which the edge attributes should be added.</p> required <code>time_attr</code> <code>str | None</code> <p>If not None, the name of the column containing time stamps for temporal edges.</p> <code>None</code> Source code in <code>src/pathpyG/io/pandas.py</code> <pre><code>def add_edge_attributes(df: pd.DataFrame, g: Graph, time_attr: str | None = None) -&gt; None:\n    \"\"\"Add (temporal) edge attributes from [pandas.DataFrame][] to existing [graph][pathpyG.Graph].\n\n    Edge attributes are mapped based on source/target node IDs in columns `v` and `w`,\n    and edge attributes x are given in columns `edge_x`.\n    If `time_attr` is not None, the dataframe is expected to contain temporal data with a timestamp\n    in a column named as specified in `time_attr`.\n\n    Args:\n        df: A DataFrame with rows containing edges and optional edge attributes.\n        g: The graph to which the edge attributes should be added.\n        time_attr: If not None, the name of the column containing time stamps for temporal edges.\n    \"\"\"\n    if \"v\" not in df or \"w\" not in df:\n        logger.error(\"Data frame must have columns `v` and `w` for source and target nodes\")\n        raise ValueError(\"Data frame must have columns `v` and `w` for source and target nodes\")\n\n    # check for non-existent nodes\n    node_ids = set(df[\"v\"]).union(set(df[\"w\"]))\n    if not node_ids.issubset(set(g.nodes)):\n        raise ValueError(\n            f\"DataFrame contains nodes {node_ids - set(g.nodes)} that do not exist in the graph. \"\n            \"Please ensure all nodes in the DataFrame are present in the graph.\"\n        )\n\n    # check if the number of edges in the data frame is consistent with the graph\n    if g.m != len(df):\n        raise ValueError(\n            f\"DataFrame contains {len(df)} edges, but the graph has {g.m} edges. \"\n            \"Please ensure the DataFrame matches the number of edges in the graph.\"\n        )\n\n    # extract indices of source/target node of edges\n    src = g.mapping.to_idxs(df[\"v\"].tolist())\n    tgt = g.mapping.to_idxs(df[\"w\"].tolist())\n\n    edge_attrs = [attr for attr in df.columns if attr not in [\"v\", \"w\"]]\n\n    if time_attr is not None:\n        if time_attr not in df:\n            logger.error(\"Data frame must have column %s for time stamps\", time_attr)\n            raise ValueError(f\"Data frame must have column {time_attr} for time stamps\")\n\n        time = df[time_attr].values\n        edge_attrs.remove(time_attr)\n\n        # find indices of edges in temporal edge_index\n        edge_idx = []\n        for src_i, tgt_i, time_i in zip(src, tgt, time):\n            edge = g.tedge_to_index.get((src_i.item(), tgt_i.item(), time_i.item()), None)  # type: ignore\n            if edge is None:\n                logger.error(\"found non-existing edge in temporal graph\")\n                raise ValueError(\n                    f\"Edge ({src_i.item()}, {tgt_i.item()}) does not exist at time {time_i.item()} in the graph.\"\n                )\n            edge_idx.append(edge)\n    else:\n        # find indices of edges in edge_index\n        edge_idx = []\n        for src_i, tgt_i in zip(src, tgt):\n            edge = g.edge_to_index.get((src_i.item(), tgt_i.item()), None)\n            if edge is None:\n                logger.error(\"found non-existing edge in temporal graph\")\n                raise ValueError(f\"Edge ({src_i.item()}, {tgt_i.item()}) does not exist in the graph.\")\n            edge_idx.append(edge)\n\n    for attr in edge_attrs:\n        if attr.startswith(\"edge_\"):\n            prefix = \"\"\n        else:\n            prefix = \"edge_\"\n\n        # parse column and add to graph\n        _parse_df_column(\n            df=df.iloc[edge_idx],\n            data=g.data,\n            attr=attr,\n            prefix=prefix,\n        )\n</code></pre>"},{"location":"reference/pathpyG/io/#pathpyG.io.add_node_attributes","title":"<code>add_node_attributes</code>","text":"<p>Add node attributes from pandas.DataFrame to existing graph.</p> <p>Node IDs or indices are given in column <code>v</code> and node attributes x are given in columns <code>node_x</code>.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pandas.DataFrame</code> <p>A DataFrame with rows containing nodes and optional node attributes.</p> required <code>g</code> <code>pathpyG.core.graph.Graph</code> <p>The graph to which the node attributes should be added.</p> required Source code in <code>src/pathpyG/io/pandas.py</code> <pre><code>def add_node_attributes(df: pd.DataFrame, g: Graph):\n    \"\"\"Add node attributes from [pandas.DataFrame][] to existing [graph][pathpyG.Graph].\n\n    Node IDs or indices are given in column `v` and node attributes x are given in columns `node_x`.\n\n    Args:\n        df: A DataFrame with rows containing nodes and optional node attributes.\n        g: The graph to which the node attributes should be added.\n    \"\"\"\n    if \"v\" in df:\n        logger.debug(\"Mapping node attributes based on node names in column `v`\")\n        attributed_nodes = list(df[\"v\"])\n    elif \"index\" in df:\n        logger.debug(\"Mapping node attributes based on node indices in column `index`\")\n        attributed_nodes = list(df[\"index\"])\n    else:\n        raise ValueError(\"DataFrame must either have `index` or `v` column\")\n\n    # check for duplicated node attributes\n    if len(set(attributed_nodes)) &lt; len(attributed_nodes):\n        raise ValueError(\"DataFrame cannot contain multiple attribute values for single node\")\n\n    # check for difference between nodes in graph and nodes in attributes\n    if \"v\" in df:\n        if set(attributed_nodes) != set([v for v in g.nodes]):\n            raise ValueError(\"Mismatch between nodes in DataFrame and nodes in graph\")\n\n        # get indices of nodes in tensor\n        node_idx = g.mapping.to_idxs(attributed_nodes).tolist()\n    else:\n        if set(attributed_nodes) != set([i for i in range(g.n)]):\n            raise ValueError(\"Mismatch between nodes in DataFrame and nodes in graph\")\n\n        # get indices of nodes in tensor\n        node_idx = attributed_nodes\n\n    # assign node property tensors\n    cols = [attr for attr in df.columns if attr not in [\"v\", \"index\"]]\n    for attr in cols:\n        # prefix attribute names that are not already prefixed\n        if attr.startswith(\"node_\"):\n            prefix = \"\"\n        else:\n            prefix = \"node_\"\n\n        _parse_df_column(\n            df=df,\n            data=g.data,\n            idx=node_idx,\n            attr=attr,\n            prefix=prefix,\n        )\n</code></pre>"},{"location":"reference/pathpyG/io/#pathpyG.io.df_to_graph","title":"<code>df_to_graph</code>","text":"<p>Reads a network from a pandas.DataFrame.</p> <p>The data frame is expected to have a minimum of two columns that give the source and target nodes of edges. Additional columns in the data frame will be mapped to edge attributes.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pandas.DataFrame</code> <p>A data frame with rows containing edges and optional edge attributes. If the data frame contains column names, the source and target columns must be called 'v' and 'w' respectively. If no column names are used the first two columns are interpreted as source and target.</p> required <code>is_undirected</code> <code>bool</code> <p>Whether or not to interpret edges as undirected.</p> <code>False</code> <code>multiedges</code> <code>bool</code> <p>Whether or not to allow multiple edges between the same node pair. By default multi edges are ignored.</p> <code>False</code> <code>num_nodes</code> <code>int | None</code> <p>The number of nodes in the graph. If None, the number of unique nodes in the data frame is used.</p> <code>None</code> Example <pre><code>import pathpyG as pp\nimport pandas as pd\n\ndf = pd.DataFrame({\"v\": [\"a\", \"b\", \"c\"], \"w\": [\"b\", \"c\", \"a\"], \"edge_weight\": [1.0, 5.0, 2.0]})\ng = pp.io.df_to_graph(df)\nprint(n)\n</code></pre> Source code in <code>src/pathpyG/io/pandas.py</code> <pre><code>def df_to_graph(\n    df: pd.DataFrame, is_undirected: bool = False, multiedges: bool = False, num_nodes: int | None = None\n) -&gt; Graph:\n    \"\"\"Reads a network from a [pandas.DataFrame][].\n\n    The data frame is expected to have a minimum of two columns\n    that give the source and target nodes of edges. Additional columns in the\n    data frame will be mapped to edge attributes.\n\n    Args:\n        df: A data frame with rows containing edges and optional edge attributes. If the\n            data frame contains column names, the source and target columns must be called\n            'v' and 'w' respectively. If no column names are used the first two columns\n            are interpreted as source and target.\n        is_undirected: Whether or not to interpret edges as undirected.\n        multiedges: Whether or not to allow multiple edges between the same node pair. By\n            default multi edges are ignored.\n        num_nodes: The number of nodes in the graph. If None, the number of unique nodes\n            in the data frame is used.\n\n    Example:\n        ```py\n        import pathpyG as pp\n        import pandas as pd\n\n        df = pd.DataFrame({\"v\": [\"a\", \"b\", \"c\"], \"w\": [\"b\", \"c\", \"a\"], \"edge_weight\": [1.0, 5.0, 2.0]})\n        g = pp.io.df_to_graph(df)\n        print(n)\n        ```\n    \"\"\"\n    # assign column names if no header is present\n    no_header = all(isinstance(x, int) for x in df.columns.values.tolist())\n\n    if no_header:\n        # interpret first two columns as source and target\n        col_names = [\"v\", \"w\"]\n        # interpret remaining columns as edge attributes\n        for i in range(2, len(df.columns.values.tolist())):\n            col_names += [f\"edge_attr_{i - 2}\"]\n        df.columns = col_names\n\n    # optionally remove multiedges\n    if not multiedges and df[[\"v\", \"w\"]].duplicated().any():\n        logger.debug(\"Data frame contains multiple edges, but multiedges is set to False. Removing duplicates.\")\n        df = df.drop_duplicates(subset=[\"v\", \"w\"])\n\n    # Create index mapping and data object\n    mapping = IndexMap(node_ids=np.unique(df[[\"v\", \"w\"]].values).tolist())\n    data = Data(\n        edge_index=mapping.to_idxs(df[[\"v\", \"w\"]].values.T),\n        num_nodes=num_nodes if num_nodes is not None else mapping.node_ids.shape[0],  # type: ignore\n    )\n\n    # Parse all columns except 'v' and 'w' as edge attributes\n    cols = df.columns.tolist()\n    cols.remove(\"v\")\n    cols.remove(\"w\")\n    for col in cols:\n        if col.startswith(\"edge_\"):\n            prefix = \"\"\n        else:\n            prefix = \"edge_\"\n\n        _parse_df_column(df=df, data=data, attr=col, prefix=prefix)\n\n    # Create graph object\n    g = Graph(data=data, mapping=mapping)\n    # If the graph should be undirected, convert it to an undirected graph\n    if is_undirected:\n        g = g.to_undirected()\n\n    return g\n</code></pre>"},{"location":"reference/pathpyG/io/#pathpyG.io.df_to_temporal_graph","title":"<code>df_to_temporal_graph</code>","text":"<p>Read a temporal graph from a DataFrame.</p> <p>The DataFrame is expected to have a minimum of two columns <code>v</code> and <code>w</code> that give the source and target nodes of edges. Each row in the DataFrame is mapped to one temporal edge. Additional columns in the DataFrame will be mapped to edge attributes.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pandas.DataFrame</code> <p>pandas.DataFrame with rows containing time-stamped edges and optional edge attributes.</p> required <code>multiedges</code> <code>bool</code> <p>Whether or not to allow multiple edges between the same node pair. By default multi edges are ignored.</p> <code>False</code> <code>timestamp_format</code> <p>The format of the time stamps in the <code>t</code> column.</p> <code>'%Y-%m-%d %H:%M:%S'</code> <code>time_rescale</code> <p>The factor by which to rescale the time stamps. Defaults to 1, meaning no rescaling.</p> <code>1</code> <code>num_nodes</code> <code>int | None</code> <p>The number of nodes in the graph. If None, the number of unique nodes in the DataFrame is used.</p> <code>None</code> Example <pre><code>import pathpyG as pp\nimport pandas as pd\n\ndf = pd.DataFrame({\"v\": [\"a\", \"b\", \"c\"], \"w\": [\"b\", \"c\", \"a\"], \"t\": [1, 2, 3]})\ng = pp.io.df_to_temporal_graph(df)\nprint(g)\n\ndf = pd.DataFrame([[\"a\", \"b\", \"c\"], [\"b\", \"c\", \"a\"], [1, 2, 3]])\ng = pp.io.df_to_temporal_graph(df)\nprint(g)\n</code></pre> Source code in <code>src/pathpyG/io/pandas.py</code> <pre><code>def df_to_temporal_graph(\n    df: pd.DataFrame,\n    multiedges: bool = False,\n    timestamp_format=\"%Y-%m-%d %H:%M:%S\",\n    time_rescale=1,\n    num_nodes: int | None = None,\n) -&gt; TemporalGraph:\n    \"\"\"Read a temporal graph from a DataFrame.\n\n    The DataFrame is expected to have a minimum of two columns `v` and `w`\n    that give the source and target nodes of edges. Each row in the DataFrame is\n    mapped to one temporal edge. Additional columns in the DataFrame will be\n    mapped to edge attributes.\n\n    Args:\n        df: pandas.DataFrame with rows containing time-stamped edges and optional edge\n            attributes.\n        multiedges: Whether or not to allow multiple edges between the same node pair. By\n            default multi edges are ignored.\n        timestamp_format: The format of the time stamps in the `t` column.\n        time_rescale: The factor by which to rescale the time stamps. Defaults to 1, meaning no rescaling.\n        num_nodes: The number of nodes in the graph. If None, the number of unique nodes\n            in the DataFrame is used.\n\n    Example:\n        ```py\n        import pathpyG as pp\n        import pandas as pd\n\n        df = pd.DataFrame({\"v\": [\"a\", \"b\", \"c\"], \"w\": [\"b\", \"c\", \"a\"], \"t\": [1, 2, 3]})\n        g = pp.io.df_to_temporal_graph(df)\n        print(g)\n\n        df = pd.DataFrame([[\"a\", \"b\", \"c\"], [\"b\", \"c\", \"a\"], [1, 2, 3]])\n        g = pp.io.df_to_temporal_graph(df)\n        print(g)\n        ```\n    \"\"\"\n    # assign column names if no header is present\n    no_header = all(isinstance(x, int) for x in df.columns.values.tolist())\n\n    if no_header:\n        # interpret first two columns as source and target\n        logger.info(\"Interpreting first three columns as v, w, t\")\n        col_names = [\"v\", \"w\", \"t\"]\n        # interpret remaining columns as edge attributes\n        for i in range(3, len(df.columns.values.tolist())):\n            col_names += [\"edge_attr_{0}\".format(i - 2)]\n        df.columns = col_names\n\n    # parse the time stamp column \"t\"\n    _parse_timestamp(df=df, timestamp_format=timestamp_format, time_rescale=time_rescale)\n\n    # optionally remove multiedges\n    if not multiedges:\n        df = df.drop_duplicates(subset=[\"v\", \"w\", \"t\"])\n\n    # Create index mapping and data object\n    mapping = IndexMap(node_ids=np.unique(df[[\"v\", \"w\"]].values))\n    data = Data(\n        edge_index=mapping.to_idxs(df[[\"v\", \"w\"]].values.T),\n        time=torch.tensor(df[\"t\"].values),\n        num_nodes=num_nodes if num_nodes is not None else mapping.node_ids.shape[0],  # type: ignore\n    )\n\n    # add edge attributes\n    cols = [col for col in df.columns if col not in [\"v\", \"w\", \"t\"]]\n    for col in cols:\n        if col.startswith(\"edge_\"):\n            prefix = \"\"\n        else:\n            prefix = \"edge_\"\n\n        _parse_df_column(df=df, data=data, attr=col, prefix=prefix)\n\n    # Create temporal graph object\n    g = TemporalGraph(data=data, mapping=mapping)\n\n    return g\n</code></pre>"},{"location":"reference/pathpyG/io/#pathpyG.io.graph_to_df","title":"<code>graph_to_df</code>","text":"<p>Return a pandas.DataFrame for a given graph.</p> <p>Contains all edges including edge attributes. Node and network-level  attributes are not included. To facilitate the import into network analysis  tools that only support integer node identifiers, node uids can be replaced  by a consecutive, zero-based index.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The graph to export as pandas DataFrame</p> required <code>node_indices</code> <code>typing.Optional[bool]</code> <p>whether nodes should be exported as integer indices</p> <code>False</code> Example <pre><code>import pathpyG as pp\n\nn = pp.Graph.from_edge_list([(\"a\", \"b\"), (\"b\", \"c\"), (\"c\", \"a\")])\ndf = pp.io.to_dataframe(n)\nprint(df)\n</code></pre> Source code in <code>src/pathpyG/io/pandas.py</code> <pre><code>def graph_to_df(graph: Graph, node_indices: Optional[bool] = False) -&gt; pd.DataFrame:\n    \"\"\"Return a [pandas.DataFrame][] for a given [graph][pathpyG.Graph].\n\n    Contains all edges including edge attributes. Node and network-level \n    attributes are not included. To facilitate the import into network analysis \n    tools that only support integer node identifiers, node uids can be replaced \n    by a consecutive, zero-based index.\n\n    Args:\n        graph: The graph to export as pandas DataFrame\n        node_indices: whether nodes should be exported as integer indices\n\n    Example:\n        ```py\n        import pathpyG as pp\n\n        n = pp.Graph.from_edge_list([(\"a\", \"b\"), (\"b\", \"c\"), (\"c\", \"a\")])\n        df = pp.io.to_dataframe(n)\n        print(df)\n        ```\n    \"\"\"\n    if node_indices:\n        vs = to_numpy(graph.data.edge_index[0])\n        ws = to_numpy(graph.data.edge_index[1])\n    else:\n        vs = graph.mapping.to_ids(to_numpy(graph.data.edge_index[0]))\n        ws = graph.mapping.to_ids(to_numpy(graph.data.edge_index[1]))\n    df = pd.DataFrame({**{\"v\": vs, \"w\": ws}, **{a: graph.data[a].tolist() for a in graph.edge_attrs()}})\n\n    return df\n</code></pre>"},{"location":"reference/pathpyG/io/#pathpyG.io.list_netzschleuder_records","title":"<code>list_netzschleuder_records</code>","text":"<p>Read a list of data sets available at the netzschleuder repository.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>Base URL of netzschleuder repository</p> <code>'https://networks.skewed.de'</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments that will be passed to the netzschleuder repository as HTTP GET parameters. For supported parameters see https://networks.skewed.de/api</p> <code>{}</code> <p>Examples:</p> <p>Return a list of all data sets</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; pp.io.list_netzschleuder_records()\n['7th_graders', 'academia_edu', 'add_health', ...]\n</code></pre> <p>Return a list of all data sets with a given tag</p> <pre><code>&gt;&gt;&gt; pp.io.list_netzschleuder_records(tags=\"Temporal\")\n['ambassador', 'board_directors', 'caida_as', ...]\n</code></pre> <p>Returns:</p> Type Description <code>typing.Union[list, dict]</code> <p>Either a list of data set names or a dictionary containing all data set names and network attributes.</p> Source code in <code>src/pathpyG/io/netzschleuder.py</code> <pre><code>def list_netzschleuder_records(base_url: str = \"https://networks.skewed.de\", **kwargs: Any) -&gt; Union[list, dict]:\n    \"\"\"Read a list of data sets available at the netzschleuder repository.\n\n    Args:\n        base_url: Base URL of netzschleuder repository\n        **kwargs: Keyword arguments that will be passed to the netzschleuder repository as HTTP GET parameters.\n            For supported parameters see https://networks.skewed.de/api\n\n    Examples:\n        Return a list of all data sets\n\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; pp.io.list_netzschleuder_records()\n        ['7th_graders', 'academia_edu', 'add_health', ...]\n\n        Return a list of all data sets with a given tag\n\n        &gt;&gt;&gt; pp.io.list_netzschleuder_records(tags=\"Temporal\")\n        ['ambassador', 'board_directors', 'caida_as', ...]\n\n    Returns:\n        Either a list of data set names or a dictionary containing all data set names and network attributes.\n    \"\"\"\n    url = \"/api/nets\"\n    for k, v in kwargs.items():\n        url += \"?{0}={1}\".format(k, v)\n    try:\n        f = request.urlopen(base_url + url).read()\n        return json.loads(f)\n    except HTTPError:\n        msg = \"Could not connect to netzschleuder repository at {0}\".format(base_url)\n        # LOG.error(msg)\n        raise Exception(msg)\n</code></pre>"},{"location":"reference/pathpyG/io/#pathpyG.io.read_csv_graph","title":"<code>read_csv_graph</code>","text":"<p>Read a <code>Graph</code> from a csv file.</p> <p>This method reads a graph from a <code>.csv</code>-file and converts it to a <code>Graph</code> object. To read a temporal graph, the csv file must have a header with column <code>t</code> containing time stamps of edges</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the csv file containing the graph data.</p> required <code>sep</code> <code>str</code> <p>character separating columns in the csv file</p> <code>','</code> <code>header</code> <code>bool</code> <p>whether or not the first line of the csv file is interpreted as header with column names</p> <code>True</code> <code>is_undirected</code> <code>bool</code> <p>whether or not to interpret edges as undirected</p> <code>False</code> <code>multiedges</code> <code>bool</code> <p>whether or not to allow multiple edges between the same node pair. By default multi edges are ignored.</p> <code>False</code> <code>**kwargs</code> <code>typing.Any</code> <p>Additional keyword arguments passed to the <code>df_to_graph</code> function.</p> <code>{}</code> Example <pre><code>import pathpyG as pp\n\ng = pp.io.read_csv(\"example_graph.csv\")\ng = pp.io.read_csv(\"example_temporal_graph.csv\")\n</code></pre> Source code in <code>src/pathpyG/io/pandas.py</code> <pre><code>def read_csv_graph(\n    filename: str,\n    sep: str = \",\",\n    header: bool = True,\n    is_undirected: bool = False,\n    multiedges: bool = False,\n    **kwargs: Any,\n) -&gt; Graph:\n    \"\"\"Read a `Graph` from a csv file.\n\n    This method reads a graph from a `.csv`-file and converts it to a\n    `Graph` object. To read a temporal graph, the csv file must have\n    a header with column `t` containing time stamps of edges\n\n    Args:\n        filename: The path to the csv file containing the graph data.\n        sep: character separating columns in the csv file\n        header: whether or not the first line of the csv file is interpreted as header with column names\n        is_undirected: whether or not to interpret edges as undirected\n        multiedges: whether or not to allow multiple edges between the same node pair. By default multi edges are\n            ignored.\n        **kwargs: Additional keyword arguments passed to the `df_to_graph` function.\n\n    Example:\n        ```py\n        import pathpyG as pp\n\n        g = pp.io.read_csv(\"example_graph.csv\")\n        g = pp.io.read_csv(\"example_temporal_graph.csv\")\n        ```\n    \"\"\"\n    if header:\n        df = pd.read_csv(filename, header=0, sep=sep)\n    else:\n        df = pd.read_csv(filename, header=None, sep=sep)\n\n    return df_to_graph(df, is_undirected=is_undirected, multiedges=multiedges, **kwargs)\n</code></pre>"},{"location":"reference/pathpyG/io/#pathpyG.io.read_csv_path_data","title":"<code>read_csv_path_data</code>","text":"<p>Read multiple paths stored in an n-gram csv file.</p> <p>Parameters:</p> Name Type Description Default <code>path_or_buf</code> <code>typing.Any</code> <p>File, path or file-like object that the pandas.read_table function will read from</p> <code>None</code> <code>weight</code> <code>bool</code> <p>If True the last column of each row in the CSV file will be interpreted as a count or weight</p> <code>True</code> <code>sep</code> <p>character that separates the nodes (and weight) in each line of the input file</p> <code>','</code> <code>device</code> <code>typing.Optional[torch.device]</code> <p>The device on which the PathData object should be created</p> <code>None</code> Source code in <code>src/pathpyG/io/pandas.py</code> <pre><code>def read_csv_path_data(\n    path_or_buf: Any = None, weight: bool = True, sep=\",\", device: Optional[torch.device] = None\n) -&gt; PathData:\n    \"\"\"Read multiple paths stored in an n-gram csv file.\n\n    Args:\n        path_or_buf: File, path or file-like object that the [pandas.read_table][] function will read from\n        weight: If True the last column of each row in the CSV file will be interpreted as a count or weight\n        sep: character that separates the nodes (and weight) in each line of the input file\n        device: The device on which the PathData object should be created\n    \"\"\"\n    # Read raw data\n    df = pd.read_table(filepath_or_buffer=path_or_buf, header=None)\n    # split and expand non-uniform rows\n    df = df[0].str.split(sep, expand=True)\n\n    paths = []\n    weights = []\n\n    # extract node sequences and edges\n    for row in df.itertuples(index=False):\n        p = [x for x in row if x]\n        if weight:\n            weights.append(float(p[-1]))\n            p.pop()\n        else:\n            weights.append(1.0)\n        paths.append(p)\n\n    # create index mapping\n    mapping = IndexMap()\n    mapping.add_ids(np.unique(np.hstack(paths)))\n\n    # create path_data object\n    pathdata = PathData(mapping, device)\n    pathdata.append_walks(node_seqs=paths, weights=weights)\n    return pathdata\n</code></pre>"},{"location":"reference/pathpyG/io/#pathpyG.io.read_csv_temporal_graph","title":"<code>read_csv_temporal_graph</code>","text":"<p>Read a <code>TemporalGraph</code> from a csv file.</p> <p>This method reads a temporal graph from a <code>.csv</code>-file and converts it to a <code>TemporalGraph</code> object. The csv file is expected to have a header with columns <code>v</code>, <code>w</code>, and <code>t</code> containing source nodes, target nodes, and time stamps of edges, respectively. Additional columns in the csv file will be interpreted as edge attributes.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the csv file containing the temporal graph data.</p> required <code>sep</code> <code>str</code> <p>character separating columns in the csv file</p> <code>','</code> <code>header</code> <code>bool</code> <p>whether or not the first line of the csv file is interpreted as header with column names</p> <code>True</code> <code>timestamp_format</code> <code>str</code> <p>The format of the time stamps in the <code>t</code> column.</p> <code>'%Y-%m-%d %H:%M:%S'</code> <code>time_rescale</code> <code>int</code> <p>The factor by which to rescale the time stamps. Defaults to 1, meaning no rescaling.</p> <code>1</code> <code>**kwargs</code> <code>typing.Any</code> <p>Additional keyword arguments passed to the <code>df_to_temporal_graph</code> function.</p> <code>{}</code> Example <pre><code>import pathpyG as pp\n\ng = pp.io.read_csv(\"example_temporal_graph.csv\")\n</code></pre> Source code in <code>src/pathpyG/io/pandas.py</code> <pre><code>def read_csv_temporal_graph(\n    filename: str,\n    sep: str = \",\",\n    header: bool = True,\n    timestamp_format: str = \"%Y-%m-%d %H:%M:%S\",\n    time_rescale: int = 1,\n    **kwargs: Any,\n) -&gt; TemporalGraph:\n    \"\"\"Read a `TemporalGraph` from a csv file.\n\n    This method reads a temporal graph from a `.csv`-file and converts it to a\n    `TemporalGraph` object. The csv file is expected to have a header with columns\n    `v`, `w`, and `t` containing source nodes, target nodes, and time stamps of edges,\n    respectively. Additional columns in the csv file will be interpreted as edge attributes.\n\n    Args:\n        filename: The path to the csv file containing the temporal graph data.\n        sep: character separating columns in the csv file\n        header: whether or not the first line of the csv file is interpreted as header with column names\n        timestamp_format: The format of the time stamps in the `t` column.\n        time_rescale: The factor by which to rescale the time stamps. Defaults to 1, meaning no rescaling.\n        **kwargs: Additional keyword arguments passed to the `df_to_temporal_graph` function.\n\n    Example:\n        ```py\n        import pathpyG as pp\n\n        g = pp.io.read_csv(\"example_temporal_graph.csv\")\n        ```\n    \"\"\"\n    if header:\n        df = pd.read_csv(filename, header=0, sep=sep)\n    else:\n        df = pd.read_csv(filename, header=None, sep=sep)\n    return df_to_temporal_graph(df, timestamp_format=timestamp_format, time_rescale=time_rescale, **kwargs)\n</code></pre>"},{"location":"reference/pathpyG/io/#pathpyG.io.read_netzschleuder_graph","title":"<code>read_netzschleuder_graph</code>","text":"<p>Read a graph or temporal graph from the netzschleuder repository.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the network data set to read from</p> required <code>network</code> <code>typing.Optional[str]</code> <p>Identifier of the network within the data set to read. For data sets containing a single network only, this can be set to None.</p> <code>None</code> <code>multiedges</code> <code>bool</code> <p>Whether to allow multiedges in the constructed graph</p> <code>False</code> <code>time_attr</code> <code>typing.Optional[str]</code> <p>Name of the edge attribute containing time stamps. If None, the function will read the graph as static network.</p> <code>None</code> <code>base_url</code> <code>str</code> <p>Base URL of netzschleuder repository.</p> <code>'https://networks.skewed.de'</code> <p>Examples:</p> <p>Read network '77' from karate club data set</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; n = pp.io.read_netzschleuder_graph(name=\"karate\", network=\"77\")\n&gt;&gt;&gt; pp.plot(n)\n&lt;IPython.core.display.HTML object&gt;\n&lt;pathpyG.visualisations._d3js.backend.D3jsBackend object at 0x...&gt;\n</code></pre> <p>Returns:</p> Type Description <code>typing.Union[pathpyG.core.graph.Graph, pathpyG.core.temporal_graph.TemporalGraph]</code> <p>Graph or TemporalGraph object</p> Source code in <code>src/pathpyG/io/netzschleuder.py</code> <pre><code>def read_netzschleuder_graph(\n    name: str,\n    network: Optional[str] = None,\n    multiedges: bool = False,\n    time_attr: Optional[str] = None,\n    base_url: str = \"https://networks.skewed.de\",\n) -&gt; Union[Graph, TemporalGraph]:\n    \"\"\"Read a graph or temporal graph from the netzschleuder repository.\n\n    Args:\n        name: Name of the network data set to read from\n        network: Identifier of the network within the data set to read. For data sets\n            containing a single network only, this can be set to None.\n        multiedges: Whether to allow multiedges in the constructed graph\n        time_attr: Name of the edge attribute containing time stamps. If None,\n            the function will read the graph as static network.\n        base_url: Base URL of netzschleuder repository.\n\n    Examples:\n        Read network '77' from karate club data set\n\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; n = pp.io.read_netzschleuder_graph(name=\"karate\", network=\"77\")\n        &gt;&gt;&gt; pp.plot(n)\n        &lt;IPython.core.display.HTML object&gt;\n        &lt;pathpyG.visualisations._d3js.backend.D3jsBackend object at 0x...&gt;\n\n        &lt;iframe src=\"karate_club.html\" width=\"550\" height=\"450\"&gt;&lt;/iframe&gt;\n\n    Returns:\n        Graph or TemporalGraph object\n    \"\"\"\n    # build URL\n    try:\n        # retrieve properties of data record via API\n        properties = json.loads(request.urlopen(f\"{base_url}/api/net/{name}\").read())\n\n        timestamps = time_attr is not None\n\n        if not network:\n            analyses = properties[\"analyses\"]\n            network = name\n        else:\n            analyses = properties[\"analyses\"][network]\n\n        try:\n            is_directed = analyses[\"is_directed\"]\n            num_nodes = analyses[\"num_vertices\"]\n        except KeyError as exc:\n            raise Exception(f\"Record {name} contains multiple networks, please specify network name.\") from exc\n\n        # Retrieve CSV data\n        url = f\"{base_url}/net/{name}/files/{network}.csv.zip\"\n        try:\n            response = request.urlopen(url)\n\n            # decompress zip into temporary folder\n            data = BytesIO(response.read())\n\n            with zipfile.ZipFile(data, \"r\") as zip_ref:\n                with tempfile.TemporaryDirectory() as temp_dir:\n                    zip_ref.extractall(path=temp_dir)\n\n                    # edges.csv contains edge list with edge properties\n                    edges = pd.read_csv(\n                        f\"{temp_dir}/edges.csv\", header=0, sep=\",\", skip_blank_lines=True, skipinitialspace=True\n                    )\n\n                    # rename columns\n                    edges.rename(columns={\"# source\": \"v\", \"target\": \"w\"}, inplace=True)\n                    if timestamps:\n                        edges.rename(columns={time_attr: \"t\"}, inplace=True)\n\n                    # construct graph and assign edge attributes\n                    if not timestamps:\n                        g = df_to_graph(\n                            df=edges, multiedges=multiedges, is_undirected=not is_directed, num_nodes=num_nodes\n                        )\n                    else:\n                        g = df_to_temporal_graph(df=edges, multiedges=multiedges, num_nodes=num_nodes)\n\n                    # nodes.csv contains node indices with node properties (like name)\n                    node_attrs = pd.read_csv(\n                        f\"{temp_dir}/nodes.csv\", header=0, sep=\",\", skip_blank_lines=True, skipinitialspace=True\n                    )\n                    node_attrs.rename(columns={\"# index\": \"index\"}, inplace=True)\n\n                    add_node_attributes(node_attrs, g)\n\n                    # add graph-level attributes\n                    for x in analyses:\n                        g.data[\"analyses_\" + x] = analyses[x]\n\n                    return g\n        except HTTPError as exc:\n            msg = f\"Could not retrieve netzschleuder record at {url}\"\n            raise Exception(msg) from exc\n    except HTTPError as exc:\n        msg = f\"Could not retrieve netzschleuder record at {base_url}/api/net/{name}\"\n        raise Exception(msg) from exc\n    return None\n</code></pre>"},{"location":"reference/pathpyG/io/#pathpyG.io.read_netzschleuder_record","title":"<code>read_netzschleuder_record</code>","text":"<p>Read metadata of a single data record with given name from the netzschleuder repository.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the data set for which to retrieve the metadata</p> required <code>base_url</code> <code>str</code> <p>Base URL of netzschleuder repository</p> <code>'https://networks.skewed.de'</code> <p>Examples:</p> <p>Retrieve metadata of karate club network</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; metadata = pp.io.read_netzschleuder_record(\"karate\")\n&gt;&gt;&gt; print(metadata)\n{'analyses': {'77': {'average_degree': 4.52...}, ...}\n</code></pre> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing key-value pairs of metadata</p> Source code in <code>src/pathpyG/io/netzschleuder.py</code> <pre><code>def read_netzschleuder_record(name: str, base_url: str = \"https://networks.skewed.de\") -&gt; dict:\n    \"\"\"Read metadata of a single data record with given name from the netzschleuder repository.\n\n    Args:\n        name: Name of the data set for which to retrieve the metadata\n        base_url: Base URL of netzschleuder repository\n\n    Examples:\n        Retrieve metadata of karate club network\n\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; metadata = pp.io.read_netzschleuder_record(\"karate\")\n        &gt;&gt;&gt; print(metadata)\n        {'analyses': {'77': {'average_degree': 4.52...}, ...}\n\n    Returns:\n        Dictionary containing key-value pairs of metadata\n    \"\"\"\n    url = f\"/api/net/{name}\"\n    try:\n        return json.loads(request.urlopen(base_url + url).read())\n    except HTTPError as exc:\n        msg = f\"Could not connect to netzschleuder repository at {base_url}\"\n        # LOG.error(msg)\n        raise Exception(msg) from exc\n</code></pre>"},{"location":"reference/pathpyG/io/#pathpyG.io.temporal_graph_to_df","title":"<code>temporal_graph_to_df</code>","text":"<p>Return a pandas.DataFrame for a given temporal graph.</p> <p>Contains all edges including edge attributes. Node and network-level  attributes are not included. To facilitate the import into network analysis  tools that only support integer node identifiers, node uids can be replaced  by a consecutive, zero-based index.</p> <p>facilitate the import into network analysis tools that only support integer node identifiers, node uids can be replaced by a consecutive, zero-based index.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.temporal_graph.TemporalGraph</code> <p>The graph to export as pandas DataFrame</p> required <code>node_indices</code> <code>typing.Optional[bool]</code> <p>whether nodes should be exported as integer indices</p> <code>False</code> Example <pre><code>import pathpyG as pp\n\nn = pp.TemporalGraph.from_edge_list([(\"a\", \"b\", 1), (\"b\", \"c\", 2), (\"c\", \"a\", 3)])\ndf = pp.io.to_df(n)\nprint(df)\n</code></pre> Source code in <code>src/pathpyG/io/pandas.py</code> <pre><code>def temporal_graph_to_df(graph: TemporalGraph, node_indices: Optional[bool] = False) -&gt; pd.DataFrame:\n    \"\"\"Return a [pandas.DataFrame][] for a given [temporal graph][pathpyG.TemporalGraph].\n\n    Contains all edges including edge attributes. Node and network-level \n    attributes are not included. To facilitate the import into network analysis \n    tools that only support integer node identifiers, node uids can be replaced \n    by a consecutive, zero-based index.\n\n    facilitate the import into network analysis tools that only support integer\n    node identifiers, node uids can be replaced by a consecutive, zero-based\n    index.\n\n    Args:\n        graph: The graph to export as pandas DataFrame\n        node_indices: whether nodes should be exported as integer indices\n\n    Example:\n        ```py\n        import pathpyG as pp\n\n        n = pp.TemporalGraph.from_edge_list([(\"a\", \"b\", 1), (\"b\", \"c\", 2), (\"c\", \"a\", 3)])\n        df = pp.io.to_df(n)\n        print(df)\n        ```\n    \"\"\"\n    if node_indices:\n        vs = to_numpy(graph.data.edge_index[0])\n        ws = to_numpy(graph.data.edge_index[1])\n    else:\n        vs = graph.mapping.to_ids(to_numpy(graph.data.edge_index[0]))\n        ws = graph.mapping.to_ids(to_numpy(graph.data.edge_index[1]))\n    df = pd.DataFrame(\n        {\n            **{\"v\": vs, \"w\": ws, \"t\": graph.data.time.tolist()},\n            **{a: graph.data[a].tolist() for a in graph.edge_attrs()},\n        }\n    )\n\n    return df\n</code></pre>"},{"location":"reference/pathpyG/io/#pathpyG.io.write_csv","title":"<code>write_csv</code>","text":"<p>Store all edges of a graph or temporal graph in a csv file.</p> <p>This method stores a <code>Graph</code> or <code>TemporalGraph</code> as a <code>.csv</code> file. The csv file will contain all edges including edge attributes. Node and network-level attributes are not included. To facilitate the import into network analysis tools that only support integer node identifiers, node uids can be replaced by a consecutive, zero-based index.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>typing.Union[pathpyG.core.graph.Graph, pathpyG.core.temporal_graph.TemporalGraph]</code> <p>The graph to export as pandas DataFrame</p> required <code>node_indices</code> <code>bool</code> <p>whether nodes should be exported as integer indices</p> <code>False</code> <code>path_or_buf</code> <code>typing.Any</code> <p>String, path, or file-like object (see documentation of pandas.DataFrame.to_csv)</p> <code>None</code> <code>**pdargs</code> <code>typing.Any</code> <p>Additional keyword arguments passed to pandas.DataFrame.to_csv.</p> <code>{}</code> Source code in <code>src/pathpyG/io/pandas.py</code> <pre><code>def write_csv(\n    graph: Union[Graph, TemporalGraph], node_indices: bool = False, path_or_buf: Any = None, **pdargs: Any\n) -&gt; None:\n    \"\"\"Store all edges of a graph or temporal graph in a csv file.\n\n    This method stores a `Graph` or `TemporalGraph` as a `.csv` file. The csv file\n    will contain all edges including edge attributes. Node and network-level attributes\n    are not included. To facilitate the import into network analysis tools that only\n    support integer node identifiers, node uids can be replaced by a consecutive,\n    zero-based index.\n\n    Args:\n        graph: The graph to export as pandas DataFrame\n        node_indices: whether nodes should be exported as integer indices\n        path_or_buf: String, path, or file-like object (see documentation of [pandas.DataFrame.to_csv][])\n        **pdargs: Additional keyword arguments passed to [pandas.DataFrame.to_csv][].\n    \"\"\"\n    if isinstance(graph, TemporalGraph):\n        frame = temporal_graph_to_df(graph=graph, node_indices=node_indices)\n    else:\n        frame = graph_to_df(graph=graph, node_indices=node_indices)\n    frame.to_csv(index=False, path_or_buf=path_or_buf, **pdargs)\n</code></pre>"},{"location":"reference/pathpyG/io/netzschleuder/","title":"netzschleuder","text":"<p>PathpyG input/output module for the netzschleuder repository.</p>"},{"location":"reference/pathpyG/io/netzschleuder/#pathpyG.io.netzschleuder.list_netzschleuder_records","title":"<code>list_netzschleuder_records</code>","text":"<p>Read a list of data sets available at the netzschleuder repository.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>Base URL of netzschleuder repository</p> <code>'https://networks.skewed.de'</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments that will be passed to the netzschleuder repository as HTTP GET parameters. For supported parameters see https://networks.skewed.de/api</p> <code>{}</code> <p>Examples:</p> <p>Return a list of all data sets</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; pp.io.list_netzschleuder_records()\n['7th_graders', 'academia_edu', 'add_health', ...]\n</code></pre> <p>Return a list of all data sets with a given tag</p> <pre><code>&gt;&gt;&gt; pp.io.list_netzschleuder_records(tags=\"Temporal\")\n['ambassador', 'board_directors', 'caida_as', ...]\n</code></pre> <p>Returns:</p> Type Description <code>typing.Union[list, dict]</code> <p>Either a list of data set names or a dictionary containing all data set names and network attributes.</p> Source code in <code>src/pathpyG/io/netzschleuder.py</code> <pre><code>def list_netzschleuder_records(base_url: str = \"https://networks.skewed.de\", **kwargs: Any) -&gt; Union[list, dict]:\n    \"\"\"Read a list of data sets available at the netzschleuder repository.\n\n    Args:\n        base_url: Base URL of netzschleuder repository\n        **kwargs: Keyword arguments that will be passed to the netzschleuder repository as HTTP GET parameters.\n            For supported parameters see https://networks.skewed.de/api\n\n    Examples:\n        Return a list of all data sets\n\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; pp.io.list_netzschleuder_records()\n        ['7th_graders', 'academia_edu', 'add_health', ...]\n\n        Return a list of all data sets with a given tag\n\n        &gt;&gt;&gt; pp.io.list_netzschleuder_records(tags=\"Temporal\")\n        ['ambassador', 'board_directors', 'caida_as', ...]\n\n    Returns:\n        Either a list of data set names or a dictionary containing all data set names and network attributes.\n    \"\"\"\n    url = \"/api/nets\"\n    for k, v in kwargs.items():\n        url += \"?{0}={1}\".format(k, v)\n    try:\n        f = request.urlopen(base_url + url).read()\n        return json.loads(f)\n    except HTTPError:\n        msg = \"Could not connect to netzschleuder repository at {0}\".format(base_url)\n        # LOG.error(msg)\n        raise Exception(msg)\n</code></pre>"},{"location":"reference/pathpyG/io/netzschleuder/#pathpyG.io.netzschleuder.read_netzschleuder_graph","title":"<code>read_netzschleuder_graph</code>","text":"<p>Read a graph or temporal graph from the netzschleuder repository.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the network data set to read from</p> required <code>network</code> <code>typing.Optional[str]</code> <p>Identifier of the network within the data set to read. For data sets containing a single network only, this can be set to None.</p> <code>None</code> <code>multiedges</code> <code>bool</code> <p>Whether to allow multiedges in the constructed graph</p> <code>False</code> <code>time_attr</code> <code>typing.Optional[str]</code> <p>Name of the edge attribute containing time stamps. If None, the function will read the graph as static network.</p> <code>None</code> <code>base_url</code> <code>str</code> <p>Base URL of netzschleuder repository.</p> <code>'https://networks.skewed.de'</code> <p>Examples:</p> <p>Read network '77' from karate club data set</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; n = pp.io.read_netzschleuder_graph(name=\"karate\", network=\"77\")\n&gt;&gt;&gt; pp.plot(n)\n&lt;IPython.core.display.HTML object&gt;\n&lt;pathpyG.visualisations._d3js.backend.D3jsBackend object at 0x...&gt;\n</code></pre> <p>Returns:</p> Type Description <code>typing.Union[pathpyG.core.graph.Graph, pathpyG.core.temporal_graph.TemporalGraph]</code> <p>Graph or TemporalGraph object</p> Source code in <code>src/pathpyG/io/netzschleuder.py</code> <pre><code>def read_netzschleuder_graph(\n    name: str,\n    network: Optional[str] = None,\n    multiedges: bool = False,\n    time_attr: Optional[str] = None,\n    base_url: str = \"https://networks.skewed.de\",\n) -&gt; Union[Graph, TemporalGraph]:\n    \"\"\"Read a graph or temporal graph from the netzschleuder repository.\n\n    Args:\n        name: Name of the network data set to read from\n        network: Identifier of the network within the data set to read. For data sets\n            containing a single network only, this can be set to None.\n        multiedges: Whether to allow multiedges in the constructed graph\n        time_attr: Name of the edge attribute containing time stamps. If None,\n            the function will read the graph as static network.\n        base_url: Base URL of netzschleuder repository.\n\n    Examples:\n        Read network '77' from karate club data set\n\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; n = pp.io.read_netzschleuder_graph(name=\"karate\", network=\"77\")\n        &gt;&gt;&gt; pp.plot(n)\n        &lt;IPython.core.display.HTML object&gt;\n        &lt;pathpyG.visualisations._d3js.backend.D3jsBackend object at 0x...&gt;\n\n        &lt;iframe src=\"karate_club.html\" width=\"550\" height=\"450\"&gt;&lt;/iframe&gt;\n\n    Returns:\n        Graph or TemporalGraph object\n    \"\"\"\n    # build URL\n    try:\n        # retrieve properties of data record via API\n        properties = json.loads(request.urlopen(f\"{base_url}/api/net/{name}\").read())\n\n        timestamps = time_attr is not None\n\n        if not network:\n            analyses = properties[\"analyses\"]\n            network = name\n        else:\n            analyses = properties[\"analyses\"][network]\n\n        try:\n            is_directed = analyses[\"is_directed\"]\n            num_nodes = analyses[\"num_vertices\"]\n        except KeyError as exc:\n            raise Exception(f\"Record {name} contains multiple networks, please specify network name.\") from exc\n\n        # Retrieve CSV data\n        url = f\"{base_url}/net/{name}/files/{network}.csv.zip\"\n        try:\n            response = request.urlopen(url)\n\n            # decompress zip into temporary folder\n            data = BytesIO(response.read())\n\n            with zipfile.ZipFile(data, \"r\") as zip_ref:\n                with tempfile.TemporaryDirectory() as temp_dir:\n                    zip_ref.extractall(path=temp_dir)\n\n                    # edges.csv contains edge list with edge properties\n                    edges = pd.read_csv(\n                        f\"{temp_dir}/edges.csv\", header=0, sep=\",\", skip_blank_lines=True, skipinitialspace=True\n                    )\n\n                    # rename columns\n                    edges.rename(columns={\"# source\": \"v\", \"target\": \"w\"}, inplace=True)\n                    if timestamps:\n                        edges.rename(columns={time_attr: \"t\"}, inplace=True)\n\n                    # construct graph and assign edge attributes\n                    if not timestamps:\n                        g = df_to_graph(\n                            df=edges, multiedges=multiedges, is_undirected=not is_directed, num_nodes=num_nodes\n                        )\n                    else:\n                        g = df_to_temporal_graph(df=edges, multiedges=multiedges, num_nodes=num_nodes)\n\n                    # nodes.csv contains node indices with node properties (like name)\n                    node_attrs = pd.read_csv(\n                        f\"{temp_dir}/nodes.csv\", header=0, sep=\",\", skip_blank_lines=True, skipinitialspace=True\n                    )\n                    node_attrs.rename(columns={\"# index\": \"index\"}, inplace=True)\n\n                    add_node_attributes(node_attrs, g)\n\n                    # add graph-level attributes\n                    for x in analyses:\n                        g.data[\"analyses_\" + x] = analyses[x]\n\n                    return g\n        except HTTPError as exc:\n            msg = f\"Could not retrieve netzschleuder record at {url}\"\n            raise Exception(msg) from exc\n    except HTTPError as exc:\n        msg = f\"Could not retrieve netzschleuder record at {base_url}/api/net/{name}\"\n        raise Exception(msg) from exc\n    return None\n</code></pre>"},{"location":"reference/pathpyG/io/netzschleuder/#pathpyG.io.netzschleuder.read_netzschleuder_record","title":"<code>read_netzschleuder_record</code>","text":"<p>Read metadata of a single data record with given name from the netzschleuder repository.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the data set for which to retrieve the metadata</p> required <code>base_url</code> <code>str</code> <p>Base URL of netzschleuder repository</p> <code>'https://networks.skewed.de'</code> <p>Examples:</p> <p>Retrieve metadata of karate club network</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; metadata = pp.io.read_netzschleuder_record(\"karate\")\n&gt;&gt;&gt; print(metadata)\n{'analyses': {'77': {'average_degree': 4.52...}, ...}\n</code></pre> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing key-value pairs of metadata</p> Source code in <code>src/pathpyG/io/netzschleuder.py</code> <pre><code>def read_netzschleuder_record(name: str, base_url: str = \"https://networks.skewed.de\") -&gt; dict:\n    \"\"\"Read metadata of a single data record with given name from the netzschleuder repository.\n\n    Args:\n        name: Name of the data set for which to retrieve the metadata\n        base_url: Base URL of netzschleuder repository\n\n    Examples:\n        Retrieve metadata of karate club network\n\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; metadata = pp.io.read_netzschleuder_record(\"karate\")\n        &gt;&gt;&gt; print(metadata)\n        {'analyses': {'77': {'average_degree': 4.52...}, ...}\n\n    Returns:\n        Dictionary containing key-value pairs of metadata\n    \"\"\"\n    url = f\"/api/net/{name}\"\n    try:\n        return json.loads(request.urlopen(base_url + url).read())\n    except HTTPError as exc:\n        msg = f\"Could not connect to netzschleuder repository at {base_url}\"\n        # LOG.error(msg)\n        raise Exception(msg) from exc\n</code></pre>"},{"location":"reference/pathpyG/io/pandas/","title":"pandas","text":"<p>\"Functions to read and write graphs from and to pandas DataFrames.</p>"},{"location":"reference/pathpyG/io/pandas/#pathpyG.io.pandas.add_edge_attributes","title":"<code>add_edge_attributes</code>","text":"<p>Add (temporal) edge attributes from pandas.DataFrame to existing graph.</p> <p>Edge attributes are mapped based on source/target node IDs in columns <code>v</code> and <code>w</code>, and edge attributes x are given in columns <code>edge_x</code>. If <code>time_attr</code> is not None, the dataframe is expected to contain temporal data with a timestamp in a column named as specified in <code>time_attr</code>.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pandas.DataFrame</code> <p>A DataFrame with rows containing edges and optional edge attributes.</p> required <code>g</code> <code>pathpyG.core.graph.Graph</code> <p>The graph to which the edge attributes should be added.</p> required <code>time_attr</code> <code>str | None</code> <p>If not None, the name of the column containing time stamps for temporal edges.</p> <code>None</code> Source code in <code>src/pathpyG/io/pandas.py</code> <pre><code>def add_edge_attributes(df: pd.DataFrame, g: Graph, time_attr: str | None = None) -&gt; None:\n    \"\"\"Add (temporal) edge attributes from [pandas.DataFrame][] to existing [graph][pathpyG.Graph].\n\n    Edge attributes are mapped based on source/target node IDs in columns `v` and `w`,\n    and edge attributes x are given in columns `edge_x`.\n    If `time_attr` is not None, the dataframe is expected to contain temporal data with a timestamp\n    in a column named as specified in `time_attr`.\n\n    Args:\n        df: A DataFrame with rows containing edges and optional edge attributes.\n        g: The graph to which the edge attributes should be added.\n        time_attr: If not None, the name of the column containing time stamps for temporal edges.\n    \"\"\"\n    if \"v\" not in df or \"w\" not in df:\n        logger.error(\"Data frame must have columns `v` and `w` for source and target nodes\")\n        raise ValueError(\"Data frame must have columns `v` and `w` for source and target nodes\")\n\n    # check for non-existent nodes\n    node_ids = set(df[\"v\"]).union(set(df[\"w\"]))\n    if not node_ids.issubset(set(g.nodes)):\n        raise ValueError(\n            f\"DataFrame contains nodes {node_ids - set(g.nodes)} that do not exist in the graph. \"\n            \"Please ensure all nodes in the DataFrame are present in the graph.\"\n        )\n\n    # check if the number of edges in the data frame is consistent with the graph\n    if g.m != len(df):\n        raise ValueError(\n            f\"DataFrame contains {len(df)} edges, but the graph has {g.m} edges. \"\n            \"Please ensure the DataFrame matches the number of edges in the graph.\"\n        )\n\n    # extract indices of source/target node of edges\n    src = g.mapping.to_idxs(df[\"v\"].tolist())\n    tgt = g.mapping.to_idxs(df[\"w\"].tolist())\n\n    edge_attrs = [attr for attr in df.columns if attr not in [\"v\", \"w\"]]\n\n    if time_attr is not None:\n        if time_attr not in df:\n            logger.error(\"Data frame must have column %s for time stamps\", time_attr)\n            raise ValueError(f\"Data frame must have column {time_attr} for time stamps\")\n\n        time = df[time_attr].values\n        edge_attrs.remove(time_attr)\n\n        # find indices of edges in temporal edge_index\n        edge_idx = []\n        for src_i, tgt_i, time_i in zip(src, tgt, time):\n            edge = g.tedge_to_index.get((src_i.item(), tgt_i.item(), time_i.item()), None)  # type: ignore\n            if edge is None:\n                logger.error(\"found non-existing edge in temporal graph\")\n                raise ValueError(\n                    f\"Edge ({src_i.item()}, {tgt_i.item()}) does not exist at time {time_i.item()} in the graph.\"\n                )\n            edge_idx.append(edge)\n    else:\n        # find indices of edges in edge_index\n        edge_idx = []\n        for src_i, tgt_i in zip(src, tgt):\n            edge = g.edge_to_index.get((src_i.item(), tgt_i.item()), None)\n            if edge is None:\n                logger.error(\"found non-existing edge in temporal graph\")\n                raise ValueError(f\"Edge ({src_i.item()}, {tgt_i.item()}) does not exist in the graph.\")\n            edge_idx.append(edge)\n\n    for attr in edge_attrs:\n        if attr.startswith(\"edge_\"):\n            prefix = \"\"\n        else:\n            prefix = \"edge_\"\n\n        # parse column and add to graph\n        _parse_df_column(\n            df=df.iloc[edge_idx],\n            data=g.data,\n            attr=attr,\n            prefix=prefix,\n        )\n</code></pre>"},{"location":"reference/pathpyG/io/pandas/#pathpyG.io.pandas.add_node_attributes","title":"<code>add_node_attributes</code>","text":"<p>Add node attributes from pandas.DataFrame to existing graph.</p> <p>Node IDs or indices are given in column <code>v</code> and node attributes x are given in columns <code>node_x</code>.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pandas.DataFrame</code> <p>A DataFrame with rows containing nodes and optional node attributes.</p> required <code>g</code> <code>pathpyG.core.graph.Graph</code> <p>The graph to which the node attributes should be added.</p> required Source code in <code>src/pathpyG/io/pandas.py</code> <pre><code>def add_node_attributes(df: pd.DataFrame, g: Graph):\n    \"\"\"Add node attributes from [pandas.DataFrame][] to existing [graph][pathpyG.Graph].\n\n    Node IDs or indices are given in column `v` and node attributes x are given in columns `node_x`.\n\n    Args:\n        df: A DataFrame with rows containing nodes and optional node attributes.\n        g: The graph to which the node attributes should be added.\n    \"\"\"\n    if \"v\" in df:\n        logger.debug(\"Mapping node attributes based on node names in column `v`\")\n        attributed_nodes = list(df[\"v\"])\n    elif \"index\" in df:\n        logger.debug(\"Mapping node attributes based on node indices in column `index`\")\n        attributed_nodes = list(df[\"index\"])\n    else:\n        raise ValueError(\"DataFrame must either have `index` or `v` column\")\n\n    # check for duplicated node attributes\n    if len(set(attributed_nodes)) &lt; len(attributed_nodes):\n        raise ValueError(\"DataFrame cannot contain multiple attribute values for single node\")\n\n    # check for difference between nodes in graph and nodes in attributes\n    if \"v\" in df:\n        if set(attributed_nodes) != set([v for v in g.nodes]):\n            raise ValueError(\"Mismatch between nodes in DataFrame and nodes in graph\")\n\n        # get indices of nodes in tensor\n        node_idx = g.mapping.to_idxs(attributed_nodes).tolist()\n    else:\n        if set(attributed_nodes) != set([i for i in range(g.n)]):\n            raise ValueError(\"Mismatch between nodes in DataFrame and nodes in graph\")\n\n        # get indices of nodes in tensor\n        node_idx = attributed_nodes\n\n    # assign node property tensors\n    cols = [attr for attr in df.columns if attr not in [\"v\", \"index\"]]\n    for attr in cols:\n        # prefix attribute names that are not already prefixed\n        if attr.startswith(\"node_\"):\n            prefix = \"\"\n        else:\n            prefix = \"node_\"\n\n        _parse_df_column(\n            df=df,\n            data=g.data,\n            idx=node_idx,\n            attr=attr,\n            prefix=prefix,\n        )\n</code></pre>"},{"location":"reference/pathpyG/io/pandas/#pathpyG.io.pandas.df_to_graph","title":"<code>df_to_graph</code>","text":"<p>Reads a network from a pandas.DataFrame.</p> <p>The data frame is expected to have a minimum of two columns that give the source and target nodes of edges. Additional columns in the data frame will be mapped to edge attributes.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pandas.DataFrame</code> <p>A data frame with rows containing edges and optional edge attributes. If the data frame contains column names, the source and target columns must be called 'v' and 'w' respectively. If no column names are used the first two columns are interpreted as source and target.</p> required <code>is_undirected</code> <code>bool</code> <p>Whether or not to interpret edges as undirected.</p> <code>False</code> <code>multiedges</code> <code>bool</code> <p>Whether or not to allow multiple edges between the same node pair. By default multi edges are ignored.</p> <code>False</code> <code>num_nodes</code> <code>int | None</code> <p>The number of nodes in the graph. If None, the number of unique nodes in the data frame is used.</p> <code>None</code> Example <pre><code>import pathpyG as pp\nimport pandas as pd\n\ndf = pd.DataFrame({\"v\": [\"a\", \"b\", \"c\"], \"w\": [\"b\", \"c\", \"a\"], \"edge_weight\": [1.0, 5.0, 2.0]})\ng = pp.io.df_to_graph(df)\nprint(n)\n</code></pre> Source code in <code>src/pathpyG/io/pandas.py</code> <pre><code>def df_to_graph(\n    df: pd.DataFrame, is_undirected: bool = False, multiedges: bool = False, num_nodes: int | None = None\n) -&gt; Graph:\n    \"\"\"Reads a network from a [pandas.DataFrame][].\n\n    The data frame is expected to have a minimum of two columns\n    that give the source and target nodes of edges. Additional columns in the\n    data frame will be mapped to edge attributes.\n\n    Args:\n        df: A data frame with rows containing edges and optional edge attributes. If the\n            data frame contains column names, the source and target columns must be called\n            'v' and 'w' respectively. If no column names are used the first two columns\n            are interpreted as source and target.\n        is_undirected: Whether or not to interpret edges as undirected.\n        multiedges: Whether or not to allow multiple edges between the same node pair. By\n            default multi edges are ignored.\n        num_nodes: The number of nodes in the graph. If None, the number of unique nodes\n            in the data frame is used.\n\n    Example:\n        ```py\n        import pathpyG as pp\n        import pandas as pd\n\n        df = pd.DataFrame({\"v\": [\"a\", \"b\", \"c\"], \"w\": [\"b\", \"c\", \"a\"], \"edge_weight\": [1.0, 5.0, 2.0]})\n        g = pp.io.df_to_graph(df)\n        print(n)\n        ```\n    \"\"\"\n    # assign column names if no header is present\n    no_header = all(isinstance(x, int) for x in df.columns.values.tolist())\n\n    if no_header:\n        # interpret first two columns as source and target\n        col_names = [\"v\", \"w\"]\n        # interpret remaining columns as edge attributes\n        for i in range(2, len(df.columns.values.tolist())):\n            col_names += [f\"edge_attr_{i - 2}\"]\n        df.columns = col_names\n\n    # optionally remove multiedges\n    if not multiedges and df[[\"v\", \"w\"]].duplicated().any():\n        logger.debug(\"Data frame contains multiple edges, but multiedges is set to False. Removing duplicates.\")\n        df = df.drop_duplicates(subset=[\"v\", \"w\"])\n\n    # Create index mapping and data object\n    mapping = IndexMap(node_ids=np.unique(df[[\"v\", \"w\"]].values).tolist())\n    data = Data(\n        edge_index=mapping.to_idxs(df[[\"v\", \"w\"]].values.T),\n        num_nodes=num_nodes if num_nodes is not None else mapping.node_ids.shape[0],  # type: ignore\n    )\n\n    # Parse all columns except 'v' and 'w' as edge attributes\n    cols = df.columns.tolist()\n    cols.remove(\"v\")\n    cols.remove(\"w\")\n    for col in cols:\n        if col.startswith(\"edge_\"):\n            prefix = \"\"\n        else:\n            prefix = \"edge_\"\n\n        _parse_df_column(df=df, data=data, attr=col, prefix=prefix)\n\n    # Create graph object\n    g = Graph(data=data, mapping=mapping)\n    # If the graph should be undirected, convert it to an undirected graph\n    if is_undirected:\n        g = g.to_undirected()\n\n    return g\n</code></pre>"},{"location":"reference/pathpyG/io/pandas/#pathpyG.io.pandas.df_to_temporal_graph","title":"<code>df_to_temporal_graph</code>","text":"<p>Read a temporal graph from a DataFrame.</p> <p>The DataFrame is expected to have a minimum of two columns <code>v</code> and <code>w</code> that give the source and target nodes of edges. Each row in the DataFrame is mapped to one temporal edge. Additional columns in the DataFrame will be mapped to edge attributes.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pandas.DataFrame</code> <p>pandas.DataFrame with rows containing time-stamped edges and optional edge attributes.</p> required <code>multiedges</code> <code>bool</code> <p>Whether or not to allow multiple edges between the same node pair. By default multi edges are ignored.</p> <code>False</code> <code>timestamp_format</code> <p>The format of the time stamps in the <code>t</code> column.</p> <code>'%Y-%m-%d %H:%M:%S'</code> <code>time_rescale</code> <p>The factor by which to rescale the time stamps. Defaults to 1, meaning no rescaling.</p> <code>1</code> <code>num_nodes</code> <code>int | None</code> <p>The number of nodes in the graph. If None, the number of unique nodes in the DataFrame is used.</p> <code>None</code> Example <pre><code>import pathpyG as pp\nimport pandas as pd\n\ndf = pd.DataFrame({\"v\": [\"a\", \"b\", \"c\"], \"w\": [\"b\", \"c\", \"a\"], \"t\": [1, 2, 3]})\ng = pp.io.df_to_temporal_graph(df)\nprint(g)\n\ndf = pd.DataFrame([[\"a\", \"b\", \"c\"], [\"b\", \"c\", \"a\"], [1, 2, 3]])\ng = pp.io.df_to_temporal_graph(df)\nprint(g)\n</code></pre> Source code in <code>src/pathpyG/io/pandas.py</code> <pre><code>def df_to_temporal_graph(\n    df: pd.DataFrame,\n    multiedges: bool = False,\n    timestamp_format=\"%Y-%m-%d %H:%M:%S\",\n    time_rescale=1,\n    num_nodes: int | None = None,\n) -&gt; TemporalGraph:\n    \"\"\"Read a temporal graph from a DataFrame.\n\n    The DataFrame is expected to have a minimum of two columns `v` and `w`\n    that give the source and target nodes of edges. Each row in the DataFrame is\n    mapped to one temporal edge. Additional columns in the DataFrame will be\n    mapped to edge attributes.\n\n    Args:\n        df: pandas.DataFrame with rows containing time-stamped edges and optional edge\n            attributes.\n        multiedges: Whether or not to allow multiple edges between the same node pair. By\n            default multi edges are ignored.\n        timestamp_format: The format of the time stamps in the `t` column.\n        time_rescale: The factor by which to rescale the time stamps. Defaults to 1, meaning no rescaling.\n        num_nodes: The number of nodes in the graph. If None, the number of unique nodes\n            in the DataFrame is used.\n\n    Example:\n        ```py\n        import pathpyG as pp\n        import pandas as pd\n\n        df = pd.DataFrame({\"v\": [\"a\", \"b\", \"c\"], \"w\": [\"b\", \"c\", \"a\"], \"t\": [1, 2, 3]})\n        g = pp.io.df_to_temporal_graph(df)\n        print(g)\n\n        df = pd.DataFrame([[\"a\", \"b\", \"c\"], [\"b\", \"c\", \"a\"], [1, 2, 3]])\n        g = pp.io.df_to_temporal_graph(df)\n        print(g)\n        ```\n    \"\"\"\n    # assign column names if no header is present\n    no_header = all(isinstance(x, int) for x in df.columns.values.tolist())\n\n    if no_header:\n        # interpret first two columns as source and target\n        logger.info(\"Interpreting first three columns as v, w, t\")\n        col_names = [\"v\", \"w\", \"t\"]\n        # interpret remaining columns as edge attributes\n        for i in range(3, len(df.columns.values.tolist())):\n            col_names += [\"edge_attr_{0}\".format(i - 2)]\n        df.columns = col_names\n\n    # parse the time stamp column \"t\"\n    _parse_timestamp(df=df, timestamp_format=timestamp_format, time_rescale=time_rescale)\n\n    # optionally remove multiedges\n    if not multiedges:\n        df = df.drop_duplicates(subset=[\"v\", \"w\", \"t\"])\n\n    # Create index mapping and data object\n    mapping = IndexMap(node_ids=np.unique(df[[\"v\", \"w\"]].values))\n    data = Data(\n        edge_index=mapping.to_idxs(df[[\"v\", \"w\"]].values.T),\n        time=torch.tensor(df[\"t\"].values),\n        num_nodes=num_nodes if num_nodes is not None else mapping.node_ids.shape[0],  # type: ignore\n    )\n\n    # add edge attributes\n    cols = [col for col in df.columns if col not in [\"v\", \"w\", \"t\"]]\n    for col in cols:\n        if col.startswith(\"edge_\"):\n            prefix = \"\"\n        else:\n            prefix = \"edge_\"\n\n        _parse_df_column(df=df, data=data, attr=col, prefix=prefix)\n\n    # Create temporal graph object\n    g = TemporalGraph(data=data, mapping=mapping)\n\n    return g\n</code></pre>"},{"location":"reference/pathpyG/io/pandas/#pathpyG.io.pandas.graph_to_df","title":"<code>graph_to_df</code>","text":"<p>Return a pandas.DataFrame for a given graph.</p> <p>Contains all edges including edge attributes. Node and network-level  attributes are not included. To facilitate the import into network analysis  tools that only support integer node identifiers, node uids can be replaced  by a consecutive, zero-based index.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The graph to export as pandas DataFrame</p> required <code>node_indices</code> <code>typing.Optional[bool]</code> <p>whether nodes should be exported as integer indices</p> <code>False</code> Example <pre><code>import pathpyG as pp\n\nn = pp.Graph.from_edge_list([(\"a\", \"b\"), (\"b\", \"c\"), (\"c\", \"a\")])\ndf = pp.io.to_dataframe(n)\nprint(df)\n</code></pre> Source code in <code>src/pathpyG/io/pandas.py</code> <pre><code>def graph_to_df(graph: Graph, node_indices: Optional[bool] = False) -&gt; pd.DataFrame:\n    \"\"\"Return a [pandas.DataFrame][] for a given [graph][pathpyG.Graph].\n\n    Contains all edges including edge attributes. Node and network-level \n    attributes are not included. To facilitate the import into network analysis \n    tools that only support integer node identifiers, node uids can be replaced \n    by a consecutive, zero-based index.\n\n    Args:\n        graph: The graph to export as pandas DataFrame\n        node_indices: whether nodes should be exported as integer indices\n\n    Example:\n        ```py\n        import pathpyG as pp\n\n        n = pp.Graph.from_edge_list([(\"a\", \"b\"), (\"b\", \"c\"), (\"c\", \"a\")])\n        df = pp.io.to_dataframe(n)\n        print(df)\n        ```\n    \"\"\"\n    if node_indices:\n        vs = to_numpy(graph.data.edge_index[0])\n        ws = to_numpy(graph.data.edge_index[1])\n    else:\n        vs = graph.mapping.to_ids(to_numpy(graph.data.edge_index[0]))\n        ws = graph.mapping.to_ids(to_numpy(graph.data.edge_index[1]))\n    df = pd.DataFrame({**{\"v\": vs, \"w\": ws}, **{a: graph.data[a].tolist() for a in graph.edge_attrs()}})\n\n    return df\n</code></pre>"},{"location":"reference/pathpyG/io/pandas/#pathpyG.io.pandas.read_csv_graph","title":"<code>read_csv_graph</code>","text":"<p>Read a <code>Graph</code> from a csv file.</p> <p>This method reads a graph from a <code>.csv</code>-file and converts it to a <code>Graph</code> object. To read a temporal graph, the csv file must have a header with column <code>t</code> containing time stamps of edges</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the csv file containing the graph data.</p> required <code>sep</code> <code>str</code> <p>character separating columns in the csv file</p> <code>','</code> <code>header</code> <code>bool</code> <p>whether or not the first line of the csv file is interpreted as header with column names</p> <code>True</code> <code>is_undirected</code> <code>bool</code> <p>whether or not to interpret edges as undirected</p> <code>False</code> <code>multiedges</code> <code>bool</code> <p>whether or not to allow multiple edges between the same node pair. By default multi edges are ignored.</p> <code>False</code> <code>**kwargs</code> <code>typing.Any</code> <p>Additional keyword arguments passed to the <code>df_to_graph</code> function.</p> <code>{}</code> Example <pre><code>import pathpyG as pp\n\ng = pp.io.read_csv(\"example_graph.csv\")\ng = pp.io.read_csv(\"example_temporal_graph.csv\")\n</code></pre> Source code in <code>src/pathpyG/io/pandas.py</code> <pre><code>def read_csv_graph(\n    filename: str,\n    sep: str = \",\",\n    header: bool = True,\n    is_undirected: bool = False,\n    multiedges: bool = False,\n    **kwargs: Any,\n) -&gt; Graph:\n    \"\"\"Read a `Graph` from a csv file.\n\n    This method reads a graph from a `.csv`-file and converts it to a\n    `Graph` object. To read a temporal graph, the csv file must have\n    a header with column `t` containing time stamps of edges\n\n    Args:\n        filename: The path to the csv file containing the graph data.\n        sep: character separating columns in the csv file\n        header: whether or not the first line of the csv file is interpreted as header with column names\n        is_undirected: whether or not to interpret edges as undirected\n        multiedges: whether or not to allow multiple edges between the same node pair. By default multi edges are\n            ignored.\n        **kwargs: Additional keyword arguments passed to the `df_to_graph` function.\n\n    Example:\n        ```py\n        import pathpyG as pp\n\n        g = pp.io.read_csv(\"example_graph.csv\")\n        g = pp.io.read_csv(\"example_temporal_graph.csv\")\n        ```\n    \"\"\"\n    if header:\n        df = pd.read_csv(filename, header=0, sep=sep)\n    else:\n        df = pd.read_csv(filename, header=None, sep=sep)\n\n    return df_to_graph(df, is_undirected=is_undirected, multiedges=multiedges, **kwargs)\n</code></pre>"},{"location":"reference/pathpyG/io/pandas/#pathpyG.io.pandas.read_csv_path_data","title":"<code>read_csv_path_data</code>","text":"<p>Read multiple paths stored in an n-gram csv file.</p> <p>Parameters:</p> Name Type Description Default <code>path_or_buf</code> <code>typing.Any</code> <p>File, path or file-like object that the pandas.read_table function will read from</p> <code>None</code> <code>weight</code> <code>bool</code> <p>If True the last column of each row in the CSV file will be interpreted as a count or weight</p> <code>True</code> <code>sep</code> <p>character that separates the nodes (and weight) in each line of the input file</p> <code>','</code> <code>device</code> <code>typing.Optional[torch.device]</code> <p>The device on which the PathData object should be created</p> <code>None</code> Source code in <code>src/pathpyG/io/pandas.py</code> <pre><code>def read_csv_path_data(\n    path_or_buf: Any = None, weight: bool = True, sep=\",\", device: Optional[torch.device] = None\n) -&gt; PathData:\n    \"\"\"Read multiple paths stored in an n-gram csv file.\n\n    Args:\n        path_or_buf: File, path or file-like object that the [pandas.read_table][] function will read from\n        weight: If True the last column of each row in the CSV file will be interpreted as a count or weight\n        sep: character that separates the nodes (and weight) in each line of the input file\n        device: The device on which the PathData object should be created\n    \"\"\"\n    # Read raw data\n    df = pd.read_table(filepath_or_buffer=path_or_buf, header=None)\n    # split and expand non-uniform rows\n    df = df[0].str.split(sep, expand=True)\n\n    paths = []\n    weights = []\n\n    # extract node sequences and edges\n    for row in df.itertuples(index=False):\n        p = [x for x in row if x]\n        if weight:\n            weights.append(float(p[-1]))\n            p.pop()\n        else:\n            weights.append(1.0)\n        paths.append(p)\n\n    # create index mapping\n    mapping = IndexMap()\n    mapping.add_ids(np.unique(np.hstack(paths)))\n\n    # create path_data object\n    pathdata = PathData(mapping, device)\n    pathdata.append_walks(node_seqs=paths, weights=weights)\n    return pathdata\n</code></pre>"},{"location":"reference/pathpyG/io/pandas/#pathpyG.io.pandas.read_csv_temporal_graph","title":"<code>read_csv_temporal_graph</code>","text":"<p>Read a <code>TemporalGraph</code> from a csv file.</p> <p>This method reads a temporal graph from a <code>.csv</code>-file and converts it to a <code>TemporalGraph</code> object. The csv file is expected to have a header with columns <code>v</code>, <code>w</code>, and <code>t</code> containing source nodes, target nodes, and time stamps of edges, respectively. Additional columns in the csv file will be interpreted as edge attributes.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the csv file containing the temporal graph data.</p> required <code>sep</code> <code>str</code> <p>character separating columns in the csv file</p> <code>','</code> <code>header</code> <code>bool</code> <p>whether or not the first line of the csv file is interpreted as header with column names</p> <code>True</code> <code>timestamp_format</code> <code>str</code> <p>The format of the time stamps in the <code>t</code> column.</p> <code>'%Y-%m-%d %H:%M:%S'</code> <code>time_rescale</code> <code>int</code> <p>The factor by which to rescale the time stamps. Defaults to 1, meaning no rescaling.</p> <code>1</code> <code>**kwargs</code> <code>typing.Any</code> <p>Additional keyword arguments passed to the <code>df_to_temporal_graph</code> function.</p> <code>{}</code> Example <pre><code>import pathpyG as pp\n\ng = pp.io.read_csv(\"example_temporal_graph.csv\")\n</code></pre> Source code in <code>src/pathpyG/io/pandas.py</code> <pre><code>def read_csv_temporal_graph(\n    filename: str,\n    sep: str = \",\",\n    header: bool = True,\n    timestamp_format: str = \"%Y-%m-%d %H:%M:%S\",\n    time_rescale: int = 1,\n    **kwargs: Any,\n) -&gt; TemporalGraph:\n    \"\"\"Read a `TemporalGraph` from a csv file.\n\n    This method reads a temporal graph from a `.csv`-file and converts it to a\n    `TemporalGraph` object. The csv file is expected to have a header with columns\n    `v`, `w`, and `t` containing source nodes, target nodes, and time stamps of edges,\n    respectively. Additional columns in the csv file will be interpreted as edge attributes.\n\n    Args:\n        filename: The path to the csv file containing the temporal graph data.\n        sep: character separating columns in the csv file\n        header: whether or not the first line of the csv file is interpreted as header with column names\n        timestamp_format: The format of the time stamps in the `t` column.\n        time_rescale: The factor by which to rescale the time stamps. Defaults to 1, meaning no rescaling.\n        **kwargs: Additional keyword arguments passed to the `df_to_temporal_graph` function.\n\n    Example:\n        ```py\n        import pathpyG as pp\n\n        g = pp.io.read_csv(\"example_temporal_graph.csv\")\n        ```\n    \"\"\"\n    if header:\n        df = pd.read_csv(filename, header=0, sep=sep)\n    else:\n        df = pd.read_csv(filename, header=None, sep=sep)\n    return df_to_temporal_graph(df, timestamp_format=timestamp_format, time_rescale=time_rescale, **kwargs)\n</code></pre>"},{"location":"reference/pathpyG/io/pandas/#pathpyG.io.pandas.temporal_graph_to_df","title":"<code>temporal_graph_to_df</code>","text":"<p>Return a pandas.DataFrame for a given temporal graph.</p> <p>Contains all edges including edge attributes. Node and network-level  attributes are not included. To facilitate the import into network analysis  tools that only support integer node identifiers, node uids can be replaced  by a consecutive, zero-based index.</p> <p>facilitate the import into network analysis tools that only support integer node identifiers, node uids can be replaced by a consecutive, zero-based index.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.temporal_graph.TemporalGraph</code> <p>The graph to export as pandas DataFrame</p> required <code>node_indices</code> <code>typing.Optional[bool]</code> <p>whether nodes should be exported as integer indices</p> <code>False</code> Example <pre><code>import pathpyG as pp\n\nn = pp.TemporalGraph.from_edge_list([(\"a\", \"b\", 1), (\"b\", \"c\", 2), (\"c\", \"a\", 3)])\ndf = pp.io.to_df(n)\nprint(df)\n</code></pre> Source code in <code>src/pathpyG/io/pandas.py</code> <pre><code>def temporal_graph_to_df(graph: TemporalGraph, node_indices: Optional[bool] = False) -&gt; pd.DataFrame:\n    \"\"\"Return a [pandas.DataFrame][] for a given [temporal graph][pathpyG.TemporalGraph].\n\n    Contains all edges including edge attributes. Node and network-level \n    attributes are not included. To facilitate the import into network analysis \n    tools that only support integer node identifiers, node uids can be replaced \n    by a consecutive, zero-based index.\n\n    facilitate the import into network analysis tools that only support integer\n    node identifiers, node uids can be replaced by a consecutive, zero-based\n    index.\n\n    Args:\n        graph: The graph to export as pandas DataFrame\n        node_indices: whether nodes should be exported as integer indices\n\n    Example:\n        ```py\n        import pathpyG as pp\n\n        n = pp.TemporalGraph.from_edge_list([(\"a\", \"b\", 1), (\"b\", \"c\", 2), (\"c\", \"a\", 3)])\n        df = pp.io.to_df(n)\n        print(df)\n        ```\n    \"\"\"\n    if node_indices:\n        vs = to_numpy(graph.data.edge_index[0])\n        ws = to_numpy(graph.data.edge_index[1])\n    else:\n        vs = graph.mapping.to_ids(to_numpy(graph.data.edge_index[0]))\n        ws = graph.mapping.to_ids(to_numpy(graph.data.edge_index[1]))\n    df = pd.DataFrame(\n        {\n            **{\"v\": vs, \"w\": ws, \"t\": graph.data.time.tolist()},\n            **{a: graph.data[a].tolist() for a in graph.edge_attrs()},\n        }\n    )\n\n    return df\n</code></pre>"},{"location":"reference/pathpyG/io/pandas/#pathpyG.io.pandas.write_csv","title":"<code>write_csv</code>","text":"<p>Store all edges of a graph or temporal graph in a csv file.</p> <p>This method stores a <code>Graph</code> or <code>TemporalGraph</code> as a <code>.csv</code> file. The csv file will contain all edges including edge attributes. Node and network-level attributes are not included. To facilitate the import into network analysis tools that only support integer node identifiers, node uids can be replaced by a consecutive, zero-based index.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>typing.Union[pathpyG.core.graph.Graph, pathpyG.core.temporal_graph.TemporalGraph]</code> <p>The graph to export as pandas DataFrame</p> required <code>node_indices</code> <code>bool</code> <p>whether nodes should be exported as integer indices</p> <code>False</code> <code>path_or_buf</code> <code>typing.Any</code> <p>String, path, or file-like object (see documentation of pandas.DataFrame.to_csv)</p> <code>None</code> <code>**pdargs</code> <code>typing.Any</code> <p>Additional keyword arguments passed to pandas.DataFrame.to_csv.</p> <code>{}</code> Source code in <code>src/pathpyG/io/pandas.py</code> <pre><code>def write_csv(\n    graph: Union[Graph, TemporalGraph], node_indices: bool = False, path_or_buf: Any = None, **pdargs: Any\n) -&gt; None:\n    \"\"\"Store all edges of a graph or temporal graph in a csv file.\n\n    This method stores a `Graph` or `TemporalGraph` as a `.csv` file. The csv file\n    will contain all edges including edge attributes. Node and network-level attributes\n    are not included. To facilitate the import into network analysis tools that only\n    support integer node identifiers, node uids can be replaced by a consecutive,\n    zero-based index.\n\n    Args:\n        graph: The graph to export as pandas DataFrame\n        node_indices: whether nodes should be exported as integer indices\n        path_or_buf: String, path, or file-like object (see documentation of [pandas.DataFrame.to_csv][])\n        **pdargs: Additional keyword arguments passed to [pandas.DataFrame.to_csv][].\n    \"\"\"\n    if isinstance(graph, TemporalGraph):\n        frame = temporal_graph_to_df(graph=graph, node_indices=node_indices)\n    else:\n        frame = graph_to_df(graph=graph, node_indices=node_indices)\n    frame.to_csv(index=False, path_or_buf=path_or_buf, **pdargs)\n</code></pre>"},{"location":"reference/pathpyG/nn/","title":"nn","text":"<p>Module for neural network architectures implemented in PathPyG.</p>"},{"location":"reference/pathpyG/nn/#pathpyG.nn.DBGNN","title":"<code>DBGNN</code>","text":"<p>               Bases: <code>torch.nn.Module</code></p> <p>Implementation of the time-aware graph neural network DBGNN for time-resolved data on dynamic graph.</p> <p>The De Bruijn Graph Neural Network (DBGNN) is a time-aware graph neural network architecture designed for dynamic graphs that captures temporal-topological patterns through causal walks \u2014 temporally ordered sequences that represent how nodes influence each other over time. The architecture uses multiple layers of higher-order De Bruijn graphs for message passing, where nodes represent walks of increasing length, enabling the model to learn non-Markovian patterns in the causal topology of dynamic graphs.</p> Reference <p>Proposed by Qarkaxhija, Perri, and Scholtes at the first Learning on Graphs Conference (LoG) in 2022<sup>1</sup>. The paper can be found here.</p> <ol> <li> <p>Qarkaxhija, L., Perri, V. &amp; Scholtes, I. De Bruijn Goes Neural: Causality-Aware Graph Neural Networks for Time Series Data on Dynamic Graphs. in LoG vol. 198 51 (PMLR, 2022). \u21a9</p> </li> </ol> Source code in <code>src/pathpyG/nn/dbgnn.py</code> <pre><code>class DBGNN(Module):\n    \"\"\"Implementation of the time-aware graph neural network DBGNN for time-resolved data on dynamic graph.\n\n    The De Bruijn Graph Neural Network (DBGNN) is a time-aware graph neural network architecture designed for dynamic graphs\n    that captures temporal-topological patterns through causal walks \u2014 temporally ordered sequences that represent how nodes influence each other over time.\n    The architecture uses multiple layers of higher-order De Bruijn graphs for message passing, where nodes represent walks of increasing length,\n    enabling the model to learn non-Markovian patterns in the causal topology of dynamic graphs.\n\n    ??? reference\n        Proposed by Qarkaxhija, Perri, and Scholtes at the first Learning on Graphs Conference (LoG) in 2022[^1]. The paper can be found [here](https://proceedings.mlr.press/v198/qarkaxhija22a/qarkaxhija22a.pdf).\n\n    [^1]: *Qarkaxhija, L., Perri, V. &amp; Scholtes, I. De Bruijn Goes Neural: Causality-Aware Graph Neural Networks for Time Series Data on Dynamic Graphs. in LoG vol. 198 51 (PMLR, 2022).*\n    \"\"\"\n\n    def __init__(self, num_classes: int, num_features: tuple[int, int], hidden_dims: list[int], p_dropout: float = 0.0):\n        \"\"\"Initialize the DBGNN model.\n\n        Args:\n            num_classes: Number of classes for the classification task\n            num_features: Number of features for first order and higher order nodes, i.e. `(first_order_num_features, second_order_num_features)`\n            hidden_dims: Number of hidden dimensions per layer in the both GNN parts (first-order and higher-order)\n            p_dropout: Drop-out probability for the dropout layers.\n        \"\"\"\n        super().__init__()\n\n        self.num_features = num_features\n        self.num_classes = num_classes\n        self.hidden_dims = hidden_dims\n        self.p_dropout = p_dropout\n\n        # higher-order layers\n        self.higher_order_layers = ModuleList()\n        self.higher_order_layers.append(GCNConv(self.num_features[1], self.hidden_dims[0]))\n\n        # first-order layers\n        self.first_order_layers = ModuleList()\n        self.first_order_layers.append(GCNConv(self.num_features[0], self.hidden_dims[0]))\n\n        for dim in range(1, len(self.hidden_dims) - 1):\n            # higher-order layers\n            self.higher_order_layers.append(GCNConv(self.hidden_dims[dim - 1], self.hidden_dims[dim]))\n            # first-order layers\n            self.first_order_layers.append(GCNConv(self.hidden_dims[dim - 1], self.hidden_dims[dim]))\n\n        self.bipartite_layer = BipartiteGraphOperator(self.hidden_dims[-2], self.hidden_dims[-1])\n\n        # Linear layer\n        self.lin = torch.nn.Linear(self.hidden_dims[-1], num_classes)\n\n    def forward(self, data: Data) -&gt; torch.Tensor:\n        \"\"\"Forward pass of the DBGNN.\n\n        Args:\n            data: Input [data][torch_geometric.data.Data] object containing the graph structure and node features.\n        \"\"\"\n        x = data.x\n        x_h = data.x_h\n\n        # First-order convolutions\n        for layer in self.first_order_layers:\n            x = F.dropout(x, p=self.p_dropout, training=self.training)\n            x = F.elu(layer(x, data.edge_index, data.edge_weights))\n        x = F.dropout(x, p=self.p_dropout, training=self.training)\n\n        # Second-order convolutions\n        for layer in self.higher_order_layers:\n            x_h = F.dropout(x_h, p=self.p_dropout, training=self.training)\n            x_h = F.elu(layer(x_h, data.edge_index_higher_order, data.edge_weights_higher_order))\n        x_h = F.dropout(x_h, p=self.p_dropout, training=self.training)\n\n        # Bipartite message passing\n        x = torch.nn.functional.elu(\n            self.bipartite_layer((x_h, x), data.bipartite_edge_index, n_ho=data.num_ho_nodes, n_fo=data.num_nodes)\n        )\n        x = F.dropout(x, p=self.p_dropout, training=self.training)\n\n        # Linear layer\n        x = self.lin(x)\n\n        return x\n</code></pre>"},{"location":"reference/pathpyG/nn/#pathpyG.nn.DBGNN.__init__","title":"<code>__init__</code>","text":"<p>Initialize the DBGNN model.</p> <p>Parameters:</p> Name Type Description Default <code>num_classes</code> <code>int</code> <p>Number of classes for the classification task</p> required <code>num_features</code> <code>tuple[int, int]</code> <p>Number of features for first order and higher order nodes, i.e. <code>(first_order_num_features, second_order_num_features)</code></p> required <code>hidden_dims</code> <code>list[int]</code> <p>Number of hidden dimensions per layer in the both GNN parts (first-order and higher-order)</p> required <code>p_dropout</code> <code>float</code> <p>Drop-out probability for the dropout layers.</p> <code>0.0</code> Source code in <code>src/pathpyG/nn/dbgnn.py</code> <pre><code>def __init__(self, num_classes: int, num_features: tuple[int, int], hidden_dims: list[int], p_dropout: float = 0.0):\n    \"\"\"Initialize the DBGNN model.\n\n    Args:\n        num_classes: Number of classes for the classification task\n        num_features: Number of features for first order and higher order nodes, i.e. `(first_order_num_features, second_order_num_features)`\n        hidden_dims: Number of hidden dimensions per layer in the both GNN parts (first-order and higher-order)\n        p_dropout: Drop-out probability for the dropout layers.\n    \"\"\"\n    super().__init__()\n\n    self.num_features = num_features\n    self.num_classes = num_classes\n    self.hidden_dims = hidden_dims\n    self.p_dropout = p_dropout\n\n    # higher-order layers\n    self.higher_order_layers = ModuleList()\n    self.higher_order_layers.append(GCNConv(self.num_features[1], self.hidden_dims[0]))\n\n    # first-order layers\n    self.first_order_layers = ModuleList()\n    self.first_order_layers.append(GCNConv(self.num_features[0], self.hidden_dims[0]))\n\n    for dim in range(1, len(self.hidden_dims) - 1):\n        # higher-order layers\n        self.higher_order_layers.append(GCNConv(self.hidden_dims[dim - 1], self.hidden_dims[dim]))\n        # first-order layers\n        self.first_order_layers.append(GCNConv(self.hidden_dims[dim - 1], self.hidden_dims[dim]))\n\n    self.bipartite_layer = BipartiteGraphOperator(self.hidden_dims[-2], self.hidden_dims[-1])\n\n    # Linear layer\n    self.lin = torch.nn.Linear(self.hidden_dims[-1], num_classes)\n</code></pre>"},{"location":"reference/pathpyG/nn/#pathpyG.nn.DBGNN.forward","title":"<code>forward</code>","text":"<p>Forward pass of the DBGNN.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>torch_geometric.data.Data</code> <p>Input data object containing the graph structure and node features.</p> required Source code in <code>src/pathpyG/nn/dbgnn.py</code> <pre><code>def forward(self, data: Data) -&gt; torch.Tensor:\n    \"\"\"Forward pass of the DBGNN.\n\n    Args:\n        data: Input [data][torch_geometric.data.Data] object containing the graph structure and node features.\n    \"\"\"\n    x = data.x\n    x_h = data.x_h\n\n    # First-order convolutions\n    for layer in self.first_order_layers:\n        x = F.dropout(x, p=self.p_dropout, training=self.training)\n        x = F.elu(layer(x, data.edge_index, data.edge_weights))\n    x = F.dropout(x, p=self.p_dropout, training=self.training)\n\n    # Second-order convolutions\n    for layer in self.higher_order_layers:\n        x_h = F.dropout(x_h, p=self.p_dropout, training=self.training)\n        x_h = F.elu(layer(x_h, data.edge_index_higher_order, data.edge_weights_higher_order))\n    x_h = F.dropout(x_h, p=self.p_dropout, training=self.training)\n\n    # Bipartite message passing\n    x = torch.nn.functional.elu(\n        self.bipartite_layer((x_h, x), data.bipartite_edge_index, n_ho=data.num_ho_nodes, n_fo=data.num_nodes)\n    )\n    x = F.dropout(x, p=self.p_dropout, training=self.training)\n\n    # Linear layer\n    x = self.lin(x)\n\n    return x\n</code></pre>"},{"location":"reference/pathpyG/nn/dbgnn/","title":"dbgnn","text":"<p>Implementation of the time-aware graph neural network DBGNN (De Bruijn Graph Neural Network) proposed by Qarkaxhija, Perri, and Scholtes (2022)<sup>1</sup>.</p> <p>This architecture is designed for time-resolved data on dynamic graphs and captures temporal-topological patterns through causal walks. For many temporal graphs, the static representation fails to capture important temporal patterns. An example for two different temporal patterns that are indistinguishable in the static representation is illustrated below:</p> <p></p> <p>Frequency and topology of edges are identical, i.e. they have the same first-order time-aggregated weighted graph (center). Due to the arrow of time, causal walks and paths differ in the dynamic graphs: Assuming a maximum waiting time \\(\\delta = 1\\) in each node, the left example node \\(A\\) cannot causally influence \\(C\\) via \\(B\\), while such a causal path is possible in the right example. A second-order De Bruijn graph model of causal walks in the two graphs (bottom left and right) captures this difference in the causal topology.</p> <p>Building on such higher-order graph models, the DBGNN defines a GNN architecture that is able to learn patterns in the causal topology of these dynamic graphs:</p> <p></p> <p>Illustration of DBGNN architecture with two message passing layers in first- (left, gray) and second-order De Bruijn graph (right, orange) corresponding to the dynamic graph above (left). Red edges indicate the bipartite mapping \\(G_b\\) of higher-order node representations to first-order representations.</p> <ol> <li> <p>Qarkaxhija, L., Perri, V. &amp; Scholtes, I. De Bruijn Goes Neural: Causality-Aware Graph Neural Networks for Time Series Data on Dynamic Graphs. in LoG vol. 198 51 (PMLR, 2022). \u21a9</p> </li> </ol>"},{"location":"reference/pathpyG/nn/dbgnn/#pathpyG.nn.dbgnn.BipartiteGraphOperator","title":"<code>BipartiteGraphOperator</code>","text":"<p>               Bases: <code>torch_geometric.nn.MessagePassing</code></p> <p>Bipartite graph operator for message passing between higher-order and first-order nodes.</p> <p>This class implements a bipartite graph operator that performs message passing from the higher-order nodes to the first-order nodes in the DBGNN architecture. This corresponds to the red edges in the DBGNN illustration above.</p> Source code in <code>src/pathpyG/nn/dbgnn.py</code> <pre><code>class BipartiteGraphOperator(MessagePassing):\n    \"\"\"Bipartite graph operator for message passing between higher-order and first-order nodes.\n\n    This class implements a bipartite graph operator that performs message passing from the higher-order nodes to the first-order nodes\n    in the DBGNN architecture. This corresponds to the red edges in the DBGNN illustration above.\n    \"\"\"\n\n    def __init__(self, in_ch: int, out_ch: int):\n        \"\"\"Initialize the BipartiteGraphOperator.\n\n        Args:\n            in_ch: number of input channels\n            out_ch: number of output channels\n        \"\"\"\n        super(BipartiteGraphOperator, self).__init__(\"add\")\n        self.lin1 = Linear(in_ch, out_ch)\n        self.lin2 = Linear(in_ch, out_ch)\n\n    def forward(\n        self, x: tuple[torch.Tensor, torch.Tensor], bipartite_index: torch.Tensor, n_ho: int, n_fo: int\n    ) -&gt; torch.Tensor:\n        \"\"\"Forward pass of the BipartiteGraphOperator.\n\n        Args:\n            x: Tuple of node features for higher-order [index 0] and first-order nodes [index 1].\n            bipartite_index: Edge index for the bipartite graph connecting higher-order and first-order nodes.\n            n_ho: Number of higher-order nodes.\n            n_fo: Number of first-order nodes.\n\n        Returns:\n            Updated node features for first-order nodes after message passing.\n        \"\"\"\n        x = (self.lin1(x[0]), self.lin2(x[1]))\n        return self.propagate(bipartite_index, size=(n_ho, n_fo), x=x)\n\n    def message(self, x_i, x_j):\n        \"\"\"Message function for message passing.\"\"\"\n        return x_i + x_j\n</code></pre>"},{"location":"reference/pathpyG/nn/dbgnn/#pathpyG.nn.dbgnn.BipartiteGraphOperator.__init__","title":"<code>__init__</code>","text":"<p>Initialize the BipartiteGraphOperator.</p> <p>Parameters:</p> Name Type Description Default <code>in_ch</code> <code>int</code> <p>number of input channels</p> required <code>out_ch</code> <code>int</code> <p>number of output channels</p> required Source code in <code>src/pathpyG/nn/dbgnn.py</code> <pre><code>def __init__(self, in_ch: int, out_ch: int):\n    \"\"\"Initialize the BipartiteGraphOperator.\n\n    Args:\n        in_ch: number of input channels\n        out_ch: number of output channels\n    \"\"\"\n    super(BipartiteGraphOperator, self).__init__(\"add\")\n    self.lin1 = Linear(in_ch, out_ch)\n    self.lin2 = Linear(in_ch, out_ch)\n</code></pre>"},{"location":"reference/pathpyG/nn/dbgnn/#pathpyG.nn.dbgnn.BipartiteGraphOperator.forward","title":"<code>forward</code>","text":"<p>Forward pass of the BipartiteGraphOperator.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>tuple[torch.Tensor, torch.Tensor]</code> <p>Tuple of node features for higher-order [index 0] and first-order nodes [index 1].</p> required <code>bipartite_index</code> <code>torch.Tensor</code> <p>Edge index for the bipartite graph connecting higher-order and first-order nodes.</p> required <code>n_ho</code> <code>int</code> <p>Number of higher-order nodes.</p> required <code>n_fo</code> <code>int</code> <p>Number of first-order nodes.</p> required <p>Returns:</p> Type Description <code>torch.Tensor</code> <p>Updated node features for first-order nodes after message passing.</p> Source code in <code>src/pathpyG/nn/dbgnn.py</code> <pre><code>def forward(\n    self, x: tuple[torch.Tensor, torch.Tensor], bipartite_index: torch.Tensor, n_ho: int, n_fo: int\n) -&gt; torch.Tensor:\n    \"\"\"Forward pass of the BipartiteGraphOperator.\n\n    Args:\n        x: Tuple of node features for higher-order [index 0] and first-order nodes [index 1].\n        bipartite_index: Edge index for the bipartite graph connecting higher-order and first-order nodes.\n        n_ho: Number of higher-order nodes.\n        n_fo: Number of first-order nodes.\n\n    Returns:\n        Updated node features for first-order nodes after message passing.\n    \"\"\"\n    x = (self.lin1(x[0]), self.lin2(x[1]))\n    return self.propagate(bipartite_index, size=(n_ho, n_fo), x=x)\n</code></pre>"},{"location":"reference/pathpyG/nn/dbgnn/#pathpyG.nn.dbgnn.BipartiteGraphOperator.message","title":"<code>message</code>","text":"<p>Message function for message passing.</p> Source code in <code>src/pathpyG/nn/dbgnn.py</code> <pre><code>def message(self, x_i, x_j):\n    \"\"\"Message function for message passing.\"\"\"\n    return x_i + x_j\n</code></pre>"},{"location":"reference/pathpyG/nn/dbgnn/#pathpyG.nn.dbgnn.DBGNN","title":"<code>DBGNN</code>","text":"<p>               Bases: <code>torch.nn.Module</code></p> <p>Implementation of the time-aware graph neural network DBGNN for time-resolved data on dynamic graph.</p> <p>The De Bruijn Graph Neural Network (DBGNN) is a time-aware graph neural network architecture designed for dynamic graphs that captures temporal-topological patterns through causal walks \u2014 temporally ordered sequences that represent how nodes influence each other over time. The architecture uses multiple layers of higher-order De Bruijn graphs for message passing, where nodes represent walks of increasing length, enabling the model to learn non-Markovian patterns in the causal topology of dynamic graphs.</p> Reference <p>Proposed by Qarkaxhija, Perri, and Scholtes at the first Learning on Graphs Conference (LoG) in 2022<sup>1</sup>. The paper can be found here.</p> <ol> <li> <p>Qarkaxhija, L., Perri, V. &amp; Scholtes, I. De Bruijn Goes Neural: Causality-Aware Graph Neural Networks for Time Series Data on Dynamic Graphs. in LoG vol. 198 51 (PMLR, 2022). \u21a9</p> </li> </ol> Source code in <code>src/pathpyG/nn/dbgnn.py</code> <pre><code>class DBGNN(Module):\n    \"\"\"Implementation of the time-aware graph neural network DBGNN for time-resolved data on dynamic graph.\n\n    The De Bruijn Graph Neural Network (DBGNN) is a time-aware graph neural network architecture designed for dynamic graphs\n    that captures temporal-topological patterns through causal walks \u2014 temporally ordered sequences that represent how nodes influence each other over time.\n    The architecture uses multiple layers of higher-order De Bruijn graphs for message passing, where nodes represent walks of increasing length,\n    enabling the model to learn non-Markovian patterns in the causal topology of dynamic graphs.\n\n    ??? reference\n        Proposed by Qarkaxhija, Perri, and Scholtes at the first Learning on Graphs Conference (LoG) in 2022[^1]. The paper can be found [here](https://proceedings.mlr.press/v198/qarkaxhija22a/qarkaxhija22a.pdf).\n\n    [^1]: *Qarkaxhija, L., Perri, V. &amp; Scholtes, I. De Bruijn Goes Neural: Causality-Aware Graph Neural Networks for Time Series Data on Dynamic Graphs. in LoG vol. 198 51 (PMLR, 2022).*\n    \"\"\"\n\n    def __init__(self, num_classes: int, num_features: tuple[int, int], hidden_dims: list[int], p_dropout: float = 0.0):\n        \"\"\"Initialize the DBGNN model.\n\n        Args:\n            num_classes: Number of classes for the classification task\n            num_features: Number of features for first order and higher order nodes, i.e. `(first_order_num_features, second_order_num_features)`\n            hidden_dims: Number of hidden dimensions per layer in the both GNN parts (first-order and higher-order)\n            p_dropout: Drop-out probability for the dropout layers.\n        \"\"\"\n        super().__init__()\n\n        self.num_features = num_features\n        self.num_classes = num_classes\n        self.hidden_dims = hidden_dims\n        self.p_dropout = p_dropout\n\n        # higher-order layers\n        self.higher_order_layers = ModuleList()\n        self.higher_order_layers.append(GCNConv(self.num_features[1], self.hidden_dims[0]))\n\n        # first-order layers\n        self.first_order_layers = ModuleList()\n        self.first_order_layers.append(GCNConv(self.num_features[0], self.hidden_dims[0]))\n\n        for dim in range(1, len(self.hidden_dims) - 1):\n            # higher-order layers\n            self.higher_order_layers.append(GCNConv(self.hidden_dims[dim - 1], self.hidden_dims[dim]))\n            # first-order layers\n            self.first_order_layers.append(GCNConv(self.hidden_dims[dim - 1], self.hidden_dims[dim]))\n\n        self.bipartite_layer = BipartiteGraphOperator(self.hidden_dims[-2], self.hidden_dims[-1])\n\n        # Linear layer\n        self.lin = torch.nn.Linear(self.hidden_dims[-1], num_classes)\n\n    def forward(self, data: Data) -&gt; torch.Tensor:\n        \"\"\"Forward pass of the DBGNN.\n\n        Args:\n            data: Input [data][torch_geometric.data.Data] object containing the graph structure and node features.\n        \"\"\"\n        x = data.x\n        x_h = data.x_h\n\n        # First-order convolutions\n        for layer in self.first_order_layers:\n            x = F.dropout(x, p=self.p_dropout, training=self.training)\n            x = F.elu(layer(x, data.edge_index, data.edge_weights))\n        x = F.dropout(x, p=self.p_dropout, training=self.training)\n\n        # Second-order convolutions\n        for layer in self.higher_order_layers:\n            x_h = F.dropout(x_h, p=self.p_dropout, training=self.training)\n            x_h = F.elu(layer(x_h, data.edge_index_higher_order, data.edge_weights_higher_order))\n        x_h = F.dropout(x_h, p=self.p_dropout, training=self.training)\n\n        # Bipartite message passing\n        x = torch.nn.functional.elu(\n            self.bipartite_layer((x_h, x), data.bipartite_edge_index, n_ho=data.num_ho_nodes, n_fo=data.num_nodes)\n        )\n        x = F.dropout(x, p=self.p_dropout, training=self.training)\n\n        # Linear layer\n        x = self.lin(x)\n\n        return x\n</code></pre>"},{"location":"reference/pathpyG/nn/dbgnn/#pathpyG.nn.dbgnn.DBGNN.__init__","title":"<code>__init__</code>","text":"<p>Initialize the DBGNN model.</p> <p>Parameters:</p> Name Type Description Default <code>num_classes</code> <code>int</code> <p>Number of classes for the classification task</p> required <code>num_features</code> <code>tuple[int, int]</code> <p>Number of features for first order and higher order nodes, i.e. <code>(first_order_num_features, second_order_num_features)</code></p> required <code>hidden_dims</code> <code>list[int]</code> <p>Number of hidden dimensions per layer in the both GNN parts (first-order and higher-order)</p> required <code>p_dropout</code> <code>float</code> <p>Drop-out probability for the dropout layers.</p> <code>0.0</code> Source code in <code>src/pathpyG/nn/dbgnn.py</code> <pre><code>def __init__(self, num_classes: int, num_features: tuple[int, int], hidden_dims: list[int], p_dropout: float = 0.0):\n    \"\"\"Initialize the DBGNN model.\n\n    Args:\n        num_classes: Number of classes for the classification task\n        num_features: Number of features for first order and higher order nodes, i.e. `(first_order_num_features, second_order_num_features)`\n        hidden_dims: Number of hidden dimensions per layer in the both GNN parts (first-order and higher-order)\n        p_dropout: Drop-out probability for the dropout layers.\n    \"\"\"\n    super().__init__()\n\n    self.num_features = num_features\n    self.num_classes = num_classes\n    self.hidden_dims = hidden_dims\n    self.p_dropout = p_dropout\n\n    # higher-order layers\n    self.higher_order_layers = ModuleList()\n    self.higher_order_layers.append(GCNConv(self.num_features[1], self.hidden_dims[0]))\n\n    # first-order layers\n    self.first_order_layers = ModuleList()\n    self.first_order_layers.append(GCNConv(self.num_features[0], self.hidden_dims[0]))\n\n    for dim in range(1, len(self.hidden_dims) - 1):\n        # higher-order layers\n        self.higher_order_layers.append(GCNConv(self.hidden_dims[dim - 1], self.hidden_dims[dim]))\n        # first-order layers\n        self.first_order_layers.append(GCNConv(self.hidden_dims[dim - 1], self.hidden_dims[dim]))\n\n    self.bipartite_layer = BipartiteGraphOperator(self.hidden_dims[-2], self.hidden_dims[-1])\n\n    # Linear layer\n    self.lin = torch.nn.Linear(self.hidden_dims[-1], num_classes)\n</code></pre>"},{"location":"reference/pathpyG/nn/dbgnn/#pathpyG.nn.dbgnn.DBGNN.forward","title":"<code>forward</code>","text":"<p>Forward pass of the DBGNN.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>torch_geometric.data.Data</code> <p>Input data object containing the graph structure and node features.</p> required Source code in <code>src/pathpyG/nn/dbgnn.py</code> <pre><code>def forward(self, data: Data) -&gt; torch.Tensor:\n    \"\"\"Forward pass of the DBGNN.\n\n    Args:\n        data: Input [data][torch_geometric.data.Data] object containing the graph structure and node features.\n    \"\"\"\n    x = data.x\n    x_h = data.x_h\n\n    # First-order convolutions\n    for layer in self.first_order_layers:\n        x = F.dropout(x, p=self.p_dropout, training=self.training)\n        x = F.elu(layer(x, data.edge_index, data.edge_weights))\n    x = F.dropout(x, p=self.p_dropout, training=self.training)\n\n    # Second-order convolutions\n    for layer in self.higher_order_layers:\n        x_h = F.dropout(x_h, p=self.p_dropout, training=self.training)\n        x_h = F.elu(layer(x_h, data.edge_index_higher_order, data.edge_weights_higher_order))\n    x_h = F.dropout(x_h, p=self.p_dropout, training=self.training)\n\n    # Bipartite message passing\n    x = torch.nn.functional.elu(\n        self.bipartite_layer((x_h, x), data.bipartite_edge_index, n_ho=data.num_ho_nodes, n_fo=data.num_nodes)\n    )\n    x = F.dropout(x, p=self.p_dropout, training=self.training)\n\n    # Linear layer\n    x = self.lin(x)\n\n    return x\n</code></pre>"},{"location":"reference/pathpyG/statistics/","title":"statistics","text":"<p>Functions to compute various graph statistics.</p> <p>The functions in this module allow to compute various statistics on graphs</p> Example <pre><code>import pathpyG as pp\n\n# Generate a toy example graph.\ng = pp.Graph.from_edge_list([(\"b\", \"c\"), (\"a\", \"b\"), (\"c\", \"d\"), (\"d\", \"a\"), (\"b\", \"d\")])\n\n# Calculate degree distribution and raw moments\nd_dist = pp.statistics.degree_distribution(g)\nk_1 = pp.statistics.degree_raw_moment(g, k=1)\nk_2 = pp.statistics.degree_raw_moment(g, k=2)\n</code></pre>"},{"location":"reference/pathpyG/statistics/#pathpyG.statistics.avg_clustering_coefficient","title":"<code>avg_clustering_coefficient</code>","text":"<p>Calculates the average clustering coefficient \\(C\\) of the graph \\(G=(V, E)\\).</p> <p>Given the local clustering coefficients \\(C_u\\) for all nodes \\(u \\in V\\), the average clustering coefficient is defined as their mean:</p> \\[ C = \\frac{1}{n} \\sum_{u \\in V} C_u \\] Warning <p>This measurement of global clustering should not be confused with the global clustering coefficient defined as the fraction of closed paths of length two over all paths of length two in the graph.</p> Reference <p>Proposed by Watts and Strogatz in their seminal paper on \"Collective dynamics of 'small-world' networks\"<sup>1</sup>. Further details can be found in in Chapter 7.3 in Networks<sup>2</sup> by Mark Newman.</p> <ol> <li> <p>Watts, D. J. &amp; Strogatz, S. H. Collective dynamics of 'small-world' networks. Nature 393, 440-442 (1998). \u21a9</p> </li> <li> <p>Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001. \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>pathpyG.core.graph.Graph</code> <p>The graph in which to calculate the average clustering coefficient.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The average clustering coefficient of the graph.</p> Source code in <code>src/pathpyG/statistics/clustering.py</code> <pre><code>def avg_clustering_coefficient(g: Graph) -&gt; float:\n    r\"\"\"Calculates the average clustering coefficient $C$ of the [graph][pathpyG.core.graph.Graph] $G=(V, E)$.\n\n    Given the local clustering coefficients $C_u$ for all nodes $u \\in V$,\n    the average clustering coefficient is defined as their mean:\n\n    $$\n    C = \\frac{1}{n} \\sum_{u \\in V} C_u\n    $$\n\n    Warning:\n        This measurement of global clustering should not be confused with the global clustering coefficient\n        defined as the fraction of closed paths of length two over all paths of length two in the graph.\n\n    ??? reference\n        Proposed by Watts and Strogatz in their seminal paper on \"Collective dynamics of 'small-world' networks\"[^1].\n        Further details can be found in in Chapter 7.3 in *Networks*[^2] by Mark Newman.\n\n    [^1]: *Watts, D. J. &amp; Strogatz, S. H. Collective dynamics of 'small-world' networks. Nature 393, 440-442 (1998).*\n    [^2]: *Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001.*\n\n    Args:\n        g (Graph): The graph in which to calculate the average clustering coefficient.\n\n    Returns:\n        float: The average clustering coefficient of the graph.\n    \"\"\"\n    return torch.mean(torch.tensor([local_clustering_coefficient(g, v) for v in g.nodes], dtype=torch.float32)).item()\n</code></pre>"},{"location":"reference/pathpyG/statistics/#pathpyG.statistics.closed_triads","title":"<code>closed_triads</code>","text":"<p>Calculates the set of edges that represent a closed triad around a given node \\(v\\).</p> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>pathpyG.core.graph.Graph</code> <p>The graph in which to calculate the list of closed triads.</p> required <code>v</code> <code>str</code> <p>The node around which to calculate the closed triads.</p> required Source code in <code>src/pathpyG/statistics/clustering.py</code> <pre><code>def closed_triads(g: Graph, v: str) -&gt; Set:\n    \"\"\"Calculates the set of edges that represent a closed triad around a given node $v$.\n\n    Args:\n        g (Graph): The graph in which to calculate the list of closed triads.\n        v (str): The node around which to calculate the closed triads.\n    \"\"\"\n    c_triads: set = set()\n    edges = set()\n\n    # Collect all edges of successors\n    for x in g.successors(v):\n        for y in g.successors(x):\n            edges.add((x, y))\n\n    for x, y in edges:\n        if y in g.successors(v):\n            c_triads.add((x, y))\n    return c_triads\n</code></pre>"},{"location":"reference/pathpyG/statistics/#pathpyG.statistics.degree_assortativity","title":"<code>degree_assortativity</code>","text":"<p>Calculate the degree assortativity coefficient of the graph.</p> <p>The degree assortativity coefficient \\(r\\) of a graph \\(G=(V, E)\\) is defined as</p> \\[ r = \\frac{\\sum_{i,j} \\left(A_{ij} - d_i d_j / (2m)\\right) d_i d_j}{\\sum_{i,j} \\left(d_i \\delta_{ij} - d_i d_j / (2m)\\right) d_i d_j} \\] <p>with the adjacency matrix \\(A\\), the degree \\(d_i\\) of node \\(i\\), the number of edges \\(m\\) and the Kronecker delta \\(\\delta_{ij}\\).</p> <p>For computational reasons, we calculate the coefficient as follows:</p> \\[ r = \\frac{S_1S_e - S_2^2}{S_1S_3 - S_2^2} \\] <p>where \\(S_l = \\sum_{i} d_i^l\\) for \\(l=1,2,3\\) and \\(S_e = \\sum_{(i,j) \\in E} d_i d_j\\).</p> Reference <p>You can find the defintions above with further explanations in Equations (10.27) and (10.28) in Chapter 10.7 in Networks<sup>1</sup> by Mark Newman.</p> <ol> <li> <p>Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001. \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The graph for which to calculate the degree assortativity</p> required <code>mode</code> <code>str</code> <p>'in', 'out' or 'total' for directed graphs, ignored for undirected graphs</p> <code>'total'</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The degree assortativity coefficient of the graph</p> Source code in <code>src/pathpyG/statistics/degrees.py</code> <pre><code>def degree_assortativity(graph: Graph, mode: str = \"total\") -&gt; float:\n    r\"\"\"Calculate the degree assortativity coefficient of the [graph][pathpyG.core.graph.Graph].\n\n    The degree assortativity coefficient $r$ of a [graph][pathpyG.core.graph.Graph] $G=(V, E)$ is defined as\n\n    $$\n    r = \\frac{\\sum_{i,j} \\left(A_{ij} - d_i d_j / (2m)\\right) d_i d_j}{\\sum_{i,j} \\left(d_i \\delta_{ij} - d_i d_j / (2m)\\right) d_i d_j}\n    $$\n\n    with the adjacency matrix $A$, the degree $d_i$ of node $i$, the number of edges [$m$][pathpyG.core.graph.Graph.m] and the Kronecker delta $\\delta_{ij}$.\n\n    For computational reasons, we calculate the coefficient as follows:\n\n    $$\n    r = \\frac{S_1S_e - S_2^2}{S_1S_3 - S_2^2}\n    $$\n\n    where $S_l = \\sum_{i} d_i^l$ for $l=1,2,3$ and $S_e = \\sum_{(i,j) \\in E} d_i d_j$.\n\n    ??? reference\n        You can find the defintions above with further explanations in Equations (10.27) and (10.28) in Chapter 10.7 in *Networks*[^1] by Mark Newman.\n\n    [^1]: *Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001.*\n\n    Args:\n        graph: The graph for which to calculate the degree assortativity\n        mode:  'in', 'out' or 'total' for directed graphs, ignored for undirected graphs\n\n    Returns:\n        float: The degree assortativity coefficient of the graph\n    \"\"\"\n    degree_seq = degree_sequence(graph, mode=mode).float()\n    S_1 = torch.sum(degree_seq).item()\n    S_2 = torch.sum(degree_seq**2).item()\n    S_3 = torch.sum(degree_seq**3).item()\n    S_e = torch.sum(degree_seq[graph.data.edge_index[0]] * degree_seq[graph.data.edge_index[1]]).item()\n\n    numerator = S_1 * S_e - S_2**2\n    denominator = S_1 * S_3 - S_2**2\n\n    return numerator / denominator\n</code></pre>"},{"location":"reference/pathpyG/statistics/#pathpyG.statistics.degree_central_moment","title":"<code>degree_central_moment</code>","text":"<p>Calculates the k-th central moment of the degree distribution.</p> <p>The k-th central moment \\(\\mu_k\\) of the degree distribution \\(P_{mode}(d)\\) of a graph \\(G=(V, E)\\) is defined as</p> \\[ \\mu_k = \\sum_d (d - \\langle d_{mode} \\rangle)^k P_{mode}(d). \\] <p>where \\(\\langle d_{mode} \\rangle\\) is the mean degree of the graph and \\(P_{mode}(d)\\) is the degree distribution.</p> Note <p>The 2<sup>nd</sup> central moment corresponds to the variance of the degree distribution.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The graph for which to calculate the k-th central moment</p> required <code>k</code> <code>int</code> <p>The order of the moment to calculate</p> <code>1</code> <code>mode</code> <code>str</code> <p>'in', 'out' or 'total' for directed graphs, ignored for undirected graphs</p> <code>'total'</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The k-th central moment of the degree distribution</p> Source code in <code>src/pathpyG/statistics/degrees.py</code> <pre><code>def degree_central_moment(graph: Graph, k: int = 1, mode: str = \"total\") -&gt; float:\n    r\"\"\"Calculates the k-th central moment of the [degree distribution][pathpyG.statistics.degrees.degree_distribution].\n\n    The k-th central moment $\\mu_k$ of the [degree distribution][pathpyG.statistics.degrees.degree_distribution] $P_{mode}(d)$ of a [graph][pathpyG.core.graph.Graph] $G=(V, E)$ is defined as\n\n    $$\n    \\mu_k = \\sum_d (d - \\langle d_{mode} \\rangle)^k P_{mode}(d).\n    $$\n\n    where $\\langle d_{mode} \\rangle$ is the [mean degree][pathpyG.statistics.degrees.mean_degree] of the graph and $P_{mode}(d)$ is the [degree distribution][pathpyG.statistics.degrees.degree_distribution].\n\n    Note:\n        The 2nd central moment corresponds to the variance of the degree distribution.\n\n    Args:\n        graph: The graph for which to calculate the k-th central moment\n        k: The order of the moment to calculate\n        mode:  'in', 'out' or 'total' for directed graphs, ignored for undirected graphs\n\n    Returns:\n        float: The k-th central moment of the degree distribution\n    \"\"\"\n    p_k = degree_distribution(graph, mode=mode)\n    mean = mean_degree(graph, mode=mode)\n    x = torch.arange(len(p_k), dtype=torch.float32)\n    m = torch.sum((x - mean) ** k * p_k).item()\n    return m\n</code></pre>"},{"location":"reference/pathpyG/statistics/#pathpyG.statistics.degree_distribution","title":"<code>degree_distribution</code>","text":"<p>Calculates the (unweighted) degree distribution of a graph.</p> <p>The degree distribution \\(P_{mode}(d)\\) of a graph \\(G=(V, E)\\) is defined as</p> \\[ P_{mode}(d) = \\frac{N_d}{n} \\] <p>with \\(N_d = |\\{v_i \\in V : d_{mode}(v_i) = d\\}|\\) being the number of nodes with degree \\(d\\) and \\(n\\) being the total number of nodes in the graph. The modes are defined as follows:</p> <ul> <li>'in': In-degree \\(d_{in}(v_i)\\) of node \\(v_i\\), i.e. the number of incoming edges \\(|\\{(v_j, v_i) \\in E\\}|\\) from any other node \\(v_j\\)</li> <li>'out': Out-degree \\(d_{out}(v_i)\\) of node \\(v_i\\), i.e. the number of outgoing edges \\(|\\{(v_i, v_j) \\in E\\}|\\) to any other node \\(v_j\\)</li> <li>'total': Total degree \\(d_{total}(v_i)\\) of node \\(v_i\\), i.e. the sum of in-degree and out-degree \\(d_{in}(v_i) + d_{out}(v_i)\\)</li> </ul> <p>The degree distribution is returned as a <code>torch.Tensor</code> of shape <code>(d_max + 1,)</code> where <code>d_max</code> is the maximum degree in the graph.</p> Reference <p>For further reading, see Chapter 10.3 in Networks<sup>1</sup> by Mark Newman.</p> <ol> <li> <p>Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001. \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The <code>Graph</code> object for which the degree distribution is calculated</p> required <code>mode</code> <code>str</code> <p>'in', 'out' or 'total' for directed graphs, ignored for undirected graphs</p> <code>'total'</code> <p>Returns:</p> Type Description <code>torch.Tensor</code> <p>torch.Tensor: A tensor containing the degree distribution</p> Source code in <code>src/pathpyG/statistics/degrees.py</code> <pre><code>def degree_distribution(graph: Graph, mode: str = \"total\") -&gt; torch.Tensor:\n    r\"\"\"Calculates the (unweighted) degree distribution of a [graph][pathpyG.core.graph.Graph].\n\n    The degree distribution $P_{mode}(d)$ of a [graph][pathpyG.core.graph.Graph] $G=(V, E)$ is defined as\n\n    $$\n    P_{mode}(d) = \\frac{N_d}{n}\n    $$\n\n    with $N_d = |\\{v_i \\in V : d_{mode}(v_i) = d\\}|$ being the number of nodes with degree $d$ and $n$ being the total number of nodes in the graph.\n    The modes are defined as follows:\n\n    - 'in': In-degree $d_{in}(v_i)$ of node $v_i$, i.e. the number of incoming edges $|\\{(v_j, v_i) \\in E\\}|$ from any other node $v_j$\n    - 'out': Out-degree $d_{out}(v_i)$ of node $v_i$, i.e. the number of outgoing edges $|\\{(v_i, v_j) \\in E\\}|$ to any other node $v_j$\n    - 'total': Total degree $d_{total}(v_i)$ of node $v_i$, i.e. the sum of in-degree and out-degree $d_{in}(v_i) + d_{out}(v_i)$\n\n    The degree distribution is returned as a `torch.Tensor` of shape `(d_max + 1,)` where `d_max` is the maximum degree in the graph.\n\n    ??? reference\n        For further reading, see Chapter 10.3 in *Networks*[^1] by Mark Newman.\n\n    [^1]: *Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001.*\n\n    Args:\n        graph: The `Graph` object for which the degree distribution is calculated\n        mode:  'in', 'out' or 'total' for directed graphs, ignored for undirected graphs\n\n    Returns:\n        torch.Tensor: A tensor containing the degree distribution\n    \"\"\"\n    return degree_sequence(graph, mode=mode).bincount() / graph.n\n</code></pre>"},{"location":"reference/pathpyG/statistics/#pathpyG.statistics.degree_generating_function","title":"<code>degree_generating_function</code>","text":"<p>Returns the generating function of the degree distribution of a graph.</p> <p>Returns \\(f(x)\\) where \\(f\\) is the probability generating function for the degree distribution \\(P_{mode}(d)\\) for a graph \\(G=(V, E)\\) defined as</p> \\[ f(x) = \\sum_d P_{mode}(d) x^d. \\] <p>The function is defined in the interval \\(\\left[0,1\\right]\\). The following properties hold:</p> <ol> <li> <p>The values of the degree distribution \\(P_{mode}(d)\\) can be retrieved from the generating function via     $$     P_{mode}(d) = \\left[\\frac{1}{d!} \\frac{d^d f}{dx^d}\\right]_{x=0}     $$</p> <p>with \\(\\frac{d^d}{dx^d} f\\) being the d-th derivative of \\(f\\) by \\(x\\).</p> </li> <li> <p>The \\(k\\)-th raw moment of the degree distribution can be retrieved from the generating function with</p> \\[ \\left[\\left(x \\frac{d}{dx}\\right)^k f\\right]_{x=1} = \\langle d_{mode}^k \\rangle. \\] </li> </ol> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The graph for which the generating function shall be computed</p> required <code>x</code> <code>float | list[float] | numpy.ndarray | torch.Tensor</code> <p>float, list, numpy.ndarray, or torch.Tensor The argument(s) for which value(s) \\(f(x)\\) shall be computed.</p> required <code>mode</code> <code>str</code> <p>'in', 'out' or 'total' for directed graphs, ignored for undirected graphs</p> <code>'total'</code> <p>Returns:</p> Type Description <code>float | torch.Tensor</code> <p>float or torch.Tensor: The value(s) of the generating function at x</p> <p>Examples:</p> <p>Generate simple network:</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt;\n&gt;&gt;&gt; g = pp.Graph.from_edge_list(\n...         [('a', 'b'), ('b', 'c'), ('a', 'c'), ('c', 'd'), ('d', 'e'), ('d', 'f'), ('e', 'f')]\n...     ).to_undirected()\n</code></pre> <p>Return single function value:</p> <pre><code>&gt;&gt;&gt; val = pp.statistics.degree_generating_function(g, 0.3)\n&gt;&gt;&gt; print(val)\n0.069...\n</code></pre> <p>Plot generating function of degree distribution</p> <pre><code>&gt;&gt;&gt; x = list(range(10))\n&gt;&gt;&gt; y = pp.statistics.degree_generating_function(g, x)\n&gt;&gt;&gt; print(y)\ntensor([  0.0000,   1.0000,   5.3333,  15.0000,  32.0000,  58.3333,  96.0000,\n147.0000, 213.3333, 297.0000])\n</code></pre> Source code in <code>src/pathpyG/statistics/degrees.py</code> <pre><code>def degree_generating_function(\n    graph: Graph, x: float | list[float] | _np.ndarray | torch.Tensor, mode: str = \"total\"\n) -&gt; float | torch.Tensor:\n    r\"\"\"Returns the generating function of the degree distribution of a [graph][pathpyG.core.graph.Graph].\n\n    Returns $f(x)$ where $f$ is the probability generating function for the degree\n    distribution $P_{mode}(d)$ for a [graph][pathpyG.core.graph.Graph] $G=(V, E)$ defined as\n\n    $$\n    f(x) = \\sum_d P_{mode}(d) x^d.\n    $$\n\n    The function is defined in the interval $\\left[0,1\\right]$. The following properties hold:\n\n    1. The values of the [degree distribution][pathpyG.statistics.degrees.degree_distribution] $P_{mode}(d)$ can be retrieved from the generating function via\n        $$\n        P_{mode}(d) = \\left[\\frac{1}{d!} \\frac{d^d f}{dx^d}\\right]_{x=0}\n        $$\n\n        with $\\frac{d^d}{dx^d} f$ being the d-th derivative of $f$ by $x$.\n\n    2. The $k$-th raw moment of the degree distribution can be retrieved from the generating function with\n\n        $$\n        \\left[\\left(x \\frac{d}{dx}\\right)^k f\\right]_{x=1} = \\langle d_{mode}^k \\rangle.\n        $$\n\n    Args:\n        graph: The [graph][pathpyG.core.graph.Graph] for which the generating function shall be computed\n        x:  float, list, numpy.ndarray, or torch.Tensor\n            The argument(s) for which value(s) $f(x)$ shall be computed.\n        mode:  'in', 'out' or 'total' for directed graphs, ignored for undirected graphs\n\n    Returns:\n        float or torch.Tensor: The value(s) of the generating function at x\n\n    Examples:\n        Generate simple network:\n\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; g = pp.Graph.from_edge_list(\n        ...         [('a', 'b'), ('b', 'c'), ('a', 'c'), ('c', 'd'), ('d', 'e'), ('d', 'f'), ('e', 'f')]\n        ...     ).to_undirected()\n\n        Return single function value:\n\n        &gt;&gt;&gt; val = pp.statistics.degree_generating_function(g, 0.3)\n        &gt;&gt;&gt; print(val)\n        0.069...\n\n        Plot generating function of degree distribution\n\n        &gt;&gt;&gt; x = list(range(10))\n        &gt;&gt;&gt; y = pp.statistics.degree_generating_function(g, x)\n        &gt;&gt;&gt; print(y)\n        tensor([  0.0000,   1.0000,   5.3333,  15.0000,  32.0000,  58.3333,  96.0000,\n        147.0000, 213.3333, 297.0000])\n    \"\"\"\n    p_k = degree_distribution(graph, mode=mode)\n\n    if isinstance(x, float):\n        x_range = torch.tensor([x])\n    elif isinstance(x, list) or isinstance(x, _np.ndarray):\n        x_range = torch.tensor(x, dtype=torch.float32)\n    elif isinstance(x, torch.Tensor):\n        x_range = x.float()\n    else:\n        raise TypeError(\"x must be a float, list, numpy.ndarray, or torch.Tensor\")\n\n    # Via broadcasting, compute f(x) for all x in x_range defined as f(x) = sum_k p_k * x^k\n    values = torch.sum(p_k.unsqueeze(1) * (x_range.unsqueeze(0) ** torch.arange(p_k.size(0)).unsqueeze(1)), dim=0)\n\n    if isinstance(x, float):\n        return values[0].item()\n    else:\n        return values\n</code></pre>"},{"location":"reference/pathpyG/statistics/#pathpyG.statistics.degree_raw_moment","title":"<code>degree_raw_moment</code>","text":"<p>Calculates the k-th raw moment of the degree distribution of a graph.</p> <p>The k-th raw moment \\(\\langle d^k \\rangle\\) of the degree distribution \\(P_{mode}(d)\\) of a graph \\(G=(V, E)\\) is defined as</p> \\[ \\langle d_{mode}^k \\rangle = \\sum_d d^k P_{mode}(d). \\] Reference <p>For further reading, see Equation 10.20 in Chapter 10.4 in Networks<sup>1</sup> by Mark Newman.</p> <ol> <li> <p>Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001. \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The graph in which to calculate the k-th raw moment</p> required <code>k</code> <code>int</code> <p>The order of the moment to calculate</p> <code>1</code> <code>mode</code> <code>str</code> <p>'in', 'out' or 'total' for directed graphs, ignored for undirected graphs</p> <code>'total'</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The k-th raw moment of the degree distribution</p> Source code in <code>src/pathpyG/statistics/degrees.py</code> <pre><code>def degree_raw_moment(graph: Graph, k: int = 1, mode: str = \"total\") -&gt; float:\n    r\"\"\"Calculates the k-th raw moment of the degree distribution of a [graph][pathpyG.core.graph.Graph].\n\n    The k-th raw moment $\\langle d^k \\rangle$ of the [degree distribution][pathpyG.statistics.degrees.degree_distribution] $P_{mode}(d)$ of a [graph][pathpyG.core.graph.Graph] $G=(V, E)$ is defined as\n\n    $$\n    \\langle d_{mode}^k \\rangle = \\sum_d d^k P_{mode}(d).\n    $$\n\n    ??? reference\n        For further reading, see Equation 10.20 in Chapter 10.4 in *Networks*[^1] by Mark Newman.\n\n    [^1]: *Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001.*\n\n    Args:\n        graph:  The graph in which to calculate the k-th raw moment\n        k: The order of the moment to calculate\n        mode:  'in', 'out' or 'total' for directed graphs, ignored for undirected graphs\n\n    Returns:\n        float: The k-th raw moment of the degree distribution\n    \"\"\"\n    p_k = degree_distribution(graph, mode=mode)\n    x = torch.arange(len(p_k), dtype=torch.float32)\n    m = torch.sum((x**k) * p_k).item()\n    return m\n</code></pre>"},{"location":"reference/pathpyG/statistics/#pathpyG.statistics.degree_sequence","title":"<code>degree_sequence</code>","text":"<p>Calculates the (unweighted) degree sequence of a graph.</p> <p>Returns the degree sequence of a graph \\(G=(V, E)\\) defined as</p> \\[ \\left\\{d_{mode}(v_1), d_{mode}(v_2), \\ldots, d_{mode}(v_n)\\right\\} \\text{ for all nodes } v_i \\in V \\] <p>with \\(d_{mode}(v_i)\\) being the degree of node \\(v_i\\) in mode 'in', 'out' or 'total'. The modes are defined as follows:</p> <ul> <li>'in': In-degree \\(d_{in}(v_i)\\) of node \\(v_i\\), i.e. the number of incoming edges \\(|\\{(v_j, v_i) \\in E\\}|\\) from any other node \\(v_j\\)</li> <li>'out': Out-degree \\(d_{out}(v_i)\\) of node \\(v_i\\), i.e. the number of outgoing edges \\(|\\{(v_i, v_j) \\in E\\}|\\) to any other node \\(v_j\\)</li> <li>'total': Total degree \\(d_{total}(v_i)\\) of node \\(v_i\\), i.e. the sum of in-degree and out-degree \\(d_{in}(v_i) + d_{out}(v_i)\\)</li> </ul> <p>The degree sequence is returned as a <code>torch.Tensor</code> of shape <code>(n,)</code> where \\(n\\) is the number of nodes in the graph. The order of the degree sequence corresponds to the indexing of the nodes in the graph and the index of a node \\(v_i\\) given by its label can be accessed via <code>graph.mapping.to_idx(v_i)</code>.</p> Reference <p>For further reading, see Chapter 10.3 in Networks<sup>1</sup> by Mark Newman.</p> <ol> <li> <p>Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001. \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The <code>Graph</code> object for which degrees are calculated</p> required <code>mode</code> <code>str</code> <p>'in', 'out' or 'total' for directed graphs, ignored for undirected graphs</p> <code>'total'</code> <p>Returns:</p> Type Description <code>torch.Tensor</code> <p>torch.Tensor: A tensor containing the degree sequence</p> Source code in <code>src/pathpyG/statistics/degrees.py</code> <pre><code>def degree_sequence(graph: Graph, mode: str = \"total\") -&gt; torch.Tensor:\n    r\"\"\"Calculates the (unweighted) degree sequence of a [graph][pathpyG.core.graph.Graph].\n\n    Returns the degree sequence of a [graph][pathpyG.core.graph.Graph] $G=(V, E)$ defined as\n\n    $$\n    \\left\\{d_{mode}(v_1), d_{mode}(v_2), \\ldots, d_{mode}(v_n)\\right\\} \\text{ for all nodes } v_i \\in V\n    $$\n\n    with $d_{mode}(v_i)$ being the degree of node $v_i$ in mode 'in', 'out' or 'total'.\n    The modes are defined as follows:\n\n    - 'in': In-degree $d_{in}(v_i)$ of node $v_i$, i.e. the number of incoming edges $|\\{(v_j, v_i) \\in E\\}|$ from any other node $v_j$\n    - 'out': Out-degree $d_{out}(v_i)$ of node $v_i$, i.e. the number of outgoing edges $|\\{(v_i, v_j) \\in E\\}|$ to any other node $v_j$\n    - 'total': Total degree $d_{total}(v_i)$ of node $v_i$, i.e. the sum of in-degree and out-degree $d_{in}(v_i) + d_{out}(v_i)$\n\n    The degree sequence is returned as a `torch.Tensor` of shape `(n,)` where $n$ is the number of nodes in the graph.\n    The order of the degree sequence corresponds to the indexing of the nodes in the graph and\n    the index of a node $v_i$ given by its label can be accessed via [`graph.mapping.to_idx(v_i)`][pathpyG.core.index_map.IndexMap.to_idx].\n\n    ??? reference\n        For further reading, see Chapter 10.3 in *Networks*[^1] by Mark Newman.\n\n    [^1]: *Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001.*\n\n    Args:\n        graph: The `Graph` object for which degrees are calculated\n        mode:  'in', 'out' or 'total' for directed graphs, ignored for undirected graphs\n\n    Returns:\n        torch.Tensor: A tensor containing the degree sequence\n    \"\"\"\n    if mode == \"total\":\n        if graph.is_directed():\n            return graph.degrees(mode=\"in\", return_tensor=True) + graph.degrees(mode=\"out\", return_tensor=True)  # type: ignore[operator]\n        else:\n            return graph.degrees(mode=\"in\", return_tensor=True)  # type: ignore[return-value]\n    else:\n        return graph.degrees(mode, return_tensor=True)  # type: ignore[return-value]\n</code></pre>"},{"location":"reference/pathpyG/statistics/#pathpyG.statistics.local_clustering_coefficient","title":"<code>local_clustering_coefficient</code>","text":"<p>Calculates the local clustering coefficient \\(C_u\\) for a given node \\(u\\) from a graph \\(G=(V, E)\\).</p> <p>The local clustering coefficient is defined as the fraction of closed triads around node \\(u\\) over the number of possible triads.</p> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>pathpyG.core.graph.Graph</code> <p>The graph in which to calculate the clustering coefficient.</p> required <code>u</code> <code>str</code> <p>The node for which to calculate the clustering coefficient.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The local clustering coefficient of node u.</p> Source code in <code>src/pathpyG/statistics/clustering.py</code> <pre><code>def local_clustering_coefficient(g: Graph, u: str) -&gt; float:\n    \"\"\"Calculates the local clustering coefficient $C_u$ for a given node $u$ from a [graph][pathpyG.core.graph.Graph] $G=(V, E)$.\n\n    The local clustering coefficient is defined as the fraction of closed\n    triads around node $u$ over the number of possible triads.\n\n    Args:\n        g (Graph): The graph in which to calculate the clustering coefficient.\n        u (str): The node for which to calculate the clustering coefficient.\n\n    Returns:\n        float: The local clustering coefficient of node u.\n    \"\"\"\n    # Compute number of directly connected neighbour pairs\n    k_u = float(len(closed_triads(g, u)))\n\n    # Normalise fraction based on number of possible edges\n    if g.is_directed():\n        if g.out_degrees[u] &gt; 1:\n            return k_u / (g.out_degrees[u] * (g.out_degrees[u] - 1))\n        else:\n            return 0.0\n    else:\n        k_u /= 2.0\n        if g.degrees()[u] &gt; 1:  # type: ignore[index]\n            return 2.0 * k_u / (g.degrees()[u] * (g.degrees()[u] - 1))  # type: ignore[index]\n        else:\n            return 0.0\n</code></pre>"},{"location":"reference/pathpyG/statistics/#pathpyG.statistics.mean_degree","title":"<code>mean_degree</code>","text":"<p>Calculates the mean degree of a graph.</p> <p>The mean degree \\(\\langle d \\rangle\\) of a graph \\(G=(V, E)\\) is defined as</p> \\[ \\langle d_{mode} \\rangle = \\frac{1}{n} \\sum_{i=1}^{n} d_{mode}(v_i) \\] <p>with \\(d_{mode}(v_i)\\) being the degree of node \\(v_i\\) in mode 'in', 'out' or 'total'. The modes are defined as follows:</p> <ul> <li>'in': In-degree \\(d_{in}(v_i)\\) of node \\(v_i\\), i.e. the number of incoming edges \\(|\\{(v_j, v_i) \\in E\\}|\\) from any other node \\(v_j\\)</li> <li>'out': Out-degree \\(d_{out}(v_i)\\) of node \\(v_i\\), i.e. the number of outgoing edges \\(|\\{(v_i, v_j) \\in E\\}|\\) to any other node \\(v_j\\)</li> <li>'total': Total degree \\(d_{total}(v_i)\\) of node \\(v_i\\), i.e. the sum of in-degree and out-degree \\(d_{in}(v_i) + d_{out}(v_i)\\)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The graph for which to calculate the mean degree</p> required <code>mode</code> <code>str</code> <p>'in', 'out' or 'total' for directed graphs, ignored for undirected graphs</p> <code>'total'</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The mean degree of the graph</p> Source code in <code>src/pathpyG/statistics/degrees.py</code> <pre><code>def mean_degree(graph: Graph, mode: str = \"total\") -&gt; float:\n    r\"\"\"Calculates the mean degree of a [graph][pathpyG.core.graph.Graph].\n\n    The mean degree $\\langle d \\rangle$ of a [graph][pathpyG.core.graph.Graph] $G=(V, E)$ is defined as\n\n    $$\n    \\langle d_{mode} \\rangle = \\frac{1}{n} \\sum_{i=1}^{n} d_{mode}(v_i)\n    $$\n\n    with $d_{mode}(v_i)$ being the degree of node $v_i$ in mode 'in', 'out' or 'total'.\n    The modes are defined as follows:\n\n    - 'in': In-degree $d_{in}(v_i)$ of node $v_i$, i.e. the number of incoming edges $|\\{(v_j, v_i) \\in E\\}|$ from any other node $v_j$\n    - 'out': Out-degree $d_{out}(v_i)$ of node $v_i$, i.e. the number of outgoing edges $|\\{(v_i, v_j) \\in E\\}|$ to any other node $v_j$\n    - 'total': Total degree $d_{total}(v_i)$ of node $v_i$, i.e. the sum of in-degree and out-degree $d_{in}(v_i) + d_{out}(v_i)$\n\n    Args:\n        graph: The graph for which to calculate the mean degree\n        mode:  'in', 'out' or 'total' for directed graphs, ignored for undirected graphs\n\n    Returns:\n        float: The mean degree of the graph\n    \"\"\"\n    return torch.mean(degree_sequence(graph, mode=mode).float()).item()\n</code></pre>"},{"location":"reference/pathpyG/statistics/#pathpyG.statistics.mean_neighbor_degree","title":"<code>mean_neighbor_degree</code>","text":"<p>Calculates the mean neighbor degree of a graph.</p> <p>The mean neighbor degree \\(\\langle d_{\\mathcal{N}} \\rangle\\) of a graph \\(G=(V, E)\\) is defined as</p> \\[ \\langle d_{\\mathcal{N}} \\rangle = \\frac{1}{m} \\sum_{v_i \\in V} \\sum_{v_j \\in \\mathcal{N}(v_i)} d_{mode}(v_j) \\] <p>with the number of edges \\(m\\) (1), the set of neighbors \\(\\mathcal{N}(v_i)\\) of node \\(v_i\\) and \\(d_{mode}(v_j)\\) being the degree of neighbor node \\(v_j \\in \\mathcal{N}(v_i)\\) in mode 'in', 'out' or 'total'.</p> <ol> <li>This definition is for directed graphs. For undirected graphs, the denominator is \\(2m\\).</li> </ol> <p>The modes are defined as follows:</p> <ul> <li>'in': In-degree \\(d_{in}(v_i)\\) of node \\(v_i\\), i.e. the number of incoming edges \\(|\\{(v_j, v_i) \\in E\\}|\\) from any other node \\(v_j\\)</li> <li>'out': Out-degree \\(d_{out}(v_i)\\) of node \\(v_i\\), i.e. the number of outgoing edges \\(|\\{(v_i, v_j) \\in E\\}|\\) to any other node \\(v_j\\)</li> <li>'total': Total degree \\(d_{total}(v_i)\\) of node \\(v_i\\), i.e. the sum of in-degree and out-degree \\(d_{in}(v_i) + d_{out}(v_i)\\)</li> </ul> Reference <p>For further reading, see Chapter 12.2 in Networks<sup>1</sup> by Mark Newman.</p> <ol> <li> <p>Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001. \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The graph for which to calculate the mean neighbor degree</p> required <code>mode</code> <code>str</code> <p>'in', 'out' or 'total' for directed graphs, ignored for undirected graphs</p> <code>'total'</code> <code>exclude_backlink</code> <code>bool</code> <p>Whether to exclude the backlink to the original node when calculating neighbor degrees</p> <code>False</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The mean neighbor degree of the graph</p> Source code in <code>src/pathpyG/statistics/degrees.py</code> <pre><code>def mean_neighbor_degree(graph: Graph, mode: str = \"total\", exclude_backlink: bool = False) -&gt; float:\n    r\"\"\"Calculates the mean neighbor degree of a [graph][pathpyG.core.graph.Graph].\n\n    The mean neighbor degree $\\langle d_{\\mathcal{N}} \\rangle$ of a [graph][pathpyG.core.graph.Graph] $G=(V, E)$ is defined as\n\n    $$\n    \\langle d_{\\mathcal{N}} \\rangle = \\frac{1}{m} \\sum_{v_i \\in V} \\sum_{v_j \\in \\mathcal{N}(v_i)} d_{mode}(v_j)\n    $$\n\n\n    with the number of edges [$m$][pathpyG.core.graph.Graph.m] (1), the set of neighbors $\\mathcal{N}(v_i)$ of node $v_i$ and $d_{mode}(v_j)$ being the degree of neighbor node $v_j \\in \\mathcal{N}(v_i)$ in mode 'in', 'out' or 'total'.\n    { .annotate }\n\n    1. This definition is for directed graphs. For undirected graphs, the denominator is $2m$.\n\n    The modes are defined as follows:\n\n    - 'in': In-degree $d_{in}(v_i)$ of node $v_i$, i.e. the number of incoming edges $|\\{(v_j, v_i) \\in E\\}|$ from any other node $v_j$\n    - 'out': Out-degree $d_{out}(v_i)$ of node $v_i$, i.e. the number of outgoing edges $|\\{(v_i, v_j) \\in E\\}|$ to any other node $v_j$\n    - 'total': Total degree $d_{total}(v_i)$ of node $v_i$, i.e. the sum of in-degree and out-degree $d_{in}(v_i) + d_{out}(v_i)$\n\n    ??? reference\n        For further reading, see Chapter 12.2 in *Networks*[^1] by Mark Newman.\n\n    [^1]: *Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001.*\n\n    Args:\n        graph: The graph for which to calculate the mean neighbor degree\n        mode:  'in', 'out' or 'total' for directed graphs, ignored for undirected graphs\n        exclude_backlink: Whether to exclude the backlink to the original node when calculating neighbor degrees\n\n    Returns:\n        float: The mean neighbor degree of the graph\n    \"\"\"\n    in_degree = degree_sequence(graph, mode=\"in\")\n    degree_seq = degree_sequence(graph, mode=mode)\n    if exclude_backlink:\n        degree_seq = degree_seq - 1\n    return torch.sum(in_degree * degree_seq).item() / (2 * graph.m if graph.is_undirected() else graph.m)\n</code></pre>"},{"location":"reference/pathpyG/statistics/clustering/","title":"clustering","text":"<p>Module for clustering coefficient calculations.</p>"},{"location":"reference/pathpyG/statistics/clustering/#pathpyG.statistics.clustering.avg_clustering_coefficient","title":"<code>avg_clustering_coefficient</code>","text":"<p>Calculates the average clustering coefficient \\(C\\) of the graph \\(G=(V, E)\\).</p> <p>Given the local clustering coefficients \\(C_u\\) for all nodes \\(u \\in V\\), the average clustering coefficient is defined as their mean:</p> \\[ C = \\frac{1}{n} \\sum_{u \\in V} C_u \\] Warning <p>This measurement of global clustering should not be confused with the global clustering coefficient defined as the fraction of closed paths of length two over all paths of length two in the graph.</p> Reference <p>Proposed by Watts and Strogatz in their seminal paper on \"Collective dynamics of 'small-world' networks\"<sup>1</sup>. Further details can be found in in Chapter 7.3 in Networks<sup>2</sup> by Mark Newman.</p> <ol> <li> <p>Watts, D. J. &amp; Strogatz, S. H. Collective dynamics of 'small-world' networks. Nature 393, 440-442 (1998). \u21a9</p> </li> <li> <p>Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001. \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>pathpyG.core.graph.Graph</code> <p>The graph in which to calculate the average clustering coefficient.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The average clustering coefficient of the graph.</p> Source code in <code>src/pathpyG/statistics/clustering.py</code> <pre><code>def avg_clustering_coefficient(g: Graph) -&gt; float:\n    r\"\"\"Calculates the average clustering coefficient $C$ of the [graph][pathpyG.core.graph.Graph] $G=(V, E)$.\n\n    Given the local clustering coefficients $C_u$ for all nodes $u \\in V$,\n    the average clustering coefficient is defined as their mean:\n\n    $$\n    C = \\frac{1}{n} \\sum_{u \\in V} C_u\n    $$\n\n    Warning:\n        This measurement of global clustering should not be confused with the global clustering coefficient\n        defined as the fraction of closed paths of length two over all paths of length two in the graph.\n\n    ??? reference\n        Proposed by Watts and Strogatz in their seminal paper on \"Collective dynamics of 'small-world' networks\"[^1].\n        Further details can be found in in Chapter 7.3 in *Networks*[^2] by Mark Newman.\n\n    [^1]: *Watts, D. J. &amp; Strogatz, S. H. Collective dynamics of 'small-world' networks. Nature 393, 440-442 (1998).*\n    [^2]: *Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001.*\n\n    Args:\n        g (Graph): The graph in which to calculate the average clustering coefficient.\n\n    Returns:\n        float: The average clustering coefficient of the graph.\n    \"\"\"\n    return torch.mean(torch.tensor([local_clustering_coefficient(g, v) for v in g.nodes], dtype=torch.float32)).item()\n</code></pre>"},{"location":"reference/pathpyG/statistics/clustering/#pathpyG.statistics.clustering.closed_triads","title":"<code>closed_triads</code>","text":"<p>Calculates the set of edges that represent a closed triad around a given node \\(v\\).</p> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>pathpyG.core.graph.Graph</code> <p>The graph in which to calculate the list of closed triads.</p> required <code>v</code> <code>str</code> <p>The node around which to calculate the closed triads.</p> required Source code in <code>src/pathpyG/statistics/clustering.py</code> <pre><code>def closed_triads(g: Graph, v: str) -&gt; Set:\n    \"\"\"Calculates the set of edges that represent a closed triad around a given node $v$.\n\n    Args:\n        g (Graph): The graph in which to calculate the list of closed triads.\n        v (str): The node around which to calculate the closed triads.\n    \"\"\"\n    c_triads: set = set()\n    edges = set()\n\n    # Collect all edges of successors\n    for x in g.successors(v):\n        for y in g.successors(x):\n            edges.add((x, y))\n\n    for x, y in edges:\n        if y in g.successors(v):\n            c_triads.add((x, y))\n    return c_triads\n</code></pre>"},{"location":"reference/pathpyG/statistics/clustering/#pathpyG.statistics.clustering.local_clustering_coefficient","title":"<code>local_clustering_coefficient</code>","text":"<p>Calculates the local clustering coefficient \\(C_u\\) for a given node \\(u\\) from a graph \\(G=(V, E)\\).</p> <p>The local clustering coefficient is defined as the fraction of closed triads around node \\(u\\) over the number of possible triads.</p> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>pathpyG.core.graph.Graph</code> <p>The graph in which to calculate the clustering coefficient.</p> required <code>u</code> <code>str</code> <p>The node for which to calculate the clustering coefficient.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The local clustering coefficient of node u.</p> Source code in <code>src/pathpyG/statistics/clustering.py</code> <pre><code>def local_clustering_coefficient(g: Graph, u: str) -&gt; float:\n    \"\"\"Calculates the local clustering coefficient $C_u$ for a given node $u$ from a [graph][pathpyG.core.graph.Graph] $G=(V, E)$.\n\n    The local clustering coefficient is defined as the fraction of closed\n    triads around node $u$ over the number of possible triads.\n\n    Args:\n        g (Graph): The graph in which to calculate the clustering coefficient.\n        u (str): The node for which to calculate the clustering coefficient.\n\n    Returns:\n        float: The local clustering coefficient of node u.\n    \"\"\"\n    # Compute number of directly connected neighbour pairs\n    k_u = float(len(closed_triads(g, u)))\n\n    # Normalise fraction based on number of possible edges\n    if g.is_directed():\n        if g.out_degrees[u] &gt; 1:\n            return k_u / (g.out_degrees[u] * (g.out_degrees[u] - 1))\n        else:\n            return 0.0\n    else:\n        k_u /= 2.0\n        if g.degrees()[u] &gt; 1:  # type: ignore[index]\n            return 2.0 * k_u / (g.degrees()[u] * (g.degrees()[u] - 1))  # type: ignore[index]\n        else:\n            return 0.0\n</code></pre>"},{"location":"reference/pathpyG/statistics/degrees/","title":"degrees","text":"<p>Module for degree-related statistics of graphs.</p>"},{"location":"reference/pathpyG/statistics/degrees/#pathpyG.statistics.degrees.degree_assortativity","title":"<code>degree_assortativity</code>","text":"<p>Calculate the degree assortativity coefficient of the graph.</p> <p>The degree assortativity coefficient \\(r\\) of a graph \\(G=(V, E)\\) is defined as</p> \\[ r = \\frac{\\sum_{i,j} \\left(A_{ij} - d_i d_j / (2m)\\right) d_i d_j}{\\sum_{i,j} \\left(d_i \\delta_{ij} - d_i d_j / (2m)\\right) d_i d_j} \\] <p>with the adjacency matrix \\(A\\), the degree \\(d_i\\) of node \\(i\\), the number of edges \\(m\\) and the Kronecker delta \\(\\delta_{ij}\\).</p> <p>For computational reasons, we calculate the coefficient as follows:</p> \\[ r = \\frac{S_1S_e - S_2^2}{S_1S_3 - S_2^2} \\] <p>where \\(S_l = \\sum_{i} d_i^l\\) for \\(l=1,2,3\\) and \\(S_e = \\sum_{(i,j) \\in E} d_i d_j\\).</p> Reference <p>You can find the defintions above with further explanations in Equations (10.27) and (10.28) in Chapter 10.7 in Networks<sup>1</sup> by Mark Newman.</p> <ol> <li> <p>Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001. \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The graph for which to calculate the degree assortativity</p> required <code>mode</code> <code>str</code> <p>'in', 'out' or 'total' for directed graphs, ignored for undirected graphs</p> <code>'total'</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The degree assortativity coefficient of the graph</p> Source code in <code>src/pathpyG/statistics/degrees.py</code> <pre><code>def degree_assortativity(graph: Graph, mode: str = \"total\") -&gt; float:\n    r\"\"\"Calculate the degree assortativity coefficient of the [graph][pathpyG.core.graph.Graph].\n\n    The degree assortativity coefficient $r$ of a [graph][pathpyG.core.graph.Graph] $G=(V, E)$ is defined as\n\n    $$\n    r = \\frac{\\sum_{i,j} \\left(A_{ij} - d_i d_j / (2m)\\right) d_i d_j}{\\sum_{i,j} \\left(d_i \\delta_{ij} - d_i d_j / (2m)\\right) d_i d_j}\n    $$\n\n    with the adjacency matrix $A$, the degree $d_i$ of node $i$, the number of edges [$m$][pathpyG.core.graph.Graph.m] and the Kronecker delta $\\delta_{ij}$.\n\n    For computational reasons, we calculate the coefficient as follows:\n\n    $$\n    r = \\frac{S_1S_e - S_2^2}{S_1S_3 - S_2^2}\n    $$\n\n    where $S_l = \\sum_{i} d_i^l$ for $l=1,2,3$ and $S_e = \\sum_{(i,j) \\in E} d_i d_j$.\n\n    ??? reference\n        You can find the defintions above with further explanations in Equations (10.27) and (10.28) in Chapter 10.7 in *Networks*[^1] by Mark Newman.\n\n    [^1]: *Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001.*\n\n    Args:\n        graph: The graph for which to calculate the degree assortativity\n        mode:  'in', 'out' or 'total' for directed graphs, ignored for undirected graphs\n\n    Returns:\n        float: The degree assortativity coefficient of the graph\n    \"\"\"\n    degree_seq = degree_sequence(graph, mode=mode).float()\n    S_1 = torch.sum(degree_seq).item()\n    S_2 = torch.sum(degree_seq**2).item()\n    S_3 = torch.sum(degree_seq**3).item()\n    S_e = torch.sum(degree_seq[graph.data.edge_index[0]] * degree_seq[graph.data.edge_index[1]]).item()\n\n    numerator = S_1 * S_e - S_2**2\n    denominator = S_1 * S_3 - S_2**2\n\n    return numerator / denominator\n</code></pre>"},{"location":"reference/pathpyG/statistics/degrees/#pathpyG.statistics.degrees.degree_central_moment","title":"<code>degree_central_moment</code>","text":"<p>Calculates the k-th central moment of the degree distribution.</p> <p>The k-th central moment \\(\\mu_k\\) of the degree distribution \\(P_{mode}(d)\\) of a graph \\(G=(V, E)\\) is defined as</p> \\[ \\mu_k = \\sum_d (d - \\langle d_{mode} \\rangle)^k P_{mode}(d). \\] <p>where \\(\\langle d_{mode} \\rangle\\) is the mean degree of the graph and \\(P_{mode}(d)\\) is the degree distribution.</p> Note <p>The 2<sup>nd</sup> central moment corresponds to the variance of the degree distribution.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The graph for which to calculate the k-th central moment</p> required <code>k</code> <code>int</code> <p>The order of the moment to calculate</p> <code>1</code> <code>mode</code> <code>str</code> <p>'in', 'out' or 'total' for directed graphs, ignored for undirected graphs</p> <code>'total'</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The k-th central moment of the degree distribution</p> Source code in <code>src/pathpyG/statistics/degrees.py</code> <pre><code>def degree_central_moment(graph: Graph, k: int = 1, mode: str = \"total\") -&gt; float:\n    r\"\"\"Calculates the k-th central moment of the [degree distribution][pathpyG.statistics.degrees.degree_distribution].\n\n    The k-th central moment $\\mu_k$ of the [degree distribution][pathpyG.statistics.degrees.degree_distribution] $P_{mode}(d)$ of a [graph][pathpyG.core.graph.Graph] $G=(V, E)$ is defined as\n\n    $$\n    \\mu_k = \\sum_d (d - \\langle d_{mode} \\rangle)^k P_{mode}(d).\n    $$\n\n    where $\\langle d_{mode} \\rangle$ is the [mean degree][pathpyG.statistics.degrees.mean_degree] of the graph and $P_{mode}(d)$ is the [degree distribution][pathpyG.statistics.degrees.degree_distribution].\n\n    Note:\n        The 2nd central moment corresponds to the variance of the degree distribution.\n\n    Args:\n        graph: The graph for which to calculate the k-th central moment\n        k: The order of the moment to calculate\n        mode:  'in', 'out' or 'total' for directed graphs, ignored for undirected graphs\n\n    Returns:\n        float: The k-th central moment of the degree distribution\n    \"\"\"\n    p_k = degree_distribution(graph, mode=mode)\n    mean = mean_degree(graph, mode=mode)\n    x = torch.arange(len(p_k), dtype=torch.float32)\n    m = torch.sum((x - mean) ** k * p_k).item()\n    return m\n</code></pre>"},{"location":"reference/pathpyG/statistics/degrees/#pathpyG.statistics.degrees.degree_distribution","title":"<code>degree_distribution</code>","text":"<p>Calculates the (unweighted) degree distribution of a graph.</p> <p>The degree distribution \\(P_{mode}(d)\\) of a graph \\(G=(V, E)\\) is defined as</p> \\[ P_{mode}(d) = \\frac{N_d}{n} \\] <p>with \\(N_d = |\\{v_i \\in V : d_{mode}(v_i) = d\\}|\\) being the number of nodes with degree \\(d\\) and \\(n\\) being the total number of nodes in the graph. The modes are defined as follows:</p> <ul> <li>'in': In-degree \\(d_{in}(v_i)\\) of node \\(v_i\\), i.e. the number of incoming edges \\(|\\{(v_j, v_i) \\in E\\}|\\) from any other node \\(v_j\\)</li> <li>'out': Out-degree \\(d_{out}(v_i)\\) of node \\(v_i\\), i.e. the number of outgoing edges \\(|\\{(v_i, v_j) \\in E\\}|\\) to any other node \\(v_j\\)</li> <li>'total': Total degree \\(d_{total}(v_i)\\) of node \\(v_i\\), i.e. the sum of in-degree and out-degree \\(d_{in}(v_i) + d_{out}(v_i)\\)</li> </ul> <p>The degree distribution is returned as a <code>torch.Tensor</code> of shape <code>(d_max + 1,)</code> where <code>d_max</code> is the maximum degree in the graph.</p> Reference <p>For further reading, see Chapter 10.3 in Networks<sup>1</sup> by Mark Newman.</p> <ol> <li> <p>Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001. \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The <code>Graph</code> object for which the degree distribution is calculated</p> required <code>mode</code> <code>str</code> <p>'in', 'out' or 'total' for directed graphs, ignored for undirected graphs</p> <code>'total'</code> <p>Returns:</p> Type Description <code>torch.Tensor</code> <p>torch.Tensor: A tensor containing the degree distribution</p> Source code in <code>src/pathpyG/statistics/degrees.py</code> <pre><code>def degree_distribution(graph: Graph, mode: str = \"total\") -&gt; torch.Tensor:\n    r\"\"\"Calculates the (unweighted) degree distribution of a [graph][pathpyG.core.graph.Graph].\n\n    The degree distribution $P_{mode}(d)$ of a [graph][pathpyG.core.graph.Graph] $G=(V, E)$ is defined as\n\n    $$\n    P_{mode}(d) = \\frac{N_d}{n}\n    $$\n\n    with $N_d = |\\{v_i \\in V : d_{mode}(v_i) = d\\}|$ being the number of nodes with degree $d$ and $n$ being the total number of nodes in the graph.\n    The modes are defined as follows:\n\n    - 'in': In-degree $d_{in}(v_i)$ of node $v_i$, i.e. the number of incoming edges $|\\{(v_j, v_i) \\in E\\}|$ from any other node $v_j$\n    - 'out': Out-degree $d_{out}(v_i)$ of node $v_i$, i.e. the number of outgoing edges $|\\{(v_i, v_j) \\in E\\}|$ to any other node $v_j$\n    - 'total': Total degree $d_{total}(v_i)$ of node $v_i$, i.e. the sum of in-degree and out-degree $d_{in}(v_i) + d_{out}(v_i)$\n\n    The degree distribution is returned as a `torch.Tensor` of shape `(d_max + 1,)` where `d_max` is the maximum degree in the graph.\n\n    ??? reference\n        For further reading, see Chapter 10.3 in *Networks*[^1] by Mark Newman.\n\n    [^1]: *Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001.*\n\n    Args:\n        graph: The `Graph` object for which the degree distribution is calculated\n        mode:  'in', 'out' or 'total' for directed graphs, ignored for undirected graphs\n\n    Returns:\n        torch.Tensor: A tensor containing the degree distribution\n    \"\"\"\n    return degree_sequence(graph, mode=mode).bincount() / graph.n\n</code></pre>"},{"location":"reference/pathpyG/statistics/degrees/#pathpyG.statistics.degrees.degree_generating_function","title":"<code>degree_generating_function</code>","text":"<p>Returns the generating function of the degree distribution of a graph.</p> <p>Returns \\(f(x)\\) where \\(f\\) is the probability generating function for the degree distribution \\(P_{mode}(d)\\) for a graph \\(G=(V, E)\\) defined as</p> \\[ f(x) = \\sum_d P_{mode}(d) x^d. \\] <p>The function is defined in the interval \\(\\left[0,1\\right]\\). The following properties hold:</p> <ol> <li> <p>The values of the degree distribution \\(P_{mode}(d)\\) can be retrieved from the generating function via     $$     P_{mode}(d) = \\left[\\frac{1}{d!} \\frac{d^d f}{dx^d}\\right]_{x=0}     $$</p> <p>with \\(\\frac{d^d}{dx^d} f\\) being the d-th derivative of \\(f\\) by \\(x\\).</p> </li> <li> <p>The \\(k\\)-th raw moment of the degree distribution can be retrieved from the generating function with</p> \\[ \\left[\\left(x \\frac{d}{dx}\\right)^k f\\right]_{x=1} = \\langle d_{mode}^k \\rangle. \\] </li> </ol> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The graph for which the generating function shall be computed</p> required <code>x</code> <code>float | list[float] | numpy.ndarray | torch.Tensor</code> <p>float, list, numpy.ndarray, or torch.Tensor The argument(s) for which value(s) \\(f(x)\\) shall be computed.</p> required <code>mode</code> <code>str</code> <p>'in', 'out' or 'total' for directed graphs, ignored for undirected graphs</p> <code>'total'</code> <p>Returns:</p> Type Description <code>float | torch.Tensor</code> <p>float or torch.Tensor: The value(s) of the generating function at x</p> <p>Examples:</p> <p>Generate simple network:</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt;\n&gt;&gt;&gt; g = pp.Graph.from_edge_list(\n...         [('a', 'b'), ('b', 'c'), ('a', 'c'), ('c', 'd'), ('d', 'e'), ('d', 'f'), ('e', 'f')]\n...     ).to_undirected()\n</code></pre> <p>Return single function value:</p> <pre><code>&gt;&gt;&gt; val = pp.statistics.degree_generating_function(g, 0.3)\n&gt;&gt;&gt; print(val)\n0.069...\n</code></pre> <p>Plot generating function of degree distribution</p> <pre><code>&gt;&gt;&gt; x = list(range(10))\n&gt;&gt;&gt; y = pp.statistics.degree_generating_function(g, x)\n&gt;&gt;&gt; print(y)\ntensor([  0.0000,   1.0000,   5.3333,  15.0000,  32.0000,  58.3333,  96.0000,\n147.0000, 213.3333, 297.0000])\n</code></pre> Source code in <code>src/pathpyG/statistics/degrees.py</code> <pre><code>def degree_generating_function(\n    graph: Graph, x: float | list[float] | _np.ndarray | torch.Tensor, mode: str = \"total\"\n) -&gt; float | torch.Tensor:\n    r\"\"\"Returns the generating function of the degree distribution of a [graph][pathpyG.core.graph.Graph].\n\n    Returns $f(x)$ where $f$ is the probability generating function for the degree\n    distribution $P_{mode}(d)$ for a [graph][pathpyG.core.graph.Graph] $G=(V, E)$ defined as\n\n    $$\n    f(x) = \\sum_d P_{mode}(d) x^d.\n    $$\n\n    The function is defined in the interval $\\left[0,1\\right]$. The following properties hold:\n\n    1. The values of the [degree distribution][pathpyG.statistics.degrees.degree_distribution] $P_{mode}(d)$ can be retrieved from the generating function via\n        $$\n        P_{mode}(d) = \\left[\\frac{1}{d!} \\frac{d^d f}{dx^d}\\right]_{x=0}\n        $$\n\n        with $\\frac{d^d}{dx^d} f$ being the d-th derivative of $f$ by $x$.\n\n    2. The $k$-th raw moment of the degree distribution can be retrieved from the generating function with\n\n        $$\n        \\left[\\left(x \\frac{d}{dx}\\right)^k f\\right]_{x=1} = \\langle d_{mode}^k \\rangle.\n        $$\n\n    Args:\n        graph: The [graph][pathpyG.core.graph.Graph] for which the generating function shall be computed\n        x:  float, list, numpy.ndarray, or torch.Tensor\n            The argument(s) for which value(s) $f(x)$ shall be computed.\n        mode:  'in', 'out' or 'total' for directed graphs, ignored for undirected graphs\n\n    Returns:\n        float or torch.Tensor: The value(s) of the generating function at x\n\n    Examples:\n        Generate simple network:\n\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; g = pp.Graph.from_edge_list(\n        ...         [('a', 'b'), ('b', 'c'), ('a', 'c'), ('c', 'd'), ('d', 'e'), ('d', 'f'), ('e', 'f')]\n        ...     ).to_undirected()\n\n        Return single function value:\n\n        &gt;&gt;&gt; val = pp.statistics.degree_generating_function(g, 0.3)\n        &gt;&gt;&gt; print(val)\n        0.069...\n\n        Plot generating function of degree distribution\n\n        &gt;&gt;&gt; x = list(range(10))\n        &gt;&gt;&gt; y = pp.statistics.degree_generating_function(g, x)\n        &gt;&gt;&gt; print(y)\n        tensor([  0.0000,   1.0000,   5.3333,  15.0000,  32.0000,  58.3333,  96.0000,\n        147.0000, 213.3333, 297.0000])\n    \"\"\"\n    p_k = degree_distribution(graph, mode=mode)\n\n    if isinstance(x, float):\n        x_range = torch.tensor([x])\n    elif isinstance(x, list) or isinstance(x, _np.ndarray):\n        x_range = torch.tensor(x, dtype=torch.float32)\n    elif isinstance(x, torch.Tensor):\n        x_range = x.float()\n    else:\n        raise TypeError(\"x must be a float, list, numpy.ndarray, or torch.Tensor\")\n\n    # Via broadcasting, compute f(x) for all x in x_range defined as f(x) = sum_k p_k * x^k\n    values = torch.sum(p_k.unsqueeze(1) * (x_range.unsqueeze(0) ** torch.arange(p_k.size(0)).unsqueeze(1)), dim=0)\n\n    if isinstance(x, float):\n        return values[0].item()\n    else:\n        return values\n</code></pre>"},{"location":"reference/pathpyG/statistics/degrees/#pathpyG.statistics.degrees.degree_raw_moment","title":"<code>degree_raw_moment</code>","text":"<p>Calculates the k-th raw moment of the degree distribution of a graph.</p> <p>The k-th raw moment \\(\\langle d^k \\rangle\\) of the degree distribution \\(P_{mode}(d)\\) of a graph \\(G=(V, E)\\) is defined as</p> \\[ \\langle d_{mode}^k \\rangle = \\sum_d d^k P_{mode}(d). \\] Reference <p>For further reading, see Equation 10.20 in Chapter 10.4 in Networks<sup>1</sup> by Mark Newman.</p> <ol> <li> <p>Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001. \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The graph in which to calculate the k-th raw moment</p> required <code>k</code> <code>int</code> <p>The order of the moment to calculate</p> <code>1</code> <code>mode</code> <code>str</code> <p>'in', 'out' or 'total' for directed graphs, ignored for undirected graphs</p> <code>'total'</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The k-th raw moment of the degree distribution</p> Source code in <code>src/pathpyG/statistics/degrees.py</code> <pre><code>def degree_raw_moment(graph: Graph, k: int = 1, mode: str = \"total\") -&gt; float:\n    r\"\"\"Calculates the k-th raw moment of the degree distribution of a [graph][pathpyG.core.graph.Graph].\n\n    The k-th raw moment $\\langle d^k \\rangle$ of the [degree distribution][pathpyG.statistics.degrees.degree_distribution] $P_{mode}(d)$ of a [graph][pathpyG.core.graph.Graph] $G=(V, E)$ is defined as\n\n    $$\n    \\langle d_{mode}^k \\rangle = \\sum_d d^k P_{mode}(d).\n    $$\n\n    ??? reference\n        For further reading, see Equation 10.20 in Chapter 10.4 in *Networks*[^1] by Mark Newman.\n\n    [^1]: *Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001.*\n\n    Args:\n        graph:  The graph in which to calculate the k-th raw moment\n        k: The order of the moment to calculate\n        mode:  'in', 'out' or 'total' for directed graphs, ignored for undirected graphs\n\n    Returns:\n        float: The k-th raw moment of the degree distribution\n    \"\"\"\n    p_k = degree_distribution(graph, mode=mode)\n    x = torch.arange(len(p_k), dtype=torch.float32)\n    m = torch.sum((x**k) * p_k).item()\n    return m\n</code></pre>"},{"location":"reference/pathpyG/statistics/degrees/#pathpyG.statistics.degrees.degree_sequence","title":"<code>degree_sequence</code>","text":"<p>Calculates the (unweighted) degree sequence of a graph.</p> <p>Returns the degree sequence of a graph \\(G=(V, E)\\) defined as</p> \\[ \\left\\{d_{mode}(v_1), d_{mode}(v_2), \\ldots, d_{mode}(v_n)\\right\\} \\text{ for all nodes } v_i \\in V \\] <p>with \\(d_{mode}(v_i)\\) being the degree of node \\(v_i\\) in mode 'in', 'out' or 'total'. The modes are defined as follows:</p> <ul> <li>'in': In-degree \\(d_{in}(v_i)\\) of node \\(v_i\\), i.e. the number of incoming edges \\(|\\{(v_j, v_i) \\in E\\}|\\) from any other node \\(v_j\\)</li> <li>'out': Out-degree \\(d_{out}(v_i)\\) of node \\(v_i\\), i.e. the number of outgoing edges \\(|\\{(v_i, v_j) \\in E\\}|\\) to any other node \\(v_j\\)</li> <li>'total': Total degree \\(d_{total}(v_i)\\) of node \\(v_i\\), i.e. the sum of in-degree and out-degree \\(d_{in}(v_i) + d_{out}(v_i)\\)</li> </ul> <p>The degree sequence is returned as a <code>torch.Tensor</code> of shape <code>(n,)</code> where \\(n\\) is the number of nodes in the graph. The order of the degree sequence corresponds to the indexing of the nodes in the graph and the index of a node \\(v_i\\) given by its label can be accessed via <code>graph.mapping.to_idx(v_i)</code>.</p> Reference <p>For further reading, see Chapter 10.3 in Networks<sup>1</sup> by Mark Newman.</p> <ol> <li> <p>Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001. \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The <code>Graph</code> object for which degrees are calculated</p> required <code>mode</code> <code>str</code> <p>'in', 'out' or 'total' for directed graphs, ignored for undirected graphs</p> <code>'total'</code> <p>Returns:</p> Type Description <code>torch.Tensor</code> <p>torch.Tensor: A tensor containing the degree sequence</p> Source code in <code>src/pathpyG/statistics/degrees.py</code> <pre><code>def degree_sequence(graph: Graph, mode: str = \"total\") -&gt; torch.Tensor:\n    r\"\"\"Calculates the (unweighted) degree sequence of a [graph][pathpyG.core.graph.Graph].\n\n    Returns the degree sequence of a [graph][pathpyG.core.graph.Graph] $G=(V, E)$ defined as\n\n    $$\n    \\left\\{d_{mode}(v_1), d_{mode}(v_2), \\ldots, d_{mode}(v_n)\\right\\} \\text{ for all nodes } v_i \\in V\n    $$\n\n    with $d_{mode}(v_i)$ being the degree of node $v_i$ in mode 'in', 'out' or 'total'.\n    The modes are defined as follows:\n\n    - 'in': In-degree $d_{in}(v_i)$ of node $v_i$, i.e. the number of incoming edges $|\\{(v_j, v_i) \\in E\\}|$ from any other node $v_j$\n    - 'out': Out-degree $d_{out}(v_i)$ of node $v_i$, i.e. the number of outgoing edges $|\\{(v_i, v_j) \\in E\\}|$ to any other node $v_j$\n    - 'total': Total degree $d_{total}(v_i)$ of node $v_i$, i.e. the sum of in-degree and out-degree $d_{in}(v_i) + d_{out}(v_i)$\n\n    The degree sequence is returned as a `torch.Tensor` of shape `(n,)` where $n$ is the number of nodes in the graph.\n    The order of the degree sequence corresponds to the indexing of the nodes in the graph and\n    the index of a node $v_i$ given by its label can be accessed via [`graph.mapping.to_idx(v_i)`][pathpyG.core.index_map.IndexMap.to_idx].\n\n    ??? reference\n        For further reading, see Chapter 10.3 in *Networks*[^1] by Mark Newman.\n\n    [^1]: *Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001.*\n\n    Args:\n        graph: The `Graph` object for which degrees are calculated\n        mode:  'in', 'out' or 'total' for directed graphs, ignored for undirected graphs\n\n    Returns:\n        torch.Tensor: A tensor containing the degree sequence\n    \"\"\"\n    if mode == \"total\":\n        if graph.is_directed():\n            return graph.degrees(mode=\"in\", return_tensor=True) + graph.degrees(mode=\"out\", return_tensor=True)  # type: ignore[operator]\n        else:\n            return graph.degrees(mode=\"in\", return_tensor=True)  # type: ignore[return-value]\n    else:\n        return graph.degrees(mode, return_tensor=True)  # type: ignore[return-value]\n</code></pre>"},{"location":"reference/pathpyG/statistics/degrees/#pathpyG.statistics.degrees.mean_degree","title":"<code>mean_degree</code>","text":"<p>Calculates the mean degree of a graph.</p> <p>The mean degree \\(\\langle d \\rangle\\) of a graph \\(G=(V, E)\\) is defined as</p> \\[ \\langle d_{mode} \\rangle = \\frac{1}{n} \\sum_{i=1}^{n} d_{mode}(v_i) \\] <p>with \\(d_{mode}(v_i)\\) being the degree of node \\(v_i\\) in mode 'in', 'out' or 'total'. The modes are defined as follows:</p> <ul> <li>'in': In-degree \\(d_{in}(v_i)\\) of node \\(v_i\\), i.e. the number of incoming edges \\(|\\{(v_j, v_i) \\in E\\}|\\) from any other node \\(v_j\\)</li> <li>'out': Out-degree \\(d_{out}(v_i)\\) of node \\(v_i\\), i.e. the number of outgoing edges \\(|\\{(v_i, v_j) \\in E\\}|\\) to any other node \\(v_j\\)</li> <li>'total': Total degree \\(d_{total}(v_i)\\) of node \\(v_i\\), i.e. the sum of in-degree and out-degree \\(d_{in}(v_i) + d_{out}(v_i)\\)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The graph for which to calculate the mean degree</p> required <code>mode</code> <code>str</code> <p>'in', 'out' or 'total' for directed graphs, ignored for undirected graphs</p> <code>'total'</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The mean degree of the graph</p> Source code in <code>src/pathpyG/statistics/degrees.py</code> <pre><code>def mean_degree(graph: Graph, mode: str = \"total\") -&gt; float:\n    r\"\"\"Calculates the mean degree of a [graph][pathpyG.core.graph.Graph].\n\n    The mean degree $\\langle d \\rangle$ of a [graph][pathpyG.core.graph.Graph] $G=(V, E)$ is defined as\n\n    $$\n    \\langle d_{mode} \\rangle = \\frac{1}{n} \\sum_{i=1}^{n} d_{mode}(v_i)\n    $$\n\n    with $d_{mode}(v_i)$ being the degree of node $v_i$ in mode 'in', 'out' or 'total'.\n    The modes are defined as follows:\n\n    - 'in': In-degree $d_{in}(v_i)$ of node $v_i$, i.e. the number of incoming edges $|\\{(v_j, v_i) \\in E\\}|$ from any other node $v_j$\n    - 'out': Out-degree $d_{out}(v_i)$ of node $v_i$, i.e. the number of outgoing edges $|\\{(v_i, v_j) \\in E\\}|$ to any other node $v_j$\n    - 'total': Total degree $d_{total}(v_i)$ of node $v_i$, i.e. the sum of in-degree and out-degree $d_{in}(v_i) + d_{out}(v_i)$\n\n    Args:\n        graph: The graph for which to calculate the mean degree\n        mode:  'in', 'out' or 'total' for directed graphs, ignored for undirected graphs\n\n    Returns:\n        float: The mean degree of the graph\n    \"\"\"\n    return torch.mean(degree_sequence(graph, mode=mode).float()).item()\n</code></pre>"},{"location":"reference/pathpyG/statistics/degrees/#pathpyG.statistics.degrees.mean_neighbor_degree","title":"<code>mean_neighbor_degree</code>","text":"<p>Calculates the mean neighbor degree of a graph.</p> <p>The mean neighbor degree \\(\\langle d_{\\mathcal{N}} \\rangle\\) of a graph \\(G=(V, E)\\) is defined as</p> \\[ \\langle d_{\\mathcal{N}} \\rangle = \\frac{1}{m} \\sum_{v_i \\in V} \\sum_{v_j \\in \\mathcal{N}(v_i)} d_{mode}(v_j) \\] <p>with the number of edges \\(m\\) (1), the set of neighbors \\(\\mathcal{N}(v_i)\\) of node \\(v_i\\) and \\(d_{mode}(v_j)\\) being the degree of neighbor node \\(v_j \\in \\mathcal{N}(v_i)\\) in mode 'in', 'out' or 'total'.</p> <ol> <li>This definition is for directed graphs. For undirected graphs, the denominator is \\(2m\\).</li> </ol> <p>The modes are defined as follows:</p> <ul> <li>'in': In-degree \\(d_{in}(v_i)\\) of node \\(v_i\\), i.e. the number of incoming edges \\(|\\{(v_j, v_i) \\in E\\}|\\) from any other node \\(v_j\\)</li> <li>'out': Out-degree \\(d_{out}(v_i)\\) of node \\(v_i\\), i.e. the number of outgoing edges \\(|\\{(v_i, v_j) \\in E\\}|\\) to any other node \\(v_j\\)</li> <li>'total': Total degree \\(d_{total}(v_i)\\) of node \\(v_i\\), i.e. the sum of in-degree and out-degree \\(d_{in}(v_i) + d_{out}(v_i)\\)</li> </ul> Reference <p>For further reading, see Chapter 12.2 in Networks<sup>1</sup> by Mark Newman.</p> <ol> <li> <p>Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001. \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The graph for which to calculate the mean neighbor degree</p> required <code>mode</code> <code>str</code> <p>'in', 'out' or 'total' for directed graphs, ignored for undirected graphs</p> <code>'total'</code> <code>exclude_backlink</code> <code>bool</code> <p>Whether to exclude the backlink to the original node when calculating neighbor degrees</p> <code>False</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The mean neighbor degree of the graph</p> Source code in <code>src/pathpyG/statistics/degrees.py</code> <pre><code>def mean_neighbor_degree(graph: Graph, mode: str = \"total\", exclude_backlink: bool = False) -&gt; float:\n    r\"\"\"Calculates the mean neighbor degree of a [graph][pathpyG.core.graph.Graph].\n\n    The mean neighbor degree $\\langle d_{\\mathcal{N}} \\rangle$ of a [graph][pathpyG.core.graph.Graph] $G=(V, E)$ is defined as\n\n    $$\n    \\langle d_{\\mathcal{N}} \\rangle = \\frac{1}{m} \\sum_{v_i \\in V} \\sum_{v_j \\in \\mathcal{N}(v_i)} d_{mode}(v_j)\n    $$\n\n\n    with the number of edges [$m$][pathpyG.core.graph.Graph.m] (1), the set of neighbors $\\mathcal{N}(v_i)$ of node $v_i$ and $d_{mode}(v_j)$ being the degree of neighbor node $v_j \\in \\mathcal{N}(v_i)$ in mode 'in', 'out' or 'total'.\n    { .annotate }\n\n    1. This definition is for directed graphs. For undirected graphs, the denominator is $2m$.\n\n    The modes are defined as follows:\n\n    - 'in': In-degree $d_{in}(v_i)$ of node $v_i$, i.e. the number of incoming edges $|\\{(v_j, v_i) \\in E\\}|$ from any other node $v_j$\n    - 'out': Out-degree $d_{out}(v_i)$ of node $v_i$, i.e. the number of outgoing edges $|\\{(v_i, v_j) \\in E\\}|$ to any other node $v_j$\n    - 'total': Total degree $d_{total}(v_i)$ of node $v_i$, i.e. the sum of in-degree and out-degree $d_{in}(v_i) + d_{out}(v_i)$\n\n    ??? reference\n        For further reading, see Chapter 12.2 in *Networks*[^1] by Mark Newman.\n\n    [^1]: *Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001.*\n\n    Args:\n        graph: The graph for which to calculate the mean neighbor degree\n        mode:  'in', 'out' or 'total' for directed graphs, ignored for undirected graphs\n        exclude_backlink: Whether to exclude the backlink to the original node when calculating neighbor degrees\n\n    Returns:\n        float: The mean neighbor degree of the graph\n    \"\"\"\n    in_degree = degree_sequence(graph, mode=\"in\")\n    degree_seq = degree_sequence(graph, mode=mode)\n    if exclude_backlink:\n        degree_seq = degree_seq - 1\n    return torch.sum(in_degree * degree_seq).item() / (2 * graph.m if graph.is_undirected() else graph.m)\n</code></pre>"},{"location":"reference/pathpyG/statistics/node_similarities/","title":"node_similarities","text":"<p>Module for node similarity measures in graphs.</p>"},{"location":"reference/pathpyG/statistics/node_similarities/#pathpyG.statistics.node_similarities.LeichtHolmeNewman_index","title":"<code>LeichtHolmeNewman_index</code>","text":"<p>Compute the Leicht-Holme-Newman index between two nodes.</p> <p>The Leicht-Holme-Newman index for all pairs of nodes \\(V^2\\) is defined as</p> \\[ S_{LHN} = 2m \\lambda_1 D^{-1} \\left(I - \\frac{\\alpha}{\\lambda_1} A\\right)^{-1} D^{-1} \\] <p>where \\(m\\) is the number of edges in the graph, \\(\\lambda_1\\) is the largest eigenvalue of the adjacency matrix \\(A\\), \\(D\\) is the diagonal degree matrix, and \\(I\\) is the identity matrix. To obtain \\(S_{LHN}(v, w)\\), the entry corresponding to nodes \\(v\\) and \\(w\\) is selected from the matrix \\(S_{LHN}\\).</p> Reference <p>Proposed by Leicht, Holme, and Newman in \"Vertex similarity in networks\"<sup>1</sup>.</p> <ol> <li> <p>Leicht, E. A., Holme, P. &amp; Newman, M. E. J. Vertex similarity in networks. Phys. Rev. E 73, 026120 (2006). \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The input graph.</p> required <code>v</code> <code>str | int</code> <p>The first node given the node label (or index if no label is provided).</p> required <code>w</code> <code>str | int</code> <p>The second node given the node label (or index if no label is provided).</p> required <code>alpha</code> <code>float</code> <p>Parameter controlling the weight of longer paths.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The Leicht-Holme-Newman index between nodes <code>v</code> and <code>w</code>.</p> Source code in <code>src/pathpyG/statistics/node_similarities.py</code> <pre><code>def LeichtHolmeNewman_index(graph: Graph, v: str | int, w: str | int, alpha: float) -&gt; float:\n    r\"\"\"Compute the Leicht-Holme-Newman index between two nodes.\n\n    The Leicht-Holme-Newman index for all pairs of nodes $V^2$ is defined as\n\n    $$\n    S_{LHN} = 2m \\lambda_1 D^{-1} \\left(I - \\frac{\\alpha}{\\lambda_1} A\\right)^{-1} D^{-1}\n    $$\n\n    where [$m$][pathpyG.core.graph.Graph.m] is the number of edges in the graph, $\\lambda_1$ is the largest eigenvalue of the adjacency matrix $A$, $D$ is the diagonal degree matrix, and $I$ is the identity matrix.\n    To obtain $S_{LHN}(v, w)$, the entry corresponding to nodes $v$ and $w$ is selected from the matrix $S_{LHN}$.\n\n    ??? reference\n        Proposed by Leicht, Holme, and Newman in \"Vertex similarity in networks\"[^1].\n\n    [^1]: *Leicht, E. A., Holme, P. &amp; Newman, M. E. J. Vertex similarity in networks. Phys. Rev. E 73, 026120 (2006).*\n\n    Args:\n        graph: The input graph.\n        v: The first node given the node label (or index if no label is provided).\n        w: The second node given the node label (or index if no label is provided).\n        alpha: Parameter controlling the weight of longer paths.\n\n    Returns:\n        The Leicht-Holme-Newman index between nodes `v` and `w`.\n    \"\"\"\n    A = graph.sparse_adj_matrix()\n    ev = _sp.sparse.linalg.eigs(A, which=\"LM\", k=2, return_eigenvectors=False)\n    eigenvalues_sorted = _np.sort(_np.absolute(ev))\n    m = graph.m\n    lambda_1 = eigenvalues_sorted[1]\n    D = _sp.sparse.diags(degree_sequence(graph).numpy()).tocsc()\n    I = _sp.sparse.identity(graph.n).tocsc()  # noqa: E741\n    S = (\n        2\n        * m\n        * lambda_1\n        * _sp.sparse.linalg.inv(D)\n        * _sp.sparse.linalg.inv(I - alpha * A / lambda_1)\n        * _sp.sparse.linalg.inv(D)\n    )\n    return S[graph.mapping.to_idx(v), graph.mapping.to_idx(w)]\n</code></pre>"},{"location":"reference/pathpyG/statistics/node_similarities/#pathpyG.statistics.node_similarities.adamic_adar_index","title":"<code>adamic_adar_index</code>","text":"<p>Compute the Adamic-Adar index between two nodes.</p> <p>The Adamic-Adar index between two nodes \\(v, w \\in V\\) is defined as</p> \\[ S_{AA}(v, w) = \\sum_{u \\in \\mathcal{N}(v) \\cap \\mathcal{N}(w)} \\frac{1}{\\log(|\\mathcal{N}(u)|)} \\] <p>where \\(\\mathcal{N}(v)\\) and \\(\\mathcal{N}(w)\\) are the sets of neighbors of nodes \\(v\\) and \\(w\\), respectively.</p> Reference <p>Proposed by Adamic and Adar in \"Friends and neighbors on the web\"<sup>1</sup>.</p> <ol> <li> <p>Adamic, L. A. &amp; Adar, E. Friends and neighbors on the Web. Social Networks 25, 211-230 (2003). \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The input graph.</p> required <code>v</code> <code>str | int</code> <p>The first node given the node label (or index if no label is provided).</p> required <code>w</code> <code>str | int</code> <p>The second node given the node label (or index if no label is provided).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The Adamic-Adar index between nodes <code>v</code> and <code>w</code>.</p> Source code in <code>src/pathpyG/statistics/node_similarities.py</code> <pre><code>def adamic_adar_index(graph: Graph, v: str | int, w: str | int) -&gt; float:\n    r\"\"\"Compute the Adamic-Adar index between two nodes.\n\n    The Adamic-Adar index between two nodes $v, w \\in V$ is defined as\n\n    $$\n    S_{AA}(v, w) = \\sum_{u \\in \\mathcal{N}(v) \\cap \\mathcal{N}(w)} \\frac{1}{\\log(|\\mathcal{N}(u)|)}\n    $$\n\n    where $\\mathcal{N}(v)$ and $\\mathcal{N}(w)$ are the sets of neighbors of nodes $v$ and $w$, respectively.\n\n    ??? reference\n        Proposed by Adamic and Adar in \"Friends and neighbors on the web\"[^1].\n\n    [^1]: *Adamic, L. A. &amp; Adar, E. Friends and neighbors on the Web. Social Networks 25, 211-230 (2003).*\n\n    Args:\n        graph: The input graph.\n        v: The first node given the node label (or index if no label is provided).\n        w: The second node given the node label (or index if no label is provided).\n\n    Returns:\n        The Adamic-Adar index between nodes `v` and `w`.\n    \"\"\"\n    A = 0\n    N_v = set([x for x in graph.successors(v)])\n    N_w = set([x for x in graph.successors(w)])\n    for u in N_v.intersection(N_w):\n        A += 1 / _np.log(graph.out_degrees[u])\n    return A\n</code></pre>"},{"location":"reference/pathpyG/statistics/node_similarities/#pathpyG.statistics.node_similarities.common_neighbors","title":"<code>common_neighbors</code>","text":"<p>Compute the number of common neighbors between two nodes.</p> \\[ S_{CN}(v, w) = |\\mathcal{N}(v) \\cap \\mathcal{N}(w)| \\] <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The input graph.</p> required <code>v</code> <code>str | int</code> <p>The first node given the node label (or index if no label is provided).</p> required <code>w</code> <code>str | int</code> <p>The second node given the node label (or index if no label is provided).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The number of common neighbors between nodes <code>v</code> and <code>w</code>.</p> Source code in <code>src/pathpyG/statistics/node_similarities.py</code> <pre><code>def common_neighbors(graph: Graph, v: str | int, w: str | int) -&gt; float:\n    r\"\"\"Compute the number of common neighbors between two nodes.\n\n    $$\n    S_{CN}(v, w) = |\\mathcal{N}(v) \\cap \\mathcal{N}(w)|\n    $$\n\n    Args:\n        graph: The input graph.\n        v: The first node given the node label (or index if no label is provided).\n        w: The second node given the node label (or index if no label is provided).\n\n    Returns:\n        The number of common neighbors between nodes `v` and `w`.\n    \"\"\"\n    N_v = set([x for x in graph.successors(v)])\n    N_w = set([x for x in graph.successors(w)])\n    return len(N_v.intersection(N_w))\n</code></pre>"},{"location":"reference/pathpyG/statistics/node_similarities/#pathpyG.statistics.node_similarities.cosine_similarity","title":"<code>cosine_similarity</code>","text":"<p>Compute the cosine similarity between two nodes.</p> <p>The cosine similarity between two nodes \\(v, w \\in V\\) is defined as</p> \\[ S_{COS}(v, w) = \\frac{\\mathbf{A}_v \\cdot \\mathbf{A}_w}{\\|\\mathbf{A}_v\\|_2 \\|\\mathbf{A}_w\\|_2} \\] <p>where \\(\\mathbf{A}_v\\) and \\(\\mathbf{A}_w\\) are row vectors of the adjacency matrix corresponding to nodes \\(v\\) and \\(w\\), respectively, \\(\\|\\cdot\\|_2\\) denotes the Euclidean norm, and \\(\\cdot\\) denotes the dot product.</p> Reference <p>For more details, see Equation (7.35) in Networks<sup>1</sup> by Mark Newman.</p> <ol> <li> <p>Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001. \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The input graph.</p> required <code>v</code> <code>str | int</code> <p>The first node given the node label (or index if no label is provided).</p> required <code>w</code> <code>str | int</code> <p>The second node given the node label (or index if no label is provided).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The cosine similarity between nodes <code>v</code> and <code>w</code>.</p> Source code in <code>src/pathpyG/statistics/node_similarities.py</code> <pre><code>def cosine_similarity(graph: Graph, v: str | int, w: str | int) -&gt; float:\n    r\"\"\"Compute the cosine similarity between two nodes.\n\n    The cosine similarity between two nodes $v, w \\in V$ is defined as\n\n    $$\n    S_{COS}(v, w) = \\frac{\\mathbf{A}_v \\cdot \\mathbf{A}_w}{\\|\\mathbf{A}_v\\|_2 \\|\\mathbf{A}_w\\|_2}\n    $$\n\n    where $\\mathbf{A}_v$ and $\\mathbf{A}_w$ are row vectors of the adjacency matrix corresponding to nodes $v$ and $w$, respectively, $\\|\\cdot\\|_2$ denotes the Euclidean norm, and $\\cdot$ denotes the dot product.\n\n    ??? reference\n        For more details, see Equation (7.35) in *Networks*[^1] by Mark Newman.\n\n    [^1]: *Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001.*\n\n    Args:\n        graph: The input graph.\n        v: The first node given the node label (or index if no label is provided).\n        w: The second node given the node label (or index if no label is provided).\n\n    Returns:\n        The cosine similarity between nodes `v` and `w`.\n    \"\"\"\n    if graph.degrees()[v] == 0 or graph.degrees()[w] == 0:  # type: ignore[index]\n        return 0\n    else:\n        A = graph.sparse_adj_matrix().todense()\n        v_v = A[graph.mapping.to_idx(v)].A1\n        v_w = A[graph.mapping.to_idx(w)].A1\n        return _np.dot(v_v, v_w) / (_np.linalg.norm(v_v) * _np.linalg.norm(v_w))\n</code></pre>"},{"location":"reference/pathpyG/statistics/node_similarities/#pathpyG.statistics.node_similarities.inverse_path_length","title":"<code>inverse_path_length</code>","text":"<p>Compute the inverse path length similarity between two nodes.</p> <p>Given a graph \\(G=(V, E)\\) and two nodes \\(v, w \\in V\\), the inverse path length similarity is defined as</p> \\[ S_{IPL}(v, w) = \\begin{cases} \\frac{1}{d(v, w)} &amp; \\text{if } d(v, w) &gt; 0 \\\\ \\infty &amp; \\text{if } d(v, w) = 0 \\end{cases} \\] <p>with the shortest path length \\(d(v, w)\\) between nodes \\(v\\) and \\(w\\).</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The input graph.</p> required <code>v</code> <code>str | int</code> <p>The first node given the node label (or index if no label is provided).</p> required <code>w</code> <code>str | int</code> <p>The second node given the node label (or index if no label is provided).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The inverse path length similarity between nodes <code>v</code> and <code>w</code>.</p> Source code in <code>src/pathpyG/statistics/node_similarities.py</code> <pre><code>def inverse_path_length(graph: Graph, v: str | int, w: str | int) -&gt; float:\n    r\"\"\"Compute the inverse path length similarity between two nodes.\n\n    Given a [graph][pathpyG.core.graph.Graph] $G=(V, E)$ and two nodes $v, w \\in V$,\n    the inverse path length similarity is defined as\n\n    $$\n    S_{IPL}(v, w) = \\begin{cases} \\frac{1}{d(v, w)} &amp; \\text{if } d(v, w) &gt; 0 \\\\ \\infty &amp; \\text{if } d(v, w) = 0 \\end{cases}\n    $$\n\n    with the shortest path length $d(v, w)$ between nodes $v$ and $w$.\n\n    Args:\n        graph: The input graph.\n        v: The first node given the node label (or index if no label is provided).\n        w: The second node given the node label (or index if no label is provided).\n\n    Returns:\n        The inverse path length similarity between nodes `v` and `w`.\n    \"\"\"\n    dist, _ = shortest_paths_dijkstra(graph)\n    d = dist[graph.mapping.to_idx(v), graph.mapping.to_idx(w)]\n    if d == 0:\n        return _np.inf\n    else:\n        return 1 / d  # type: ignore[return-value]\n</code></pre>"},{"location":"reference/pathpyG/statistics/node_similarities/#pathpyG.statistics.node_similarities.jaccard_similarity","title":"<code>jaccard_similarity</code>","text":"<p>Compute the Jaccard similarity between two nodes.</p> <p>The Jaccard similarity between two nodes \\(v, w \\in V\\) is defined as</p> \\[ S_{J}(v, w) = \\frac{|\\mathcal{N}(v) \\cap \\mathcal{N}(w)|}{|\\mathcal{N}(v) \\cup \\mathcal{N}(w)|} \\] <p>where \\(\\mathcal{N}(v)\\) and \\(\\mathcal{N}(w)\\) are the sets of neighbors of nodes \\(v\\) and \\(w\\), respectively.</p> Reference <p>For more details, see Equation (7.38) in Networks<sup>1</sup> by Mark Newman.</p> <ol> <li> <p>Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001. \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The input graph.</p> required <code>v</code> <code>str | int</code> <p>The first node given the node label (or index if no label is provided).</p> required <code>w</code> <code>str | int</code> <p>The second node given the node label (or index if no label is provided).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The Jaccard similarity between nodes <code>v</code> and <code>w</code>.</p> Source code in <code>src/pathpyG/statistics/node_similarities.py</code> <pre><code>def jaccard_similarity(graph: Graph, v: str | int, w: str | int) -&gt; float:\n    r\"\"\"Compute the Jaccard similarity between two nodes.\n\n    The Jaccard similarity between two nodes $v, w \\in V$ is defined as\n\n    $$\n    S_{J}(v, w) = \\frac{|\\mathcal{N}(v) \\cap \\mathcal{N}(w)|}{|\\mathcal{N}(v) \\cup \\mathcal{N}(w)|}\n    $$\n\n    where $\\mathcal{N}(v)$ and $\\mathcal{N}(w)$ are the sets of neighbors of nodes $v$ and $w$, respectively.\n\n    ??? reference\n        For more details, see Equation (7.38) in *Networks*[^1] by Mark Newman.\n\n    [^1]: *Newman, M. E. J. Networks. (Oxford University Press, 2018). doi:10.1093/oso/9780198805090.001.0001.*\n\n    Args:\n        graph: The input graph.\n        v: The first node given the node label (or index if no label is provided).\n        w: The second node given the node label (or index if no label is provided).\n\n    Returns:\n        The Jaccard similarity between nodes `v` and `w`.\n    \"\"\"\n    N_v = set([x for x in graph.successors(v)])\n    N_w = set([x for x in graph.successors(w)])\n    intersection = N_v.intersection(N_w)\n    if len(N_v) == 0 and len(N_w) == 0:\n        return 1\n    else:\n        return len(intersection) / (len(N_v) + len(N_w) - len(intersection))\n</code></pre>"},{"location":"reference/pathpyG/statistics/node_similarities/#pathpyG.statistics.node_similarities.katz_index","title":"<code>katz_index</code>","text":"<p>Compute the Katz index between two nodes.</p> <p>The Katz index for all pairs of nodes \\(V^2\\) is defined as</p> \\[ S_{Katz} = \\sum_{l=1}^{\\infty} \\beta^l A^l = (I - \\beta A)^{-1} - I \\] <p>where \\(A\\) is the adjacency matrix of the graph, \\(I\\) is the identity matrix, and \\(\\beta\\) is a parameter controlling the weight of longer paths. To get \\(S_{Katz}(v, w)\\), the entry corresponding to nodes \\(v\\) and \\(w\\) is selected from the matrix \\(S_{Katz}\\).</p> Reference <p>While the Katz index was originally proposed by Leo Katz in 1953<sup>1</sup> as a measure of social influence of a node (centrality), it can also be used as a node similarity measure between two nodes.</p> <ol> <li> <p>Katz, L. A new status index derived from sociometric analysis. Psychometrika 18, 39-43 (1953). \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The input graph.</p> required <code>v</code> <code>str | int</code> <p>The first node given the node label (or index if no label is provided).</p> required <code>w</code> <code>str | int</code> <p>The second node given the node label (or index if no label is provided).</p> required <code>beta</code> <code>float</code> <p>Parameter controlling the weight of longer paths.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The Katz index between nodes <code>v</code> and <code>w</code>.</p> Source code in <code>src/pathpyG/statistics/node_similarities.py</code> <pre><code>def katz_index(graph: Graph, v: str | int, w: str | int, beta: float) -&gt; float:\n    r\"\"\"Compute the Katz index between two nodes.\n\n    The Katz index for all pairs of nodes $V^2$ is defined as\n\n    $$\n    S_{Katz} = \\sum_{l=1}^{\\infty} \\beta^l A^l = (I - \\beta A)^{-1} - I\n    $$\n\n    where $A$ is the adjacency matrix of the graph, $I$ is the identity matrix, and $\\beta$ is a parameter controlling the weight of longer paths.\n    To get $S_{Katz}(v, w)$, the entry corresponding to nodes $v$ and $w$ is selected from the matrix $S_{Katz}$.\n\n    ??? reference\n        While the Katz index was originally proposed by Leo Katz in 1953[^1] as a measure of social influence of a node (centrality),\n        it can also be used as a node similarity measure between two nodes.\n\n    [^1]: *Katz, L. A new status index derived from sociometric analysis. Psychometrika 18, 39-43 (1953).*\n\n    Args:\n        graph: The input graph.\n        v: The first node given the node label (or index if no label is provided).\n        w: The second node given the node label (or index if no label is provided).\n        beta: Parameter controlling the weight of longer paths.\n\n    Returns:\n        The Katz index between nodes `v` and `w`.\n    \"\"\"\n    A = graph.sparse_adj_matrix()\n    I = _sp.sparse.identity(graph.n)  # noqa: E741\n    S = _sp.sparse.linalg.inv(I - beta * A) - I\n    return S[graph.mapping.to_idx(v), graph.mapping.to_idx(w)]\n</code></pre>"},{"location":"reference/pathpyG/statistics/node_similarities/#pathpyG.statistics.node_similarities.overlap_coefficient","title":"<code>overlap_coefficient</code>","text":"<p>Compute the overlap coefficient between two nodes.</p> <p>The overlap coefficient between two nodes \\(v, w \\in V\\) is defined as</p> \\[ S_{OC}(v, w) = \\frac{|\\mathcal{N}(v) \\cap \\mathcal{N}(w)|}{\\min(|\\mathcal{N}(v)|, |\\mathcal{N}(w)|)} \\] <p>where \\(\\mathcal{N}(v)\\) and \\(\\mathcal{N}(w)\\) are the sets of neighbors of nodes \\(v\\) and \\(w\\), respectively.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>The input graph.</p> required <code>v</code> <code>str | int</code> <p>The first node given the node label (or index if no label is provided).</p> required <code>w</code> <code>str | int</code> <p>The second node given the node label (or index if no label is provided).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The overlap coefficient between nodes <code>v</code> and <code>w</code>.</p> Source code in <code>src/pathpyG/statistics/node_similarities.py</code> <pre><code>def overlap_coefficient(graph: Graph, v: str | int, w: str | int) -&gt; float:\n    r\"\"\"Compute the overlap coefficient between two nodes.\n\n    The overlap coefficient between two nodes $v, w \\in V$ is defined as\n\n    $$\n    S_{OC}(v, w) = \\frac{|\\mathcal{N}(v) \\cap \\mathcal{N}(w)|}{\\min(|\\mathcal{N}(v)|, |\\mathcal{N}(w)|)}\n    $$\n\n    where $\\mathcal{N}(v)$ and $\\mathcal{N}(w)$ are the sets of neighbors of nodes $v$ and $w$, respectively.\n\n    Args:\n        graph: The input graph.\n        v: The first node given the node label (or index if no label is provided).\n        w: The second node given the node label (or index if no label is provided).\n\n    Returns:\n        The overlap coefficient between nodes `v` and `w`.\n    \"\"\"\n    N_v = set([x for x in graph.successors(v)])\n    N_w = set([x for x in graph.successors(w)])\n    return len(N_v.intersection(N_w)) / min(len(N_v), len(N_w))\n</code></pre>"},{"location":"reference/pathpyG/utils/","title":"utils","text":"<p>Utility functions for pathpyG.</p> <p>This module provides various utility functions that assist in config management, logging, conversion between data formats, and other common tasks needed in pathpyG.</p>"},{"location":"reference/pathpyG/utils/config/","title":"config","text":"<p>Config reader.</p>"},{"location":"reference/pathpyG/utils/convert/","title":"convert","text":"<p>Utility functions for converting between different data types.</p>"},{"location":"reference/pathpyG/utils/convert/#pathpyG.utils.convert.to_numpy","title":"<code>to_numpy</code>","text":"<p>Convert an iterable (including a tensor or tensor subclasses like <code>torch_geometric.EdgeIndex</code>) to numpy.</p> <p>Parameters:</p> Name Type Description Default <code>input_iterable</code> <code>torch.Tensor | numpy.ndarray | list | tuple</code> <p>Tensor, tensor subclass, numpy array or list.</p> required <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Numpy array.</p> Source code in <code>src/pathpyG/utils/convert.py</code> <pre><code>def to_numpy(input_iterable: torch.Tensor | np.ndarray | list | tuple) -&gt; np.ndarray:\n    \"\"\"Convert an iterable (including a tensor or tensor subclasses like [`torch_geometric.EdgeIndex`][torch_geometric.EdgeIndex]) to numpy.\n\n    Args:\n        input_iterable: [Tensor][torch.Tensor], tensor subclass, [numpy array][numpy.ndarray] or list.\n\n    Returns:\n        Numpy array.\n    \"\"\"\n    if isinstance(input_iterable, (EdgeIndex, Index)):\n        return input_iterable.as_tensor().cpu().numpy()\n    elif isinstance(input_iterable, torch.Tensor):\n        return input_iterable.cpu().numpy()\n    elif isinstance(input_iterable, (list, tuple)):\n        return np.array(input_iterable)\n    elif isinstance(input_iterable, np.ndarray):\n        return input_iterable\n</code></pre>"},{"location":"reference/pathpyG/utils/dbgnn/","title":"dbgnn","text":"<p>Utils for DBGNN models.</p>"},{"location":"reference/pathpyG/utils/dbgnn/#pathpyG.utils.dbgnn.generate_bipartite_edge_index","title":"<code>generate_bipartite_edge_index</code>","text":"<p>Generate edge_index for bipartite graph connecting nodes of a second-order graph to first-order nodes.</p> <p>The mapping strategy determines to which first-order nodes the second-order nodes are connected: - \"last\": Connects each second-order node to the last node in its sequence. - \"first\": Connects each second-order node to the first node in its sequence. - \"both\": Connects each second-order node to both the first and last nodes in its sequence.</p> <p>Only for Second-Order Graphs</p> <p>This function is intended to be used with second-order graphs only.  It does not support the use of higher-order graphs, such as third-order graphs or beyond.</p> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>pathpyG.core.graph.Graph</code> <p>The first-order graph.</p> required <code>g2</code> <code>pathpyG.core.graph.Graph</code> <p>The second-order graph.</p> required <code>mapping</code> <code>str</code> <p>The mapping strategy to use. Options are \"last\", \"first\", or \"both\". Defaults to \"last\".</p> <code>'last'</code> <code>device</code> <code>torch.device</code> <p>The device to place the tensor on. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>torch.Tensor</code> <p>torch.Tensor: The edge_index tensor for the bipartite graph.</p> Source code in <code>src/pathpyG/utils/dbgnn.py</code> <pre><code>def generate_bipartite_edge_index(\n    g: Graph, g2: Graph, mapping: str = \"last\", device: Optional[torch.device] = None\n) -&gt; torch.Tensor:\n    \"\"\"Generate edge_index for bipartite graph connecting nodes of a second-order graph to first-order nodes.\n\n    The mapping strategy determines to which first-order nodes the second-order nodes are connected:\n    - \"last\": Connects each second-order node to the last node in its sequence.\n    - \"first\": Connects each second-order node to the first node in its sequence.\n    - \"both\": Connects each second-order node to both the first and last nodes in its sequence.\n\n    !!! warning \"Only for Second-Order Graphs\"\n        This function is intended to be used with second-order graphs only. \n        It does not support the use of higher-order graphs, such as third-order graphs or beyond.\n\n    Args:\n        g (Graph): The first-order graph.\n        g2 (Graph): The second-order graph.\n        mapping (str, optional): The mapping strategy to use. Options are \"last\", \"first\", or \"both\". Defaults to \"last\".\n        device (torch.device, optional): The device to place the tensor on. Defaults to None.\n\n    Returns:\n        torch.Tensor: The edge_index tensor for the bipartite graph.\n    \"\"\"\n    if mapping == \"last\":\n        bipartide_edge_index = torch.tensor([list(range(g2.n)), [v[1] for v in g2.data.node_sequence]], device=device)\n    elif mapping == \"first\":\n        bipartide_edge_index = torch.tensor([list(range(g2.n)), [v[0] for v in g2.data.node_sequence]], device=device)\n    else:\n        bipartide_edge_index = torch.tensor(\n            [\n                list(range(g2.n)) + list(range(g2.n)),\n                [v[0] for v in g2.data.node_sequence] + [v[1] for v in g2.data.node_sequence],\n            ],\n            device=device,\n        )\n\n    return bipartide_edge_index\n</code></pre>"},{"location":"reference/pathpyG/utils/logger/","title":"logger","text":"<p>Logging utility module for pathpyG.</p>"},{"location":"reference/pathpyG/utils/progress/","title":"progress","text":"<p>Progressbar for pathpy.</p>"},{"location":"reference/pathpyG/utils/progress/#pathpyG.utils.progress.tqdm_console","title":"<code>tqdm_console</code>","text":"<p>Progressbar for a console environment.</p> Source code in <code>src/pathpyG/utils/progress.py</code> <pre><code>def tqdm_console(*args, **kwargs):\n    \"\"\"Progressbar for a console environment.\"\"\"\n    if len(args[0]) &gt; config[\"progress\"][\"min_iter\"]:\n        return tq(*args, **kwargs)\n    else:\n        return args[0]\n</code></pre>"},{"location":"reference/pathpyG/utils/progress/#pathpyG.utils.progress.tqdm_disabled","title":"<code>tqdm_disabled</code>","text":"<p>Disable the progress bar and return initial iterator.</p> Source code in <code>src/pathpyG/utils/progress.py</code> <pre><code>def tqdm_disabled(it, *args, **kwargs):\n    \"\"\"Disable the progress bar and return initial iterator.\"\"\"\n    return it\n</code></pre>"},{"location":"reference/pathpyG/utils/progress/#pathpyG.utils.progress.tqdm_notebook","title":"<code>tqdm_notebook</code>","text":"<p>Progressbar for a notebook environment.</p> Source code in <code>src/pathpyG/utils/progress.py</code> <pre><code>def tqdm_notebook(*args, **kwargs):\n    \"\"\"Progressbar for a notebook environment.\"\"\"\n    if len(args[0]) &gt; config[\"progress\"][\"min_iter\"]:\n        return tqn(*args, **kwargs)\n    else:\n        return args[0]\n</code></pre>"},{"location":"reference/pathpyG/visualisations/","title":"PathpyG Visualisations","text":"<p>This page provides an overview of the available visualisations and the supported backends. It also describes which displaying and saving options are available as well as the supported keyword arguments for customized plot styling.</p>"},{"location":"reference/pathpyG/visualisations/#overview","title":"Overview","text":"<p>The main plotting function is <code>pathpyG.plot()</code>, which can be used to create visualisations of both static and temporal networks. The function supports multiple backends, each with its own capabilities and output formats. The backend will be automatically chosen depending on the input data and the specified options.</p> <p>The default backend is <code>d3.js</code>, which is suitable for both static and temporal networks and produces interactive visualisations that can be viewed in a web browser.</p> <p>Interactive Temporal Graph Visualisation with d3.js</p> <p><pre><code>import pathpyG as pp\n\n# Example temporal network data\ntedges = [\n    (\"a\", \"b\", 1),\n    (\"a\", \"b\", 2),\n    (\"b\", \"a\", 3),\n    (\"b\", \"c\", 3),\n    (\"d\", \"c\", 4),\n    (\"a\", \"b\", 4),\n    (\"c\", \"b\", 4),\n    (\"c\", \"d\", 5),\n    (\"b\", \"a\", 5),\n    (\"c\", \"b\", 6),\n]\nt = pp.TemporalGraph.from_edge_list(tedges)\n\n# Create temporal plot and display inline\npp.plot(t)\n</code></pre> </p> Interactive Static Graph Visualisation with d3.js <p><pre><code>import pathpyG as pp\n\n# Example network data\nedges = [\n    (\"a\", \"b\"),\n    (\"a\", \"c\"),\n    (\"b\", \"c\"),\n    (\"c\", \"d\"),\n    (\"d\", \"e\"),\n    (\"e\", \"a\"),\n]\ng = pp.Graph.from_edge_list(edges)\npp.plot(g)\n</code></pre> </p>"},{"location":"reference/pathpyG/visualisations/#backends","title":"Backends","text":"<p>We currently support a total of four plotting backends, each with different capabilities making them suitable for different use cases. The table below provides an overview of the supported backends and their available file formats:</p> Backend Static Networks Temporal Networks Time-Unfolded Networks Available File Formats d3.js \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f <code>html</code> manim \u274c \u2714\ufe0f \u274c <code>mp4</code>, <code>gif</code> matplotlib \u2714\ufe0f \u274c \u2714\ufe0f <code>png</code>, <code>jpg</code> tikz \u2714\ufe0f \u274c \u2714\ufe0f <code>svg</code>, <code>pdf</code>, <code>tex</code>"},{"location":"reference/pathpyG/visualisations/#details","title":"Details","text":"<ul> <li>d3.js: The default backend, suitable for both static and temporal networks. It produces interactive visualisations that can be viewed in a web browser.</li> <li>matplotlib: A widely used plotting library in Python. It is suitable for static networks and produces raster graphics files.</li> <li>manim: A backend specifically designed for creating animations of temporal graphs, producing high-quality video files.</li> <li>tikz: A backend for creating publication-quality vector graphics with LaTeX-compatible output or directly compiled output as PDF or SVG.</li> </ul> <p>Note</p> <p>The <code>manim</code> and the <code>tikz</code> backends require additional dependencies to be installed. Please refer to the respective sections in the Installation Guide for more information.</p>"},{"location":"reference/pathpyG/visualisations/#saving-a-plot","title":"Saving a Plot","text":"<p>You can save plots to files by specifying the <code>filename</code> argument in the <code>pp.plot()</code> function call. The file format will be automatically determined based on the file extension. If no filename is provided, the plot will be displayed inline (in a Jupyter notebook or similar environment).</p>"},{"location":"reference/pathpyG/visualisations/#customisation","title":"Customisation","text":"<p>For more advanced visualisations, <code>PathpyG</code> offers customisation options for node and edge properties (like <code>color</code>, <code>size</code>, and <code>opacity</code>), as well as support for additional backends, including <code>manim</code>, <code>matplotlib</code>, and <code>tikz</code>. We provide some usage examples below, and a detailed overview of the supported keyword arguments for each backend in section Customisation Options.</p>"},{"location":"reference/pathpyG/visualisations/#visualising-undirected-networks","title":"Visualising Undirected Networks","text":"<p>We provide support for directed and undirected static networks. Directed networks are visualised with arrows, while undirected networks use simple lines in all backends. We provide an example using <code>matplotlib</code> below.</p> <p>Undirected Static Graph Visualisation with <code>matplotlib</code></p> <p>You will see below that compared to the examples above, the nodes do not have arrows indicating directionality. <pre><code>import torch\nimport pathpyG as pp\n\n# Example undirected network data\nedge_index = torch.tensor([[0, 1, 3, 3], [1, 2, 1, 0]])\ng = pp.Graph.from_edge_index(edge_index).to_undirected()\n\n# Create static plot and display inline\npp.plot(g, backend=\"matplotlib\")\n</code></pre> </p> <p>Node Labels</p> <p>In the above picture, the nodes do not have labels. This is because labels are automatically generated based on the node IDs provided in <code>g.mapping.node_ids</code>. When we created the graph using the <code>from_edge_index()</code> method, we did not provide any specific node IDs, so no IDs were assigned and no labels were generated. You can override the default behaviour by specifying <code>show_labels=True</code> in the <code>pp.plot()</code> function call.</p>"},{"location":"reference/pathpyG/visualisations/#node-and-edge-customisation","title":"Node and Edge Customisation","text":"<p>You can customise the appearance of nodes and edges in both static and temporal networks. We describe the different options below.</p>"},{"location":"reference/pathpyG/visualisations/#static-networks","title":"Static Networks","text":"<p>In all backends, you can customise the <code>size</code>, <code>color</code>, and <code>opacity</code> of nodes and edges.  You can specify these properties either as attributes of the <code>PyG</code> graph object <code>PathpyG.Graph.data</code> (as <code>torch.Tensor</code> or <code>numpy.ndarray</code> with one value per node/edge) or as arguments in the <code>pp.plot()</code> function call in three different ways: (1)</p> <ul> <li>A single value (applied uniformly to all nodes/edges)</li> <li>A list of values with length equal to the number of nodes/edges (values are applied in order)</li> <li>A dictionary mapping node/edge IDs to values (values are applied based on the IDs)</li> </ul> <p>For <code>color</code>, you can use color names (e.g., <code>\"blue\"</code>), HEX codes (e.g., <code>\"#ff0000\"</code>), or RGB tuples (e.g., <code>(255, 0, 0)</code>). You can also pass numeric values, which will be mapped to colors using a <code>matplotlib</code> colormap (specified via <code>cmap</code>).</p> <ol> <li>If both the graph attribute and the function argument are provided, the function argument takes precedence.</li> </ol> <p>Custom Node and Edge Properties</p> <p>In the example below, we set custom properties for nodes and edges using all three methods. <pre><code>import torch\nimport pathpyG as pp\n\n# Example network data\nedges = [\n    (\"a\", \"b\"),\n    (\"a\", \"c\"),\n    (\"b\", \"d\"),\n    (\"c\", \"d\"),\n    (\"d\", \"a\"),\n]\ng = pp.Graph.from_edge_list(edges)\n\n# Add properties as attributes to the graph\ng.data[\"node_size\"] = torch.tensor([10, 15, 20, 15])\ng.data[\"edge_color\"] = torch.tensor([0, 1, 2, 1, 0])\ng.data[\"node_opacity\"] = torch.zeros(g.n)\n\n# Create static plot with custom settings and display inline\npp.plot(\n    g,\n    backend=\"tikz\",\n    node_color={\"a\": \"red\", \"b\": \"#00FF00\"},\n    edge_opacity={(\"a\", \"b\"): 0.1, (\"a\", \"c\"): 0.5, (\"b\", \"d\"): 1.0},\n    node_opacity=1.0,  # override graph attribute\n    edge_size=torch.tensor([1, 2, 3, 2, 1]),\n)\n</code></pre> </p> Display Images inside your Nodes <p><code>d3.js</code> additionally supports images as node representations. You can specify the image source using the <code>node_image</code> argument. The image source can be a URL or a local file path. <pre><code>import torch\nimport pathpyG as pp\n\n# Example network data\nedges = [\n    (\"b\", \"a\"),\n    (\"c\", \"a\"),\n]\nmapping = pp.IndexMap([\"a\", \"b\", \"c\", \"d\"])\ng = pp.Graph.from_edge_list(edges, mapping=mapping)\ng.data[\"node_size\"] = torch.tensor([25]*4)\npp.plot(\n    g,\n    node_size={\"d\": 50},\n    edge_size=5,\n    node_image={\n        \"a\": \"https://avatars.githubusercontent.com/u/52822508?s=48&amp;v=4\",\n        \"b\": \"https://raw.githubusercontent.com/pyg-team/pyg_sphinx_theme/master/pyg_sphinx_theme/static/img/pyg_logo.png\",\n        \"c\": \"https://pytorch-geometric.readthedocs.io/en/latest/_static/img/pytorch_logo.svg\",\n        \"d\": \"docs/img/pathpy_logo_new.png\",\n    },\n    show_labels=False,\n)\n</code></pre> </p>"},{"location":"reference/pathpyG/visualisations/#temporal-networks","title":"Temporal Networks","text":"<p>For temporal networks, you can also customise the <code>size</code>, <code>color</code>, and <code>opacity</code> of nodes and edges at each timestep. In our understanding, a temporal network has a fixed set of nodes, but edges appear at different timesteps. Thus, all nodes exist at all times, but edges may only exist at certain timesteps. Therefore, edge properties can be specified for each timestep where the edge exists. In contrast, node properties can change at specified points in time, but will remain the same for all subsequent timesteps until they are changed again.</p> <p>The customisation options work similarly to static networks, with the exception that passing a dictionary for node/edge properties requires adding the timestep to the key:</p> <p>Custom Node and Edge Properties in Temporal Networks</p> <p>In the example below, we set the starting <code>node_color</code> and <code>node_size</code> for all nodes using graph attributes. We further customise the <code>edge_color</code> for each edge at each timestep using a graph attribute. Next, we override the <code>node_color</code> for node <code>\"b\"</code> at timestep <code>2</code> and for node <code>\"a\"</code> from the start using function arguments. Finally, we use a dictionary with a tuple consisting of the source node, target node, and timestep to set the <code>edge_size</code> for two specific edges at specific timesteps.</p> <p><pre><code>import torch\nimport numpy as np\nimport pathpyG as pp\n\n# Example temporal network data\ntedges = [\n    (\"a\", \"b\", 1),\n    (\"a\", \"b\", 2),\n    (\"b\", \"a\", 3),\n    (\"b\", \"c\", 3),\n]\nt = pp.TemporalGraph.from_edge_list(tedges)\nt.data[\"node_size\"] = torch.tensor([15, 8, 19])\nt.data[\"node_color\"] = np.array([\"blue\", \"green\", \"orange\"])\nt.data[\"edge_color\"] = torch.tensor([0, 1, 2, 1])\n\n# Create temporal plot and display inline\npp.plot(\n    t,\n    backend=\"manim\",\n    node_opacity=0.5,\n    edge_size={(\"a\", \"b\", 1): 10, (\"a\", \"b\", 2): 1},\n    node_color={(\"b\", 2): \"red\", \"a\": \"purple\"}, # node_color for node 'a' is set to 'purple' from the start\n)\n</code></pre> </p>"},{"location":"reference/pathpyG/visualisations/#layouts","title":"Layouts","text":"<p>By default, <code>PathpyG</code> uses the Fruchterman-Reingold force-directed algorithm to compute node positions for static networks. For temporal networks, the layout is computed dynamically at each timestep using the <code>d3.js</code> backend, while the <code>manim</code> backend uses a Fruchterman-Reingold layout computed on the aggregated static network by default.</p>"},{"location":"reference/pathpyG/visualisations/#static-networks_1","title":"Static Networks","text":"<p>You can change the layout algorithm for static networks using the <code>layout</code> argument in the <code>pp.plot()</code> function call.</p> <p>networkx layouts:</p> <p>We currently support most layouts via the <code>networkx</code> library. See the examples below for usage.</p> RandomCircularShellSpectralKamada-KawaiFruchterman-ReingoldForceAtlas2 <p>Use <code>\"random\"</code>, <code>\"rand\"</code> or <code>None</code> to specify a random layout. <pre><code>import pathpyG as pp\nfrom torch_geometric import seed_everything\nseed_everything(42)\n\ng = pp.algorithms.generative_models.watts_strogatz(30, 2, 0.25)\npp.plot(g, backend=\"tikz\", layout=\"random\")\n</code></pre> </p> <p>Use <code>\"circular\"</code>, <code>\"circle\"</code>, <code>\"ring\"</code>, <code>\"1d-lattice\"</code>, or <code>\"lattice-1d\"</code> to specify a circular layout. <pre><code>import pathpyG as pp\nfrom torch_geometric import seed_everything\nseed_everything(42)\n\ng = pp.algorithms.generative_models.watts_strogatz(30, 2, 0.25)\npp.plot(g, backend=\"tikz\", layout=\"circular\")\n</code></pre> </p> <p>Use <code>\"shell\"</code>, <code>\"concentric\"</code>, <code>\"concentric-circles\"</code>, or <code>\"shell layout\"</code> to specify a shell layout. <pre><code>import pathpyG as pp\nfrom torch_geometric import seed_everything\nseed_everything(42)\n\ng = pp.algorithms.generative_models.watts_strogatz(30, 2, 0.25)\npp.plot(g, backend=\"tikz\", layout=\"shell\")\n</code></pre> </p> <p>Use <code>\"spectral\"</code>, <code>\"eigen\"</code>, or <code>\"spectral layout\"</code> to specify a spectral layout. <pre><code>import pathpyG as pp\nfrom torch_geometric import seed_everything\nseed_everything(42)\n\ng = pp.algorithms.generative_models.watts_strogatz(30, 2, 0.25)\npp.plot(g, backend=\"tikz\", layout=\"spectral\")\n</code></pre> </p> <p>Use <code>\"kamada-kawai\"</code>, <code>\"kamada_kawai\"</code>, <code>\"kk\"</code>, <code>\"kamada\"</code>, or <code>\"kamada layout\"</code> to specify a Kamada-Kawai layout. <pre><code>import pathpyG as pp\nfrom torch_geometric import seed_everything\nseed_everything(42)\n\ng = pp.algorithms.generative_models.watts_strogatz(30, 2, 0.25)\npp.plot(g, backend=\"tikz\", layout=\"kamada-kawai\")\n</code></pre> </p> <p>Use <code>\"fruchterman-reingold\"</code>, <code>\"fruchterman_reingold\"</code>, <code>\"fr\"</code>, <code>\"spring_layout\"</code>, <code>\"spring layout\"</code>, or <code>\"spring\"</code> to specify a Fruchterman-Reingold layout. <pre><code>import pathpyG as pp\nfrom torch_geometric import seed_everything\nseed_everything(42)\n\ng = pp.algorithms.generative_models.watts_strogatz(30, 2, 0.25)\npp.plot(g, backend=\"tikz\", layout=\"fruchterman-reingold\")\n</code></pre> </p> <p>Use <code>\"forceatlas2\"</code>, <code>\"fa2\"</code>, <code>\"forceatlas\"</code>, <code>\"force-atlas\"</code>, <code>\"force-atlas2\"</code>, or <code>\"fa 2\"</code> to specify a ForceAtlas2 layout. <pre><code>import pathpyG as pp\nfrom torch_geometric import seed_everything\nseed_everything(42)\n\ng = pp.algorithms.generative_models.watts_strogatz(30, 2, 0.25)\npp.plot(g, backend=\"tikz\", layout=\"forceatlas2\")\n</code></pre> </p> <p>Other layouts: In addition to the <code>networkx</code> layouts, we also support:</p> <ul> <li> <p>Grid layout</p> Example <p><pre><code>import pathpyG as pp\nfrom torch_geometric import seed_everything\nseed_everything(42)\n\ng = pp.algorithms.generative_models.watts_strogatz(30, 2, 0.25)\npp.plot(g, backend=\"tikz\", layout=\"grid\", filename=\"tikz_grid_layout.svg\")\n</code></pre> </p> </li> <li> <p>Custom layout (by providing a dictionary mapping node IDs to positions)</p> Example <p><pre><code>import pathpyG as pp\n\ng = pp.Graph.from_edge_list([(\"a\", \"b\"), (\"a\", \"c\"), (\"b\", \"d\"), (\"c\", \"d\"), (\"d\", \"a\")])\n# Provide custom x and y coordinates for a layout\nlayout = {\n    \"a\": (0, 0),\n    \"b\": (1, 0),\n    \"c\": (0, 1),\n    \"d\": (1, 1)\n}\npp.plot(g, backend=\"tikz\", layout=layout, filename=\"tikz_layout.svg\")\n</code></pre> </p> </li> </ul>"},{"location":"reference/pathpyG/visualisations/#temporal-networks_1","title":"Temporal Networks","text":"<p>We apply a sliding window approach to compute layouts for temporal networks. At each timestep, we consider a window of past and future timesteps (controlled via the <code>layout_window_size</code> argument) and aggregate all edges inside this window to a static graph to compute the layout. You can either pass a fixed integer value, which will then be split equally into past and future timesteps, or a tuple specifying the number of past and future timesteps separately. The layout algorithm can be any of the supported static layout algorithms described above.</p> <p>Custom Layout for Temporal Networks</p> <p>In the example below, we use a sliding window of <code>2</code>, meaning that we aggregate the current and one previous timestep to compute the layout at each timestep. <pre><code>import pathpyG as pp\n\n# Example temporal network data\ntedges = [\n    (\"a\", \"b\", 1),\n    (\"a\", \"b\", 2),\n    (\"b\", \"a\", 3),\n    (\"b\", \"c\", 3),\n    (\"d\", \"c\", 4),\n    (\"a\", \"b\", 4),\n    (\"c\", \"b\", 4),\n    (\"c\", \"d\", 5),\n    (\"b\", \"a\", 5),\n    (\"c\", \"b\", 6),\n]\nt = pp.TemporalGraph.from_edge_list(tedges)\n\n# Create temporal plot and display inline\npp.plot(t, backend=\"manim\", layout_window_size=2, layout=\"fa2\")\n</code></pre> </p>"},{"location":"reference/pathpyG/visualisations/#time-unfolded-networks","title":"Time-Unfolded Networks","text":"<p>For temporal networks, you can use the time-unfolded visualisation to show a static representation of the temporal network. In this representation, each node is duplicated for each timestep, and edges are drawn between nodes at different timesteps to represent temporal interactions. You can enable this visualisation by setting the \"kind\" argument to <code>\"unfolded\"</code> in the <code>pp.plot()</code> function call. This visualisation is supported by all backends that support static networks, i.e. D3.js, Matplotlib, and TikZ.</p> <p>Time-Unfolded Visualisation of Temporal Networks</p> <p>In the example below, we create a time-unfolded visualisation of a temporal network using the <code>tikz</code> backend. <pre><code>import pathpyG as pp\n\n# Example temporal network data\ntedges = [\n    (\"a\", \"b\", 1),\n    (\"a\", \"b\", 2),\n    (\"b\", \"a\", 3),\n    (\"b\", \"c\", 3),\n    (\"d\", \"c\", 4),\n    (\"a\", \"b\", 4),\n    (\"c\", \"b\", 4),\n    (\"c\", \"d\", 5),\n    (\"b\", \"a\", 5),\n    (\"c\", \"b\", 6),\n]\nt = pp.TemporalGraph.from_edge_list(tedges)\n\n# Create temporal plot and display inline\nnode_color = {\"a\": \"red\", (\"a\", 2): \"darkred\"}\nedge_color = {(\"a\", \"b\", 2): \"blue\"}\npp.plot(t, backend=\"tikz\", kind=\"unfolded\", node_size=12, node_color=node_color, edge_color=edge_color)\n</code></pre> </p> <p>Customising Time-Unfolded Visualisations</p> <p>In the time-unfolded visualisation, you can still customise node and edge properties as described in the Node and Edge Customisation section.</p>"},{"location":"reference/pathpyG/visualisations/#customisation-options","title":"Customisation Options","text":"<p>Below is full list of supported keyword arguments for each backend and their descriptions.</p> Argument d3.js manim matplotlib tikz Short Description General <code>default_backend</code> \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Backend to use when none is specified <code>cmap</code> \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Colormap (string that refers to matplotlib cmap) for scalar node/edge values <code>layout</code> \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Layout algorithm for static networks (see Layouts) <code>width</code> \u2714\ufe0f \u274c \u2714\ufe0f \u2714\ufe0f Width of the output <code>height</code> \u2714\ufe0f \u274c \u2714\ufe0f \u2714\ufe0f Height of the output <code>latex_class_options</code> \u274c \u274c \u274c \u2714\ufe0f LaTeX document class options (e.g., <code>\"border=2mm\"</code>) for <code>tikz</code> backend <code>margin</code> \u2714\ufe0f \u274c \u2714\ufe0f \u2714\ufe0f Margin around the plot area (in pixels for <code>d3.js</code>, in points for <code>matplotlib</code> and <code>tikz</code>) <code>curvature</code> \u2714\ufe0f \u274c \u274c \u2714\ufe0f Curvature of edges (0: straight, &gt;0: curved) <code>layout_window_size</code> \u2714\ufe0f \u2714\ufe0f \u274c \u274c Size of sliding window for temporal network layouts (int or tuple of int) <code>delta</code> \u2714\ufe0f \u2714\ufe0f \u274c \u274c Duration of timestep in milliseconds (ms) <code>separator</code> \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Separator for higher-order node labels <code>orientation</code> \u2714\ufe0f \u2714\ufe0f \u274c \u2714\ufe0f Orientation of the time-unfolded network plot (<code>\"up\"</code>, <code>\"down\"</code>, <code>\"left\"</code>, or <code>\"right\"</code>) Nodes <code>size</code> \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Radius of nodes (uniform or per-node) <code>color</code> \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Node fill color <code>opacity</code> \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Node fill opacity (0 transparent, 1 solid) <code>image_padding</code> \u2714\ufe0f \u274c \u274c \u274c Padding around node images (in pixels) Edges <code>size</code> \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Edge width (uniform or per-edge) <code>color</code> \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Edge line color <code>opacity</code> \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Edge line opacity (0 transparent, 1 solid) <p>Legend: \u2714\ufe0f Supported\u2003\u274c Not Supported </p> <p>You can find the default values for each argument in <code>pathpyG.toml</code> located in the <code>pathpyG</code> installation directory.</p> <p>Node and Edge Keyword Arguments</p> <p>The node and edge keyword arguments listed above represent the default options that are specified via the <code>pathpyG.toml</code> configuration file. You can change these defaults using keyword arguments in the <code>pp.plot()</code> function call as follows: <pre><code>import pathpyG as pp\n\n# Example network data\ng = pp.Graph.from_edge_list([(\"a\", \"b\"), (\"a\", \"c\")])\n\n# Create network plot and display inline\npp.plot(g, node={\"opacity\": 0.2}, filename=\"d3js_node_opacity.html\")\n</code></pre> </p> <p>However, if you want to change either <code>color</code>, <code>size</code>, or <code>opacity</code> for nodes or edges, the preferred way is to use the dedicated keyword arguments described in the previous sections.</p> <p>For more details and usage examples, see Manim Visualisation Tutorial,Visualisation Tutorial and Develop your own plot Functions</p>"},{"location":"reference/pathpyG/visualisations/layout/","title":"layout","text":"<p>Network layout algorithms for node positioning.</p> <p>Provides comprehensive layout computation for network visualization using various algorithms from NetworkX and custom implementations. Supports both weighted and  unweighted networks with flexible parameter configuration.</p> <p>Key Features</p> <ul> <li>NetworkX integration for proven algorithms</li> <li>Custom grid layout for regular structures  </li> <li>Weighted layout support for better positioning</li> <li>Automatic algorithm selection and validation</li> </ul> <p>Available Algorithms</p> <ul> <li>All layouts that are implemented in <code>networkx</code><ul> <li>Random layout</li> <li>Circular layout</li> <li>Shell layout</li> <li>Spectral layout</li> <li>Kamada-Kawai layout</li> <li>Fruchterman-Reingold force-directed algorithm</li> <li>ForceAtlas2 layout algorithm</li> </ul> </li> <li>Grid layout</li> </ul> <p>Examples:</p> <p>Compute a spring layout for a simple graph:</p> <pre><code>&gt;&gt;&gt; from pathpyG import Graph\n&gt;&gt;&gt; from pathpyG.visualisations import layout\n&gt;&gt;&gt; \n&gt;&gt;&gt; g = Graph.from_edge_list([('a', 'b'), ('b', 'c')])\n&gt;&gt;&gt; positions = layout(g, layout='spring', k=0.5)\n&gt;&gt;&gt; print(positions)\n{'a': array(...), 'b': array(...), 'c': array(...)}\n</code></pre>"},{"location":"reference/pathpyG/visualisations/layout/#pathpyG.visualisations.layout.Layout","title":"<code>Layout</code>","text":"<p>               Bases: <code>object</code></p> <p>Layout computation engine for network node positioning.</p> <p>Core class that handles algorithm selection, parameter management, and coordinate generation. Integrates with NetworkX for proven algorithms while providing custom implementations for specialized cases.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list</code> <p>List of unique node identifiers</p> required <code>edge_index</code> <code>typing.Optional[torch.Tensor]</code> <p>Tensor containing source/target indices for each edge</p> <code>None</code> <code>layout_type</code> <code>str</code> <p>Algorithm name for position computation</p> <code>'random'</code> <code>weight</code> <code>typing.Optional[torch.Tensor]</code> <p>Optional edge weights as tensor with shape [num_edges]</p> <code>None</code> <code>**kwargs</code> <p>Algorithm-specific parameters</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>nodes</code> <p>Node identifier list</p> <code>edge_index</code> <p>Edge connectivity tensor</p> <code>weight</code> <p>Edge weight tensor (optional)</p> <code>layout_type</code> <p>Selected algorithm name</p> <code>kwargs</code> <p>Algorithm parameters</p> Source code in <code>src/pathpyG/visualisations/layout.py</code> <pre><code>class Layout(object):\n    \"\"\"Layout computation engine for network node positioning.\n\n    Core class that handles algorithm selection, parameter management, and\n    coordinate generation. Integrates with NetworkX for proven algorithms\n    while providing custom implementations for specialized cases.\n\n    Args:\n        nodes: List of unique node identifiers\n        edge_index: Tensor containing source/target indices for each edge\n        layout_type: Algorithm name for position computation\n        weight: Optional edge weights as tensor with shape [num_edges]\n        **kwargs: Algorithm-specific parameters\n\n    Attributes:\n        nodes: Node identifier list\n        edge_index: Edge connectivity tensor\n        weight: Edge weight tensor (optional)\n        layout_type: Selected algorithm name\n        kwargs: Algorithm parameters\n    \"\"\"\n\n    def __init__(self, nodes: list, edge_index: Optional[Tensor] = None, layout_type: str = \"random\", weight: Optional[Tensor] = None, **kwargs):\n        \"\"\"Initialize layout computation with network data and parameters.\n\n        Args:\n            nodes: List of unique node identifiers\n            edge_index: Edge connectivity tensor (creates empty if None)\n            layout_type: Algorithm name for position computation\n            weight: Optional edge weights tensor\n            **kwargs: Algorithm-specific parameters\n        \"\"\"\n        # initialize variables\n        self.nodes = nodes\n        if edge_index is None:\n            self.edge_index = EdgeIndex(torch.empty((2, 0), dtype=torch.long))\n        else:\n            self.edge_index = edge_index\n        self.weight = weight\n        self.layout_type = layout_type.lower()\n        self.kwargs = kwargs\n\n    def generate_layout(self):\n        \"\"\"Select and execute appropriate layout algorithm.\n\n        Routes computation to either custom grid implementation or \n        NetworkX-based algorithms based on layout_type specification.\n\n        Returns:\n            dict: Node positions as {node_id: (x, y)} coordinate mapping\n        \"\"\"\n        # method names\n        names_grid = [\"grid\", \"2d-lattice\", \"lattice-2d\"]\n        # check which layout should be plotted\n        if self.layout_type in names_grid:\n            self.layout = self.grid()\n        else:\n            self.layout = self.generate_nx_layout()\n\n        return self.layout\n\n    def generate_nx_layout(self):\n        \"\"\"Compute layout using NetworkX algorithms with weight support.\n\n        Converts pathpyG network to NetworkX format, applies selected algorithm\n        with proper weight handling, and returns position dictionary.\n\n        Returns:\n            dict: Node positions from NetworkX layout algorithm\n\n        Raises:\n            ValueError: If layout algorithm name not recognized\n\n        !!! note \"Algorithm Mapping\"\n            Multiple aliases map to the same underlying NetworkX function\n            for user convenience and compatibility with different naming conventions.\n        \"\"\"\n        import networkx as nx\n\n        sp_matrix = to_scipy_sparse_matrix(self.edge_index.as_tensor(), edge_attr=self.weight, num_nodes=len(self.nodes))\n        nx_network = nx.from_scipy_sparse_array(sp_matrix)\n        nx_network = nx.relabel_nodes(nx_network, {i: node for i, node in enumerate(self.nodes)})\n\n        names_rand = [\"random\", \"rand\", None]\n        names_circular = [\"circular\", \"circle\", \"ring\", \"1d-lattice\", \"lattice-1d\"]\n        names_shell = [\"shell\", \"concentric\", \"concentric-circles\", \"shell layout\"]\n        names_spectral = [\"spectral\", \"eigen\", \"spectral layout\"]\n        names_kk = [\"kamada-kawai\", \"kamada_kawai\", \"kk\", \"kamada\", \"kamada layout\"]\n        names_fr = [\"fruchterman-reingold\", \"fruchterman_reingold\", \"fr\", \"spring_layout\", \"spring layout\", \"spring\"]\n        names_forceatlas2 = [\"forceatlas2\", \"fa2\", \"forceatlas\", \"force-atlas\", \"force-atlas2\", \"fa 2\"]\n\n        if self.layout_type in names_rand:\n            layout = nx.random_layout(nx_network, **self.kwargs)\n        elif self.layout_type in names_circular:\n            layout = nx.circular_layout(nx_network, **self.kwargs)\n        elif self.layout_type in names_shell:\n            layout = nx.shell_layout(nx_network, **self.kwargs)\n        elif self.layout_type in names_spectral:\n            layout = nx.spectral_layout(nx_network, **self.kwargs)\n        elif self.layout_type in names_kk:\n            layout = nx.kamada_kawai_layout(\n                nx_network, weight=\"weight\" if self.weight is not None else None, **self.kwargs\n            )\n        elif self.layout_type in names_fr:\n            layout = nx.spring_layout(nx_network, weight=\"weight\" if self.weight is not None else None, **self.kwargs)\n        elif self.layout_type in names_forceatlas2:\n            layout = nx.forceatlas2_layout(\n                nx_network, weight=\"weight\" if self.weight is not None else None, **self.kwargs\n            )\n        else:\n            raise ValueError(f\"Layout '{self.layout_type}' not recognized.\")\n\n        return layout\n\n    def grid(self):\n        \"\"\"Position nodes on regular 2D grid for lattice-like structures.\n\n        Arranges nodes in a square grid pattern with uniform spacing.\n        Useful for regular networks, lattices.\n\n        Returns:\n            dict: Grid positions as {node_id: (x, y)} coordinates\n        \"\"\"\n        n = len(self.nodes)\n        width = 1.0\n\n        # number of nodes in horizontal/vertical direction\n        k = np.floor(np.sqrt(n))\n        dist = width / k\n\n        x = (np.arange(0, n) % k) * dist\n        y = -(np.floor(np.arange(0, n) / k)) * dist\n        coords = np.vstack((x, y)).T\n\n        return {node: coords[i] for i, node in enumerate(self.nodes)}\n</code></pre>"},{"location":"reference/pathpyG/visualisations/layout/#pathpyG.visualisations.layout.Layout.__init__","title":"<code>__init__</code>","text":"<p>Initialize layout computation with network data and parameters.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list</code> <p>List of unique node identifiers</p> required <code>edge_index</code> <code>typing.Optional[torch.Tensor]</code> <p>Edge connectivity tensor (creates empty if None)</p> <code>None</code> <code>layout_type</code> <code>str</code> <p>Algorithm name for position computation</p> <code>'random'</code> <code>weight</code> <code>typing.Optional[torch.Tensor]</code> <p>Optional edge weights tensor</p> <code>None</code> <code>**kwargs</code> <p>Algorithm-specific parameters</p> <code>{}</code> Source code in <code>src/pathpyG/visualisations/layout.py</code> <pre><code>def __init__(self, nodes: list, edge_index: Optional[Tensor] = None, layout_type: str = \"random\", weight: Optional[Tensor] = None, **kwargs):\n    \"\"\"Initialize layout computation with network data and parameters.\n\n    Args:\n        nodes: List of unique node identifiers\n        edge_index: Edge connectivity tensor (creates empty if None)\n        layout_type: Algorithm name for position computation\n        weight: Optional edge weights tensor\n        **kwargs: Algorithm-specific parameters\n    \"\"\"\n    # initialize variables\n    self.nodes = nodes\n    if edge_index is None:\n        self.edge_index = EdgeIndex(torch.empty((2, 0), dtype=torch.long))\n    else:\n        self.edge_index = edge_index\n    self.weight = weight\n    self.layout_type = layout_type.lower()\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/pathpyG/visualisations/layout/#pathpyG.visualisations.layout.Layout.generate_layout","title":"<code>generate_layout</code>","text":"<p>Select and execute appropriate layout algorithm.</p> <p>Routes computation to either custom grid implementation or  NetworkX-based algorithms based on layout_type specification.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Node positions as {node_id: (x, y)} coordinate mapping</p> Source code in <code>src/pathpyG/visualisations/layout.py</code> <pre><code>def generate_layout(self):\n    \"\"\"Select and execute appropriate layout algorithm.\n\n    Routes computation to either custom grid implementation or \n    NetworkX-based algorithms based on layout_type specification.\n\n    Returns:\n        dict: Node positions as {node_id: (x, y)} coordinate mapping\n    \"\"\"\n    # method names\n    names_grid = [\"grid\", \"2d-lattice\", \"lattice-2d\"]\n    # check which layout should be plotted\n    if self.layout_type in names_grid:\n        self.layout = self.grid()\n    else:\n        self.layout = self.generate_nx_layout()\n\n    return self.layout\n</code></pre>"},{"location":"reference/pathpyG/visualisations/layout/#pathpyG.visualisations.layout.Layout.generate_nx_layout","title":"<code>generate_nx_layout</code>","text":"<p>Compute layout using NetworkX algorithms with weight support.</p> <p>Converts pathpyG network to NetworkX format, applies selected algorithm with proper weight handling, and returns position dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Node positions from NetworkX layout algorithm</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If layout algorithm name not recognized</p> <p>Algorithm Mapping</p> <p>Multiple aliases map to the same underlying NetworkX function for user convenience and compatibility with different naming conventions.</p> Source code in <code>src/pathpyG/visualisations/layout.py</code> <pre><code>def generate_nx_layout(self):\n    \"\"\"Compute layout using NetworkX algorithms with weight support.\n\n    Converts pathpyG network to NetworkX format, applies selected algorithm\n    with proper weight handling, and returns position dictionary.\n\n    Returns:\n        dict: Node positions from NetworkX layout algorithm\n\n    Raises:\n        ValueError: If layout algorithm name not recognized\n\n    !!! note \"Algorithm Mapping\"\n        Multiple aliases map to the same underlying NetworkX function\n        for user convenience and compatibility with different naming conventions.\n    \"\"\"\n    import networkx as nx\n\n    sp_matrix = to_scipy_sparse_matrix(self.edge_index.as_tensor(), edge_attr=self.weight, num_nodes=len(self.nodes))\n    nx_network = nx.from_scipy_sparse_array(sp_matrix)\n    nx_network = nx.relabel_nodes(nx_network, {i: node for i, node in enumerate(self.nodes)})\n\n    names_rand = [\"random\", \"rand\", None]\n    names_circular = [\"circular\", \"circle\", \"ring\", \"1d-lattice\", \"lattice-1d\"]\n    names_shell = [\"shell\", \"concentric\", \"concentric-circles\", \"shell layout\"]\n    names_spectral = [\"spectral\", \"eigen\", \"spectral layout\"]\n    names_kk = [\"kamada-kawai\", \"kamada_kawai\", \"kk\", \"kamada\", \"kamada layout\"]\n    names_fr = [\"fruchterman-reingold\", \"fruchterman_reingold\", \"fr\", \"spring_layout\", \"spring layout\", \"spring\"]\n    names_forceatlas2 = [\"forceatlas2\", \"fa2\", \"forceatlas\", \"force-atlas\", \"force-atlas2\", \"fa 2\"]\n\n    if self.layout_type in names_rand:\n        layout = nx.random_layout(nx_network, **self.kwargs)\n    elif self.layout_type in names_circular:\n        layout = nx.circular_layout(nx_network, **self.kwargs)\n    elif self.layout_type in names_shell:\n        layout = nx.shell_layout(nx_network, **self.kwargs)\n    elif self.layout_type in names_spectral:\n        layout = nx.spectral_layout(nx_network, **self.kwargs)\n    elif self.layout_type in names_kk:\n        layout = nx.kamada_kawai_layout(\n            nx_network, weight=\"weight\" if self.weight is not None else None, **self.kwargs\n        )\n    elif self.layout_type in names_fr:\n        layout = nx.spring_layout(nx_network, weight=\"weight\" if self.weight is not None else None, **self.kwargs)\n    elif self.layout_type in names_forceatlas2:\n        layout = nx.forceatlas2_layout(\n            nx_network, weight=\"weight\" if self.weight is not None else None, **self.kwargs\n        )\n    else:\n        raise ValueError(f\"Layout '{self.layout_type}' not recognized.\")\n\n    return layout\n</code></pre>"},{"location":"reference/pathpyG/visualisations/layout/#pathpyG.visualisations.layout.Layout.grid","title":"<code>grid</code>","text":"<p>Position nodes on regular 2D grid for lattice-like structures.</p> <p>Arranges nodes in a square grid pattern with uniform spacing. Useful for regular networks, lattices.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Grid positions as {node_id: (x, y)} coordinates</p> Source code in <code>src/pathpyG/visualisations/layout.py</code> <pre><code>def grid(self):\n    \"\"\"Position nodes on regular 2D grid for lattice-like structures.\n\n    Arranges nodes in a square grid pattern with uniform spacing.\n    Useful for regular networks, lattices.\n\n    Returns:\n        dict: Grid positions as {node_id: (x, y)} coordinates\n    \"\"\"\n    n = len(self.nodes)\n    width = 1.0\n\n    # number of nodes in horizontal/vertical direction\n    k = np.floor(np.sqrt(n))\n    dist = width / k\n\n    x = (np.arange(0, n) % k) * dist\n    y = -(np.floor(np.arange(0, n) / k)) * dist\n    coords = np.vstack((x, y)).T\n\n    return {node: coords[i] for i, node in enumerate(self.nodes)}\n</code></pre>"},{"location":"reference/pathpyG/visualisations/layout/#pathpyG.visualisations.layout.layout","title":"<code>layout</code>","text":"<p>Generate node positions using specified layout algorithm.</p> <p>Computes 2D coordinates for all nodes in the network using various layout algorithms. Supports edge weighting for physics-based layouts and provides flexible parameter passing to underlying algorithms.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>pathpyG.core.graph.Graph</code> <p>Graph instance to generate layout for</p> required <code>layout</code> <code>str</code> <p>Algorithm name (see supported algorithms below)</p> <code>'random'</code> <code>weight</code> <code>None | str | typing.Iterable</code> <p>Edge weights as attribute name, iterable, or None</p> <code>None</code> <code>**kwargs</code> <p>Algorithm-specific parameters passed to layout function</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Node positions as {node_id: (x, y)} coordinate mapping</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If weight attribute not found or weight length mismatch</p> <code>ValueError</code> <p>If layout algorithm not recognized</p> <p>Examples:</p> <pre><code># Basic spring layout\npos = layout(graph, 'spring')\n\n# Weighted layout with edge attribute\npos = layout(graph, 'kamada-kawai', weight='edge_weight')\n\n# Custom parameters\npos = layout(graph, 'spring', k=0.3, iterations=100)\n</code></pre> <p>Supported Algorithms</p> Algorithm Aliases Best For <code>spring</code> <code>fruchterman-reingold</code>, <code>fr</code> General networks <code>kamada-kawai</code> <code>kk</code>, <code>kamada</code> Small/medium networks <code>forceatlas2</code> <code>fa2</code>, <code>force-atlas2</code> Large networks <code>circular</code> <code>circle</code>, <code>ring</code> Cycle structures <code>shell</code> <code>concentric</code> Hierarchical data <code>grid</code> <code>lattice-2d</code> Regular structures <code>spectral</code> <code>eigen</code> Community detection <code>random</code> <code>rand</code> Testing/baseline Source code in <code>src/pathpyG/visualisations/layout.py</code> <pre><code>def layout(network: Graph, layout: str = \"random\", weight: None | str | Iterable = None, **kwargs):\n    \"\"\"Generate node positions using specified layout algorithm.\n\n    Computes 2D coordinates for all nodes in the network using various layout\n    algorithms. Supports edge weighting for physics-based layouts and provides\n    flexible parameter passing to underlying algorithms.\n\n    Args:\n        network: Graph instance to generate layout for\n        layout: Algorithm name (see supported algorithms below)\n        weight: Edge weights as attribute name, iterable, or None\n        **kwargs: Algorithm-specific parameters passed to layout function\n\n    Returns:\n        dict: Node positions as {node_id: (x, y)} coordinate mapping\n\n    Raises:\n        ValueError: If weight attribute not found or weight length mismatch\n        ValueError: If layout algorithm not recognized\n\n    Examples:\n        ```python\n        # Basic spring layout\n        pos = layout(graph, 'spring')\n\n        # Weighted layout with edge attribute\n        pos = layout(graph, 'kamada-kawai', weight='edge_weight')\n\n        # Custom parameters\n        pos = layout(graph, 'spring', k=0.3, iterations=100)\n        ```\n\n    !!! note \"Supported Algorithms\"\n\n        | Algorithm | Aliases | Best For |\n        |-----------|---------|----------|\n        | `spring` | `fruchterman-reingold`, `fr` | General networks |\n        | `kamada-kawai` | `kk`, `kamada` | Small/medium networks |\n        | `forceatlas2` | `fa2`, `force-atlas2` | Large networks |\n        | `circular` | `circle`, `ring` | Cycle structures |\n        | `shell` | `concentric` | Hierarchical data |\n        | `grid` | `lattice-2d` | Regular structures |\n        | `spectral` | `eigen` | Community detection |\n        | `random` | `rand` | Testing/baseline |\n    \"\"\"\n    # initialize variables\n    if isinstance(weight, str):\n        if weight in network.edge_attrs():\n            weight = network.data[weight]\n        else:\n            raise ValueError(f\"Weight attribute '{weight}' not found in edge attributes.\")\n    elif isinstance(weight, Iterable) and not isinstance(weight, torch.Tensor):\n        n_edges = network.m * 2 if network.is_undirected() else network.m\n        if len(weight) == n_edges:  # type: ignore[arg-type]\n            weight = torch.tensor(weight)\n        else:\n            raise ValueError(\"Length of weight iterable does not match number of edges in the network.\")\n\n    # create layout class\n    layout_cls = Layout(\n        nodes=network.nodes, edge_index=network.data.edge_index, layout_type=layout, weight=weight, **kwargs  # type: ignore[arg-type]\n    )\n    # return the layout\n    return layout_cls.generate_layout()\n</code></pre>"},{"location":"reference/pathpyG/visualisations/network_plot/","title":"network_plot","text":"<p>Static network visualization classes.</p> <p>Provides comprehensive plotting functionality for static (non-temporal) networks. Handles data preparation, attribute assignment, layout computation, and backend integration for Graph objects.</p> <p>Key Features</p> <ul> <li>Automatic attribute extraction from network data</li> <li>Flexible node/edge styling (colors, sizes, images)</li> <li>Layout algorithm integration</li> <li>Multi-backend compatibility</li> </ul> <p>Attribute Sources</p> <p>Attributes are resolved in order (highest priority to the leftmost): user arguments \u2192 network attributes \u2192 config defaults</p>"},{"location":"reference/pathpyG/visualisations/network_plot/#pathpyG.visualisations.network_plot.NetworkPlot","title":"<code>NetworkPlot</code>","text":"<p>               Bases: <code>pathpyG.visualisations.pathpy_plot.PathPyPlot</code></p> <p>Static network visualization with comprehensive styling options.</p> <p>Prepares Graph objects for visualization by extracting node/edge data, computing layouts, and processing visual attributes. Supports both  simple and higher-order networks with flexible attribute assignment.</p> <p>Attributes:</p> Name Type Description <code>network</code> <p>Graph instance being visualized</p> <code>node_args</code> <p>Node-specific styling arguments</p> <code>edge_args</code> <p>Edge-specific styling arguments</p> <code>attributes</code> <p>Standard visual attributes (color, size, opacity, image)</p> <p>Attribute Assignment</p> <p>Use <code>node_color</code>, <code>edge_size</code> etc. for convenient styling. Attributes support constants, lists, or node/edge mappings.</p> Source code in <code>src/pathpyG/visualisations/network_plot.py</code> <pre><code>class NetworkPlot(PathPyPlot):\n    \"\"\"Static network visualization with comprehensive styling options.\n\n    Prepares Graph objects for visualization by extracting node/edge data,\n    computing layouts, and processing visual attributes. Supports both \n    simple and higher-order networks with flexible attribute assignment.\n\n    Attributes:\n        network: Graph instance being visualized\n        node_args: Node-specific styling arguments\n        edge_args: Edge-specific styling arguments\n        attributes: Standard visual attributes (color, size, opacity, image)\n\n    !!! tip \"Attribute Assignment\"\n        Use `node_color`, `edge_size` etc. for convenient styling.\n        Attributes support constants, lists, or node/edge mappings.\n    \"\"\"\n\n    _kind = \"network\"\n\n    def __init__(self, network: Graph, **kwargs: Any) -&gt; None:\n        \"\"\"Initialize network plot with graph and styling options.\n\n        Processes node/edge arguments, updates configuration, and generates\n        plot data structures. Arguments prefixed with 'node_' or 'edge_'\n        are automatically assigned to respective components.\n\n        Args:\n            network: Graph instance to visualize\n            **kwargs: Styling options (node_color, edge_size, layout, etc.)\n        \"\"\"\n        super().__init__()\n        self.network = network if network.device == torch.device(\"cpu\") else deepcopy(network).to(torch.device(\"cpu\"))\n        self.node_args = {}\n        self.edge_args = {}\n        self.attributes = [\"color\", \"size\", \"opacity\", \"image\"]\n        # extract node and edge specific arguments from kwargs\n        for key in kwargs.keys():\n            if key.startswith(\"node_\"):\n                self.node_args[key[5:]] = kwargs.get(key)\n            elif key.startswith(\"edge_\"):\n                self.edge_args[key[5:]] = kwargs.get(key)\n        # remove node_ and edge_ arguments from kwargs and update config with remaining kwargs\n        for node_arg in self.node_args.keys():\n            kwargs.pop(f\"node_{node_arg}\")\n        for edge_arg in self.edge_args.keys():\n            kwargs.pop(f\"edge_{edge_arg}\")\n        if \"node\" in kwargs:\n            self.config[\"node\"].update(kwargs[\"node\"])\n            kwargs.pop(\"node\")\n        if \"edge\" in kwargs:\n            self.config[\"edge\"].update(kwargs[\"edge\"])\n            kwargs.pop(\"edge\")\n        self.config.update(kwargs)\n        # generate plot data\n        self.generate()\n\n    def generate(self) -&gt; None:\n        \"\"\"Generate complete plot data through processing pipeline.\n\n        Orchestrates data preparation: edges \u2192 nodes \u2192 layout \u2192 post-processing \u2192 config.\n        Creates final data structures ready for backend rendering.\n        \"\"\"\n        self._compute_edge_data()\n        self._compute_node_data()\n        self._compute_layout()\n        self._post_process_node_data()\n        self._compute_config()\n\n    def _compute_node_data(self) -&gt; None:\n        \"\"\"Build node DataFrame with visual attributes.\n\n        Creates indexed DataFrame for all nodes, handling higher-order networks\n        by converting tuple nodes to string representation. Assigns attributes\n        from config defaults, network data, and user arguments.\n        \"\"\"\n        # initialize values\n        nodes: pd.DataFrame = pd.DataFrame(index=self.network.nodes)\n        # if higher-order network, convert node tuples to string representation\n        if self.network.order &gt; 1:\n            nodes.index = nodes.index.map(lambda x: self.config[\"separator\"].join(map(str, x)))\n        for attribute in self.attributes:\n            # set default value for each attribute based on the pathpyG.toml config\n            if isinstance(self.config.get(\"node\").get(attribute, None), list | tuple):  # type: ignore[union-attr]\n                nodes[attribute] = [self.config.get(\"node\").get(attribute, None)] * len(nodes)  # type: ignore[union-attr]\n            else:\n                nodes[attribute] = self.config.get(\"node\").get(attribute, None)  # type: ignore[union-attr]\n            # check if attribute is given as node attribute\n            if f\"node_{attribute}\" in self.network.node_attrs():\n                nodes[attribute] = self.network.data[f\"node_{attribute}\"]\n            # check if attribute is given as argument\n            if attribute in self.node_args:\n                nodes = self._assign_argument(attribute, self.node_args[attribute], nodes)\n\n        # save node data\n        self.data[\"nodes\"] = nodes\n\n    def _post_process_node_data(self) -&gt; None:\n        \"\"\"Finalize node attributes for backend compatibility.\n\n        Converts colors to uniform hex format and loads local images\n        to base64 strings for embedding in output formats.\n        \"\"\"\n        # convert colors to uniform hex values\n        self.data[\"nodes\"][\"color\"] = self._convert_to_rgb_tuple(self.data[\"nodes\"][\"color\"])\n        self.data[\"nodes\"][\"color\"] = self.data[\"nodes\"][\"color\"].map(self._convert_color)\n\n        # load any local images to base64 strings\n        if self.data[\"nodes\"][\"image\"].notna().any():\n            self.data[\"nodes\"][\"image\"] = self.data[\"nodes\"][\"image\"].map(self._load_image)\n\n    def _compute_edge_data(self) -&gt; None:\n        \"\"\"Build edge DataFrame with visual attributes and deduplication.\n\n        Creates MultiIndex DataFrame for edges, handles higher-order networks,\n        assigns attributes, and removes duplicates for undirected graphs.\n        Special handling for edge weights as size defaults.\n\n        !!! warning \"No support for networks with multiedges\"\n            For efficiency, duplicate edges are removed.\n        \"\"\"\n        # initialize values\n        edges: pd.DataFrame = pd.DataFrame(index=pd.MultiIndex.from_tuples(self.network.edges, names=[\"source\", \"target\"]))\n        # if higher-order network, convert node tuples to string representation\n        if self.network.order &gt; 1:\n            edges.index = edges.index.map(lambda x: (self.config[\"separator\"].join(map(str, x[0])), self.config[\"separator\"].join(map(str, x[1]))))\n        for attribute in self.attributes:\n            # set default value for each attribute based on the pathpyG.toml config\n            if isinstance(self.config.get(\"edge\").get(attribute, None), list | tuple):  # type: ignore[union-attr]\n                edges[attribute] = [self.config.get(\"edge\").get(attribute, None)] * len(edges)  # type: ignore[union-attr]\n            else:\n                edges[attribute] = self.config.get(\"edge\").get(attribute, None)  # type: ignore[union-attr]\n            # check if attribute is given as edge attribute\n            if f\"edge_{attribute}\" in self.network.edge_attrs():\n                edges[attribute] = self.network.data[f\"edge_{attribute}\"]\n            # special case for size: If no edge_size is given use edge_weight if available\n            elif attribute == \"size\" and \"edge_weight\" in self.network.edge_attrs():\n                edges[attribute] = self.network.data[\"edge_weight\"]\n            # check if attribute is given as argument\n            if attribute in self.edge_args:\n                edges = self._assign_argument(attribute, self.edge_args[attribute], edges)\n            elif attribute == \"size\" and \"weight\" in self.edge_args:\n                edges = self._assign_argument(\"size\", self.edge_args[\"weight\"], edges)\n\n        # convert attributes to useful values\n        edges[\"color\"] = self._convert_to_rgb_tuple(edges[\"color\"])\n        edges[\"color\"] = edges[\"color\"].map(self._convert_color)\n\n        # remove duplicate edges for better efficiency\n        if not self.network.is_directed():\n            # for undirected networks, sort source and target and drop duplicates\n            edges = edges.reset_index()\n            edges[\"sorted\"] = edges.apply(lambda row: tuple(sorted((row[\"source\"], row[\"target\"]))), axis=1)\n            edges = edges.drop_duplicates(subset=[\"sorted\"]).drop(columns=[\"sorted\"])\n            edges = edges.set_index([\"source\", \"target\"])\n        else:\n            # for directed networks, remove duplicates based on index\n            edges = edges[~edges.index.duplicated(keep=\"first\")]\n\n        # save edge data\n        self.data[\"edges\"] = edges\n\n    def _assign_argument(self, attr_key: str, attr_value: Any, df: pd.DataFrame) -&gt; pd.DataFrame:\n        \"\"\"Assign user arguments to node/edge attributes flexibly.\n\n        Handles multiple value types: constants, lists/arrays, or dictionaries\n        mapping node/edge IDs to values. Special handling for RGB color tuples\n        and proper length validation for sequence types.\n\n        Args:\n            attr_key: Attribute name (color, size, opacity, image)\n            attr_value: Value to assign (constant, list, or dict mapping)\n            df: Target DataFrame (nodes or edges)\n\n        Returns:\n            Updated DataFrame with assigned attributes\n\n        Raises:\n            AttributeError: If list length doesn't match DataFrame size\n        \"\"\"\n        if isinstance(attr_value, dict):\n            # if dict does not contain values for all edges, only update those that are given\n            if attr_key == \"color\":\n                # convert color tuples to hex strings to avoid pandas sequence assignment\n                for key in attr_value.keys():\n                    value = attr_value[key]\n                    if isinstance(value, tuple) and len(value) == 3:\n                        attr_value[key] = rgb_to_hex(value)\n            new_attrs = df.index.map(attr_value)\n            # Check if all values are assigned\n            if (~new_attrs.isna()).sum() == df.shape[0]:\n                # If all values are assigned, directly set the column to make sure that dtype is correct\n                df[attr_key] = new_attrs\n            else:\n                # Otherwise, only update the values that are not NaN\n                df.loc[~new_attrs.isna(), attr_key] = new_attrs[~new_attrs.isna()]\n        elif isinstance(attr_value, Sized) and not isinstance(attr_value, str):\n            # check if attr_key=\"color\" and given values is an RGB tuple\n            if attr_key == \"color\":\n                if isinstance(attr_value, tuple) and len(attr_value) == 3:\n                    df[attr_key] = [attr_value] * len(df)\n                else:\n                    df[attr_key] = attr_value\n            elif len(attr_value) != len(df):\n                logger.error(f\"The provided list for {attr_key} has length {len(attr_value)}, but there are {len(df)} nodes/edges!\")\n                raise AttributeError\n            else:\n                df[attr_key] = attr_value\n        else:\n            df[attr_key] = attr_value\n        return df\n\n    def _convert_to_rgb_tuple(self, colors: pd.Series) -&gt; dict:\n        \"\"\"Convert numeric color values to RGB tuples via colormap.\n\n        Maps numerical values to colors using matplotlib colormap when\n        colors are provided as numeric data (for value-based coloring).\n\n        Args:\n            colors: Series containing color values (numeric or already processed)\n\n        Returns:\n            Series with RGB tuple colors or original non-numeric colors\n        \"\"\"\n        # check if colors are given as numerical values\n        if pd.api.types.is_numeric_dtype(colors):\n            # load colormap to map numerical values to color\n            cmap_name = self.config.get(\"cmap\")\n            cmap = plt.get_cmap(cmap_name)\n            # normalize values to [0,1]\n            norm = plt.Normalize(vmin=colors.min(), vmax=colors.max())\n            # map values to colors\n            colors = colors.map(lambda x: cmap(norm(x)))\n        return colors\n\n    def _convert_color(self, color: tuple[int, int, int]) -&gt; str:\n        \"\"\"Normalize colors to hex format for backend consistency.\n\n        Converts RGB tuples, color names, or existing hex values to\n        standardized hex format. Handles matplotlib color names via\n        automatic RGB conversion.\n\n        Args:\n            color: Color as RGB tuple, hex string, or named color\n\n        Returns:\n            Hex color string (e.g., \"#ff0000\")\n\n        Raises:\n            AttributeError: If color format is invalid or unrecognized\n        \"\"\"\n        if isinstance(color, tuple):\n            return rgb_to_hex(color[:3])\n        elif isinstance(color, str):\n            if color.startswith(\"#\"):\n                return color\n            else:\n                # try to convert color name to hex\n                try:\n                    rgb = to_rgb(color)\n                    return rgb_to_hex(rgb)\n                except ValueError:\n                    logger.error(f\"The provided color {color} is not valid!\")\n                    raise AttributeError\n        elif not isinstance(color, Sized) and (color is None or pd.isna(color)):\n            return pd.NA  # will be filled with self._fill_node_values()\n        else:\n            logger.error(f\"The provided color {color} is not valid!\")\n            raise AttributeError\n\n    def _load_image(self, image_path: str) -&gt; str:\n        \"\"\"Load local images to base64 or pass through URLs.\n\n        Converts local image files to base64 data URLs for embedding\n        while preserving existing URLs and data URLs unchanged.\n\n        Args:\n            image_path: Local file path, URL, or data URL\n\n        Returns:\n            Base64 data URL for local files, original string for URLs\n\n        Raises:\n            AttributeError: If local file path doesn't exist\n        \"\"\"\n        if image_path.startswith(\"http://\") or image_path.startswith(\"https://\") or image_path.startswith(\"data:\"):\n            return image_path  # already a URL or base64 string\n        else:\n            # check if file exists\n            if not os.path.isfile(image_path):\n                logger.error(f\"The provided image path {image_path} does not exist!\")\n                raise AttributeError\n            return image_to_base64(image_path)\n\n    def _compute_layout(self) -&gt; None:\n        \"\"\"Compute and normalize node positions using layout algorithms.\n\n        Applies layout algorithm from config, normalizes coordinates to [0,1]\n        range, and joins position data with node attributes. Handles both\n        string layout names and pre-computed position dictionaries.\n        \"\"\"\n        # get layout from the config\n        layout = self.config.get(\"layout\")\n\n        # if no layout is considered stop this process\n        if layout is None:\n            return\n\n        # get layout dict for each node\n        if isinstance(layout, str):\n            layout = network_layout(self.network, layout=layout)\n        elif not isinstance(layout, dict):\n            logger.error(\"The provided layout is not valid!\")\n            raise AttributeError\n\n        # update x,y position of the nodes\n        layout_df = pd.DataFrame.from_dict(layout, orient=\"index\", columns=[\"x\", \"y\"])\n        if self.network.order &gt; 1 and not isinstance(layout_df.index[0], str):\n            layout_df.index = layout_df.index.map(lambda x: self.config[\"separator\"].join(map(str, x)))\n        # scale x and y to [0,1]\n        layout_df[\"x\"] = (layout_df[\"x\"] - layout_df[\"x\"].min()) / (layout_df[\"x\"].max() - layout_df[\"x\"].min())\n        layout_df[\"y\"] = (layout_df[\"y\"] - layout_df[\"y\"].min()) / (layout_df[\"y\"].max() - layout_df[\"y\"].min())\n        # join layout with node data\n        self.data[\"nodes\"] = self.data[\"nodes\"].join(layout_df, how=\"left\")\n\n    def _compute_config(self) -&gt; None:\n        \"\"\"Set network-specific visualization configuration.\n\n        Configures directedness, edge curvature, and simulation mode (for `d3.js` backend)\n        based on network properties. Directed networks use curved edges,\n        simulation mode activates when no layout is specified.\n        \"\"\"\n        self.config[\"directed\"] = self.network.is_directed()\n        self.config[\"curved\"] = self.network.is_directed()\n        self.config[\"simulation\"] = self.config[\"layout\"] is None\n</code></pre>"},{"location":"reference/pathpyG/visualisations/network_plot/#pathpyG.visualisations.network_plot.NetworkPlot.__init__","title":"<code>__init__</code>","text":"<p>Initialize network plot with graph and styling options.</p> <p>Processes node/edge arguments, updates configuration, and generates plot data structures. Arguments prefixed with 'node_' or 'edge_' are automatically assigned to respective components.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>pathpyG.core.graph.Graph</code> <p>Graph instance to visualize</p> required <code>**kwargs</code> <code>typing.Any</code> <p>Styling options (node_color, edge_size, layout, etc.)</p> <code>{}</code> Source code in <code>src/pathpyG/visualisations/network_plot.py</code> <pre><code>def __init__(self, network: Graph, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize network plot with graph and styling options.\n\n    Processes node/edge arguments, updates configuration, and generates\n    plot data structures. Arguments prefixed with 'node_' or 'edge_'\n    are automatically assigned to respective components.\n\n    Args:\n        network: Graph instance to visualize\n        **kwargs: Styling options (node_color, edge_size, layout, etc.)\n    \"\"\"\n    super().__init__()\n    self.network = network if network.device == torch.device(\"cpu\") else deepcopy(network).to(torch.device(\"cpu\"))\n    self.node_args = {}\n    self.edge_args = {}\n    self.attributes = [\"color\", \"size\", \"opacity\", \"image\"]\n    # extract node and edge specific arguments from kwargs\n    for key in kwargs.keys():\n        if key.startswith(\"node_\"):\n            self.node_args[key[5:]] = kwargs.get(key)\n        elif key.startswith(\"edge_\"):\n            self.edge_args[key[5:]] = kwargs.get(key)\n    # remove node_ and edge_ arguments from kwargs and update config with remaining kwargs\n    for node_arg in self.node_args.keys():\n        kwargs.pop(f\"node_{node_arg}\")\n    for edge_arg in self.edge_args.keys():\n        kwargs.pop(f\"edge_{edge_arg}\")\n    if \"node\" in kwargs:\n        self.config[\"node\"].update(kwargs[\"node\"])\n        kwargs.pop(\"node\")\n    if \"edge\" in kwargs:\n        self.config[\"edge\"].update(kwargs[\"edge\"])\n        kwargs.pop(\"edge\")\n    self.config.update(kwargs)\n    # generate plot data\n    self.generate()\n</code></pre>"},{"location":"reference/pathpyG/visualisations/network_plot/#pathpyG.visualisations.network_plot.NetworkPlot.generate","title":"<code>generate</code>","text":"<p>Generate complete plot data through processing pipeline.</p> <p>Orchestrates data preparation: edges \u2192 nodes \u2192 layout \u2192 post-processing \u2192 config. Creates final data structures ready for backend rendering.</p> Source code in <code>src/pathpyG/visualisations/network_plot.py</code> <pre><code>def generate(self) -&gt; None:\n    \"\"\"Generate complete plot data through processing pipeline.\n\n    Orchestrates data preparation: edges \u2192 nodes \u2192 layout \u2192 post-processing \u2192 config.\n    Creates final data structures ready for backend rendering.\n    \"\"\"\n    self._compute_edge_data()\n    self._compute_node_data()\n    self._compute_layout()\n    self._post_process_node_data()\n    self._compute_config()\n</code></pre>"},{"location":"reference/pathpyG/visualisations/pathpy_plot/","title":"pathpy_plot","text":"<p>Abstract base class for plot data preparation.</p> <p>Provides common foundation for assembling plot data and configuration before backend-specific rendering. Handles configuration loading and data structure initialization.</p>"},{"location":"reference/pathpyG/visualisations/pathpy_plot/#pathpyG.visualisations.pathpy_plot.PathPyPlot","title":"<code>PathPyPlot</code>","text":"<p>Abstract base class for plot data assembly.</p> <p>Prepares network data and configuration for backend rendering. Subclasses implement specific plot types (static, temporal, histogram, etc.).</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>dict</code> <p>Dictionary containing processed plot data</p> <code>config</code> <code>dict</code> <p>Visualization configuration from pathpyG settings</p> Source code in <code>src/pathpyG/visualisations/pathpy_plot.py</code> <pre><code>class PathPyPlot:\n    \"\"\"Abstract base class for plot data assembly.\n\n    Prepares network data and configuration for backend rendering.\n    Subclasses implement specific plot types (static, temporal, histogram, etc.).\n\n    Attributes:\n        data: Dictionary containing processed plot data\n        config: Visualization configuration from pathpyG settings\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize plot with empty data and default configuration.\n\n        Loads visualization config and normalizes color settings from\n        lists to tuples for consistency across backends.\n        \"\"\"\n        self.data: dict = {}\n        self.config: dict = config.get(\"visualisation\", {}).copy()\n        if isinstance(self.config[\"node\"][\"color\"], list):\n            self.config[\"node\"][\"color\"] = tuple(self.config[\"node\"][\"color\"])\n        if isinstance(self.config[\"edge\"][\"color\"], list):\n            self.config[\"edge\"][\"color\"] = tuple(self.config[\"edge\"][\"color\"])\n        logger.debug(f\"Intialising PathpyPlot with config: {self.config}\")\n\n    def generate(self) -&gt; None:\n        \"\"\"Generate plot data structures.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/pathpyG/visualisations/pathpy_plot/#pathpyG.visualisations.pathpy_plot.PathPyPlot.__init__","title":"<code>__init__</code>","text":"<p>Initialize plot with empty data and default configuration.</p> <p>Loads visualization config and normalizes color settings from lists to tuples for consistency across backends.</p> Source code in <code>src/pathpyG/visualisations/pathpy_plot.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize plot with empty data and default configuration.\n\n    Loads visualization config and normalizes color settings from\n    lists to tuples for consistency across backends.\n    \"\"\"\n    self.data: dict = {}\n    self.config: dict = config.get(\"visualisation\", {}).copy()\n    if isinstance(self.config[\"node\"][\"color\"], list):\n        self.config[\"node\"][\"color\"] = tuple(self.config[\"node\"][\"color\"])\n    if isinstance(self.config[\"edge\"][\"color\"], list):\n        self.config[\"edge\"][\"color\"] = tuple(self.config[\"edge\"][\"color\"])\n    logger.debug(f\"Intialising PathpyPlot with config: {self.config}\")\n</code></pre>"},{"location":"reference/pathpyG/visualisations/pathpy_plot/#pathpyG.visualisations.pathpy_plot.PathPyPlot.generate","title":"<code>generate</code>","text":"<p>Generate plot data structures.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses</p> Source code in <code>src/pathpyG/visualisations/pathpy_plot.py</code> <pre><code>def generate(self) -&gt; None:\n    \"\"\"Generate plot data structures.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pathpyG/visualisations/plot_backend/","title":"plot_backend","text":"<p>Abstract base class for visualization backends.</p> <p>Defines the common interface that all visualization backends (matplotlib, TikZ,  d3.js, manim) must implement. Handles plot data extraction and provides  standardized save/show methods.</p> Example <pre><code>class CustomBackend(PlotBackend):\n    def save(self, filename: str) -&gt; None:\n        # Implementation for saving\n        pass\n\n    def show(self) -&gt; None:\n        # Implementation for display\n        pass\n</code></pre>"},{"location":"reference/pathpyG/visualisations/plot_backend/#pathpyG.visualisations.plot_backend.PlotBackend","title":"<code>PlotBackend</code>","text":"<p>Abstract base class for all visualization backends.</p> <p>Provides common interface for matplotlib, TikZ, d3.js, and manim backends. Extracts plot data and configuration for backend-specific rendering.</p> Source code in <code>src/pathpyG/visualisations/plot_backend.py</code> <pre><code>class PlotBackend:\n    \"\"\"Abstract base class for all visualization backends.\n\n    Provides common interface for matplotlib, TikZ, d3.js, and manim backends.\n    Extracts plot data and configuration for backend-specific rendering.\n    \"\"\"\n    def __init__(self, plot: PathPyPlot, show_labels: bool) -&gt; None:\n        \"\"\"Initialize backend with plot data and configuration.\n\n        Args:\n            plot: PathPyPlot instance containing network data\n            show_labels: Whether to display node labels\n        \"\"\"\n        self.data = plot.data\n        self.config = plot.config\n        self.show_labels = show_labels\n\n    def save(self, filename: str) -&gt; None:\n        \"\"\"Save plot to file.\n\n        Args:\n            filename: Output file path\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses\n        \"\"\"\n        raise NotImplementedError(\"Subclasses should implement this method.\")\n\n    def show(self) -&gt; None:\n        \"\"\"Display plot on screen.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses\n        \"\"\"\n        raise NotImplementedError(\"Subclasses should implement this method.\")\n</code></pre>"},{"location":"reference/pathpyG/visualisations/plot_backend/#pathpyG.visualisations.plot_backend.PlotBackend.__init__","title":"<code>__init__</code>","text":"<p>Initialize backend with plot data and configuration.</p> <p>Parameters:</p> Name Type Description Default <code>plot</code> <code>pathpyG.visualisations.pathpy_plot.PathPyPlot</code> <p>PathPyPlot instance containing network data</p> required <code>show_labels</code> <code>bool</code> <p>Whether to display node labels</p> required Source code in <code>src/pathpyG/visualisations/plot_backend.py</code> <pre><code>def __init__(self, plot: PathPyPlot, show_labels: bool) -&gt; None:\n    \"\"\"Initialize backend with plot data and configuration.\n\n    Args:\n        plot: PathPyPlot instance containing network data\n        show_labels: Whether to display node labels\n    \"\"\"\n    self.data = plot.data\n    self.config = plot.config\n    self.show_labels = show_labels\n</code></pre>"},{"location":"reference/pathpyG/visualisations/plot_backend/#pathpyG.visualisations.plot_backend.PlotBackend.save","title":"<code>save</code>","text":"<p>Save plot to file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Output file path</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses</p> Source code in <code>src/pathpyG/visualisations/plot_backend.py</code> <pre><code>def save(self, filename: str) -&gt; None:\n    \"\"\"Save plot to file.\n\n    Args:\n        filename: Output file path\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses\n    \"\"\"\n    raise NotImplementedError(\"Subclasses should implement this method.\")\n</code></pre>"},{"location":"reference/pathpyG/visualisations/plot_backend/#pathpyG.visualisations.plot_backend.PlotBackend.show","title":"<code>show</code>","text":"<p>Display plot on screen.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses</p> Source code in <code>src/pathpyG/visualisations/plot_backend.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Display plot on screen.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses\n    \"\"\"\n    raise NotImplementedError(\"Subclasses should implement this method.\")\n</code></pre>"},{"location":"reference/pathpyG/visualisations/plot_function/","title":"plot_function","text":"<p>Network visualization orchestration module.</p> <p>Provides the main plotting interface for pathpyG networks with automatic backend selection and plot type detection. Serves as the unified entry point for all  visualization functionality across different backends and graph types.</p> Key Features <ul> <li>Multi-backend support (matplotlib, TikZ, d3.js, manim)</li> <li>Automatic plot type detection (static vs temporal)</li> <li>File format-based backend inference</li> <li>Unified plotting interface for all graph types</li> </ul> Supported Backends <ul> <li>matplotlib: PNG, JPG plots for static visualization</li> <li>TikZ: PDF, SVG, TEX for publication-quality vector graphics</li> <li>d3.js: HTML for interactive web visualization</li> <li>manim: MP4, GIF for animated temporal networks</li> </ul> <p>Examples:</p> <p>Plot a static network with the matplotlib backend and save it as <code>network.png</code>:</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; g = pp.Graph.from_edge_list([('a', 'b'), ('b', 'c')])\n&gt;&gt;&gt; pp.plot(g, filename='network.png')\n&lt;pathpyG.visualisations._matplotlib.backend.MatplotlibBackend object at 0x...&gt;\n</code></pre> <p></p> <p>Plot a temporal network with the default d3.js backend:</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; tg = pp.TemporalGraph.from_edge_list([('a', 'b', 1), ('b', 'c', 2), ('a', 'c', 3)])\n&gt;&gt;&gt; pp.plot(tg)\n&lt;IPython.core.display.HTML object&gt;\n&lt;pathpyG.visualisations._d3js.backend.D3jsBackend object at 0x...&gt;\n</code></pre> <p>```</p> <p>Backend Selection</p> <p>Backends are auto-selected from file extensions or can be explicitly  specified via the <code>backend</code> parameter.</p>"},{"location":"reference/pathpyG/visualisations/plot_function/#pathpyG.visualisations.plot_function.Backends","title":"<code>Backends</code>","text":"<p>               Bases: <code>str</code>, <code>enum.Enum</code></p> <p>Enumeration of supported visualization backends.</p> <p>Defines the available backend engines for network visualization, each optimized for different output formats and use cases.</p> Source code in <code>src/pathpyG/visualisations/plot_function.py</code> <pre><code>class Backends(str, Enum):\n    \"\"\"Enumeration of supported visualization backends.\n\n    Defines the available backend engines for network visualization,\n    each optimized for different output formats and use cases.\n    \"\"\"\n    d3js = \"d3js\"\n    matplotlib = \"matplotlib\"\n    tikz = \"tikz\"\n    manim = \"manim\"\n\n    @staticmethod\n    def is_backend(backend: str) -&gt; bool:\n        \"\"\"Check if string is a valid backend identifier.\n\n        Args:\n            backend: Backend name to validate\n\n        Returns:\n            True if backend is supported, False otherwise\n        \"\"\"\n        return backend in Backends.__members__.values()\n</code></pre>"},{"location":"reference/pathpyG/visualisations/plot_function/#pathpyG.visualisations.plot_function.Backends.is_backend","title":"<code>is_backend</code>  <code>staticmethod</code>","text":"<p>Check if string is a valid backend identifier.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>str</code> <p>Backend name to validate</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if backend is supported, False otherwise</p> Source code in <code>src/pathpyG/visualisations/plot_function.py</code> <pre><code>@staticmethod\ndef is_backend(backend: str) -&gt; bool:\n    \"\"\"Check if string is a valid backend identifier.\n\n    Args:\n        backend: Backend name to validate\n\n    Returns:\n        True if backend is supported, False otherwise\n    \"\"\"\n    return backend in Backends.__members__.values()\n</code></pre>"},{"location":"reference/pathpyG/visualisations/plot_function/#pathpyG.visualisations.plot_function.plot","title":"<code>plot</code>","text":"<p>Make plot of pathpyG objects.</p> <p>Creates and displays a plot for a given <code>pathpyG</code> object. This function can generate different types of network plots based on the nature of the input data and specified plot kind.</p> <p>The function dynamically determines the plot type if not explicitly provided, based on the input data type. It supports static network plots for <code>Graph</code> objects, temporal network plots for <code>TemporalGraph</code> objects, and potentially other types if specified in <code>kind</code>.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>pathpyG.core.graph.Graph</code> <p>A <code>pathpyG</code> object representing the network data. This can be a <code>Graph</code> or <code>TemporalGraph</code> object, or other compatible types.</p> required <code>kind</code> <code>typing.Optional[str]</code> <p>A string keyword defining the type of plot to generate. Options include: 'static', and 'temporal'.</p> <code>None</code> <code>show_labels</code> <p>Whether to display node labels (None uses graph.mapping.has_ids)</p> <code>None</code> <code>**kwargs</code> <code>typing.Any</code> <p>Backend-specific plotting parameters including: filename: Output file path (triggers backend auto-selection); backend: Explicit backend choice; layout: Layout algorithm name; style: Various styling parameters (colors, sizes, etc.)</p> <code>{}</code> <p>Returns:</p> Type Description <code>pathpyG.visualisations.plot_backend.PlotBackend</code> <p>Configured backend instance ready for display or saving</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If graph type cannot be auto-detected for plotting</p> <code>KeyError</code> <p>If specified backend is not supported</p> <code>ImportError</code> <p>If required backend cannot be loaded</p> <p>Examples:</p> <p>This will create a static network plot of the <code>graph</code> and save it to 'graph.png'.</p> <pre><code>&gt;&gt;&gt; import pathpyG as pp\n&gt;&gt;&gt; graph = pp.Graph.from_edge_list([[\"a\", \"b\"], [\"b\", \"c\"], [\"a\", \"c\"]])\n&gt;&gt;&gt; pp.plot(graph, kind=\"static\", filename=\"graph.png\")\n&lt;pathpyG.visualisations._matplotlib.backend.MatplotlibBackend object at 0x...&gt;\n</code></pre> <p></p> Note <ul> <li>If a 'filename' is provided in <code>kwargs</code>, the plot will be saved to   that file. Otherwise, it will be displayed using <code>plt.show()</code>.</li> <li>The function's behavior and the available options in <code>kwargs</code> might   change based on the type of plot being generated.</li> </ul> <p>Backend Auto-Selection</p> <p>When filename is provided, backend is inferred from extension:</p> Extension Backend Best For .png, .jpg matplotlib Quick visualization .pdf, .svg, .tex tikz Publication quality .html d3js Interactive exploration .mp4, .gif manim Animated sequences Source code in <code>src/pathpyG/visualisations/plot_function.py</code> <pre><code>def plot(graph: Graph, kind: Optional[str] = None, show_labels=None, **kwargs: Any) -&gt; PlotBackend:\n    \"\"\"Make plot of pathpyG objects.\n\n    Creates and displays a plot for a given `pathpyG` object. This function can\n    generate different types of network plots based on the nature of the input\n    data and specified plot kind.\n\n    The function dynamically determines the plot type if not explicitly\n    provided, based on the input data type. It supports static network plots\n    for `Graph` objects, temporal network plots for `TemporalGraph` objects,\n    and potentially other types if specified in `kind`.\n\n    Args:\n        graph: A `pathpyG` object representing the network data. This can\n            be a `Graph` or `TemporalGraph` object, or other compatible types.\n        kind: A string keyword defining the type of plot to generate. Options include:\n            **'static'**, and **'temporal'**.\n        show_labels: Whether to display node labels (None uses graph.mapping.has_ids)\n        **kwargs: Backend-specific plotting parameters including:\n            **filename**: Output file path (triggers backend auto-selection);\n            **backend**: Explicit backend choice;\n            **layout**: Layout algorithm name;\n            **style**: Various styling parameters (colors, sizes, etc.)\n\n    Returns:\n        Configured backend instance ready for display or saving\n\n    Raises:\n        NotImplementedError: If graph type cannot be auto-detected for plotting\n        KeyError: If specified backend is not supported\n        ImportError: If required backend cannot be loaded\n\n    Examples:\n        This will create a static network plot of the `graph` and save it to 'graph.png'.\n\n        &gt;&gt;&gt; import pathpyG as pp\n        &gt;&gt;&gt; graph = pp.Graph.from_edge_list([[\"a\", \"b\"], [\"b\", \"c\"], [\"a\", \"c\"]])\n        &gt;&gt;&gt; pp.plot(graph, kind=\"static\", filename=\"graph.png\")\n        &lt;pathpyG.visualisations._matplotlib.backend.MatplotlibBackend object at 0x...&gt;\n\n        &lt;img src=\"../plot/graph.png\" alt=\"Example static network plot\" width=\"550\"/&gt;\n\n    Note:\n        - If a 'filename' is provided in `kwargs`, the plot will be saved to\n          that file. Otherwise, it will be displayed using `plt.show()`.\n        - The function's behavior and the available options in `kwargs` might\n          change based on the type of plot being generated.\n\n    !!! abstract \"Backend Auto-Selection\"\n        When filename is provided, backend is inferred from extension:\n\n        | Extension | Backend | Best For |\n        |-----------|---------|----------|\n        | .png, .jpg | matplotlib | Quick visualization |\n        | .pdf, .svg, .tex | tikz | Publication quality |\n        | .html | d3js | Interactive exploration |\n        | .mp4, .gif | manim | Animated sequences |\n    \"\"\"\n    if kind is None:\n        if isinstance(graph, TemporalGraph):\n            kind = \"temporal\"\n        elif isinstance(graph, Graph):\n            kind = \"static\"\n        else:\n            raise NotImplementedError\n\n    if show_labels is None:\n        show_labels = graph.mapping.has_ids\n\n    filename = kwargs.pop(\"filename\", None)\n    _backend: str = kwargs.pop(\"backend\", None)\n\n    plot_backend_class = _get_plot_backend(\n        backend=_backend, filename=filename, default=config.get(\"visualisation\").get(\"default_backend\")  # type: ignore[union-attr]\n    )\n\n    # Check if backend is d3js and set layout to None if not specifically given as argument\n    if plot_backend_class == D3jsBackend:\n        if \"layout\" not in kwargs:\n            kwargs[\"layout\"] = None\n\n    plt = PLOT_CLASSES[kind](graph, **kwargs)\n    plot_backend = plot_backend_class(plt, show_labels=show_labels)\n    if filename:\n        plot_backend.save(filename)\n    else:\n        if config[\"environment\"][\"interactive\"]:\n            plot_backend.show()\n    return plot_backend\n</code></pre>"},{"location":"reference/pathpyG/visualisations/temporal_network_plot/","title":"temporal_network_plot","text":"<p>Temporal network visualization module.</p> <p>Prepares temporal graphs for visualization, handling time-based node and edge dynamics, windowed layout computation, and attribute interpolation.</p>"},{"location":"reference/pathpyG/visualisations/temporal_network_plot/#pathpyG.visualisations.temporal_network_plot.TemporalNetworkPlot","title":"<code>TemporalNetworkPlot</code>","text":"<p>               Bases: <code>pathpyG.visualisations.network_plot.NetworkPlot</code></p> <p>Temporal network visualization with time-based node and edge dynamics.</p> <p>Extends NetworkPlot to handle temporal graphs where edges appear at fixed times. Provides windowed layout computation and time-aware attribute interpolation.</p> <p>Temporal Features</p> <ul> <li>Node lifetime tracking (start/end times)</li> <li>Windowed layout computation</li> <li>Time-based attribute interpolation</li> </ul> Source code in <code>src/pathpyG/visualisations/temporal_network_plot.py</code> <pre><code>class TemporalNetworkPlot(NetworkPlot):\n    \"\"\"Temporal network visualization with time-based node and edge dynamics.\n\n    Extends NetworkPlot to handle temporal graphs where edges appear at\n    fixed times. Provides windowed layout computation and\n    time-aware attribute interpolation.\n\n    !!! info \"Temporal Features\"\n        - Node lifetime tracking (start/end times)\n        - Windowed layout computation\n        - Time-based attribute interpolation\n    \"\"\"\n\n    _kind = \"temporal\"\n    network: TemporalGraph\n\n    def __init__(self, network: TemporalGraph, **kwargs: Any) -&gt; None:\n        \"\"\"Initialize temporal network plot.\n\n        Args:\n            network: TemporalGraph instance to visualize\n            **kwargs: Additional plotting parameters\n        \"\"\"\n        super().__init__(network, **kwargs)\n\n    def _compute_node_data(self) -&gt; None:\n        \"\"\"Generate temporal node data with time-based attributes.\n\n        Creates multi-index DataFrame with (node_id, time) structure.\n        Handles node appearance times and attribute assignment from\n        network data, config defaults, and user arguments.\n        \"\"\"\n        # initialize values with index `node-0` to indicate time step 0\n        start_nodes: pd.DataFrame = pd.DataFrame(\n            index=pd.MultiIndex.from_tuples([(node, 0) for node in self.network.nodes], names=[\"uid\", \"time\"])\n        )\n        new_nodes: pd.DataFrame = pd.DataFrame(index=pd.MultiIndex.from_tuples([], names=[\"uid\", \"time\"]))\n        # add attributes to start nodes and new nodes if given as dictionary\n        for attribute in self.attributes:\n            # set default value for each attribute based on the pathpyG.toml config\n            if isinstance(self.config.get(\"node\").get(attribute, None), list | tuple):  # type: ignore[union-attr]\n                start_nodes[attribute] = [self.config.get(\"node\").get(attribute, None)] * len(start_nodes)  # type: ignore[union-attr]\n            else:\n                start_nodes[attribute] = self.config.get(\"node\").get(attribute, None)  # type: ignore[union-attr]\n            # check if attribute is given as node attribute\n            if f\"node_{attribute}\" in self.network.node_attrs():\n                start_nodes[attribute] = self.network.data[f\"node_{attribute}\"]\n            # check if attribute is given as argument\n            if attribute in self.node_args:\n                if isinstance(self.node_args[attribute], dict):\n                    # check if entry is tuple or string\n                    for key in self.node_args[attribute].keys():  # type: ignore[union-attr]\n                        value = self.node_args[attribute][key]  # type: ignore[index]\n                        # key is a tuple, add node attribute according to node-time keys\n                        if isinstance(key, tuple):\n                            # convert color tuples to hex strings to avoid pandas sequence assignment\n                            if attribute == \"color\" and isinstance(value, tuple) and len(value) == 3:\n                                value = rgb_to_hex(value)\n                            new_nodes.loc[key, attribute] = value\n                        # key is a single node, assign to start nodes at time 0\n                        else:\n                            # cast dtype of start_nodes attribute column to match value type\n                            start_nodes[attribute] = start_nodes[attribute].astype(type(value) if type(value) in [int, float, str] else object)\n                            # add node attributes to start nodes according to node keys\n                            start_nodes.loc[(key, 0), attribute] = value\n                else:\n                    start_nodes[attribute] = self.node_args[attribute]\n\n        # save node data and combine start nodes with new nodes by making sure start nodes are overwritten\n        self.data[\"nodes\"] = new_nodes.combine_first(start_nodes)\n\n    def _post_process_node_data(self) -&gt; None:\n        \"\"\"Add node lifetime information and forward-fill attributes.\n\n        Computes start/end times for each node appearance and fills\n        missing attribute values using forward-fill within node groups.\n\n        Returns:\n            Processed DataFrame with start/end time columns\n        \"\"\"\n        # Post-processing from parent class\n        super()._post_process_node_data()\n\n        # Fill all NaN/None values with the previous value and add start/end time columns.\n        nodes = self.data[\"nodes\"]\n        nodes = nodes.sort_values(by=[\"uid\", \"time\"]).groupby(\"uid\", sort=False).ffill()\n        nodes[\"start\"] = nodes.index.get_level_values(\"time\")\n        nodes = nodes.droplevel(\"time\")\n        # add end time step with the start the node appears the next time or max time step + 1\n        nodes[\"end\"] = nodes.groupby(\"uid\")[\"start\"].shift(-1)\n        max_node_time = nodes[\"start\"].max() + 1\n        if self.network.data.time.size(0) &gt; 0 and max_node_time &lt; self.network.data.time[-1].item() + 1:\n            max_node_time = self.network.data.time[-1].item() + 1\n        nodes[\"end\"] = nodes[\"end\"].fillna(max_node_time).astype(int)\n        self.data[\"nodes\"] = nodes\n\n    def _compute_edge_data(self) -&gt; None:\n        \"\"\"Generate temporal edge data with time-based attributes.\n\n        Creates edge DataFrame with temporal index (source, target, time).\n        Handles edge attributes from network data, config defaults, and\n        user arguments. Adds start/end time columns for edge lifetime.\n        \"\"\"\n        # initialize values\n        edges: pd.DataFrame = pd.DataFrame(\n            index=pd.MultiIndex.from_tuples(self.network.temporal_edges, names=[\"source\", \"target\", \"time\"])\n        )\n        for attribute in self.attributes:\n            # set default value for each attribute based on the pathpyG.toml config\n            if isinstance(self.config.get(\"edge\").get(attribute, None), list | tuple):  # type: ignore[union-attr]\n                edges[attribute] = [self.config.get(\"edge\").get(attribute, None)] * len(edges)  # type: ignore[union-attr]\n            else:\n                edges[attribute] = self.config.get(\"edge\").get(attribute, None)  # type: ignore[union-attr]\n            # check if attribute is given as edge attribute\n            if f\"edge_{attribute}\" in self.network.edge_attrs():\n                edges[attribute] = self.network.data[f\"edge_{attribute}\"]\n            # special case for size: If no edge_size is given use edge_weight if available\n            elif attribute == \"size\" and \"edge_weight\" in self.network.edge_attrs():\n                edges[attribute] = self.network.data[\"edge_weight\"]\n            # check if attribute is given as argument\n            if attribute in self.edge_args:\n                edges = self._assign_argument(attribute, self.edge_args[attribute], edges)\n            elif attribute == \"size\" and \"weight\" in self.edge_args:\n                edges = self._assign_argument(\"size\", self.edge_args[\"weight\"], edges)\n\n        # convert needed attributes to useful values\n        edges[\"color\"] = self._convert_to_rgb_tuple(edges[\"color\"])\n        edges[\"color\"] = edges[\"color\"].map(self._convert_color)\n        edges[\"start\"] = edges.index.get_level_values(\"time\").astype(int)\n        edges[\"end\"] = edges[\"start\"] + 1  # assume all edges last for one time step\n        edges.index = edges.index.droplevel(\"time\")\n\n        # save edge data\n        self.data[\"edges\"] = edges\n\n    def _compute_layout(self) -&gt; None:\n        \"\"\"Compute time-aware node layout using sliding window approach.\n\n        Uses configurable time windows to create smooth layout transitions.\n        For each time step, considers edges from surrounding time steps\n        based on layout_window_size configuration.\n\n        !!! tip \"Window Configuration\"\n            - Integer: symmetric window around current time\n            - [past, future]: asymmetric window sizes\n            - Negative values: use all past/future time steps\n        \"\"\"\n        # get layout from the config\n        layout_type = self.config.get(\"layout\")\n\n        # if no layout is considered or the graph is empty stop this process\n        if layout_type is None or len(self.data[\"nodes\"]) == 0:\n            return\n\n        max_time = int(\n            max(self.data[\"nodes\"].index.get_level_values(\"time\").max() + 1, self.data[\"edges\"][\"end\"].max())\n        )\n        window_size = self.config.get(\"layout_window_size\")\n        if isinstance(window_size, int):\n            # if uneven window size, add one to the future time steps since the end time step is exclusive\n            window_size = [window_size // 2, ceil(window_size / 2)]\n        elif isinstance(window_size, list | tuple):\n            if window_size[0] &lt; 0:\n                # use all previous time steps\n                window_size[0] = max_time  # type: ignore[index]\n            if window_size[1] &lt; 0:\n                # use all following time steps\n                window_size[1] = max_time  # type: ignore[index]\n        elif not isinstance(window_size, (list, tuple)):\n            logger.error(\"The provided layout_window_size is not valid!\")\n            raise AttributeError\n\n        pos = network_layout(self.network, layout=\"random\")  # initial layout\n        num_steps = max(max_time - window_size[1], 0)\n        layout_df = pd.DataFrame()\n        for step in range(num_steps + 1):\n            start_time = max(0, step - window_size[0])\n            end_time = step + window_size[1] + 1\n            # only compute layout if there are edges in the current window, otherwise use the previous layout\n            if ((start_time &lt;= self.network.data.time) &amp; (self.network.data.time &lt;= end_time)).sum() &gt; 0:\n                # get subgraph for the current time step\n                sub_graph = self.network.get_window(start_time=start_time, end_time=end_time)\n\n                # get layout dict for each node\n                if isinstance(layout_type, str):\n                    pos = network_layout(sub_graph, layout=layout_type, pos=pos)\n                elif not isinstance(layout_type, dict):\n                    logger.error(\"The provided layout is not valid!\")\n                    raise AttributeError\n\n            # update x,y position of the nodes\n            new_layout_df = pd.DataFrame.from_dict(pos, orient=\"index\", columns=[\"x\", \"y\"])\n            if self.network.order &gt; 1 and not isinstance(new_layout_df.index[0], str):\n                new_layout_df.index = new_layout_df.index.map(lambda x: self.config[\"separator\"].join(map(str, x)))\n            # scale x and y to [0,1]\n            new_layout_df[\"x\"] = (new_layout_df[\"x\"] - new_layout_df[\"x\"].min()) / (\n                new_layout_df[\"x\"].max() - new_layout_df[\"x\"].min()\n            )\n            new_layout_df[\"y\"] = (new_layout_df[\"y\"] - new_layout_df[\"y\"].min()) / (\n                new_layout_df[\"y\"].max() - new_layout_df[\"y\"].min()\n            )\n            # add time for the layout\n            new_layout_df[\"time\"] = step\n            # append to layout df\n            layout_df = pd.concat([layout_df, new_layout_df])\n        # join layout with node data\n        layout_df = layout_df.reset_index().rename(columns={\"index\": \"uid\"}).set_index([\"uid\", \"time\"])\n        self.data[\"nodes\"] = self.data[\"nodes\"].join(layout_df, how=\"outer\")\n\n    def _compute_config(self) -&gt; None:\n        \"\"\"Set temporal-specific visualization configuration.\n\n        Forces directed=True and curved=False for temporal networks.\n        Enables simulation mode (for `d3js` backend) when no layout algorithm is specified.\n        \"\"\"\n        self.config[\"directed\"] = True\n        self.config[\"curved\"] = False\n        self.config[\"simulation\"] = self.config[\"layout\"] is None\n</code></pre>"},{"location":"reference/pathpyG/visualisations/temporal_network_plot/#pathpyG.visualisations.temporal_network_plot.TemporalNetworkPlot.__init__","title":"<code>__init__</code>","text":"<p>Initialize temporal network plot.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>pathpyG.core.temporal_graph.TemporalGraph</code> <p>TemporalGraph instance to visualize</p> required <code>**kwargs</code> <code>typing.Any</code> <p>Additional plotting parameters</p> <code>{}</code> Source code in <code>src/pathpyG/visualisations/temporal_network_plot.py</code> <pre><code>def __init__(self, network: TemporalGraph, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize temporal network plot.\n\n    Args:\n        network: TemporalGraph instance to visualize\n        **kwargs: Additional plotting parameters\n    \"\"\"\n    super().__init__(network, **kwargs)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/unfolded_network_plot/","title":"unfolded_network_plot","text":"<p>Time-unfolded temporal network visualisation module.</p> <p>Prepares temporal graphs for visualization as time-unfolded networks by assigning the node positions in a grid.</p>"},{"location":"reference/pathpyG/visualisations/unfolded_network_plot/#pathpyG.visualisations.unfolded_network_plot.TimeUnfoldedNetworkPlot","title":"<code>TimeUnfoldedNetworkPlot</code>","text":"<p>               Bases: <code>pathpyG.visualisations.temporal_network_plot.TemporalNetworkPlot</code></p> <p>Time-unfolded temporal network visualisation class.</p> <p>Prepares temporal graphs for visualization as time-unfolded networks by assigning the node positions in a grid.</p> <p>Inherits from TemporalNetworkPlot.</p> Source code in <code>src/pathpyG/visualisations/unfolded_network_plot.py</code> <pre><code>class TimeUnfoldedNetworkPlot(TemporalNetworkPlot):\n    \"\"\"Time-unfolded temporal network visualisation class.\n\n    Prepares temporal graphs for visualization as time-unfolded networks\n    by assigning the node positions in a grid.\n\n    Inherits from TemporalNetworkPlot.\n    \"\"\"\n\n    _kind = \"unfolded\"\n    network: TemporalGraph\n\n    def _compute_edge_data(self):\n        super()._compute_edge_data()\n        self.data[\"edges\"].index = pd.MultiIndex.from_arrays(\n            [\n                list(zip(self.data[\"edges\"].index.get_level_values(\"source\"), self.data[\"edges\"][\"start\"])),\n                list(zip(self.data[\"edges\"].index.get_level_values(\"target\"), self.data[\"edges\"][\"end\"])),\n            ],\n            names=[\"source\", \"target\"],\n        )\n\n    def _post_process_node_data(self):\n        super()._post_process_node_data()\n\n        self.data[\"nodes\"].index = pd.Index(\n            list(zip(self.data[\"nodes\"].index, self.data[\"nodes\"][\"start\"])),\n            name=\"uid\",\n            tupleize_cols=False\n        )\n\n    def _compute_layout(self) -&gt; None:\n        \"\"\"Compute time-unfolded node layout.\n\n        For each node, assign positions in a grid based on time steps.\n        Depending on orientation, x (left/right) or y (up/down) coordinates represent time steps\n        and the other coordinate represents node identity.\n        \"\"\"\n        num_nodes = self.network.n\n        max_time = int(\n            max(self.data[\"nodes\"].index.get_level_values(\"time\").max() + 1, self.data[\"edges\"][\"end\"].max() + 1)\n        )\n        orientation = self.config.get(\"orientation\")\n\n        # Determine coordinate assignment based on orientation\n        if orientation in [\"left\", \"right\"]:\n            time_coord = \"x\"\n            node_coord = \"y\"\n            if orientation == \"left\":\n                sign = -1\n            else:\n                sign = 1\n        elif orientation in [\"up\", \"down\"]:\n            time_coord = \"y\"\n            node_coord = \"x\"\n            if orientation == \"down\":\n                sign = -1\n            else:\n                sign = 1\n        else:\n            raise ValueError(\"Invalid orientation option. Choose from 'left', 'right', 'up', or 'down'.\")\n\n        # Create a DataFrame for the grid layout\n        node_ids = np.repeat(self.data[\"nodes\"].index.get_level_values(\"uid\").unique(), max_time)\n        node_values = np.repeat(np.arange(num_nodes), max_time)\n        time_values = np.tile(np.arange(max_time), num_nodes)\n        layout_df = pd.DataFrame(\n            {\n                \"uid\": node_ids,\n                \"time\": time_values,\n                time_coord: (sign * time_values).astype(float),\n                node_coord: node_values.astype(float),\n            }\n        ).set_index([\"uid\", \"time\"])\n\n        # Scale coordinates between 0 and 1\n        layout_df[time_coord] = (layout_df[time_coord] - layout_df[time_coord].min()) / (\n            layout_df[time_coord].max() - layout_df[time_coord].min()\n        )\n        layout_df[node_coord] = (layout_df[node_coord] - layout_df[node_coord].min()) / (\n            layout_df[node_coord].max() - layout_df[node_coord].min()\n        )\n\n        # Join the layout DataFrame with the existing node data\n        self.data[\"nodes\"] = self.data[\"nodes\"].join(layout_df, how=\"outer\")\n\n    def _compute_config(self) -&gt; None:\n        \"\"\"Set temporal-specific visualization configuration.\n\n        Forces directed=True and curved=False for temporal networks.\n        Enables simulation mode (for `d3js` backend) when no layout algorithm is specified.\n        \"\"\"\n        self.config[\"directed\"] = True\n        self.config[\"curved\"] = False\n        self.config[\"simulation\"] = False\n</code></pre>"},{"location":"reference/pathpyG/visualisations/utils/","title":"utils","text":"<p>Visualization Utilities for PathpyG.</p> <p>Essential helper functions for network visualization backends. This module provides utilities for file management, color conversion, unit conversion, and image processing to support the various visualization backends in PathpyG.</p> <p>Key Utilities</p> <ul> <li> File Management - Temporary directory handling for compilation</li> <li> Color Conversion - RGB/Hex color format transformations</li> <li> Unit Conversion - Between cm, inches, and pixels</li> <li> Image Processing - Base64 encoding for web compatibility</li> </ul> <p>These utilities are primarily used internally by visualization backends but can also be useful for custom visualization development and data preprocessing.</p>"},{"location":"reference/pathpyG/visualisations/utils/#pathpyG.visualisations.utils--usage-examples","title":"Usage Examples","text":"<p>Color Format Conversion</p> <pre><code>from pathpyG.visualisations.utils import rgb_to_hex, hex_to_rgb\n\n# Convert RGB to hex\nhex_color = rgb_to_hex((255, 0, 0))  # \"#ff0000\"\nhex_color = rgb_to_hex((1.0, 0.0, 0.0))  # Also \"#ff0000\"\n\n# Convert hex to RGB\nrgb_color = hex_to_rgb(\"#ff0000\")  # (255, 0, 0)\n</code></pre> <p>Unit Conversions for Layout</p> <pre><code>from pathpyG.visualisations.utils import unit_str_to_float\n\n# Convert between different units\nwidth_px = unit_str_to_float(\"12cm\", \"px\")  # Converts 12cm to pixels\nheight_in = unit_str_to_float(\"800px\", \"in\")  # Converts 800px to inches\n</code></pre>"},{"location":"reference/pathpyG/visualisations/utils/#pathpyG.visualisations.utils.cm_to_inch","title":"<code>cm_to_inch</code>","text":"<p>Convert centimeters to inches.</p> <p>Converts metric length measurements to imperial inches for compatibility with systems that use imperial units.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Length in centimeters</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Equivalent length in inches (1 cm = 0.393701 in)</p> <p>Examples:</p> <pre><code># Convert A4 width to inches\nwidth_in = cm_to_inch(21.0)  # 8.268 inches\n\n# Convert small measurement\nthickness_in = cm_to_inch(0.1)  # 0.039 inches\n</code></pre> Source code in <code>src/pathpyG/visualisations/utils.py</code> <pre><code>def cm_to_inch(value: float) -&gt; float:\n    \"\"\"Convert centimeters to inches.\n\n    Converts metric length measurements to imperial inches for compatibility\n    with systems that use imperial units.\n\n    Args:\n        value: Length in centimeters\n\n    Returns:\n        float: Equivalent length in inches (1 cm = 0.393701 in)\n\n    Examples:\n        ```python\n        # Convert A4 width to inches\n        width_in = cm_to_inch(21.0)  # 8.268 inches\n\n        # Convert small measurement\n        thickness_in = cm_to_inch(0.1)  # 0.039 inches\n        ```\n    \"\"\"\n    return value / 2.54\n</code></pre>"},{"location":"reference/pathpyG/visualisations/utils/#pathpyG.visualisations.utils.hex_to_rgb","title":"<code>hex_to_rgb</code>","text":"<p>Convert hexadecimal color string to RGB color tuple.</p> <p>Parses standard hex color strings (with or without '#' prefix) and returns RGB values in 0-255 integer range suitable for most graphics libraries.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Hexadecimal color string (e.g., \"#ff0000\" or \"ff0000\")</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>RGB color tuple with values in range 0-255</p> <p>Examples:</p> <pre><code># Standard hex with hash\nrgb = hex_to_rgb(\"#ff0000\")  # (255, 0, 0) - red\n\n# Hex without hash\nrgb = hex_to_rgb(\"00ff00\")  # (0, 255, 0) - green\n\n# Short hex notation\nrgb = hex_to_rgb(\"#f0f\")  # (255, 0, 255) - magenta\n</code></pre> Source code in <code>src/pathpyG/visualisations/utils.py</code> <pre><code>def hex_to_rgb(value: str) -&gt; tuple:\n    \"\"\"Convert hexadecimal color string to RGB color tuple.\n\n    Parses standard hex color strings (with or without '#' prefix) and\n    returns RGB values in 0-255 integer range suitable for most graphics libraries.\n\n    Args:\n        value: Hexadecimal color string (e.g., \"#ff0000\" or \"ff0000\")\n\n    Returns:\n        tuple: RGB color tuple with values in range 0-255\n\n    Examples:\n        ```python\n        # Standard hex with hash\n        rgb = hex_to_rgb(\"#ff0000\")  # (255, 0, 0) - red\n\n        # Hex without hash\n        rgb = hex_to_rgb(\"00ff00\")  # (0, 255, 0) - green\n\n        # Short hex notation\n        rgb = hex_to_rgb(\"#f0f\")  # (255, 0, 255) - magenta\n        ```\n    \"\"\"\n    value = value.lstrip(\"#\")\n    _l = len(value)\n    return tuple((int(value[i : i + _l // 3], 16) + 1)**(6 // _l) - 1 for i in range(0, _l, _l // 3))\n</code></pre>"},{"location":"reference/pathpyG/visualisations/utils/#pathpyG.visualisations.utils.image_to_base64","title":"<code>image_to_base64</code>","text":"<p>Convert local image file to base64 data URL for embedding.</p> <p>Reads an image file from disk and converts it to a base64-encoded data URL that can be embedded directly in HTML, SVG, or other formats without requiring external file references.</p> <p>Parameters:</p> Name Type Description Default <code>image_path</code> <p>Path to the image file (str or Path object)</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Base64 data URL (e.g., \"data:image/png;base64,iVBORw0KGgoAAAA...\")</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the specified image file does not exist</p> <p>Examples:</p> <pre><code># Convert PNG logo to data URL\nlogo_data = image_to_base64(\"logo.png\")\n# Returns: \"data:image/png;base64,iVBORw0KGgoAAAA...\"\n\n# Use in HTML template\nhtml = f'&lt;img src=\"{logo_data}\" alt=\"Logo\"&gt;'\n\n# Use in SVG embedding\nsvg_image = f'&lt;image href=\"{logo_data}\" x=\"10\" y=\"10\"/&gt;'\n</code></pre> <p>Supported Formats</p> <p>Automatically detects MIME types for PNG, JPEG, GIF, and SVG files based on file extension. Defaults to PNG for unknown extensions.</p> <p>Use Cases</p> <ul> <li>Embedding images in standalone HTML/SVG files</li> <li>Creating self-contained visualizations</li> <li>Avoiding external file dependencies in templates</li> <li>Allows visualizations in VSCode Jupyter notebook- and browser-environments where local file access is restricted</li> </ul> Source code in <code>src/pathpyG/visualisations/utils.py</code> <pre><code>def image_to_base64(image_path):\n    \"\"\"Convert local image file to base64 data URL for embedding.\n\n    Reads an image file from disk and converts it to a base64-encoded data URL\n    that can be embedded directly in HTML, SVG, or other formats without\n    requiring external file references.\n\n    Args:\n        image_path: Path to the image file (str or Path object)\n\n    Returns:\n        str: Base64 data URL (e.g., \"data:image/png;base64,iVBORw0KGgoAAAA...\")\n\n    Raises:\n        FileNotFoundError: If the specified image file does not exist\n\n    Examples:\n        ```python\n        # Convert PNG logo to data URL\n        logo_data = image_to_base64(\"logo.png\")\n        # Returns: \"data:image/png;base64,iVBORw0KGgoAAAA...\"\n\n        # Use in HTML template\n        html = f'&lt;img src=\"{logo_data}\" alt=\"Logo\"&gt;'\n\n        # Use in SVG embedding\n        svg_image = f'&lt;image href=\"{logo_data}\" x=\"10\" y=\"10\"/&gt;'\n        ```\n\n    !!! info \"Supported Formats\"\n        Automatically detects MIME types for PNG, JPEG, GIF, and SVG files\n        based on file extension. Defaults to PNG for unknown extensions.\n\n    !!! tip \"Use Cases\"\n        - Embedding images in standalone HTML/SVG files\n        - Creating self-contained visualizations\n        - Avoiding external file dependencies in templates\n        - Allows visualizations in VSCode Jupyter notebook- and browser-environments where local file access is restricted\n    \"\"\"\n    path = Path(image_path)\n    if not path.exists():\n        raise FileNotFoundError(f\"Image not found: {image_path}\")\n\n    # Detect image type\n    suffix = path.suffix.lower()\n    mime_types = {\n        \".png\": \"image/png\",\n        \".jpg\": \"image/jpeg\",\n        \".jpeg\": \"image/jpeg\",\n        \".gif\": \"image/gif\",\n        \".svg\": \"image/svg+xml\",\n    }\n    mime_type = mime_types.get(suffix, \"image/png\")\n\n    # Read and encode\n    with open(image_path, \"rb\") as f:\n        encoded = base64.b64encode(f.read()).decode()\n\n    return f\"data:{mime_type};base64,{encoded}\"\n</code></pre>"},{"location":"reference/pathpyG/visualisations/utils/#pathpyG.visualisations.utils.in_jupyter_notebook","title":"<code>in_jupyter_notebook</code>","text":"<p>Detects whether the current Python session is running inside a Jupyter Notebook.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if running inside a Jupyter notebook, False otherwise</p> Source code in <code>src/pathpyG/visualisations/utils.py</code> <pre><code>def in_jupyter_notebook() -&gt; bool:\n    \"\"\"Detects whether the current Python session is running inside a Jupyter Notebook.\n\n    Returns:\n        bool: True if running inside a Jupyter notebook, False otherwise\n    \"\"\"\n    try:\n        return \"IPKernelApp\" in get_ipython().config\n    except NameError:\n        return False\n    except AttributeError:\n        return False\n</code></pre>"},{"location":"reference/pathpyG/visualisations/utils/#pathpyG.visualisations.utils.inch_to_cm","title":"<code>inch_to_cm</code>","text":"<p>Convert inches to centimeters.</p> <p>Converts imperial length measurements to metric centimeters for standardization and international compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Length in inches</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Equivalent length in centimeters (1 in = 2.54 cm)</p> <p>Examples:</p> <pre><code># Convert US letter width to cm\nwidth_cm = inch_to_cm(8.5)  # 21.59 cm\n\n# Convert screen size\nscreen_cm = inch_to_cm(15.6)  # 39.624 cm\n</code></pre> Source code in <code>src/pathpyG/visualisations/utils.py</code> <pre><code>def inch_to_cm(value: float) -&gt; float:\n    \"\"\"Convert inches to centimeters.\n\n    Converts imperial length measurements to metric centimeters for\n    standardization and international compatibility.\n\n    Args:\n        value: Length in inches\n\n    Returns:\n        float: Equivalent length in centimeters (1 in = 2.54 cm)\n\n    Examples:\n        ```python\n        # Convert US letter width to cm\n        width_cm = inch_to_cm(8.5)  # 21.59 cm\n\n        # Convert screen size\n        screen_cm = inch_to_cm(15.6)  # 39.624 cm\n        ```\n    \"\"\"\n    return value * 2.54\n</code></pre>"},{"location":"reference/pathpyG/visualisations/utils/#pathpyG.visualisations.utils.inch_to_px","title":"<code>inch_to_px</code>","text":"<p>Convert inches to pixels based on DPI resolution.</p> <p>Converts physical measurements to screen pixels using dots-per-inch resolution for accurate display sizing across different screens.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Length in inches</p> required <code>dpi</code> <code>int</code> <p>Resolution in dots per inch (default: 96 - standard web DPI)</p> <code>96</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Equivalent length in pixels</p> <p>Examples:</p> <pre><code># Standard web resolution\nwidth_px = inch_to_px(8.5)  # 816.0 pixels (96 DPI)\n\n# High-resolution display\nwidth_px = inch_to_px(8.5, 300)  # 2550.0 pixels (300 DPI)\n</code></pre> Source code in <code>src/pathpyG/visualisations/utils.py</code> <pre><code>def inch_to_px(value: float, dpi: int = 96) -&gt; float:\n    \"\"\"Convert inches to pixels based on DPI resolution.\n\n    Converts physical measurements to screen pixels using dots-per-inch\n    resolution for accurate display sizing across different screens.\n\n    Args:\n        value: Length in inches\n        dpi: Resolution in dots per inch (default: 96 - standard web DPI)\n\n    Returns:\n        float: Equivalent length in pixels\n\n    Examples:\n        ```python\n        # Standard web resolution\n        width_px = inch_to_px(8.5)  # 816.0 pixels (96 DPI)\n\n        # High-resolution display\n        width_px = inch_to_px(8.5, 300)  # 2550.0 pixels (300 DPI)\n        ```\n    \"\"\"\n    return value * dpi\n</code></pre>"},{"location":"reference/pathpyG/visualisations/utils/#pathpyG.visualisations.utils.prepare_tempfile","title":"<code>prepare_tempfile</code>","text":"<p>Prepare temporary directory for backend compilation processes.</p> <p>Creates a secure temporary directory and changes the working directory to it. This is essential for LaTeX compilation and other backends that generate intermediate files during the rendering process.</p> <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>tuple[str, str]: (temp_directory_path, original_directory_path)</p> <p>Directory Management</p> <p>The caller is responsible for:</p> <ul> <li>Restoring the original working directory</li> <li>Cleaning up the temporary directory when done</li> </ul> Source code in <code>src/pathpyG/visualisations/utils.py</code> <pre><code>def prepare_tempfile() -&gt; tuple[str, str]:\n    \"\"\"Prepare temporary directory for backend compilation processes.\n\n    Creates a secure temporary directory and changes the working directory\n    to it. This is essential for LaTeX compilation and other backends that\n    generate intermediate files during the rendering process.\n\n    Returns:\n        tuple[str, str]: (temp_directory_path, original_directory_path)\n\n    !!! warning \"Directory Management\"\n        The caller is responsible for:\n\n        - Restoring the original working directory\n        - Cleaning up the temporary directory when done\n    \"\"\"\n    # get current directory\n    current_dir = os.getcwd()\n\n    # get temporal directory\n    temp_dir = tempfile.mkdtemp()\n\n    # change to output dir\n    os.chdir(temp_dir)\n\n    return temp_dir, current_dir\n</code></pre>"},{"location":"reference/pathpyG/visualisations/utils/#pathpyG.visualisations.utils.px_to_inch","title":"<code>px_to_inch</code>","text":"<p>Convert pixels to inches based on DPI resolution.</p> <p>Converts screen pixels to physical measurements using dots-per-inch resolution for print layout and physical sizing calculations.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Length in pixels</p> required <code>dpi</code> <code>int</code> <p>Resolution in dots per inch (default: 96 - standard web DPI)</p> <code>96</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Equivalent length in inches</p> <p>Examples:</p> <pre><code># Standard web resolution\nwidth_in = px_to_inch(800)  # 8.333 inches (96 DPI)\n\n# Print resolution conversion\nwidth_in = px_to_inch(2400, 300)  # 8.0 inches (300 DPI)\n</code></pre> Source code in <code>src/pathpyG/visualisations/utils.py</code> <pre><code>def px_to_inch(value: float, dpi: int = 96) -&gt; float:\n    \"\"\"Convert pixels to inches based on DPI resolution.\n\n    Converts screen pixels to physical measurements using dots-per-inch\n    resolution for print layout and physical sizing calculations.\n\n    Args:\n        value: Length in pixels\n        dpi: Resolution in dots per inch (default: 96 - standard web DPI)\n\n    Returns:\n        float: Equivalent length in inches\n\n    Examples:\n        ```python\n        # Standard web resolution\n        width_in = px_to_inch(800)  # 8.333 inches (96 DPI)\n\n        # Print resolution conversion\n        width_in = px_to_inch(2400, 300)  # 8.0 inches (300 DPI)\n        ```\n    \"\"\"\n    return value / dpi\n</code></pre>"},{"location":"reference/pathpyG/visualisations/utils/#pathpyG.visualisations.utils.rgb_to_hex","title":"<code>rgb_to_hex</code>","text":"<p>Convert RGB color tuple to hexadecimal color string.</p> <p>Accepts RGB values in either 0-1 float range (matplotlib style) or 0-255 integer range (web/PIL style) and converts to standard hex format.</p> <p>Parameters:</p> Name Type Description Default <code>rgb</code> <code>tuple</code> <p>RGB color tuple - either (r, g, b) with values 0-1 or 0-255</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Hexadecimal color string (e.g., \"#ff0000\" for red)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If RGB values are outside valid ranges</p> <p>Examples:</p> <pre><code># Float values (matplotlib/numpy style)\nhex_color = rgb_to_hex((1.0, 0.0, 0.0))  # \"#ff0000\" (red)\n\n# Integer values (web/PIL style)\nhex_color = rgb_to_hex((255, 128, 0))  # \"#ff8000\" (orange)\n</code></pre> <p>Format Detection</p> <p>The function automatically detects whether input values are in 0-1 or 0-255 range and converts appropriately.</p> Source code in <code>src/pathpyG/visualisations/utils.py</code> <pre><code>def rgb_to_hex(rgb: tuple) -&gt; str:\n    \"\"\"Convert RGB color tuple to hexadecimal color string.\n\n    Accepts RGB values in either 0-1 float range (matplotlib style) or\n    0-255 integer range (web/PIL style) and converts to standard hex format.\n\n    Args:\n        rgb: RGB color tuple - either (r, g, b) with values 0-1 or 0-255\n\n    Returns:\n        str: Hexadecimal color string (e.g., \"#ff0000\" for red)\n\n    Raises:\n        ValueError: If RGB values are outside valid ranges\n\n    Examples:\n        ```python\n        # Float values (matplotlib/numpy style)\n        hex_color = rgb_to_hex((1.0, 0.0, 0.0))  # \"#ff0000\" (red)\n\n        # Integer values (web/PIL style)\n        hex_color = rgb_to_hex((255, 128, 0))  # \"#ff8000\" (orange)\n        ```\n\n    !!! tip \"Format Detection\"\n        The function automatically detects whether input values are in 0-1\n        or 0-255 range and converts appropriately.\n    \"\"\"\n    if all(0.0 &lt;= val &lt;= 1.0 for val in rgb):\n        rgb = tuple(int(val * 255) for val in rgb)\n    elif not all(0 &lt;= val &lt;= 255 for val in rgb) or any(not isinstance(val, int) for val in rgb):\n        raise ValueError(\"RGB values must be in range 0-1 or 0-255.\")\n    return \"#%02x%02x%02x\" % rgb\n</code></pre>"},{"location":"reference/pathpyG/visualisations/utils/#pathpyG.visualisations.utils.unit_str_to_float","title":"<code>unit_str_to_float</code>","text":"<p>Convert string with unit suffix to float in target unit.</p> <p>Parses strings containing numeric values with unit suffixes (e.g., \"10px\", \"5cm\") and converts to the specified target unit using appropriate conversion functions.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>String with numeric value and 2-character unit suffix</p> required <code>unit</code> <code>str</code> <p>Target unit for conversion (\"px\", \"cm\", \"in\")</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Converted numeric value in target unit</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If conversion between units is not supported</p> <p>Examples:</p> <pre><code># Convert pixel string to centimeters\ncm_value = unit_str_to_float(\"800px\", \"cm\")  # 21.17 cm (96 DPI)\n\n# Convert cm string to inches\nin_value = unit_str_to_float(\"21cm\", \"in\")  # 8.268 inches\n\n# Same unit (no conversion needed)\npx_value = unit_str_to_float(\"100px\", \"px\")  # 100.0\n</code></pre> <p>Supported Conversions</p> <p>Only supports conversions between \"px\", \"cm\", and \"in\" units. Pixel conversions assume 96 DPI by default.</p> <p>Supported conversion patterns:</p> From To Function cm in <code>cm_to_inch()</code> in cm <code>inch_to_cm()</code> in px <code>inch_to_px()</code> px in <code>px_to_inch()</code> cm px <code>cm_to_inch() + inch_to_px()</code> px cm <code>px_to_inch() + inch_to_cm()</code> Source code in <code>src/pathpyG/visualisations/utils.py</code> <pre><code>def unit_str_to_float(value: str, unit: str) -&gt; float:\n    \"\"\"Convert string with unit suffix to float in target unit.\n\n    Parses strings containing numeric values with unit suffixes (e.g., \"10px\", \"5cm\")\n    and converts to the specified target unit using appropriate conversion functions.\n\n    Args:\n        value: String with numeric value and 2-character unit suffix\n        unit: Target unit for conversion (\"px\", \"cm\", \"in\")\n\n    Returns:\n        float: Converted numeric value in target unit\n\n    Raises:\n        ValueError: If conversion between units is not supported\n\n    Examples:\n        ```python\n        # Convert pixel string to centimeters\n        cm_value = unit_str_to_float(\"800px\", \"cm\")  # 21.17 cm (96 DPI)\n\n        # Convert cm string to inches\n        in_value = unit_str_to_float(\"21cm\", \"in\")  # 8.268 inches\n\n        # Same unit (no conversion needed)\n        px_value = unit_str_to_float(\"100px\", \"px\")  # 100.0\n        ```\n\n    !!! warning \"Supported Conversions\"\n        Only supports conversions between \"px\", \"cm\", and \"in\" units.\n        Pixel conversions assume 96 DPI by default.\n\n    Supported conversion patterns:\n\n    | From | To | Function |\n    |------|----| ---------|\n    | cm   | in | `cm_to_inch()` |\n    | in   | cm | `inch_to_cm()` |\n    | in   | px | `inch_to_px()` |\n    | px   | in | `px_to_inch()` |\n    | cm   | px | `cm_to_inch() + inch_to_px()` |\n    | px   | cm | `px_to_inch() + inch_to_cm()` |\n    \"\"\"\n    conversion_functions: dict[str, Callable[[float], float]] = {\n        \"cm_to_in\": cm_to_inch,\n        \"in_to_cm\": inch_to_cm,\n        \"in_to_px\": inch_to_px,\n        \"px_to_in\": px_to_inch,\n        \"cm_to_px\": lambda x: inch_to_px(cm_to_inch(x)),\n        \"px_to_cm\": lambda x: inch_to_cm(px_to_inch(x)),\n    }\n    conversion_key = f\"{value[-2:]}_to_{unit}\"\n    if conversion_key in conversion_functions:\n        return conversion_functions[conversion_key](float(value[:-2]))\n    elif value[-2:] == unit:\n        return float(value[:-2])\n    else:\n        raise ValueError(f\"The provided conversion '{conversion_key}' is not supported.\")\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_d3js/","title":"d3js","text":"<p>D3.js Backend for PathpyG Visualizations.</p> <p>Interactive web-based visualization backend using D3.js for both static and temporal networks. Default backend providing rich interactivity, real-time exploration, and web-compatible output.</p> <p>Output Formats</p> <ul> <li>HTML: Interactive web visualizations where nodes can be dragged around and temporal graphs can be paused/played.</li> </ul> <p>Default Backend</p> <p>D3.js is the default visualization backend for PathpyG, automatically selected when no specific backend is specified. No additional dependencies required beyond web browser.</p>"},{"location":"reference/pathpyG/visualisations/_d3js/#pathpyG.visualisations._d3js--basic-usage","title":"Basic Usage","text":"<pre><code>import pathpyG as pp\n\n# Simple network visualization\nedges = [(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"A\")]\ng = pp.Graph.from_edge_list(edges)\npp.plot(g)  # Uses d3.js backend by default\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_d3js/#pathpyG.visualisations._d3js--advanced-temporal-network-example","title":"Advanced Temporal Network Example","text":"<pre><code>import torch\nimport pathpyG as pp\n\n# Temporal network with evolving properties\ntedges = [\n    (\"a\", \"b\", 1), (\"b\", \"c\", 1),\n    (\"c\", \"d\", 2), (\"d\", \"a\", 2), \n    (\"a\", \"c\", 3), (\"b\", \"d\", 3)\n]\ntg = pp.TemporalGraph.from_edge_list(tedges)\ntg.data[\"edge_color\"] = torch.arange(tg.m)  # Assign a unique color index to each edge\n\npp.plot(\n    tg,\n    delta=750,  # 0.75 seconds per timestep\n    node_size={(\"a\", 1): 20, (\"b\", 2): 7},\n    node_color=[\"red\", \"blue\", \"green\", \"orange\"],\n    edge_opacity=0.7,\n    filename=\"dynamic_network.html\"\n)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_d3js/#pathpyG.visualisations._d3js--network-visualization-with-custom-images","title":"Network Visualization with custom Images","text":"<p>With D3.js, you can easily use custom images for nodes by providing URLs or local paths.</p> <pre><code>import torch\nimport pathpyG as pp\n\n# Example network data\nedges = [\n    (\"b\", \"a\"),\n    (\"c\", \"a\"),\n]\nmapping = pp.IndexMap([\"a\", \"b\", \"c\", \"d\"])\ng = pp.Graph.from_edge_list(edges, mapping=mapping)\ng.data[\"node_size\"] = torch.tensor([25]*4)\npp.plot(\n    g,\n    node_size={\"d\": 50},\n    edge_size=5,\n    node_image={\n        \"a\": \"https://avatars.githubusercontent.com/u/52822508?s=48&amp;v=4\",\n        \"b\": \"https://raw.githubusercontent.com/pyg-team/pyg_sphinx_theme/master/pyg_sphinx_theme/static/img/pyg_logo.png\",\n        \"c\": \"https://pytorch-geometric.readthedocs.io/en/latest/_static/img/pytorch_logo.svg\",\n        \"d\": \"docs/img/pathpy_logo_new.png\",\n    },\n    show_labels=False,\n)\n</code></pre> <p>Deployment Options</p> <ul> <li>Standalone: Self-contained HTML with embedded resources</li> <li>Jupyter: Direct display in notebook cells</li> <li>Web Apps: Easy integration into existing websites</li> </ul>"},{"location":"reference/pathpyG/visualisations/_d3js/#pathpyG.visualisations._d3js--time-unfolded-network","title":"Time-Unfolded Network","text":"<p>Below is an example of a time-unfolded network visualization using the D3.js backend.</p> <pre><code>import pathpyG as pp\n\n# Example temporal network data\ntedges = [\n    (\"a\", \"d\", 1),\n    (\"b\", \"c\", 2),\n    (\"b\", \"c\", 3),\n    (\"b\", \"a\", 3),\n    (\"d\", \"b\", 4),\n\n]\nt = pp.TemporalGraph.from_edge_list(tedges)\n\n# Create temporal plot and display inline\npp.plot(t, kind=\"unfolded\", show_labels=False)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_d3js/#pathpyG.visualisations._d3js--templates","title":"Templates","text":"<p>PathpyG uses HTML templates to generate D3.js visualizations located in the <code>templates</code> directory. Templates define the overall structure and include placeholders for dynamic content. Currently used templates:</p> <ul> <li><code>network.js</code>: A basic template for static and temporal networks</li> <li><code>setup.js</code>: Loads requireJS and D3.js libraries</li> <li><code>styles.css</code>: Basic CSS styling for the visualizations</li> <li><code>static.js</code>: Template for static networks that initializes the network from <code>network.js</code></li> <li><code>temporal.js</code>: Template for temporal networks that initializes the network from <code>network.js</code> with temporal controls</li> <li><code>d3.v7.min.js</code>: D3.js library (version 7) for using D3.js functionalities without internet connection</li> </ul>"},{"location":"reference/pathpyG/visualisations/_d3js/backend/","title":"backend","text":"<p>D3.js backend for interactive web-based network visualization.</p> <p>Template-driven HTML generation using D3.js library for rich interactive visualizations. Supports both static and temporal networks with embedded JavaScript, and CSS styling.</p> <p>!!! abstract \"Features\":     - Interactive HTML output with drag-and-drop node movement     - Template-based architecture for extensibility     - Both static and temporal network support     - Jupyter notebook integration with inline display</p>"},{"location":"reference/pathpyG/visualisations/_d3js/backend/#pathpyG.visualisations._d3js.backend.D3jsBackend","title":"<code>D3jsBackend</code>","text":"<p>               Bases: <code>pathpyG.visualisations.plot_backend.PlotBackend</code></p> <p>D3.js backend for interactive web visualization with template system.</p> <p>Generates self-contained HTML files with embedded D3.js visualizations using modular template architecture. Supports both static and temporal networks with rich interactivity and web-standard compatibility.</p> Features <ul> <li>Template-driven HTML generation (CSS + JavaScript + data)</li> <li>Multiple output modes: standalone HTML, Jupyter display, browser</li> <li>JSON data serialization with proper type conversion</li> </ul> Example <pre><code>import pathpyG as pp\n\n# Simple network visualization\nedges = [(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"A\")]\ng = pp.Graph.from_edge_list(edges)\npp.plot(g)  # Uses d3.js backend by default\n</code></pre> <p>Template Architecture</p> <p>Uses modular templates for extensibility:</p> <ul> <li><code>styles.css</code>: Visual styling and responsive design</li> <li><code>setup.js</code>: Environment detection and D3.js loading</li> <li><code>network.js</code>: Core network visualization logic</li> <li><code>static.js</code> / <code>temporal.js</code>: Plot-type specific functionality</li> </ul> <p>Web Standards</p> <p>Generates standards-compliant HTML5 with SVG graphics, compatible with all modern browsers without plugins.</p> Source code in <code>src/pathpyG/visualisations/_d3js/backend.py</code> <pre><code>class D3jsBackend(PlotBackend):\n    \"\"\"D3.js backend for interactive web visualization with template system.\n\n    Generates self-contained HTML files with embedded D3.js visualizations\n    using modular template architecture. Supports both static and temporal\n    networks with rich interactivity and web-standard compatibility.\n\n    Features:\n        - Template-driven HTML generation (CSS + JavaScript + data)\n        - Multiple output modes: standalone HTML, Jupyter display, browser\n        - JSON data serialization with proper type conversion\n\n    Example:\n        ```python\n        import pathpyG as pp\n\n        # Simple network visualization\n        edges = [(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"A\")]\n        g = pp.Graph.from_edge_list(edges)\n        pp.plot(g)  # Uses d3.js backend by default\n        ```\n        &lt;iframe src=\"../../plot/simple_network.html\" width=\"650\" height=\"520\"&gt;&lt;/iframe&gt;\n\n    !!! info \"Template Architecture\"\n        Uses modular templates for extensibility:\n\n        - `styles.css`: Visual styling and responsive design\n        - `setup.js`: Environment detection and D3.js loading\n        - `network.js`: Core network visualization logic\n        - `static.js` / `temporal.js`: Plot-type specific functionality\n\n    !!! note \"Web Standards\"\n        Generates standards-compliant HTML5 with SVG graphics,\n        compatible with all modern browsers without plugins.\n    \"\"\"\n\n    def __init__(self, plot: PathPyPlot, show_labels: bool):\n        \"\"\"Initialize D3.js backend with plot validation and configuration.\n\n        Args:\n            plot: PathPyPlot instance (NetworkPlot or TemporalNetworkPlot)\n            show_labels: Whether to display node labels in visualization\n\n        Raises:\n            ValueError: If plot type not supported by D3.js backend\n\n        !!! tip \"Supported Plot Types\"\n            - **NetworkPlot**: Static network visualization\n            - **TemporalNetworkPlot**: Animated temporal network evolution\n        \"\"\"\n        super().__init__(plot, show_labels)\n        self._kind = SUPPORTED_KINDS.get(type(plot), None)\n        if self._kind is None:\n            logger.error(f\"Plot of type {type(plot)} not supported by D3js backend.\")\n            raise ValueError(f\"Plot of type {type(plot)} not supported.\")\n\n    def save(self, filename: str) -&gt; None:\n        \"\"\"Save interactive visualization as standalone HTML file.\n\n        Creates self-contained HTML file with embedded D3.js visualization,\n        complete with styling, JavaScript, and data. File can be opened\n        in any web browser or served from web servers.\n\n        Args:\n            filename: Output HTML file path\n\n        !!! tip \"Deployment Ready\"\n            Generated HTML files are standalone and can be:\n\n            - Opened directly in browsers\n            - Served from web servers\n            - Embedded in websites or documentation\n            - Shared without additional dependencies\n        \"\"\"\n        # Default to the CDN version of d3js since browsers may block local scripts\n        self.config[\"d3js_local\"] = self.config.get(\"d3js_local\", False)\n        with open(filename, \"w+\") as new:\n            new.write(self.to_html())\n\n    def show(self) -&gt; None:\n        \"\"\"Display visualization in appropriate environment.\n\n        Automatically detects environment and displays visualization:\n        - Jupyter notebooks: Inline HTML display with IPython widgets\n        - Scripts/terminals: Opens temporary HTML file in system browser\n\n        !!! info \"Environment Detection\"\n            Uses pathpyG config to detect interactive environment\n            and choose appropriate display method automatically.\n        \"\"\"\n        # Default to CDN version if reachable\n        # Check if CDN is reachable\n        try:\n            urllib.request.urlopen(_CDN_URL, timeout=2)\n            self.config[\"d3js_local\"] = self.config.get(\"d3js_local\", False)\n        except (urllib.error.URLError, urllib.error.HTTPError):\n            self.config[\"d3js_local\"] = self.config.get(\"d3js_local\", True)\n\n        if config[\"environment\"][\"interactive\"]:\n            from IPython.display import display_html, HTML  # noqa I001\n\n            display_html(HTML(self.to_html()))\n        else:\n            # create temporal file\n            with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n                # save html\n                self.save(filename=temp_file.name)\n                # open the file\n                webbrowser.open(r\"file:///\" + temp_file.name)\n\n    def _prepare_data(self) -&gt; dict:\n        \"\"\"Transform network data for JSON serialization and D3.js consumption.\n\n        Converts pandas DataFrames to D3.js-compatible format with proper\n        node/edge structure. Handles coordinate renaming and unique ID generation\n        for JavaScript processing.\n\n        Returns:\n            dict: Structured data with 'nodes' and 'edges' arrays\n\n        !!! note \"Data Structure\"\n            **Nodes**: Include uid, coordinates (xpos/ypos), and all attributes\n\n            **Edges**: Include uid, source/target references, and styling\n        \"\"\"\n        node_data = self.data[\"nodes\"].copy()\n        node_data[\"uid\"] = self.data[\"nodes\"].index.map(lambda x: f\"({x[0]},{x[1]})\" if isinstance(x, tuple) else str(x))\n        node_data = node_data.rename(columns={\"x\": \"xpos\", \"y\": \"ypos\"})\n        if self._kind == \"unfolded\":\n            node_data[\"ypos\"] = 1 - node_data[\"ypos\"]  # Invert y-axis for unfolded layout\n        edge_data = self.data[\"edges\"].copy()\n        edge_data[\"uid\"] = self.data[\"edges\"].index.map(lambda x: f\"{x[0]}-{x[1]}\")\n        if len(edge_data) &gt; 0:\n            edge_data[\"source\"] = edge_data.index.to_frame()[\"source\"].map(lambda x: f\"({x[0]},{x[1]})\" if isinstance(x, tuple) else str(x))\n            edge_data[\"target\"] = edge_data.index.to_frame()[\"target\"].map(lambda x: f\"({x[0]},{x[1]})\" if isinstance(x, tuple) else str(x))\n        data_dict = {\n            \"nodes\": node_data.to_dict(orient=\"records\"),\n            \"edges\": edge_data.to_dict(orient=\"records\"),\n        }\n        return data_dict\n\n    def _prepare_config(self) -&gt; dict:\n        \"\"\"Transform configuration for JavaScript compatibility.\n\n        Converts pathpyG configuration to web-compatible format with proper\n        color conversion, unit normalization, and JavaScript-friendly types.\n\n        Returns:\n            dict: Web-compatible configuration object\n\n        !!! info \"Configuration Processing\"\n            - **Colors**: Convert to hex format for CSS compatibility\n            - **Units**: Convert to pixels for SVG rendering\n            - **Types**: Ensure JSON-serializable data types\n        \"\"\"\n        config = deepcopy(self.config)\n        config[\"node\"][\"color\"] = rgb_to_hex(self.config[\"node\"][\"color\"])\n        config[\"edge\"][\"color\"] = rgb_to_hex(self.config[\"edge\"][\"color\"])\n        config[\"width\"] = unit_str_to_float(self.config[\"width\"], \"px\")\n        config[\"height\"] = unit_str_to_float(self.config[\"height\"], \"px\")\n        config[\"show_labels\"] = self.show_labels\n        return config\n\n    def to_json(self) -&gt; tuple[str, str]:\n        \"\"\"Serialize network data and configuration to JSON strings.\n\n        Processes both data and configuration through preparation methods\n        and converts to JSON format suitable for JavaScript consumption.\n\n        Returns:\n            tuple: (data_json, config_json) string pair for template injection\n\n        !!! tip \"Template Integration\"\n            JSON strings are injected directly into JavaScript templates\n            as `const data = {...}` and `const config = {...}` declarations.\n        \"\"\"\n        data_dict = self._prepare_data()\n        config_dict = self._prepare_config()\n        return json.dumps(data_dict), json.dumps(config_dict)\n\n    def to_html(self) -&gt; str:\n        \"\"\"Generate complete standalone HTML visualization.\n\n        Assembles full HTML document using template system with embedded CSS,\n        JavaScript, and data. Creates unique DOM IDs to prevent conflicts\n        when multiple visualizations exist on same page.\n\n        Returns:\n            str: Complete HTML document with embedded visualization\n\n        !!! info \"HTML Structure\"\n            1. **CSS Styles**: Embedded styling\n            2. **DOM Container**: Unique div element for visualization\n            3. **D3.js Library**: CDN or local library loading\n            4. **Setup Code**: Environment detection and module loading\n            5. **Data/Config**: JSON-serialized network and configuration\n            6. **Visualization**: Plot-specific JavaScript execution\n\n        !!! note \"Library Loading\"\n            Supports both CDN and local (default) D3.js library embedding\n            based on `d3js_local` configuration parameter.\n        \"\"\"\n        # generate unique dom uids\n        dom_id = \"#x\" + uuid.uuid4().hex\n\n        # get path to the pathpy templates\n        template_dir = os.path.join(\n            os.path.dirname(os.path.dirname(__file__)),\n            os.path.normpath(\"_d3js/templates\"),\n        )\n\n        # get d3js library path\n        if self.config.get(\"d3js_local\", False):\n            d3js = os.path.join(template_dir, \"d3.v7.min.js\")\n        else:\n            d3js = _CDN_URL\n\n        js_template = self.get_template(template_dir)\n\n        with open(os.path.join(template_dir, \"setup.js\")) as template:\n            setup_template = template.read()\n\n        with open(os.path.join(template_dir, \"styles.css\")) as template:\n            css_template = template.read()\n\n        # update config\n        self.config[\"selector\"] = dom_id\n        data_json, config_json = self.to_json()\n\n        # generate html file\n        html = \"&lt;style&gt;\\n\" + css_template + \"\\n&lt;/style&gt;\\n\"\n\n        # div environment for the plot object\n        html += f'\\n&lt;div id = \"{dom_id[1:]}\"&gt; &lt;/div&gt;\\n'\n\n        # add d3js library\n        html += f'&lt;script charset=\"utf-8\" src=\"{d3js}\"&gt;&lt;/script&gt;\\n'\n\n        # start JavaScript\n        html += '&lt;script charset=\"utf-8\"&gt;\\n'\n\n        # add setup code to run d3js in multiple environments\n        html += Template(setup_template).substitute(d3js=d3js)\n\n        # start d3 environment\n        html += \"require(['d3'], function(d3){ //START\\n\"\n\n        # add data and config\n        html += f\"const data = {data_json}\\n\"\n        html += f\"const config = {config_json}\\n\"\n\n        # add log print\n        html += f\"console.log('{self._kind} Network Template');\\n\"\n\n        # add JavaScript\n        html += js_template\n\n        # end d3 environment\n        html += \"\\n}); //END\\n\"\n\n        # end JavaScript\n        html += \"\\n&lt;/script&gt;\"\n\n        return html\n\n    def get_template(self, template_dir: str) -&gt; str:\n        \"\"\"Load and combine JavaScript templates for visualization.\n\n        Assembles modular JavaScript code by combining core network\n        functionality with plot-type specific features. Enables clean\n        separation of concerns and extensible template architecture.\n\n        Args:\n            template_dir: Directory containing JavaScript template files\n\n        Returns:\n            str: Combined JavaScript code for visualization\n\n        !!! info \"Template Composition\"\n            **Core Template** (`network.js`): Base network visualization logic\n\n            **Plot Templates**: Type-specific functionality:\n\n            - `static.js`: Force simulation and interaction for static networks\n            - `temporal.js`: Timeline controls and animation for temporal networks\n\n        !!! tip \"Extensibility\"\n            New plot types can be added by creating additional\n            JavaScript templates following the established patterns.\n        \"\"\"\n        js_template = \"\"\n        with open(os.path.join(template_dir, \"network.js\")) as template:\n            js_template += template.read()\n\n        with open(\n            os.path.join(template_dir, \"static.js\" if self._kind == \"unfolded\" else f\"{self._kind}.js\")\n        ) as template:\n            js_template += template.read()\n\n        return js_template\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_d3js/backend/#pathpyG.visualisations._d3js.backend.D3jsBackend.__init__","title":"<code>__init__</code>","text":"<p>Initialize D3.js backend with plot validation and configuration.</p> <p>Parameters:</p> Name Type Description Default <code>plot</code> <code>pathpyG.visualisations.pathpy_plot.PathPyPlot</code> <p>PathPyPlot instance (NetworkPlot or TemporalNetworkPlot)</p> required <code>show_labels</code> <code>bool</code> <p>Whether to display node labels in visualization</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If plot type not supported by D3.js backend</p> <p>Supported Plot Types</p> <ul> <li>NetworkPlot: Static network visualization</li> <li>TemporalNetworkPlot: Animated temporal network evolution</li> </ul> Source code in <code>src/pathpyG/visualisations/_d3js/backend.py</code> <pre><code>def __init__(self, plot: PathPyPlot, show_labels: bool):\n    \"\"\"Initialize D3.js backend with plot validation and configuration.\n\n    Args:\n        plot: PathPyPlot instance (NetworkPlot or TemporalNetworkPlot)\n        show_labels: Whether to display node labels in visualization\n\n    Raises:\n        ValueError: If plot type not supported by D3.js backend\n\n    !!! tip \"Supported Plot Types\"\n        - **NetworkPlot**: Static network visualization\n        - **TemporalNetworkPlot**: Animated temporal network evolution\n    \"\"\"\n    super().__init__(plot, show_labels)\n    self._kind = SUPPORTED_KINDS.get(type(plot), None)\n    if self._kind is None:\n        logger.error(f\"Plot of type {type(plot)} not supported by D3js backend.\")\n        raise ValueError(f\"Plot of type {type(plot)} not supported.\")\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_d3js/backend/#pathpyG.visualisations._d3js.backend.D3jsBackend.get_template","title":"<code>get_template</code>","text":"<p>Load and combine JavaScript templates for visualization.</p> <p>Assembles modular JavaScript code by combining core network functionality with plot-type specific features. Enables clean separation of concerns and extensible template architecture.</p> <p>Parameters:</p> Name Type Description Default <code>template_dir</code> <code>str</code> <p>Directory containing JavaScript template files</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Combined JavaScript code for visualization</p> <p>Template Composition</p> <p>Core Template (<code>network.js</code>): Base network visualization logic</p> <p>Plot Templates: Type-specific functionality:</p> <ul> <li><code>static.js</code>: Force simulation and interaction for static networks</li> <li><code>temporal.js</code>: Timeline controls and animation for temporal networks</li> </ul> <p>Extensibility</p> <p>New plot types can be added by creating additional JavaScript templates following the established patterns.</p> Source code in <code>src/pathpyG/visualisations/_d3js/backend.py</code> <pre><code>def get_template(self, template_dir: str) -&gt; str:\n    \"\"\"Load and combine JavaScript templates for visualization.\n\n    Assembles modular JavaScript code by combining core network\n    functionality with plot-type specific features. Enables clean\n    separation of concerns and extensible template architecture.\n\n    Args:\n        template_dir: Directory containing JavaScript template files\n\n    Returns:\n        str: Combined JavaScript code for visualization\n\n    !!! info \"Template Composition\"\n        **Core Template** (`network.js`): Base network visualization logic\n\n        **Plot Templates**: Type-specific functionality:\n\n        - `static.js`: Force simulation and interaction for static networks\n        - `temporal.js`: Timeline controls and animation for temporal networks\n\n    !!! tip \"Extensibility\"\n        New plot types can be added by creating additional\n        JavaScript templates following the established patterns.\n    \"\"\"\n    js_template = \"\"\n    with open(os.path.join(template_dir, \"network.js\")) as template:\n        js_template += template.read()\n\n    with open(\n        os.path.join(template_dir, \"static.js\" if self._kind == \"unfolded\" else f\"{self._kind}.js\")\n    ) as template:\n        js_template += template.read()\n\n    return js_template\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_d3js/backend/#pathpyG.visualisations._d3js.backend.D3jsBackend.save","title":"<code>save</code>","text":"<p>Save interactive visualization as standalone HTML file.</p> <p>Creates self-contained HTML file with embedded D3.js visualization, complete with styling, JavaScript, and data. File can be opened in any web browser or served from web servers.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Output HTML file path</p> required <p>Deployment Ready</p> <p>Generated HTML files are standalone and can be:</p> <ul> <li>Opened directly in browsers</li> <li>Served from web servers</li> <li>Embedded in websites or documentation</li> <li>Shared without additional dependencies</li> </ul> Source code in <code>src/pathpyG/visualisations/_d3js/backend.py</code> <pre><code>def save(self, filename: str) -&gt; None:\n    \"\"\"Save interactive visualization as standalone HTML file.\n\n    Creates self-contained HTML file with embedded D3.js visualization,\n    complete with styling, JavaScript, and data. File can be opened\n    in any web browser or served from web servers.\n\n    Args:\n        filename: Output HTML file path\n\n    !!! tip \"Deployment Ready\"\n        Generated HTML files are standalone and can be:\n\n        - Opened directly in browsers\n        - Served from web servers\n        - Embedded in websites or documentation\n        - Shared without additional dependencies\n    \"\"\"\n    # Default to the CDN version of d3js since browsers may block local scripts\n    self.config[\"d3js_local\"] = self.config.get(\"d3js_local\", False)\n    with open(filename, \"w+\") as new:\n        new.write(self.to_html())\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_d3js/backend/#pathpyG.visualisations._d3js.backend.D3jsBackend.show","title":"<code>show</code>","text":"<p>Display visualization in appropriate environment.</p> <p>Automatically detects environment and displays visualization: - Jupyter notebooks: Inline HTML display with IPython widgets - Scripts/terminals: Opens temporary HTML file in system browser</p> <p>Environment Detection</p> <p>Uses pathpyG config to detect interactive environment and choose appropriate display method automatically.</p> Source code in <code>src/pathpyG/visualisations/_d3js/backend.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Display visualization in appropriate environment.\n\n    Automatically detects environment and displays visualization:\n    - Jupyter notebooks: Inline HTML display with IPython widgets\n    - Scripts/terminals: Opens temporary HTML file in system browser\n\n    !!! info \"Environment Detection\"\n        Uses pathpyG config to detect interactive environment\n        and choose appropriate display method automatically.\n    \"\"\"\n    # Default to CDN version if reachable\n    # Check if CDN is reachable\n    try:\n        urllib.request.urlopen(_CDN_URL, timeout=2)\n        self.config[\"d3js_local\"] = self.config.get(\"d3js_local\", False)\n    except (urllib.error.URLError, urllib.error.HTTPError):\n        self.config[\"d3js_local\"] = self.config.get(\"d3js_local\", True)\n\n    if config[\"environment\"][\"interactive\"]:\n        from IPython.display import display_html, HTML  # noqa I001\n\n        display_html(HTML(self.to_html()))\n    else:\n        # create temporal file\n        with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n            # save html\n            self.save(filename=temp_file.name)\n            # open the file\n            webbrowser.open(r\"file:///\" + temp_file.name)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_d3js/backend/#pathpyG.visualisations._d3js.backend.D3jsBackend.to_html","title":"<code>to_html</code>","text":"<p>Generate complete standalone HTML visualization.</p> <p>Assembles full HTML document using template system with embedded CSS, JavaScript, and data. Creates unique DOM IDs to prevent conflicts when multiple visualizations exist on same page.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Complete HTML document with embedded visualization</p> <p>HTML Structure</p> <ol> <li>CSS Styles: Embedded styling</li> <li>DOM Container: Unique div element for visualization</li> <li>D3.js Library: CDN or local library loading</li> <li>Setup Code: Environment detection and module loading</li> <li>Data/Config: JSON-serialized network and configuration</li> <li>Visualization: Plot-specific JavaScript execution</li> </ol> <p>Library Loading</p> <p>Supports both CDN and local (default) D3.js library embedding based on <code>d3js_local</code> configuration parameter.</p> Source code in <code>src/pathpyG/visualisations/_d3js/backend.py</code> <pre><code>def to_html(self) -&gt; str:\n    \"\"\"Generate complete standalone HTML visualization.\n\n    Assembles full HTML document using template system with embedded CSS,\n    JavaScript, and data. Creates unique DOM IDs to prevent conflicts\n    when multiple visualizations exist on same page.\n\n    Returns:\n        str: Complete HTML document with embedded visualization\n\n    !!! info \"HTML Structure\"\n        1. **CSS Styles**: Embedded styling\n        2. **DOM Container**: Unique div element for visualization\n        3. **D3.js Library**: CDN or local library loading\n        4. **Setup Code**: Environment detection and module loading\n        5. **Data/Config**: JSON-serialized network and configuration\n        6. **Visualization**: Plot-specific JavaScript execution\n\n    !!! note \"Library Loading\"\n        Supports both CDN and local (default) D3.js library embedding\n        based on `d3js_local` configuration parameter.\n    \"\"\"\n    # generate unique dom uids\n    dom_id = \"#x\" + uuid.uuid4().hex\n\n    # get path to the pathpy templates\n    template_dir = os.path.join(\n        os.path.dirname(os.path.dirname(__file__)),\n        os.path.normpath(\"_d3js/templates\"),\n    )\n\n    # get d3js library path\n    if self.config.get(\"d3js_local\", False):\n        d3js = os.path.join(template_dir, \"d3.v7.min.js\")\n    else:\n        d3js = _CDN_URL\n\n    js_template = self.get_template(template_dir)\n\n    with open(os.path.join(template_dir, \"setup.js\")) as template:\n        setup_template = template.read()\n\n    with open(os.path.join(template_dir, \"styles.css\")) as template:\n        css_template = template.read()\n\n    # update config\n    self.config[\"selector\"] = dom_id\n    data_json, config_json = self.to_json()\n\n    # generate html file\n    html = \"&lt;style&gt;\\n\" + css_template + \"\\n&lt;/style&gt;\\n\"\n\n    # div environment for the plot object\n    html += f'\\n&lt;div id = \"{dom_id[1:]}\"&gt; &lt;/div&gt;\\n'\n\n    # add d3js library\n    html += f'&lt;script charset=\"utf-8\" src=\"{d3js}\"&gt;&lt;/script&gt;\\n'\n\n    # start JavaScript\n    html += '&lt;script charset=\"utf-8\"&gt;\\n'\n\n    # add setup code to run d3js in multiple environments\n    html += Template(setup_template).substitute(d3js=d3js)\n\n    # start d3 environment\n    html += \"require(['d3'], function(d3){ //START\\n\"\n\n    # add data and config\n    html += f\"const data = {data_json}\\n\"\n    html += f\"const config = {config_json}\\n\"\n\n    # add log print\n    html += f\"console.log('{self._kind} Network Template');\\n\"\n\n    # add JavaScript\n    html += js_template\n\n    # end d3 environment\n    html += \"\\n}); //END\\n\"\n\n    # end JavaScript\n    html += \"\\n&lt;/script&gt;\"\n\n    return html\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_d3js/backend/#pathpyG.visualisations._d3js.backend.D3jsBackend.to_json","title":"<code>to_json</code>","text":"<p>Serialize network data and configuration to JSON strings.</p> <p>Processes both data and configuration through preparation methods and converts to JSON format suitable for JavaScript consumption.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[str, str]</code> <p>(data_json, config_json) string pair for template injection</p> <p>Template Integration</p> <p>JSON strings are injected directly into JavaScript templates as <code>const data = {...}</code> and <code>const config = {...}</code> declarations.</p> Source code in <code>src/pathpyG/visualisations/_d3js/backend.py</code> <pre><code>def to_json(self) -&gt; tuple[str, str]:\n    \"\"\"Serialize network data and configuration to JSON strings.\n\n    Processes both data and configuration through preparation methods\n    and converts to JSON format suitable for JavaScript consumption.\n\n    Returns:\n        tuple: (data_json, config_json) string pair for template injection\n\n    !!! tip \"Template Integration\"\n        JSON strings are injected directly into JavaScript templates\n        as `const data = {...}` and `const config = {...}` declarations.\n    \"\"\"\n    data_dict = self._prepare_data()\n    config_dict = self._prepare_config()\n    return json.dumps(data_dict), json.dumps(config_dict)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_manim/","title":"manim","text":"<p>Manim Backend for PathpyG Visualizations.</p> <p>High-quality animation backend using Manim for temporal networks and dynamic visualizations. Perfect for creating engaging presentations, educational content, and scientific animations.</p> <p>Output Formats</p> <ul> <li>MP4: High-quality video animations for presentations</li> <li>GIF: Animated graphics for web and social media</li> </ul> <p>Requirements</p> <ul> <li>Manim Community Edition (<code>pip install manim</code>)</li> <li>FFmpeg for video rendering</li> <li>LaTeX distribution for mathematical text</li> </ul>"},{"location":"reference/pathpyG/visualisations/_manim/#pathpyG.visualisations._manim--basic-usage","title":"Basic Usage","text":"<pre><code>import pathpyG as pp\n\n# Simple temporal network animation\ntedges = [(\"a\", \"b\", 1), (\"b\", \"c\", 2), (\"c\", \"a\", 3)]\ntg = pp.TemporalGraph.from_edge_list(tedges)\npp.plot(tg, backend=\"manim\", filename=\"temporal_network.mp4\")\n</code></pre>    Your browser does not support the video tag."},{"location":"reference/pathpyG/visualisations/_manim/#pathpyG.visualisations._manim--advanced-example","title":"Advanced Example","text":"<pre><code>import pathpyG as pp\n\n# Temporal network with evolving properties\ntedges = [\n    (\"a\", \"b\", 1), (\"b\", \"c\", 1),\n    (\"c\", \"d\", 2), (\"d\", \"a\", 2), \n    (\"a\", \"c\", 3), (\"b\", \"d\", 3)\n]\ntg = pp.TemporalGraph.from_edge_list(tedges)\n\npp.plot(\n    tg,\n    backend=\"manim\",\n    delta=2000,                    # 2 seconds per timestep\n    node_size={(\"a\", 1): 20, (\"b\", 2): 7},\n    node_color=[\"red\", \"blue\", \"green\", \"orange\"],\n    edge_opacity=0.7,\n    edge_color={(\"a\", \"b\", 1): \"purple\", (\"c\", \"d\", 2): \"orange\"},\n    filename=\"dynamic_network.mp4\"\n)\n</code></pre>    Your browser does not support the video tag.  <p>Rendering Time</p> <p>High-quality animations can take significant time to render. A 60-second animation of a medium-sized network at high quality  may take 5-30 minutes depending on the hardware specifications.</p>"},{"location":"reference/pathpyG/visualisations/_manim/backend/","title":"backend","text":"<p>Manim backend for high-quality temporal network animations.</p> <p>Professional animation backend using Manim Community Edition for creating high-quality temporal network visualizations. Optimized for temporal graphs with smooth transitions and customizable animation parameters.</p> Features <ul> <li>High-quality video output (MP4, GIF)</li> <li>Temporal network animation with smooth transitions</li> <li>Jupyter notebook integration with inline video display</li> <li>FFmpeg integration for format conversion</li> </ul>"},{"location":"reference/pathpyG/visualisations/_manim/backend/#pathpyG.visualisations._manim.backend--workflow-overview","title":"Workflow Overview","text":"<pre><code>graph LR\n    A[Graph Data] --&gt; B[Manim Scene Creation]\n    B --&gt; C[Rendering]\n    C --&gt; D[MP4 Output]\n    D --&gt; E[Conversion]\n    E --&gt; F[GIF Output]</code></pre>"},{"location":"reference/pathpyG/visualisations/_manim/backend/#pathpyG.visualisations._manim.backend.ManimBackend","title":"<code>ManimBackend</code>","text":"<p>               Bases: <code>pathpyG.visualisations.plot_backend.PlotBackend</code></p> <p>Manim backend for temporal network animation.</p> <p>Integrates Manim Community Edition for creating smooth temporal network animations. Supports both MP4 and GIF output formats with Jupyter notebook integration for inline display.</p> Features <ul> <li>Temporal network animation with smooth node/edge transitions</li> <li>Multiple output formats (MP4, GIF via FFmpeg)</li> <li>Jupyter integration with base64 video embedding</li> </ul> Example <p>Create and display a simple temporal network animation: <pre><code>import pathpyG as pp\n\ntedges = [(\"a\", \"b\", 1), (\"b\", \"c\", 2), (\"c\", \"a\", 3)]\ntg = pp.TemporalGraph.from_edge_list(tedges)\npp.plot(tg, backend=\"manim\", filename=\"temporal_network.gif\")\n</code></pre> </p> <p>Temporal Networks Only</p> <p>This backend is specifically designed for TemporalNetworkPlot objects and does not support static network visualization.</p> <p>Performance Requirements</p> <p>High-quality animations require significant computational resources. Rendering time scales with network size, animation duration, and quality settings.</p> Source code in <code>src/pathpyG/visualisations/_manim/backend.py</code> <pre><code>class ManimBackend(PlotBackend):\n    \"\"\"Manim backend for temporal network animation.\n\n    Integrates Manim Community Edition for creating smooth temporal network\n    animations. Supports both MP4 and GIF output formats with Jupyter notebook\n    integration for inline display.\n\n    Features:\n        - Temporal network animation with smooth node/edge transitions\n        - Multiple output formats (MP4, GIF via FFmpeg)\n        - Jupyter integration with base64 video embedding\n\n    Example:\n        Create and display a simple temporal network animation:\n        ```python\n        import pathpyG as pp\n\n        tedges = [(\"a\", \"b\", 1), (\"b\", \"c\", 2), (\"c\", \"a\", 3)]\n        tg = pp.TemporalGraph.from_edge_list(tedges)\n        pp.plot(tg, backend=\"manim\", filename=\"temporal_network.gif\")\n        ```\n        &lt;img src=\"../../plot/temporal_network.gif\" alt=\"Example Matplotlib Backend Output\" width=\"550\"/&gt;\n\n    !!! note \"Temporal Networks Only\"\n        This backend is specifically designed for TemporalNetworkPlot\n        objects and does not support static network visualization.\n\n    !!! warning \"Performance Requirements\"\n        High-quality animations require significant computational resources.\n        Rendering time scales with network size, animation duration, and quality settings.\n    \"\"\"\n\n    def __init__(self, plot: PathPyPlot, show_labels: bool):\n        \"\"\"Initialize Manim backend with temporal network validation and configuration.\n\n        Sets up Manim configuration parameters including resolution, frame rate,\n        quality settings, and background color. Validates that the plot type\n        is supported (currently only TemporalNetworkPlot).\n\n        Args:\n            plot: PathPyPlot instance (must be TemporalNetworkPlot)\n            show_labels: Whether to display node labels in animation\n\n        Raises:\n            ValueError: If plot type is not supported by Manim backend\n\n        !!! info \"Manim Configuration\"\n            Automatically configures Manim settings using pathpyG config and fixed defaults:\n\n            - **Resolution**: From width/height config parameters\n            - **Frame Rate**: Default 15 fps for smooth playback\n            - **Quality**: High quality\n            - **Background**: White background for clarity\n        \"\"\"\n        super().__init__(plot, show_labels=show_labels)\n        self._kind = SUPPORTED_KINDS.get(type(plot), None)\n        if self._kind is None:\n            logger.error(f\"Plot of type {type(plot)} not supported by Matplotlib backend.\")\n            raise ValueError(f\"Plot of type {type(plot)} not supported.\")\n\n        # Optional config settings\n        manim_config.pixel_height = int(unit_str_to_float(self.config.get(\"height\"), \"px\"))  # type: ignore[arg-type]\n        manim_config.pixel_width = int(unit_str_to_float(self.config.get(\"width\"), \"px\"))  # type: ignore[arg-type]\n        manim_config.quality = \"high_quality\"\n        manim_config.background_color = WHITE\n\n    def render_video(self) -&gt; tuple[Path, str]:\n        \"\"\"Render temporal network animation using Manim engine.\n\n        Creates temporary directory, configures Manim settings, instantiates\n        TemporalGraphScene, and renders the complete animation sequence.\n        Handles all Manim-specific setup and teardown.\n\n        Returns:\n            tuple: (video_file_path, temp_directory_path) for post-processing\n\n        !!! info \"Rendering Pipeline\"\n            1. **Setup**: Create temporary directory for Manim output\n            2. **Configuration**: Set output path and filename\n            3. **Scene Creation**: Instantiate TemporalGraphScene with data\n            4. **Rendering**: Execute Manim rendering process\n            5. **Cleanup**: Return paths for further processing and returns to original directory\n        \"\"\"\n        temp_dir, current_dir = prepare_tempfile()\n        manim_config.media_dir = temp_dir\n        manim_config.output_file = \"default.mp4\"\n        self.scene = TemporalGraphScene(data=self.data, config=self.config, show_labels=self.show_labels)\n        self.scene.render()\n        os.chdir(current_dir)\n        return Path(temp_dir) / \"videos\" / \"1080p60\" / \"default.mp4\", temp_dir\n\n    def save(self, filename: str) -&gt; None:\n        \"\"\"Render and save temporal network animation to specified file.\n\n        Creates high-quality animation video and saves to disk. Supports both\n        MP4 and GIF formats with automatic format detection from filename\n        extension. GIF conversion uses FFmpeg.\n\n        Args:\n            filename: Output file path with extension (.mp4 or .gif)\n\n        !!! warning \"GIF Conversion\"\n            GIF creation requires FFmpeg to be installed and available in PATH.\n            Conversion may take additional time for long animations.\n        \"\"\"\n        # render temporary .mp4\n        temp_file, temp_dir = self.render_video()\n        if filename.endswith(\".gif\"):\n            self.convert_to_gif(temp_file)\n            temp_file = temp_file.with_suffix(\".gif\")\n        shutil.copy(temp_file, filename)\n        shutil.rmtree(temp_dir)\n\n    def convert_to_gif(self, filename: Path) -&gt; None:\n        \"\"\"Convert rendered MP4 video to animated GIF using FFmpeg.\n\n        Uses FFmpeg with optimized settings for web-friendly GIF output:\n        30 fps for smooth animation, Lanczos scaling for quality preservation,\n        and 1080p resolution maintenance.\n\n        Args:\n            filename: Path to source MP4 file (output GIF uses same path with .gif extension)\n\n        Raises:\n            Exception: If FFmpeg conversion fails (logged as error)\n        \"\"\"\n        try:\n            subprocess.run(\n                [\n                    \"ffmpeg\",\n                    \"-i\",\n                    filename,\n                    \"-vf\",\n                    \"fps=30,scale=1080:-1:flags=lanczos\",\n                    \"-y\",\n                    \"-hide_banner\",\n                    \"-loglevel\",\n                    \"error\",\n                    filename.with_suffix(\".gif\"),\n                ],\n                check=True,\n            )\n        except Exception as e:\n            logger.error(f\"GIF conversion failed: {e}\")\n\n    def show(self) -&gt; None:\n        \"\"\"Display temporal network animation in interactive environment.\n\n        Renders animation and displays inline in Jupyter notebooks using base64\n        video embedding, or opens in system browser for non-interactive environments.\n        Automatically cleans up temporary files after display.\n        \"\"\"\n        temp_file, temp_dir = self.render_video()\n\n        if config[\"environment\"][\"interactive\"]:\n            from IPython.display import HTML, display\n\n            video_bytes = temp_file.read_bytes()\n            video_b64 = base64.b64encode(video_bytes).decode()\n            video_html = f\"\"\"\n            &lt;video width=\"580\" height=\"340\" controls&gt;\n                &lt;source src=\"data:video/mp4;base64,{video_b64}\" type=\"video/mp4\"&gt;\n                Your browser does not support the video tag.\n            &lt;/video&gt;\n            \"\"\"\n            display(HTML(video_html))\n        else:\n            # open the file in the webbrowser\n            webbrowser.open(r\"file:///\" + temp_file.as_posix())\n        shutil.rmtree(temp_dir)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_manim/backend/#pathpyG.visualisations._manim.backend.ManimBackend.__init__","title":"<code>__init__</code>","text":"<p>Initialize Manim backend with temporal network validation and configuration.</p> <p>Sets up Manim configuration parameters including resolution, frame rate, quality settings, and background color. Validates that the plot type is supported (currently only TemporalNetworkPlot).</p> <p>Parameters:</p> Name Type Description Default <code>plot</code> <code>pathpyG.visualisations.pathpy_plot.PathPyPlot</code> <p>PathPyPlot instance (must be TemporalNetworkPlot)</p> required <code>show_labels</code> <code>bool</code> <p>Whether to display node labels in animation</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If plot type is not supported by Manim backend</p> <p>Manim Configuration</p> <p>Automatically configures Manim settings using pathpyG config and fixed defaults:</p> <ul> <li>Resolution: From width/height config parameters</li> <li>Frame Rate: Default 15 fps for smooth playback</li> <li>Quality: High quality</li> <li>Background: White background for clarity</li> </ul> Source code in <code>src/pathpyG/visualisations/_manim/backend.py</code> <pre><code>def __init__(self, plot: PathPyPlot, show_labels: bool):\n    \"\"\"Initialize Manim backend with temporal network validation and configuration.\n\n    Sets up Manim configuration parameters including resolution, frame rate,\n    quality settings, and background color. Validates that the plot type\n    is supported (currently only TemporalNetworkPlot).\n\n    Args:\n        plot: PathPyPlot instance (must be TemporalNetworkPlot)\n        show_labels: Whether to display node labels in animation\n\n    Raises:\n        ValueError: If plot type is not supported by Manim backend\n\n    !!! info \"Manim Configuration\"\n        Automatically configures Manim settings using pathpyG config and fixed defaults:\n\n        - **Resolution**: From width/height config parameters\n        - **Frame Rate**: Default 15 fps for smooth playback\n        - **Quality**: High quality\n        - **Background**: White background for clarity\n    \"\"\"\n    super().__init__(plot, show_labels=show_labels)\n    self._kind = SUPPORTED_KINDS.get(type(plot), None)\n    if self._kind is None:\n        logger.error(f\"Plot of type {type(plot)} not supported by Matplotlib backend.\")\n        raise ValueError(f\"Plot of type {type(plot)} not supported.\")\n\n    # Optional config settings\n    manim_config.pixel_height = int(unit_str_to_float(self.config.get(\"height\"), \"px\"))  # type: ignore[arg-type]\n    manim_config.pixel_width = int(unit_str_to_float(self.config.get(\"width\"), \"px\"))  # type: ignore[arg-type]\n    manim_config.quality = \"high_quality\"\n    manim_config.background_color = WHITE\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_manim/backend/#pathpyG.visualisations._manim.backend.ManimBackend.convert_to_gif","title":"<code>convert_to_gif</code>","text":"<p>Convert rendered MP4 video to animated GIF using FFmpeg.</p> <p>Uses FFmpeg with optimized settings for web-friendly GIF output: 30 fps for smooth animation, Lanczos scaling for quality preservation, and 1080p resolution maintenance.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>pathlib.Path</code> <p>Path to source MP4 file (output GIF uses same path with .gif extension)</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If FFmpeg conversion fails (logged as error)</p> Source code in <code>src/pathpyG/visualisations/_manim/backend.py</code> <pre><code>def convert_to_gif(self, filename: Path) -&gt; None:\n    \"\"\"Convert rendered MP4 video to animated GIF using FFmpeg.\n\n    Uses FFmpeg with optimized settings for web-friendly GIF output:\n    30 fps for smooth animation, Lanczos scaling for quality preservation,\n    and 1080p resolution maintenance.\n\n    Args:\n        filename: Path to source MP4 file (output GIF uses same path with .gif extension)\n\n    Raises:\n        Exception: If FFmpeg conversion fails (logged as error)\n    \"\"\"\n    try:\n        subprocess.run(\n            [\n                \"ffmpeg\",\n                \"-i\",\n                filename,\n                \"-vf\",\n                \"fps=30,scale=1080:-1:flags=lanczos\",\n                \"-y\",\n                \"-hide_banner\",\n                \"-loglevel\",\n                \"error\",\n                filename.with_suffix(\".gif\"),\n            ],\n            check=True,\n        )\n    except Exception as e:\n        logger.error(f\"GIF conversion failed: {e}\")\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_manim/backend/#pathpyG.visualisations._manim.backend.ManimBackend.render_video","title":"<code>render_video</code>","text":"<p>Render temporal network animation using Manim engine.</p> <p>Creates temporary directory, configures Manim settings, instantiates TemporalGraphScene, and renders the complete animation sequence. Handles all Manim-specific setup and teardown.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[pathlib.Path, str]</code> <p>(video_file_path, temp_directory_path) for post-processing</p> <p>Rendering Pipeline</p> <ol> <li>Setup: Create temporary directory for Manim output</li> <li>Configuration: Set output path and filename</li> <li>Scene Creation: Instantiate TemporalGraphScene with data</li> <li>Rendering: Execute Manim rendering process</li> <li>Cleanup: Return paths for further processing and returns to original directory</li> </ol> Source code in <code>src/pathpyG/visualisations/_manim/backend.py</code> <pre><code>def render_video(self) -&gt; tuple[Path, str]:\n    \"\"\"Render temporal network animation using Manim engine.\n\n    Creates temporary directory, configures Manim settings, instantiates\n    TemporalGraphScene, and renders the complete animation sequence.\n    Handles all Manim-specific setup and teardown.\n\n    Returns:\n        tuple: (video_file_path, temp_directory_path) for post-processing\n\n    !!! info \"Rendering Pipeline\"\n        1. **Setup**: Create temporary directory for Manim output\n        2. **Configuration**: Set output path and filename\n        3. **Scene Creation**: Instantiate TemporalGraphScene with data\n        4. **Rendering**: Execute Manim rendering process\n        5. **Cleanup**: Return paths for further processing and returns to original directory\n    \"\"\"\n    temp_dir, current_dir = prepare_tempfile()\n    manim_config.media_dir = temp_dir\n    manim_config.output_file = \"default.mp4\"\n    self.scene = TemporalGraphScene(data=self.data, config=self.config, show_labels=self.show_labels)\n    self.scene.render()\n    os.chdir(current_dir)\n    return Path(temp_dir) / \"videos\" / \"1080p60\" / \"default.mp4\", temp_dir\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_manim/backend/#pathpyG.visualisations._manim.backend.ManimBackend.save","title":"<code>save</code>","text":"<p>Render and save temporal network animation to specified file.</p> <p>Creates high-quality animation video and saves to disk. Supports both MP4 and GIF formats with automatic format detection from filename extension. GIF conversion uses FFmpeg.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Output file path with extension (.mp4 or .gif)</p> required <p>GIF Conversion</p> <p>GIF creation requires FFmpeg to be installed and available in PATH. Conversion may take additional time for long animations.</p> Source code in <code>src/pathpyG/visualisations/_manim/backend.py</code> <pre><code>def save(self, filename: str) -&gt; None:\n    \"\"\"Render and save temporal network animation to specified file.\n\n    Creates high-quality animation video and saves to disk. Supports both\n    MP4 and GIF formats with automatic format detection from filename\n    extension. GIF conversion uses FFmpeg.\n\n    Args:\n        filename: Output file path with extension (.mp4 or .gif)\n\n    !!! warning \"GIF Conversion\"\n        GIF creation requires FFmpeg to be installed and available in PATH.\n        Conversion may take additional time for long animations.\n    \"\"\"\n    # render temporary .mp4\n    temp_file, temp_dir = self.render_video()\n    if filename.endswith(\".gif\"):\n        self.convert_to_gif(temp_file)\n        temp_file = temp_file.with_suffix(\".gif\")\n    shutil.copy(temp_file, filename)\n    shutil.rmtree(temp_dir)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_manim/backend/#pathpyG.visualisations._manim.backend.ManimBackend.show","title":"<code>show</code>","text":"<p>Display temporal network animation in interactive environment.</p> <p>Renders animation and displays inline in Jupyter notebooks using base64 video embedding, or opens in system browser for non-interactive environments. Automatically cleans up temporary files after display.</p> Source code in <code>src/pathpyG/visualisations/_manim/backend.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Display temporal network animation in interactive environment.\n\n    Renders animation and displays inline in Jupyter notebooks using base64\n    video embedding, or opens in system browser for non-interactive environments.\n    Automatically cleans up temporary files after display.\n    \"\"\"\n    temp_file, temp_dir = self.render_video()\n\n    if config[\"environment\"][\"interactive\"]:\n        from IPython.display import HTML, display\n\n        video_bytes = temp_file.read_bytes()\n        video_b64 = base64.b64encode(video_bytes).decode()\n        video_html = f\"\"\"\n        &lt;video width=\"580\" height=\"340\" controls&gt;\n            &lt;source src=\"data:video/mp4;base64,{video_b64}\" type=\"video/mp4\"&gt;\n            Your browser does not support the video tag.\n        &lt;/video&gt;\n        \"\"\"\n        display(HTML(video_html))\n    else:\n        # open the file in the webbrowser\n        webbrowser.open(r\"file:///\" + temp_file.as_posix())\n    shutil.rmtree(temp_dir)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_manim/temporal_graph_scene/","title":"temporal_graph_scene","text":"<p>Manim scene implementation for temporal graph animation.</p> <p>Core animation scene that renders temporal networks with time-based node/edge evolution. Handles smooth transitions, proper edge-node boundary calculations, and time indicator display.</p>"},{"location":"reference/pathpyG/visualisations/_manim/temporal_graph_scene/#pathpyG.visualisations._manim.temporal_graph_scene.TemporalGraphScene","title":"<code>TemporalGraphScene</code>","text":"<p>               Bases: <code>manim.Scene</code></p> <p>Manim scene for animated temporal network visualization.</p> <p>Creates time-based animations showing network evolution with nodes appearing/moving and edges being added/removed over time. Handles proper scaling, positioning, and smooth transitions between timesteps.</p> Source code in <code>src/pathpyG/visualisations/_manim/temporal_graph_scene.py</code> <pre><code>class TemporalGraphScene(Scene):\n    \"\"\"Manim scene for animated temporal network visualization.\n\n    Creates time-based animations showing network evolution with nodes\n    appearing/moving and edges being added/removed over time. Handles\n    proper scaling, positioning, and smooth transitions between timesteps.\n    \"\"\"\n    def __init__(self, data: dict, config: dict, show_labels: bool):\n        \"\"\"Initialize temporal graph scene with network data and configuration.\n\n        Args:\n            data: Network data with nodes/edges DataFrames in a dictionary\n            config: Animation configuration (timing, colors, etc.)\n            show_labels: Whether to display node labels\n        \"\"\"\n        super().__init__()\n        self.data = deepcopy(data)\n        self.data[\"nodes\"][\"size\"] *= 0.025  # scale sizes down\n        self.data[\"nodes\"] = self.data[\"nodes\"].rename(\n            columns={\"size\": \"radius\", \"color\": \"fill_color\", \"opacity\": \"fill_opacity\"}\n        )\n        if \"x\" in self.data[\"nodes\"] and \"y\" in self.data[\"nodes\"]:\n            self.data[\"nodes\"][[\"x\", \"y\"]] = (self.data[\"nodes\"][[\"x\", \"y\"]] - 0.5) * 5  # scale layout\n        self.data[\"edges\"] = self.data[\"edges\"].rename(\n            columns={\"color\": \"stroke_color\", \"opacity\": \"stroke_opacity\", \"size\": \"stroke_width\"}\n        )\n        self.config = config\n        self.show_labels = show_labels\n\n    def construct(self):\n        \"\"\"Create temporal network animation with time-based evolution.\n\n        Main animation sequence:\n        1. Initialize nodes at t=0 with layout positioning\n        2. For each timestep: update time display, add new edges, \n           transform node positions, remove old edges\n        3. Clean up final frame\n\n        Uses smooth transitions and proper edge-node boundary calculations\n        for professional animation quality.\n        \"\"\"\n        # Add initial nodes\n        start_node_df = self.data[\"nodes\"][self.data[\"nodes\"][\"start\"] == 0]\n        if \"x\" in self.data[\"nodes\"] and \"y\" in self.data[\"nodes\"]:\n            layout = {node: np.concatenate([pos.values, [0]]) for node, pos in start_node_df[[\"x\", \"y\"]].iterrows()}\n        else:\n            # Use random layout if no positions are given\n            layout = Layout(nodes=start_node_df.index.tolist()).generate_layout()\n            # add z coordinate for manim and scale layout\n            layout = {node: (np.concatenate([pos, [0]]) - 0.5) * 5 for node, pos in layout.items()}\n        vertex_config = start_node_df[[\"radius\", \"fill_color\", \"fill_opacity\"]].to_dict(orient=\"index\")\n        if self.show_labels:\n            nodes = {node: LabeledDot(label=str(node), point=layout[node], **vertex_config[node]) for node in vertex_config}\n        else:\n            nodes = {node: Dot(point=layout[node], **vertex_config[node]) for node in vertex_config}\n        self.play(*[Create(node) for node in nodes.values()])\n\n        # Iterate over time steps and update nodes and edges\n        time_text = Text(f\"Time: {0}\", font_size=24, color=BLACK).to_corner(UP + RIGHT)\n        for t in range(self.data[\"edges\"][\"end\"].max() + 1):\n            # Add time step text\n            self.play(Transform(time_text, Text(f\"Time: {t}\", font_size=24, color=BLACK).to_corner(UP + RIGHT)), run_time=0.02)\n\n            # Add edges for current time step\n            new_edge_df = self.data[\"edges\"][(self.data[\"edges\"][\"start\"] == t)]\n            # drop duplicate edges\n            if new_edge_df.index.duplicated().any():\n                logger.warning(f\"Dropping duplicate edges at time {t}.\")\n                new_edge_df = new_edge_df[~new_edge_df.index.duplicated(keep='first')]\n            new_edge_config = new_edge_df[[\"stroke_color\", \"stroke_opacity\", \"stroke_width\"]].to_dict(orient=\"index\")\n            if not new_edge_df.empty:\n                arrows = {\n                    (source, target): Arrow(\n                        start=self.get_boundary_point(\n                            center=layout[source],\n                            direction=layout[target] - layout[source],\n                            radius=nodes[source].radius/2,\n                        ),\n                        end=self.get_boundary_point(\n                            center=layout[target],\n                            direction=layout[source] - layout[target],\n                            radius=nodes[target].radius/2,\n                        ),\n                        **new_edge_config[(source, target)],\n                    )\n                    for source, target in new_edge_df.index\n                }\n                self.play(*[GrowArrow(arrow) for arrow in arrows.values()], run_time=self.config[\"delta\"]/(4*1000))\n            else:\n                self.wait(self.config[\"delta\"]/(4*1000))\n\n            # Update node positions for the next time step\n            new_nodes = self.data[\"nodes\"][self.data[\"nodes\"][\"start\"] == (t + 1)]\n            if not new_nodes.empty:\n                new_vertex_config = new_nodes[[\"radius\", \"fill_color\", \"fill_opacity\"]].to_dict(orient=\"index\")\n                if \"x\" in new_nodes and \"y\" in new_nodes:\n                    layout.update({node: np.concatenate([pos.values, [0]]) for node, pos in new_nodes[[\"x\", \"y\"]].iterrows()})\n                if self.show_labels:\n                    new_nodes = {\n                        node: LabeledDot(label=str(node), point=layout[node], **new_vertex_config[node])\n                        for node in new_vertex_config\n                    }\n                else:\n                    new_nodes = {node: Dot(point=layout[node], **new_vertex_config[node]) for node in new_vertex_config}\n                movement_animations = [Transform(nodes[node], new_nodes[node]) for node in new_nodes]\n\n                # Update edge positions with moving nodes\n                if not new_edge_df.empty:\n                    new_arrows = {\n                        (source, target): Arrow(\n                            start=self.get_boundary_point(\n                                center=layout[source],\n                                direction=layout[target] - layout[source],\n                                radius=(nodes | new_nodes)[source].radius/2,\n                            ),\n                            end=self.get_boundary_point(\n                                center=layout[target],\n                                direction=layout[source] - layout[target],\n                                radius=(nodes | new_nodes)[target].radius/2,\n                            ),\n                            **new_edge_config[(source, target)],\n                        )\n                        for source, target in new_edge_df.index\n                        if (source, target) in arrows\n                    }\n                    movement_animations.extend([Transform(arrows[index], new_arrows[index]) for index in new_arrows])\n                self.play(*movement_animations, run_time=self.config[\"delta\"]/(2*1000) - 0.02) # 0.02 for time text update\n            else:\n                self.wait(self.config[\"delta\"]/(2*1000) - 0.02) # 0.02 for time text update\n\n            # Gather all old edges to be removed\n            if not new_edge_df.empty:\n                self.play(\n                    *[arrow.animate.scale(0, scale_tips=True, about_point=arrow.get_end()) for arrow in arrows.values()],\n                    run_time=self.config[\"delta\"]/(4*1000)\n                )\n            else:\n                self.wait(self.config[\"delta\"]/(4*1000))\n\n        self.play(Uncreate(node) for node in nodes.values())\n\n    def get_boundary_point(self, center, direction, radius):\n        \"\"\"Calculate edge attachment point on node boundary.\n\n        Computes where edges should connect to nodes to avoid visual\n        overlap with node circles. Uses vector normalization to find\n        the intersection point on the node's circumference.\n\n        Args:\n            center: Node center coordinates (x, y, z)\n            direction: Direction vector to target node\n            radius: Node radius for boundary calculation\n\n        Returns:\n            Boundary point coordinates for clean edge attachment\n        \"\"\"\n        distance = np.linalg.norm(direction)\n        if distance == 0:\n            return center  # Avoid division by zero\n        direction = direction / distance\n        return center + direction * radius\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_manim/temporal_graph_scene/#pathpyG.visualisations._manim.temporal_graph_scene.TemporalGraphScene.__init__","title":"<code>__init__</code>","text":"<p>Initialize temporal graph scene with network data and configuration.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Network data with nodes/edges DataFrames in a dictionary</p> required <code>config</code> <code>dict</code> <p>Animation configuration (timing, colors, etc.)</p> required <code>show_labels</code> <code>bool</code> <p>Whether to display node labels</p> required Source code in <code>src/pathpyG/visualisations/_manim/temporal_graph_scene.py</code> <pre><code>def __init__(self, data: dict, config: dict, show_labels: bool):\n    \"\"\"Initialize temporal graph scene with network data and configuration.\n\n    Args:\n        data: Network data with nodes/edges DataFrames in a dictionary\n        config: Animation configuration (timing, colors, etc.)\n        show_labels: Whether to display node labels\n    \"\"\"\n    super().__init__()\n    self.data = deepcopy(data)\n    self.data[\"nodes\"][\"size\"] *= 0.025  # scale sizes down\n    self.data[\"nodes\"] = self.data[\"nodes\"].rename(\n        columns={\"size\": \"radius\", \"color\": \"fill_color\", \"opacity\": \"fill_opacity\"}\n    )\n    if \"x\" in self.data[\"nodes\"] and \"y\" in self.data[\"nodes\"]:\n        self.data[\"nodes\"][[\"x\", \"y\"]] = (self.data[\"nodes\"][[\"x\", \"y\"]] - 0.5) * 5  # scale layout\n    self.data[\"edges\"] = self.data[\"edges\"].rename(\n        columns={\"color\": \"stroke_color\", \"opacity\": \"stroke_opacity\", \"size\": \"stroke_width\"}\n    )\n    self.config = config\n    self.show_labels = show_labels\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_manim/temporal_graph_scene/#pathpyG.visualisations._manim.temporal_graph_scene.TemporalGraphScene.construct","title":"<code>construct</code>","text":"<p>Create temporal network animation with time-based evolution.</p> <p>Main animation sequence: 1. Initialize nodes at t=0 with layout positioning 2. For each timestep: update time display, add new edges,     transform node positions, remove old edges 3. Clean up final frame</p> <p>Uses smooth transitions and proper edge-node boundary calculations for professional animation quality.</p> Source code in <code>src/pathpyG/visualisations/_manim/temporal_graph_scene.py</code> <pre><code>def construct(self):\n    \"\"\"Create temporal network animation with time-based evolution.\n\n    Main animation sequence:\n    1. Initialize nodes at t=0 with layout positioning\n    2. For each timestep: update time display, add new edges, \n       transform node positions, remove old edges\n    3. Clean up final frame\n\n    Uses smooth transitions and proper edge-node boundary calculations\n    for professional animation quality.\n    \"\"\"\n    # Add initial nodes\n    start_node_df = self.data[\"nodes\"][self.data[\"nodes\"][\"start\"] == 0]\n    if \"x\" in self.data[\"nodes\"] and \"y\" in self.data[\"nodes\"]:\n        layout = {node: np.concatenate([pos.values, [0]]) for node, pos in start_node_df[[\"x\", \"y\"]].iterrows()}\n    else:\n        # Use random layout if no positions are given\n        layout = Layout(nodes=start_node_df.index.tolist()).generate_layout()\n        # add z coordinate for manim and scale layout\n        layout = {node: (np.concatenate([pos, [0]]) - 0.5) * 5 for node, pos in layout.items()}\n    vertex_config = start_node_df[[\"radius\", \"fill_color\", \"fill_opacity\"]].to_dict(orient=\"index\")\n    if self.show_labels:\n        nodes = {node: LabeledDot(label=str(node), point=layout[node], **vertex_config[node]) for node in vertex_config}\n    else:\n        nodes = {node: Dot(point=layout[node], **vertex_config[node]) for node in vertex_config}\n    self.play(*[Create(node) for node in nodes.values()])\n\n    # Iterate over time steps and update nodes and edges\n    time_text = Text(f\"Time: {0}\", font_size=24, color=BLACK).to_corner(UP + RIGHT)\n    for t in range(self.data[\"edges\"][\"end\"].max() + 1):\n        # Add time step text\n        self.play(Transform(time_text, Text(f\"Time: {t}\", font_size=24, color=BLACK).to_corner(UP + RIGHT)), run_time=0.02)\n\n        # Add edges for current time step\n        new_edge_df = self.data[\"edges\"][(self.data[\"edges\"][\"start\"] == t)]\n        # drop duplicate edges\n        if new_edge_df.index.duplicated().any():\n            logger.warning(f\"Dropping duplicate edges at time {t}.\")\n            new_edge_df = new_edge_df[~new_edge_df.index.duplicated(keep='first')]\n        new_edge_config = new_edge_df[[\"stroke_color\", \"stroke_opacity\", \"stroke_width\"]].to_dict(orient=\"index\")\n        if not new_edge_df.empty:\n            arrows = {\n                (source, target): Arrow(\n                    start=self.get_boundary_point(\n                        center=layout[source],\n                        direction=layout[target] - layout[source],\n                        radius=nodes[source].radius/2,\n                    ),\n                    end=self.get_boundary_point(\n                        center=layout[target],\n                        direction=layout[source] - layout[target],\n                        radius=nodes[target].radius/2,\n                    ),\n                    **new_edge_config[(source, target)],\n                )\n                for source, target in new_edge_df.index\n            }\n            self.play(*[GrowArrow(arrow) for arrow in arrows.values()], run_time=self.config[\"delta\"]/(4*1000))\n        else:\n            self.wait(self.config[\"delta\"]/(4*1000))\n\n        # Update node positions for the next time step\n        new_nodes = self.data[\"nodes\"][self.data[\"nodes\"][\"start\"] == (t + 1)]\n        if not new_nodes.empty:\n            new_vertex_config = new_nodes[[\"radius\", \"fill_color\", \"fill_opacity\"]].to_dict(orient=\"index\")\n            if \"x\" in new_nodes and \"y\" in new_nodes:\n                layout.update({node: np.concatenate([pos.values, [0]]) for node, pos in new_nodes[[\"x\", \"y\"]].iterrows()})\n            if self.show_labels:\n                new_nodes = {\n                    node: LabeledDot(label=str(node), point=layout[node], **new_vertex_config[node])\n                    for node in new_vertex_config\n                }\n            else:\n                new_nodes = {node: Dot(point=layout[node], **new_vertex_config[node]) for node in new_vertex_config}\n            movement_animations = [Transform(nodes[node], new_nodes[node]) for node in new_nodes]\n\n            # Update edge positions with moving nodes\n            if not new_edge_df.empty:\n                new_arrows = {\n                    (source, target): Arrow(\n                        start=self.get_boundary_point(\n                            center=layout[source],\n                            direction=layout[target] - layout[source],\n                            radius=(nodes | new_nodes)[source].radius/2,\n                        ),\n                        end=self.get_boundary_point(\n                            center=layout[target],\n                            direction=layout[source] - layout[target],\n                            radius=(nodes | new_nodes)[target].radius/2,\n                        ),\n                        **new_edge_config[(source, target)],\n                    )\n                    for source, target in new_edge_df.index\n                    if (source, target) in arrows\n                }\n                movement_animations.extend([Transform(arrows[index], new_arrows[index]) for index in new_arrows])\n            self.play(*movement_animations, run_time=self.config[\"delta\"]/(2*1000) - 0.02) # 0.02 for time text update\n        else:\n            self.wait(self.config[\"delta\"]/(2*1000) - 0.02) # 0.02 for time text update\n\n        # Gather all old edges to be removed\n        if not new_edge_df.empty:\n            self.play(\n                *[arrow.animate.scale(0, scale_tips=True, about_point=arrow.get_end()) for arrow in arrows.values()],\n                run_time=self.config[\"delta\"]/(4*1000)\n            )\n        else:\n            self.wait(self.config[\"delta\"]/(4*1000))\n\n    self.play(Uncreate(node) for node in nodes.values())\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_manim/temporal_graph_scene/#pathpyG.visualisations._manim.temporal_graph_scene.TemporalGraphScene.get_boundary_point","title":"<code>get_boundary_point</code>","text":"<p>Calculate edge attachment point on node boundary.</p> <p>Computes where edges should connect to nodes to avoid visual overlap with node circles. Uses vector normalization to find the intersection point on the node's circumference.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <p>Node center coordinates (x, y, z)</p> required <code>direction</code> <p>Direction vector to target node</p> required <code>radius</code> <p>Node radius for boundary calculation</p> required <p>Returns:</p> Type Description <p>Boundary point coordinates for clean edge attachment</p> Source code in <code>src/pathpyG/visualisations/_manim/temporal_graph_scene.py</code> <pre><code>def get_boundary_point(self, center, direction, radius):\n    \"\"\"Calculate edge attachment point on node boundary.\n\n    Computes where edges should connect to nodes to avoid visual\n    overlap with node circles. Uses vector normalization to find\n    the intersection point on the node's circumference.\n\n    Args:\n        center: Node center coordinates (x, y, z)\n        direction: Direction vector to target node\n        radius: Node radius for boundary calculation\n\n    Returns:\n        Boundary point coordinates for clean edge attachment\n    \"\"\"\n    distance = np.linalg.norm(direction)\n    if distance == 0:\n        return center  # Avoid division by zero\n    direction = direction / distance\n    return center + direction * radius\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_matplotlib/","title":"matplotlib","text":"<p>Matplotlib Backend for PathpyG Visualizations.</p> <p>Raster graphics backend using matplotlib for static network images.</p> <p>Output Formats</p> <ul> <li>PNG: High-quality raster images for presentations</li> <li>JPG: Compressed raster images for web usage</li> </ul>"},{"location":"reference/pathpyG/visualisations/_matplotlib/#pathpyG.visualisations._matplotlib--basic-usage","title":"Basic Usage","text":"<p><pre><code>import pathpyG as pp\n\n# Simple network visualization\nedges = [(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"A\")]\ng = pp.Graph.from_edge_list(edges)\npp.plot(g, backend=\"matplotlib\")\n</code></pre> </p>"},{"location":"reference/pathpyG/visualisations/_matplotlib/#pathpyG.visualisations._matplotlib--time-unfolded-network","title":"Time-Unfolded Network","text":"<p>We also support time-unfolded static visualizations of temporal networks using the matplotlib backend. The example uses the <code>node_opacity</code> parameter to highlight active nodes and edges at each time step.</p> <p><pre><code>import pathpyG as pp\n\n# Example temporal network data\ntedges = [\n    (\"a\", \"b\", 1),\n    (\"a\", \"b\", 2),\n    (\"b\", \"a\", 3),\n    (\"b\", \"c\", 3),\n    (\"d\", \"c\", 4),\n    (\"a\", \"b\", 4),\n    (\"c\", \"b\", 4),\n]\nt = pp.TemporalGraph.from_edge_list(tedges)\n\n# Create temporal plot and display inline\nnode_opacity = {(node_id, time): 0.1 for node_id in t.nodes for time in range(t.data.time.max().item() + 2)}\nnode_opacity.update({(source_id, time): 1.0 for source_id, target_id, time in t.temporal_edges})\nnode_opacity.update({(target_id, time+1): 1.0 for source_id, target_id, time in t.temporal_edges})\npp.plot(t, backend=\"matplotlib\", kind=\"unfolded\", node_size=12, node_opacity=node_opacity)\n</code></pre> </p>"},{"location":"reference/pathpyG/visualisations/_matplotlib/backend/","title":"backend","text":"<p>Matplotlib backend for raster graphics network visualization.</p> <p>High-performance matplotlib implementation with optimized collections for efficient rendering. Supports both directed and undirected networks with curved edges, proper arrowheads, and comprehensive styling options.</p>"},{"location":"reference/pathpyG/visualisations/_matplotlib/backend/#pathpyG.visualisations._matplotlib.backend.MatplotlibBackend","title":"<code>MatplotlibBackend</code>","text":"<p>               Bases: <code>pathpyG.visualisations.plot_backend.PlotBackend</code></p> <p>Matplotlib backend for network visualization with optimized rendering.</p> <p>Uses matplotlib collections (EllipseCollection, LineCollection, PathCollection) for efficient batch rendering of network elements. Provides high-quality output with proper edge-node intersection handling and curved edge support.</p> Features <ul> <li>Batch rendering via matplotlib collections</li> <li>Bezier curves for directed edges</li> <li>Automatic edge shortening to avoid node overlap</li> </ul> Example <p>Plot a simple directed network with curved edges: <pre><code>import pathpyG as pp\n\nedges = [(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"A\")]\ng = pp.Graph.from_edge_list(edges)\npp.plot(g, backend=\"matplotlib\")\n</code></pre> </p> <p>Performance Optimization</p> <p>Uses collections instead of individual plot calls for 10-100x faster rendering on networks with many edges.</p> Source code in <code>src/pathpyG/visualisations/_matplotlib/backend.py</code> <pre><code>class MatplotlibBackend(PlotBackend):\n    \"\"\"Matplotlib backend for network visualization with optimized rendering.\n\n    Uses matplotlib collections (EllipseCollection, LineCollection, PathCollection)\n    for efficient batch rendering of network elements. Provides high-quality\n    output with proper edge-node intersection handling and curved edge support.\n\n    Features:\n        - Batch rendering via matplotlib collections\n        - Bezier curves for directed edges\n        - Automatic edge shortening to avoid node overlap\n\n    Example:\n        Plot a simple directed network with curved edges:\n        ```python\n        import pathpyG as pp\n\n        edges = [(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"A\")]\n        g = pp.Graph.from_edge_list(edges)\n        pp.plot(g, backend=\"matplotlib\")\n        ```\n        &lt;img src=\"../../plot/network.png\" alt=\"Example Matplotlib Backend Output\" width=\"550\"/&gt;\n\n    !!! note \"Performance Optimization\"\n        Uses collections instead of individual plot calls for 10-100x\n        faster rendering on networks with many edges.\n    \"\"\"\n\n    def __init__(self, plot: PathPyPlot, show_labels: bool):\n        \"\"\"Initialize matplotlib backend with plot validation.\n\n        Args:\n            plot: PathPyPlot instance containing network data\n            show_labels: Whether to display node labels\n\n        Raises:\n            ValueError: If plot type not supported by matplotlib backend\n        \"\"\"\n        super().__init__(plot, show_labels=show_labels)\n        self._kind = SUPPORTED_KINDS.get(type(plot), None)  # type: ignore[arg-type]\n        if self._kind is None:\n            logger.error(f\"Plot of type {type(plot)} not supported by Matplotlib backend.\")\n            raise ValueError(f\"Plot of type {type(plot)} not supported.\")\n\n    def save(self, filename: str) -&gt; None:\n        \"\"\"Save plot to file with automatic format detection.\n\n        Args:\n            filename: Output file path (format inferred from extension)\n        \"\"\"\n        fig, ax = self.to_fig()\n        fig.savefig(filename)\n\n    def show(self) -&gt; None:\n        \"\"\"Display plot in interactive matplotlib window.\n\n        Opens plot in default matplotlib backend for interactive exploration.\n        \"\"\"\n        fig, ax = self.to_fig()\n        plt.show()\n\n    def to_fig(self) -&gt; tuple[plt.Figure, plt.Axes]:\n        \"\"\"Generate complete matplotlib figure with network visualization.\n\n        Creates figure with proper sizing, renders edges and nodes using optimized\n        collections, adds labels if enabled, and sets appropriate axis limits.\n\n        Returns:\n            tuple: (Figure, Axes) matplotlib objects ready for display/saving\n\n        !!! info \"Rendering Pipeline\"\n            1. **Setup**: Create figure with configured dimensions and DPI\n            2. **Edges**: Render using LineCollection (undirected) or PathCollection (directed)\n            3. **Nodes**: Render using EllipseCollection for precise sizing\n            4. **Labels**: Add text annotations at node centers\n            5. **Layout**: Set axis limits with margin configuration\n        \"\"\"\n        size_factor = 1 / 200  # scale node size to reasonable values\n        fig, ax = plt.subplots(\n            figsize=(unit_str_to_float(self.config[\"width\"], \"in\"), unit_str_to_float(self.config[\"height\"], \"in\")),\n            dpi=150,\n        )\n        ax.set_axis_off()\n\n        # get source and target coordinates for edges\n        source_coords = self.data[\"nodes\"].loc[self.data[\"edges\"].index.get_level_values(\"source\"), [\"x\", \"y\"]].values\n        target_coords = self.data[\"nodes\"].loc[self.data[\"edges\"].index.get_level_values(\"target\"), [\"x\", \"y\"]].values\n\n        if self.config[\"directed\"]:\n            self.add_directed_edges(source_coords, target_coords, ax, size_factor)\n        else:\n            self.add_undirected_edges(source_coords, target_coords, ax, size_factor)\n\n        # plot nodes\n        # We use EllipseCollection instead of scatter because there you can specify the radius of each circle in the unit of the data coordinates\n        # https://stackoverflow.com/a/33095224\n        ax.add_collection(\n            EllipseCollection(\n                widths=self.data[\"nodes\"][\"size\"] * size_factor,\n                heights=self.data[\"nodes\"][\"size\"] * size_factor,\n                angles=0,\n                units=\"xy\",\n                offsets=self.data[\"nodes\"][[\"x\", \"y\"]].values,\n                transOffset=ax.transData,\n                facecolors=self.data[\"nodes\"][\"color\"],\n                edgecolors=\"black\",\n                linewidths=0.5,\n                alpha=self.data[\"nodes\"][\"opacity\"],\n                zorder=2,\n            )\n        )\n\n        # add node labels\n        if self.show_labels:\n            if self._kind == \"static\":\n                for label in self.data[\"nodes\"].index:\n                    x, y = self.data[\"nodes\"].loc[[label], [\"x\", \"y\"]].values.flatten()\n                    # Annotate the node label with text in the center of the node\n                    ax.annotate(\n                        label,\n                        (x, y),\n                        fontsize=0.4 * self.data[\"nodes\"][\"size\"].mean(),\n                        ha=\"center\",\n                        va=\"center\",\n                    )\n            elif self._kind == \"unfolded\":\n                # add labels at the starting nodes only\n                min_time = self.data[\"nodes\"][\"start\"].min()\n                offset = 0.005 * self.data[\"nodes\"][\"size\"].mean()\n                sign = 1 if self.config[\"orientation\"] in [\"down\", \"left\"] else -1\n                label_df = self.data[\"nodes\"][self.data[\"nodes\"][\"start\"] == min_time]\n                for label in label_df.index:\n                    x, y = label_df.loc[[label], [\"x\", \"y\"]].values.flatten()\n                    ax.annotate(\n                        label[0],\n                        (x, y + offset * sign) if self.config[\"orientation\"] in [\"down\", \"up\"] else (x + offset * sign, y),\n                        fontsize=0.5 * self.data[\"nodes\"][\"size\"].mean(),\n                        ha=\"center\",\n                        va=\"center\",\n                    )\n\n                # add timestamps at the border\n                times = self.data[\"nodes\"][\"start\"].unique()\n                for time in times[:-1]:  # skip last time as it would be outside the plot\n                    x, y = self.data[\"nodes\"].iloc[time:time+2, :][[\"x\", \"y\"]].values.mean(axis=0)\n                    ax.annotate(\n                        str(time),\n                        (x - offset, y) if self.config[\"orientation\"] in [\"down\", \"up\"] else (x, y - offset),\n                        fontsize=0.5 * self.data[\"nodes\"][\"size\"].mean(),\n                        ha=\"center\",\n                        va=\"center\",\n                    )\n\n        # set limits\n        ax.set_xlim(-1 * self.config[\"margin\"], 1 + (1*self.config[\"margin\"]))\n        ax.set_ylim(-1 * self.config[\"margin\"], 1 + (1*self.config[\"margin\"]))\n        return fig, ax\n\n    def add_undirected_edges(self, source_coords, target_coords, ax, size_factor):\n        \"\"\"Render undirected edges using LineCollection for efficiency.\n\n        Computes edge shortening to prevent overlap with nodes and renders\n        all edges in a single matplotlib LineCollection for optimal performance.\n\n        Args:\n            source_coords: Source node coordinates array\n            target_coords: Target node coordinates array  \n            ax: Matplotlib axes for rendering\n            size_factor: Scaling factor for node size calculations\n\n        !!! tip \"Edge Shortening\"\n            Automatically shortens edges by node radius to create clean\n            visual separation between edges and node boundaries.\n        \"\"\"\n        # shorten edges so they don't overlap with nodes\n        vec = target_coords - source_coords\n        dist = np.linalg.norm(vec, axis=1, keepdims=True)\n        direction = vec / dist\n        source_coords += direction * (self.data[\"nodes\"].loc[self.data[\"edges\"].index.get_level_values(\"source\"), [\"size\"]].values * (size_factor / 2))  # /2 because we use radius instead of diameter\n        target_coords -= direction * (self.data[\"nodes\"].loc[self.data[\"edges\"].index.get_level_values(\"target\"), [\"size\"]].values * (size_factor / 2))\n\n        # create and add lines\n        edge_lines = list(zip(source_coords, target_coords))\n        ax.add_collection(\n            LineCollection(\n                edge_lines,\n                colors=self.data[\"edges\"][\"color\"],\n                alpha=self.data[\"edges\"][\"opacity\"],\n                linewidths=self.data[\"edges\"][\"size\"],\n                zorder=1,\n            )\n        )\n\n    def add_directed_edges(self, source_coords, target_coords, ax, size_factor):\n        \"\"\"Render directed edges using Bezier curves with arrowheads.\n\n        Creates curved edges using quadratic Bezier curves and adds proportional\n        arrowheads. Handles edge shortening and automatic fallback to straight\n        edges when curves would be too short.\n\n        Args:\n            source_coords: Source node coordinates array\n            target_coords: Target node coordinates array\n            ax: Matplotlib axes for rendering  \n            size_factor: Scaling factor for node size calculations\n\n        !!! warning \"Curve Limitations\"\n            Falls back to straight edges when arrowheads would be too large\n            relative to edge length to maintain visual clarity.\n        \"\"\"\n        # get bezier curve vertices and codes\n        head_length = 0.02\n        vertices, codes = self.get_bezier_curve(\n            source_coords,\n            target_coords,\n            source_node_size=self.data[\"nodes\"].loc[self.data[\"edges\"].index.get_level_values(\"source\"), [\"size\"]].values\n            * (size_factor / 2),  # /2 because we use radius instead of diameter\n            target_node_size=self.data[\"nodes\"].loc[self.data[\"edges\"].index.get_level_values(\"target\"), [\"size\"]].values\n            * (size_factor / 2),\n            head_length=head_length,\n        )\n        ax.add_collection(\n            PathCollection(\n                [\n                    Path(\n                        v,\n                        codes,\n                    )\n                    for v in zip(*vertices)\n                ],\n                facecolor=\"none\",\n                edgecolor=self.data[\"edges\"][\"color\"],\n                alpha=self.data[\"edges\"][\"opacity\"],\n                linewidth=self.data[\"edges\"][\"size\"],\n                zorder=1,\n            )\n        )\n\n        # add arrowheads\n        arrow_vertices, arrow_codes = self.get_arrowhead(vertices, head_length=head_length)\n        ax.add_collection(\n            PathCollection(\n                [Path(v, arrow_codes) for v in zip(*arrow_vertices)],\n                facecolor=self.data[\"edges\"][\"color\"],\n                edgecolor=self.data[\"edges\"][\"color\"],\n                alpha=self.data[\"edges\"][\"opacity\"],\n                zorder=1,\n            )\n        )\n\n    def get_bezier_curve(\n        self,\n        source_coords,\n        target_coords,\n        source_node_size,\n        target_node_size,\n        head_length,\n        shorten=0.005,\n    ):\n        \"\"\"Generate quadratic Bezier curve paths for directed edges.\n\n        Computes control points for smooth curved edges with automatic shortening\n        to accommodate node sizes and arrowheads. Uses perpendicular offset for\n        curve control points based on curvature configuration.\n\n        Args:\n            source_coords: Start points (x, y) for all edges\n            target_coords: End points (x, y) for all edges  \n            source_node_size: Source node radii for edge shortening\n            target_node_size: Target node radii for edge shortening\n            head_length: Arrowhead length for target-end shortening\n            shorten: Additional shortening amount to prevent visual overlap\n\n        Returns:\n            tuple: (vertices, codes) for matplotlib Path objects\n\n        !!! info \"Bezier Curve Mathematics\"\n            Uses quadratic Bezier curves with control point positioned\n            perpendicular to edge midpoint. Curvature parameter controls\n            the distance of control point from edge midpoint.\n\n        !!! note \"Fallback Behavior\" \n            Returns straight line paths when curves would be too short\n            for proper arrowhead placement.\n        \"\"\"\n        # Start and end points for the B\u00e9zier curve\n        P0 = source_coords\n        P2 = target_coords\n\n        # Calculate distance and direction vector\n        mid_point = (P0 + P2) / 2\n        vec = P2 - P0\n        dist = np.linalg.norm(vec, axis=1, keepdims=True)\n        # Avoid division by zero\n        dist[dist == 0] = 1e-6\n\n        # Perpendicular vector\n        perp_vec = np.array([-vec[:, 1], vec[:, 0]]).T / dist\n\n        # Calculate control points\n        P1 = mid_point + perp_vec * dist * self.config[\"curvature\"]\n\n        # Shorten the curve to avoid overlap with nodes\n        distance_P0_P1 = np.linalg.norm(P1 - P0, axis=1, keepdims=True)\n        distance_P0_P1[distance_P0_P1 == 0] = 1e-6\n        distance_P2_P1 = np.linalg.norm(P1 - P2, axis=1, keepdims=True)\n        distance_P2_P1[distance_P2_P1 == 0] = 1e-6\n        direction_P0_P1 = (P1 - P0) / distance_P0_P1\n        direction_P2_P1 = (P1 - P2) / distance_P2_P1\n        P0_offset_dist = shorten + source_node_size\n        P2_offset_dist = shorten + target_node_size + (head_length * self.data[\"edges\"][\"size\"].values[:, np.newaxis])\n        if (not self.config[\"curved\"]) or np.any(distance_P2_P1/2 &lt; P2_offset_dist):\n            logger.warning(\"Arrowhead length is too long for some edges. Please reduce the edge size. Using non-curved edges instead.\")\n            direction_P0_P2 = vec / dist\n            P0 += direction_P0_P2 * P0_offset_dist\n            P2 -= direction_P0_P2 * P2_offset_dist\n            return [P0, P2], [Path.MOVETO, Path.LINETO]\n\n        P0 += direction_P0_P1 * P0_offset_dist\n        P2 += direction_P2_P1 * P2_offset_dist\n\n        vertices = [P0, P1, P2]\n        codes = [\n            Path.MOVETO,\n            Path.CURVE3,\n            Path.MOVETO,\n        ]\n        return vertices, codes\n\n    def get_arrowhead(self, vertices, head_length, head_width=0.02):\n        \"\"\"Generate triangular arrowhead paths for directed edges.\n\n        Creates proportional arrowheads at curve endpoints using tangent vectors\n        for proper orientation. Arrowhead size scales with edge width for\n        consistent visual appearance across different edge weights.\n\n        Args:\n            vertices: Bezier curve vertices list for tangent calculation\n            head_length: Base arrowhead length (scaled by edge size)\n            head_width: Base arrowhead width (scaled by edge size)\n\n        Returns:\n            tuple: (vertices, codes) for matplotlib Path objects\n\n        !!! tip \"Proportional Scaling\"\n            Arrowhead dimensions automatically scale with edge width\n            to maintain consistent visual proportions across different\n            edge weights in the same network.\n        \"\"\"\n        # Extract the last segment of the B\u00e9zier curve\n        P1, P2 = vertices[-2], vertices[-1]\n        # 1. Calculate the tangent vector (direction of the curve at the end)\n        # For a quadratic curve, this is the vector from the control point to the end point.\n        tangent = P2 - P1\n        tangent_norm = np.linalg.norm(tangent, axis=1, keepdims=True)\n        # Avoid division by zero\n        tangent_norm[tangent_norm == 0] = 1e-6\n        tangent /= tangent_norm\n        # Avoid division by zero\n        tangent[tangent == 0] = 1e-6\n\n        # 2. Calculate the perpendicular vector for the width\n        perp = np.array([-tangent[:, 1], tangent[:, 0]]).T\n\n        # 3. Define the three points of the arrowhead triangle\n        base_center = P2\n        tip = P2 + tangent * head_length * self.data[\"edges\"][\"size\"].values[:, np.newaxis]\n        wing1 = base_center + perp * head_width / 2 * self.data[\"edges\"][\"size\"].values[:, np.newaxis]\n        wing2 = base_center - perp * head_width / 2 * self.data[\"edges\"][\"size\"].values[:, np.newaxis]\n\n        vertices = [wing1, tip, wing2, wing1]\n        codes = [\n            Path.MOVETO,\n            Path.LINETO,\n            Path.LINETO,\n            Path.CLOSEPOLY,  # Close the shape to make it fillable\n        ]\n        return vertices, codes\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_matplotlib/backend/#pathpyG.visualisations._matplotlib.backend.MatplotlibBackend.__init__","title":"<code>__init__</code>","text":"<p>Initialize matplotlib backend with plot validation.</p> <p>Parameters:</p> Name Type Description Default <code>plot</code> <code>pathpyG.visualisations.pathpy_plot.PathPyPlot</code> <p>PathPyPlot instance containing network data</p> required <code>show_labels</code> <code>bool</code> <p>Whether to display node labels</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If plot type not supported by matplotlib backend</p> Source code in <code>src/pathpyG/visualisations/_matplotlib/backend.py</code> <pre><code>def __init__(self, plot: PathPyPlot, show_labels: bool):\n    \"\"\"Initialize matplotlib backend with plot validation.\n\n    Args:\n        plot: PathPyPlot instance containing network data\n        show_labels: Whether to display node labels\n\n    Raises:\n        ValueError: If plot type not supported by matplotlib backend\n    \"\"\"\n    super().__init__(plot, show_labels=show_labels)\n    self._kind = SUPPORTED_KINDS.get(type(plot), None)  # type: ignore[arg-type]\n    if self._kind is None:\n        logger.error(f\"Plot of type {type(plot)} not supported by Matplotlib backend.\")\n        raise ValueError(f\"Plot of type {type(plot)} not supported.\")\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_matplotlib/backend/#pathpyG.visualisations._matplotlib.backend.MatplotlibBackend.add_directed_edges","title":"<code>add_directed_edges</code>","text":"<p>Render directed edges using Bezier curves with arrowheads.</p> <p>Creates curved edges using quadratic Bezier curves and adds proportional arrowheads. Handles edge shortening and automatic fallback to straight edges when curves would be too short.</p> <p>Parameters:</p> Name Type Description Default <code>source_coords</code> <p>Source node coordinates array</p> required <code>target_coords</code> <p>Target node coordinates array</p> required <code>ax</code> <p>Matplotlib axes for rendering  </p> required <code>size_factor</code> <p>Scaling factor for node size calculations</p> required <p>Curve Limitations</p> <p>Falls back to straight edges when arrowheads would be too large relative to edge length to maintain visual clarity.</p> Source code in <code>src/pathpyG/visualisations/_matplotlib/backend.py</code> <pre><code>def add_directed_edges(self, source_coords, target_coords, ax, size_factor):\n    \"\"\"Render directed edges using Bezier curves with arrowheads.\n\n    Creates curved edges using quadratic Bezier curves and adds proportional\n    arrowheads. Handles edge shortening and automatic fallback to straight\n    edges when curves would be too short.\n\n    Args:\n        source_coords: Source node coordinates array\n        target_coords: Target node coordinates array\n        ax: Matplotlib axes for rendering  \n        size_factor: Scaling factor for node size calculations\n\n    !!! warning \"Curve Limitations\"\n        Falls back to straight edges when arrowheads would be too large\n        relative to edge length to maintain visual clarity.\n    \"\"\"\n    # get bezier curve vertices and codes\n    head_length = 0.02\n    vertices, codes = self.get_bezier_curve(\n        source_coords,\n        target_coords,\n        source_node_size=self.data[\"nodes\"].loc[self.data[\"edges\"].index.get_level_values(\"source\"), [\"size\"]].values\n        * (size_factor / 2),  # /2 because we use radius instead of diameter\n        target_node_size=self.data[\"nodes\"].loc[self.data[\"edges\"].index.get_level_values(\"target\"), [\"size\"]].values\n        * (size_factor / 2),\n        head_length=head_length,\n    )\n    ax.add_collection(\n        PathCollection(\n            [\n                Path(\n                    v,\n                    codes,\n                )\n                for v in zip(*vertices)\n            ],\n            facecolor=\"none\",\n            edgecolor=self.data[\"edges\"][\"color\"],\n            alpha=self.data[\"edges\"][\"opacity\"],\n            linewidth=self.data[\"edges\"][\"size\"],\n            zorder=1,\n        )\n    )\n\n    # add arrowheads\n    arrow_vertices, arrow_codes = self.get_arrowhead(vertices, head_length=head_length)\n    ax.add_collection(\n        PathCollection(\n            [Path(v, arrow_codes) for v in zip(*arrow_vertices)],\n            facecolor=self.data[\"edges\"][\"color\"],\n            edgecolor=self.data[\"edges\"][\"color\"],\n            alpha=self.data[\"edges\"][\"opacity\"],\n            zorder=1,\n        )\n    )\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_matplotlib/backend/#pathpyG.visualisations._matplotlib.backend.MatplotlibBackend.add_undirected_edges","title":"<code>add_undirected_edges</code>","text":"<p>Render undirected edges using LineCollection for efficiency.</p> <p>Computes edge shortening to prevent overlap with nodes and renders all edges in a single matplotlib LineCollection for optimal performance.</p> <p>Parameters:</p> Name Type Description Default <code>source_coords</code> <p>Source node coordinates array</p> required <code>target_coords</code> <p>Target node coordinates array  </p> required <code>ax</code> <p>Matplotlib axes for rendering</p> required <code>size_factor</code> <p>Scaling factor for node size calculations</p> required <p>Edge Shortening</p> <p>Automatically shortens edges by node radius to create clean visual separation between edges and node boundaries.</p> Source code in <code>src/pathpyG/visualisations/_matplotlib/backend.py</code> <pre><code>def add_undirected_edges(self, source_coords, target_coords, ax, size_factor):\n    \"\"\"Render undirected edges using LineCollection for efficiency.\n\n    Computes edge shortening to prevent overlap with nodes and renders\n    all edges in a single matplotlib LineCollection for optimal performance.\n\n    Args:\n        source_coords: Source node coordinates array\n        target_coords: Target node coordinates array  \n        ax: Matplotlib axes for rendering\n        size_factor: Scaling factor for node size calculations\n\n    !!! tip \"Edge Shortening\"\n        Automatically shortens edges by node radius to create clean\n        visual separation between edges and node boundaries.\n    \"\"\"\n    # shorten edges so they don't overlap with nodes\n    vec = target_coords - source_coords\n    dist = np.linalg.norm(vec, axis=1, keepdims=True)\n    direction = vec / dist\n    source_coords += direction * (self.data[\"nodes\"].loc[self.data[\"edges\"].index.get_level_values(\"source\"), [\"size\"]].values * (size_factor / 2))  # /2 because we use radius instead of diameter\n    target_coords -= direction * (self.data[\"nodes\"].loc[self.data[\"edges\"].index.get_level_values(\"target\"), [\"size\"]].values * (size_factor / 2))\n\n    # create and add lines\n    edge_lines = list(zip(source_coords, target_coords))\n    ax.add_collection(\n        LineCollection(\n            edge_lines,\n            colors=self.data[\"edges\"][\"color\"],\n            alpha=self.data[\"edges\"][\"opacity\"],\n            linewidths=self.data[\"edges\"][\"size\"],\n            zorder=1,\n        )\n    )\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_matplotlib/backend/#pathpyG.visualisations._matplotlib.backend.MatplotlibBackend.get_arrowhead","title":"<code>get_arrowhead</code>","text":"<p>Generate triangular arrowhead paths for directed edges.</p> <p>Creates proportional arrowheads at curve endpoints using tangent vectors for proper orientation. Arrowhead size scales with edge width for consistent visual appearance across different edge weights.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <p>Bezier curve vertices list for tangent calculation</p> required <code>head_length</code> <p>Base arrowhead length (scaled by edge size)</p> required <code>head_width</code> <p>Base arrowhead width (scaled by edge size)</p> <code>0.02</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(vertices, codes) for matplotlib Path objects</p> <p>Proportional Scaling</p> <p>Arrowhead dimensions automatically scale with edge width to maintain consistent visual proportions across different edge weights in the same network.</p> Source code in <code>src/pathpyG/visualisations/_matplotlib/backend.py</code> <pre><code>def get_arrowhead(self, vertices, head_length, head_width=0.02):\n    \"\"\"Generate triangular arrowhead paths for directed edges.\n\n    Creates proportional arrowheads at curve endpoints using tangent vectors\n    for proper orientation. Arrowhead size scales with edge width for\n    consistent visual appearance across different edge weights.\n\n    Args:\n        vertices: Bezier curve vertices list for tangent calculation\n        head_length: Base arrowhead length (scaled by edge size)\n        head_width: Base arrowhead width (scaled by edge size)\n\n    Returns:\n        tuple: (vertices, codes) for matplotlib Path objects\n\n    !!! tip \"Proportional Scaling\"\n        Arrowhead dimensions automatically scale with edge width\n        to maintain consistent visual proportions across different\n        edge weights in the same network.\n    \"\"\"\n    # Extract the last segment of the B\u00e9zier curve\n    P1, P2 = vertices[-2], vertices[-1]\n    # 1. Calculate the tangent vector (direction of the curve at the end)\n    # For a quadratic curve, this is the vector from the control point to the end point.\n    tangent = P2 - P1\n    tangent_norm = np.linalg.norm(tangent, axis=1, keepdims=True)\n    # Avoid division by zero\n    tangent_norm[tangent_norm == 0] = 1e-6\n    tangent /= tangent_norm\n    # Avoid division by zero\n    tangent[tangent == 0] = 1e-6\n\n    # 2. Calculate the perpendicular vector for the width\n    perp = np.array([-tangent[:, 1], tangent[:, 0]]).T\n\n    # 3. Define the three points of the arrowhead triangle\n    base_center = P2\n    tip = P2 + tangent * head_length * self.data[\"edges\"][\"size\"].values[:, np.newaxis]\n    wing1 = base_center + perp * head_width / 2 * self.data[\"edges\"][\"size\"].values[:, np.newaxis]\n    wing2 = base_center - perp * head_width / 2 * self.data[\"edges\"][\"size\"].values[:, np.newaxis]\n\n    vertices = [wing1, tip, wing2, wing1]\n    codes = [\n        Path.MOVETO,\n        Path.LINETO,\n        Path.LINETO,\n        Path.CLOSEPOLY,  # Close the shape to make it fillable\n    ]\n    return vertices, codes\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_matplotlib/backend/#pathpyG.visualisations._matplotlib.backend.MatplotlibBackend.get_bezier_curve","title":"<code>get_bezier_curve</code>","text":"<p>Generate quadratic Bezier curve paths for directed edges.</p> <p>Computes control points for smooth curved edges with automatic shortening to accommodate node sizes and arrowheads. Uses perpendicular offset for curve control points based on curvature configuration.</p> <p>Parameters:</p> Name Type Description Default <code>source_coords</code> <p>Start points (x, y) for all edges</p> required <code>target_coords</code> <p>End points (x, y) for all edges  </p> required <code>source_node_size</code> <p>Source node radii for edge shortening</p> required <code>target_node_size</code> <p>Target node radii for edge shortening</p> required <code>head_length</code> <p>Arrowhead length for target-end shortening</p> required <code>shorten</code> <p>Additional shortening amount to prevent visual overlap</p> <code>0.005</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(vertices, codes) for matplotlib Path objects</p> <p>Bezier Curve Mathematics</p> <p>Uses quadratic Bezier curves with control point positioned perpendicular to edge midpoint. Curvature parameter controls the distance of control point from edge midpoint.</p> <p>Fallback Behavior</p> <p>Returns straight line paths when curves would be too short for proper arrowhead placement.</p> Source code in <code>src/pathpyG/visualisations/_matplotlib/backend.py</code> <pre><code>def get_bezier_curve(\n    self,\n    source_coords,\n    target_coords,\n    source_node_size,\n    target_node_size,\n    head_length,\n    shorten=0.005,\n):\n    \"\"\"Generate quadratic Bezier curve paths for directed edges.\n\n    Computes control points for smooth curved edges with automatic shortening\n    to accommodate node sizes and arrowheads. Uses perpendicular offset for\n    curve control points based on curvature configuration.\n\n    Args:\n        source_coords: Start points (x, y) for all edges\n        target_coords: End points (x, y) for all edges  \n        source_node_size: Source node radii for edge shortening\n        target_node_size: Target node radii for edge shortening\n        head_length: Arrowhead length for target-end shortening\n        shorten: Additional shortening amount to prevent visual overlap\n\n    Returns:\n        tuple: (vertices, codes) for matplotlib Path objects\n\n    !!! info \"Bezier Curve Mathematics\"\n        Uses quadratic Bezier curves with control point positioned\n        perpendicular to edge midpoint. Curvature parameter controls\n        the distance of control point from edge midpoint.\n\n    !!! note \"Fallback Behavior\" \n        Returns straight line paths when curves would be too short\n        for proper arrowhead placement.\n    \"\"\"\n    # Start and end points for the B\u00e9zier curve\n    P0 = source_coords\n    P2 = target_coords\n\n    # Calculate distance and direction vector\n    mid_point = (P0 + P2) / 2\n    vec = P2 - P0\n    dist = np.linalg.norm(vec, axis=1, keepdims=True)\n    # Avoid division by zero\n    dist[dist == 0] = 1e-6\n\n    # Perpendicular vector\n    perp_vec = np.array([-vec[:, 1], vec[:, 0]]).T / dist\n\n    # Calculate control points\n    P1 = mid_point + perp_vec * dist * self.config[\"curvature\"]\n\n    # Shorten the curve to avoid overlap with nodes\n    distance_P0_P1 = np.linalg.norm(P1 - P0, axis=1, keepdims=True)\n    distance_P0_P1[distance_P0_P1 == 0] = 1e-6\n    distance_P2_P1 = np.linalg.norm(P1 - P2, axis=1, keepdims=True)\n    distance_P2_P1[distance_P2_P1 == 0] = 1e-6\n    direction_P0_P1 = (P1 - P0) / distance_P0_P1\n    direction_P2_P1 = (P1 - P2) / distance_P2_P1\n    P0_offset_dist = shorten + source_node_size\n    P2_offset_dist = shorten + target_node_size + (head_length * self.data[\"edges\"][\"size\"].values[:, np.newaxis])\n    if (not self.config[\"curved\"]) or np.any(distance_P2_P1/2 &lt; P2_offset_dist):\n        logger.warning(\"Arrowhead length is too long for some edges. Please reduce the edge size. Using non-curved edges instead.\")\n        direction_P0_P2 = vec / dist\n        P0 += direction_P0_P2 * P0_offset_dist\n        P2 -= direction_P0_P2 * P2_offset_dist\n        return [P0, P2], [Path.MOVETO, Path.LINETO]\n\n    P0 += direction_P0_P1 * P0_offset_dist\n    P2 += direction_P2_P1 * P2_offset_dist\n\n    vertices = [P0, P1, P2]\n    codes = [\n        Path.MOVETO,\n        Path.CURVE3,\n        Path.MOVETO,\n    ]\n    return vertices, codes\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_matplotlib/backend/#pathpyG.visualisations._matplotlib.backend.MatplotlibBackend.save","title":"<code>save</code>","text":"<p>Save plot to file with automatic format detection.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Output file path (format inferred from extension)</p> required Source code in <code>src/pathpyG/visualisations/_matplotlib/backend.py</code> <pre><code>def save(self, filename: str) -&gt; None:\n    \"\"\"Save plot to file with automatic format detection.\n\n    Args:\n        filename: Output file path (format inferred from extension)\n    \"\"\"\n    fig, ax = self.to_fig()\n    fig.savefig(filename)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_matplotlib/backend/#pathpyG.visualisations._matplotlib.backend.MatplotlibBackend.show","title":"<code>show</code>","text":"<p>Display plot in interactive matplotlib window.</p> <p>Opens plot in default matplotlib backend for interactive exploration.</p> Source code in <code>src/pathpyG/visualisations/_matplotlib/backend.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Display plot in interactive matplotlib window.\n\n    Opens plot in default matplotlib backend for interactive exploration.\n    \"\"\"\n    fig, ax = self.to_fig()\n    plt.show()\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_matplotlib/backend/#pathpyG.visualisations._matplotlib.backend.MatplotlibBackend.to_fig","title":"<code>to_fig</code>","text":"<p>Generate complete matplotlib figure with network visualization.</p> <p>Creates figure with proper sizing, renders edges and nodes using optimized collections, adds labels if enabled, and sets appropriate axis limits.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[matplotlib.pyplot.Figure, matplotlib.pyplot.Axes]</code> <p>(Figure, Axes) matplotlib objects ready for display/saving</p> <p>Rendering Pipeline</p> <ol> <li>Setup: Create figure with configured dimensions and DPI</li> <li>Edges: Render using LineCollection (undirected) or PathCollection (directed)</li> <li>Nodes: Render using EllipseCollection for precise sizing</li> <li>Labels: Add text annotations at node centers</li> <li>Layout: Set axis limits with margin configuration</li> </ol> Source code in <code>src/pathpyG/visualisations/_matplotlib/backend.py</code> <pre><code>def to_fig(self) -&gt; tuple[plt.Figure, plt.Axes]:\n    \"\"\"Generate complete matplotlib figure with network visualization.\n\n    Creates figure with proper sizing, renders edges and nodes using optimized\n    collections, adds labels if enabled, and sets appropriate axis limits.\n\n    Returns:\n        tuple: (Figure, Axes) matplotlib objects ready for display/saving\n\n    !!! info \"Rendering Pipeline\"\n        1. **Setup**: Create figure with configured dimensions and DPI\n        2. **Edges**: Render using LineCollection (undirected) or PathCollection (directed)\n        3. **Nodes**: Render using EllipseCollection for precise sizing\n        4. **Labels**: Add text annotations at node centers\n        5. **Layout**: Set axis limits with margin configuration\n    \"\"\"\n    size_factor = 1 / 200  # scale node size to reasonable values\n    fig, ax = plt.subplots(\n        figsize=(unit_str_to_float(self.config[\"width\"], \"in\"), unit_str_to_float(self.config[\"height\"], \"in\")),\n        dpi=150,\n    )\n    ax.set_axis_off()\n\n    # get source and target coordinates for edges\n    source_coords = self.data[\"nodes\"].loc[self.data[\"edges\"].index.get_level_values(\"source\"), [\"x\", \"y\"]].values\n    target_coords = self.data[\"nodes\"].loc[self.data[\"edges\"].index.get_level_values(\"target\"), [\"x\", \"y\"]].values\n\n    if self.config[\"directed\"]:\n        self.add_directed_edges(source_coords, target_coords, ax, size_factor)\n    else:\n        self.add_undirected_edges(source_coords, target_coords, ax, size_factor)\n\n    # plot nodes\n    # We use EllipseCollection instead of scatter because there you can specify the radius of each circle in the unit of the data coordinates\n    # https://stackoverflow.com/a/33095224\n    ax.add_collection(\n        EllipseCollection(\n            widths=self.data[\"nodes\"][\"size\"] * size_factor,\n            heights=self.data[\"nodes\"][\"size\"] * size_factor,\n            angles=0,\n            units=\"xy\",\n            offsets=self.data[\"nodes\"][[\"x\", \"y\"]].values,\n            transOffset=ax.transData,\n            facecolors=self.data[\"nodes\"][\"color\"],\n            edgecolors=\"black\",\n            linewidths=0.5,\n            alpha=self.data[\"nodes\"][\"opacity\"],\n            zorder=2,\n        )\n    )\n\n    # add node labels\n    if self.show_labels:\n        if self._kind == \"static\":\n            for label in self.data[\"nodes\"].index:\n                x, y = self.data[\"nodes\"].loc[[label], [\"x\", \"y\"]].values.flatten()\n                # Annotate the node label with text in the center of the node\n                ax.annotate(\n                    label,\n                    (x, y),\n                    fontsize=0.4 * self.data[\"nodes\"][\"size\"].mean(),\n                    ha=\"center\",\n                    va=\"center\",\n                )\n        elif self._kind == \"unfolded\":\n            # add labels at the starting nodes only\n            min_time = self.data[\"nodes\"][\"start\"].min()\n            offset = 0.005 * self.data[\"nodes\"][\"size\"].mean()\n            sign = 1 if self.config[\"orientation\"] in [\"down\", \"left\"] else -1\n            label_df = self.data[\"nodes\"][self.data[\"nodes\"][\"start\"] == min_time]\n            for label in label_df.index:\n                x, y = label_df.loc[[label], [\"x\", \"y\"]].values.flatten()\n                ax.annotate(\n                    label[0],\n                    (x, y + offset * sign) if self.config[\"orientation\"] in [\"down\", \"up\"] else (x + offset * sign, y),\n                    fontsize=0.5 * self.data[\"nodes\"][\"size\"].mean(),\n                    ha=\"center\",\n                    va=\"center\",\n                )\n\n            # add timestamps at the border\n            times = self.data[\"nodes\"][\"start\"].unique()\n            for time in times[:-1]:  # skip last time as it would be outside the plot\n                x, y = self.data[\"nodes\"].iloc[time:time+2, :][[\"x\", \"y\"]].values.mean(axis=0)\n                ax.annotate(\n                    str(time),\n                    (x - offset, y) if self.config[\"orientation\"] in [\"down\", \"up\"] else (x, y - offset),\n                    fontsize=0.5 * self.data[\"nodes\"][\"size\"].mean(),\n                    ha=\"center\",\n                    va=\"center\",\n                )\n\n    # set limits\n    ax.set_xlim(-1 * self.config[\"margin\"], 1 + (1*self.config[\"margin\"]))\n    ax.set_ylim(-1 * self.config[\"margin\"], 1 + (1*self.config[\"margin\"]))\n    return fig, ax\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_tikz/","title":"tikz","text":"<p>TikZ Backend for PathpyG Visualizations.</p> <p>Publication-quality vector graphics backend using LaTeX's TikZ package for static networks. Ideal for academic publications and high-quality print materials.</p> <p>Output Formats</p> <ul> <li>SVG: Scalable vector graphics for web and presentations</li> <li>PDF: Print-ready documents with embedded fonts  </li> <li>TeX: Raw LaTeX code for document integration</li> </ul> <p>Requirements</p> <ul> <li>LaTeX distribution with TikZ package</li> <li><code>dvisvgm</code> for SVG output (included with TeX Live)</li> <li><code>pdflatex</code> for PDF output</li> </ul>"},{"location":"reference/pathpyG/visualisations/_tikz/#pathpyG.visualisations._tikz--basic-usage","title":"Basic Usage","text":"<p><pre><code>import pathpyG as pp\n\n# Simple network visualization\nedges = [(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"A\")]\ng = pp.Graph.from_edge_list(edges)\npp.plot(g, backend=\"tikz\")\n</code></pre> </p>"},{"location":"reference/pathpyG/visualisations/_tikz/#pathpyG.visualisations._tikz--advanced-example","title":"Advanced Example","text":"<p><pre><code>import pathpyG as pp\nimport torch\n\n# Graph with custom styling\nedges = [(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"A\")]\ng = pp.Graph.from_edge_list(edges)\ng.data[\"node_size\"] = torch.tensor([15, 20, 25, 20])\n\npp.plot(\n    g,\n    backend=\"tikz\",\n    node_color={\"A\": \"red\", \"B\": \"#00FF00\"},\n    edge_opacity=0.7,\n    curvature=0.2,\n    width=\"8cm\",\n    height=\"6cm\",\n    filename=\"custom_network.svg\"\n)\n</code></pre> </p>"},{"location":"reference/pathpyG/visualisations/_tikz/#pathpyG.visualisations._tikz--time-unfolded-network-example","title":"Time-Unfolded Network Example","text":"<p>You can also create time-unfolded visualizations of temporal networks using the TikZ backend with all customization options from the temporal animations. With the <code>orientation</code> parameter, you can control the layout direction of the time-unfolded graph.</p> <p><pre><code>import pathpyG as pp\n\n# Example temporal network data\ntedges = [\n    (\"a\", \"b\", 1),\n    (\"a\", \"b\", 2),\n    (\"b\", \"a\", 3),\n    (\"a\", \"b\", 4),\n    (\"c\", \"b\", 4),\n    (\"c\", \"d\", 5),\n    (\"b\", \"a\", 5),\n    (\"c\", \"b\", 6),\n]\nt = pp.TemporalGraph.from_edge_list(tedges)\n\n# Create temporal plot and display inline\nnode_color = {\"a\": \"red\", (\"a\", 2): \"darkred\"}\nedge_color = {(\"a\", \"b\", 2): \"blue\"}\npp.plot(t, backend=\"tikz\", kind=\"unfolded\", node_size=12, node_color=node_color, edge_color=edge_color, orientation=\"right\")\n</code></pre> </p>"},{"location":"reference/pathpyG/visualisations/_tikz/#pathpyG.visualisations._tikz--templates","title":"Templates","text":"<p>PathpyG uses LaTeX templates to generate TikZ visualizations. Templates define standalone LaTeX documents with placeholders for dynamic content. Templates are located in the <code>pathpyG/visualisations/_tikz/templates/</code> directory. Currently supported templates: - <code>static.tex</code>: For static networks without time dynamics.</p>"},{"location":"reference/pathpyG/visualisations/_tikz/backend/","title":"backend","text":"<p>TikZ/LaTeX Backend for High-Quality Network Visualizations.</p> <p>This backend generates publication-ready vector graphics using LaTeX's TikZ package. It provides precise control over visual elements and produces scalable output suitable for academic papers, presentations, and professional documentation.</p> <p>Backend Capabilities</p> <ul> <li>Static networks only - Temporal networks not supported</li> <li>Vector output - SVG, PDF, and raw TeX formats</li> <li>LaTeX compilation - Automatic document generation and compilation</li> <li>Custom styling - Full control over colors, sizes, and layouts</li> </ul> <p>The backend handles the complete workflow from graph data to compiled output, including template processing, LaTeX compilation, and format conversion.</p>"},{"location":"reference/pathpyG/visualisations/_tikz/backend/#pathpyG.visualisations._tikz.backend--workflow-overview","title":"Workflow Overview","text":"<pre><code>graph LR\n    A[Graph Data] --&gt; B[TikZ Template]\n    B --&gt; C[LaTeX Document]\n    C --&gt; D[Compilation]\n    D --&gt; E[PDF Output]\n    D --&gt; F[DVI Output]\n    F --&gt; H[Conversion]\n    H --&gt; I[SVG Output]\n    C --&gt; G[TeX Output]</code></pre> <p>Performance Considerations</p> <ul> <li>Compilation time scales with network complexity</li> <li>Large networks (&gt;500 nodes) may require significant processing time</li> <li>Consider <code>matplotlib</code> backend for rapid prototyping of complex networks</li> </ul>"},{"location":"reference/pathpyG/visualisations/_tikz/backend/#pathpyG.visualisations._tikz.backend.TikzBackend","title":"<code>TikzBackend</code>","text":"<p>               Bases: <code>pathpyG.visualisations.plot_backend.PlotBackend</code></p> <p>TikZ/LaTeX Backend for Publication-Quality Network Graphics.</p> <p>Generates high-quality vector graphics using LaTeX's TikZ package. The backend mainly uses the <code>tikz-network</code> package to create detailed and customizable visualizations. This backend is optimized for static networks and provides publication-ready output with precise control over visual elements.</p> <p>Supported Operations</p> <ul> <li>Formats: SVG, PDF, TeX</li> <li>Networks: Static graphs only</li> <li>Styling: Full customization support</li> <li>Layouts: All pathpyG layout algorithms</li> </ul> <p>The backend automatically handles LaTeX compilation, temporary file management, and format conversion to deliver clean, scalable graphics suitable for academic publications and professional presentations.</p> <p>Attributes:</p> Name Type Description <code>plot</code> <p>The PathPyPlot instance containing graph data and configuration</p> <code>show_labels</code> <p>Whether to display node labels in the output</p> <code>_kind</code> <p>Type of plot being processed (for now only \"static\" supported)</p> Example <p><pre><code># The backend is typically used via pp.plot()\nimport pathpyG as pp\n\ng = pp.Graph.from_edge_list([(\"A\", \"B\"), (\"B\", \"C\")])\npp.plot(g, backend=\"tikz\")\n</code></pre> </p> Source code in <code>src/pathpyG/visualisations/_tikz/backend.py</code> <pre><code>class TikzBackend(PlotBackend):\n    \"\"\"TikZ/LaTeX Backend for Publication-Quality Network Graphics.\n\n    Generates high-quality vector graphics using LaTeX's TikZ package.\n    The backend mainly uses the [`tikz-network`](https://github.com/hackl/tikz-network)\n    package to create detailed and customizable visualizations. This backend\n    is optimized for static networks and provides publication-ready output with\n    precise control over visual elements.\n\n    !!! info \"Supported Operations\"\n        - **Formats**: SVG, PDF, TeX\n        - **Networks**: Static graphs only\n        - **Styling**: Full customization support\n        - **Layouts**: All pathpyG layout algorithms\n\n    The backend automatically handles LaTeX compilation, temporary file management,\n    and format conversion to deliver clean, scalable graphics suitable for\n    academic publications and professional presentations.\n\n    Attributes:\n        plot: The PathPyPlot instance containing graph data and configuration\n        show_labels: Whether to display node labels in the output\n        _kind: Type of plot being processed (for now only \"static\" supported)\n\n    Example:\n        ```python\n        # The backend is typically used via pp.plot()\n        import pathpyG as pp\n\n        g = pp.Graph.from_edge_list([(\"A\", \"B\"), (\"B\", \"C\")])\n        pp.plot(g, backend=\"tikz\")\n        ```\n        &lt;img src=\"../../plot/tikz_backend_example.svg\" alt=\"Example TikZ Backend Output\" width=\"550\"/&gt;\n    \"\"\"\n\n    def __init__(self, plot: PathPyPlot, show_labels: bool):\n        \"\"\"Initialize the TikZ backend with plot data and configuration.\n\n        Sets up the backend to process the provided plot data and validates\n        that the plot type is supported by the TikZ backend.\n\n        Args:\n            plot: PathPyPlot instance containing graph data, layout, and styling\n            show_labels: Whether to display node labels in the generated output\n\n        Raises:\n            ValueError: If the plot type is not supported by the TikZ backend\n\n        Note:\n            Currently only static NetworkPlot instances are supported.\n            Temporal networks require, e.g. the manim backend instead.\n        \"\"\"\n        super().__init__(plot, show_labels=show_labels)\n        self._kind = SUPPORTED_KINDS.get(type(plot), None)  # type: ignore[arg-type]\n        if self._kind is None:\n            logger.error(f\"Plot of type {type(plot)} not supported by Tikz backend.\")\n            raise ValueError(f\"Plot of type {type(plot)} not supported.\")\n\n    def save(self, filename: str) -&gt; None:\n        \"\"\"Save the network visualization to a file in the specified format.\n\n        Automatically detects the output format from the file extension and\n        performs the necessary compilation steps. Supports TeX (raw LaTeX),\n        PDF (compiled document), and SVG (vector graphics) formats.\n\n        Args:\n            filename: Output file path with extension (.tex, .pdf, or .svg)\n\n        Raises:\n            NotImplementedError: If the file extension is not supported\n\n        Note:\n            PDF and SVG compilation requires LaTeX toolchain installation.\n            The method handles temporary file creation and cleanup automatically.\n        \"\"\"\n        if filename.endswith(\"tex\"):\n            with open(filename, \"w+\") as new:\n                new.write(self.to_tex())\n        elif filename.endswith(\"pdf\"):\n            # compile temporary pdf\n            temp_file, temp_dir = self.compile_pdf()\n            # Copy a file with new name\n            shutil.copy(temp_file, filename)\n            # remove the temporal directory\n            shutil.rmtree(temp_dir)\n        elif filename.endswith(\"svg\"):\n            # compile temporary svg\n            temp_file, temp_dir = self.compile_svg()\n            # Copy a file with new name\n            shutil.copy(temp_file, filename)\n            # remove the temporal directory\n            shutil.rmtree(temp_dir)\n        else:\n            raise NotImplementedError\n\n    def show(self) -&gt; None:\n        \"\"\"Display the network visualization in the current environment.\n\n        Compiles the network to SVG format and displays it either inline\n        (in Jupyter notebooks) or opens it in the default web browser.\n        The display method is automatically chosen based on the environment.\n\n        The method creates temporary files for compilation and cleans them\n        up automatically after display.\n\n        Environment Detection:\n            - **Interactive (Jupyter)**: Displays SVG inline using IPython.display\n            - **Non-interactive**: Opens SVG file in default web browser\n\n        Note:\n            Requires LaTeX toolchain with TikZ and dvisvgm for SVG compilation.\n            Temporary files are automatically cleaned up after a brief delay.\n        \"\"\"\n        # compile temporary pdf\n        temp_file, temp_dir = self.compile_svg()\n\n        if config[\"environment\"][\"interactive\"]:\n            from IPython.display import SVG, display\n\n            # open the file, read the content and display it\n            # workaround because it is not possible to embed files in vs code\n            # https://github.com/microsoft/vscode-jupyter/discussions/13769\n            with open(temp_file, \"r\") as svg_file:\n                svg = SVG(svg_file.read())\n            display(svg)\n        else:\n            # open the file in the webbrowser\n            webbrowser.open(r\"file:///\" + temp_file)\n\n        # Wait for .1 second before temp file is deleted\n        time.sleep(0.1)\n\n        # remove the temporal directory\n        shutil.rmtree(temp_dir)\n\n    def compile_svg(self) -&gt; tuple:\n        \"\"\"Compile LaTeX source to SVG format using the LaTeX toolchain.\n\n        Performs a complete compilation workflow: TeX \u2192 DVI \u2192 SVG conversion.\n        Uses latexmk for robust LaTeX compilation and dvisvgm for high-quality\n        SVG conversion with proper text rendering.\n\n        Returns:\n            tuple: (svg_file_path, temp_directory_path) for the compiled SVG\n\n        Raises:\n            AttributeError: If LaTeX compilation fails or required tools are missing\n\n        Compilation Steps:\n            1. Generate temporary directory and save TeX source\n            2. Run latexmk to compile TeX \u2192 DVI\n            3. Use dvisvgm to convert DVI \u2192 SVG\n            4. Return paths for file access and cleanup\n\n        Note:\n            Both latexmk and dvisvgm must be available in the system PATH.\n        \"\"\"\n        temp_dir, current_dir = prepare_tempfile()\n        # save the tex file\n        self.save(\"default.tex\")\n\n        # latex compiler\n        command = [\n            \"latexmk\",\n            \"--interaction=nonstopmode\",\n            \"default.tex\",\n        ]\n        try:\n            subprocess.check_output(command, stderr=subprocess.STDOUT)\n        except subprocess.CalledProcessError as e:\n            logger.error(\"latexmk compiler failed with output:\\n%s\", e.output.decode())\n            raise AttributeError from e\n\n        # dvisvgm command\n        command = [\n            \"dvisvgm\",\n            \"default.dvi\",\n            \"-o\",\n            \"default.svg\",\n        ]\n        try:\n            subprocess.check_output(command, stderr=subprocess.STDOUT)\n        except subprocess.CalledProcessError as e:\n            logger.error(\"dvisvgm command failed with output:\\n%s\", e.output.decode())\n            raise AttributeError from e\n        finally:\n            # change back to the current directory\n            os.chdir(current_dir)\n\n        # return the name of the folder and temp svg file\n        return os.path.join(temp_dir, \"default.svg\"), temp_dir\n\n    def compile_pdf(self) -&gt; tuple:\n        \"\"\"Compile LaTeX source to PDF format using pdflatex.\n\n        Generates a high-quality PDF document suitable for printing and\n        publication. Uses latexmk with PDF mode for robust compilation\n        and automatic dependency handling.\n\n        Returns:\n            tuple: (pdf_file_path, temp_directory_path) for the compiled PDF\n\n        Raises:\n            AttributeError: If LaTeX compilation fails or pdflatex is not available\n\n        Note:\n            Requires latexmk and a PDF-capable LaTeX engine (pdflatex, xelatex, etc.).\n        \"\"\"\n        temp_dir, current_dir = prepare_tempfile()\n        # save the tex file\n        self.save(\"default.tex\")\n\n        # latex compiler\n        command = [\n            \"latexmk\",\n            \"--pdf\",\n            \"-shell-escape\",\n            \"--interaction=nonstopmode\",\n            \"default.tex\",\n        ]\n\n        try:\n            subprocess.check_output(command, stderr=subprocess.STDOUT)\n        except subprocess.CalledProcessError as e:\n            logger.error(\"latexmk compiler failed with output:\\n%s\", e.output.decode())\n            raise AttributeError from e\n        finally:\n            # change back to the current directory\n            os.chdir(current_dir)\n\n        # return the name of the folder and temp pdf file\n        return os.path.join(temp_dir, \"default.pdf\"), temp_dir\n\n    def to_tex(self) -&gt; str:\n        \"\"\"Generate complete LaTeX document with TikZ network visualization.\n\n        Combines the network data with a LaTeX template to create a complete\n        document ready for compilation. The template includes all necessary\n        packages, document setup, and TikZ drawing commands.\n\n        Returns:\n            str: Complete LaTeX document source code\n\n        Process:\n            1. **Load template** - Retrieves the appropriate template for the plot type\n            2. **Generate TikZ** - Converts network data to TikZ drawing commands\n            3. **Template substitution** - Fills template variables with graph data\n            4. **Return final string** - Complete LaTeX document ready for compilation\n\n        Template Variables:\n            - `$classoptions`: LaTeX class options\n            - `$width`, `$height`: Document dimensions\n            - `$margin`: Margin around the drawing area\n            - `$tikz`: TikZ drawing commands for nodes and edges\n\n        Note:\n            The generated document is self-contained and includes all necessary\n            TikZ packages and configuration for network visualization.\n        \"\"\"\n        # get path to the pathpy templates\n        template_dir = os.path.join(\n            os.path.dirname(os.path.dirname(__file__)),\n            os.path.normpath(\"_tikz/templates\"),\n        )\n\n        # get template files\n        with open(os.path.join(template_dir, \"static.tex\")) as template:\n            tex_template = template.read()\n\n        # generate data\n        data = self.to_tikz()\n\n        # fill template with data\n        tex = Template(tex_template).substitute(\n            classoptions=self.config.get(\"latex_class_options\"),\n            width=unit_str_to_float(self.config.get(\"width\"), \"cm\"),  # type: ignore[arg-type]\n            height=unit_str_to_float(self.config.get(\"height\"), \"cm\"),  # type: ignore[arg-type]\n            margin=self.config.get(\"margin\"),\n            tikz=data,\n        )\n\n        return tex\n\n    def to_tikz(self) -&gt; str:\n        r\"\"\"Generate TikZ drawing commands for the network visualization.\n\n        Converts the processed graph data (nodes, edges, layout) into TikZ-specific\n        drawing commands. Handles node positioning, styling, edge routing, and\n        label placement according to the configured visualization parameters.\n\n        Returns:\n            str: TikZ drawing commands ready for inclusion in LaTeX document\n\n        Generated Elements:\n            - **Node commands** - `\\Vertex` with labels, positions, colors, and sizes\n            - **Edge commands** - `\\Edge` with styling and optional curvature\n\n        Note:\n            The output assumes the tikz-network package is loaded in the template.\n            Coordinates are assumed to be normalized to [0, 1] range and scaled\n            according to the specified document dimensions.\n        \"\"\"\n        tikz = \"\"\n        # generate node strings\n        if not self.data[\"nodes\"].empty:\n            node_strings: pd.Series = \"\\\\Vertex[\"\n            # show labels if specified\n            if self.show_labels and self._kind == \"static\":\n                node_strings += (\n                    \"label=$\" + self.data[\"nodes\"].index.astype(str).map(self._replace_with_LaTeX_math_symbol) + \"$,\"\n                )\n                node_strings += (\n                    r\"fontsize=\\fontsize{\" + str(int(0.6 * self.data[\"nodes\"][\"size\"].mean())) + r\"}{10}\\selectfont,\"\n                )\n            # Convert hex colors to rgb if necessary\n            if self.data[\"nodes\"][\"color\"].str.startswith(\"#\").all():\n                self.data[\"nodes\"][\"color\"] = self.data[\"nodes\"][\"color\"].map(hex_to_rgb)\n                node_strings += \"RGB,color={\" + self.data[\"nodes\"][\"color\"].astype(str).str.strip(\"()\") + \"},\"\n            else:\n                node_strings += \"color=\" + self.data[\"nodes\"][\"color\"] + \",\"\n            # add other options\n            node_strings += \"size=\" + (self.data[\"nodes\"][\"size\"] * 0.075).astype(str) + \",\"\n            node_strings += \"opacity=\" + self.data[\"nodes\"][\"opacity\"].astype(str) + \",style={draw opacity=\" + self.data[\"nodes\"][\"opacity\"].astype(str) + \"},\" \n            # add position\n            node_strings += (\n                \"x=\"\n                + ((self.data[\"nodes\"][\"x\"] - 0.5) * unit_str_to_float(self.config[\"width\"], \"cm\")).astype(str)\n                + \",\"\n            )\n            node_strings += (\n                \"y=\"\n                + ((self.data[\"nodes\"][\"y\"] - 0.5) * unit_str_to_float(self.config[\"height\"], \"cm\")).astype(str)\n                + \"]\"\n            )\n            # add node name\n            node_strings += (\n                \"{\"\n                + self.data[\"nodes\"].index.map(lambda x: f\"{x[0]}{x[1]}\" if isinstance(x, tuple) else str(x))\n                + \"};\\n\"\n            )\n            tikz += node_strings.str.cat()\n\n            if self.show_labels and self._kind == \"unfolded\":\n                # add labels at the starting nodes only\n                min_time = self.data[\"nodes\"][\"start\"].min()\n                offset = 0.06 * self.data[\"nodes\"][\"size\"].mean()\n                sign = 1 if self.config[\"orientation\"] in [\"down\", \"left\"] else -1\n                label_df = self.data[\"nodes\"][self.data[\"nodes\"][\"start\"] == min_time]\n                label_strings: pd.Series = \"\\\\Vertex[\"\n                label_strings += \"label=$\" + label_df.index.map(lambda x: str(x[0])) + \"$,\"\n                label_strings += \"fontsize=\\\\fontsize{\" + str(int(label_df[\"size\"].mean())) + \"}{10}\\\\selectfont,\"\n                label_strings += \"opacity=0.0,style={draw=none},\"\n                label_strings += (\n                    \"x=\"\n                    + (\n                        (label_df[\"x\"] - 0.5) * unit_str_to_float(self.config[\"width\"], \"cm\")\n                        + (sign * offset if self.config[\"orientation\"] in [\"left\", \"right\"] else 0)\n                    ).astype(str)\n                    + \",\"\n                )\n                label_strings += (\n                    \"y=\"\n                    + (\n                        (label_df[\"y\"] - 0.5) * unit_str_to_float(self.config[\"height\"], \"cm\")\n                        + (sign * offset if self.config[\"orientation\"] in [\"down\", \"up\"] else 0)\n                    ).astype(str)\n                    + \"]\"\n                )\n                label_strings += \"{\" + label_df.index.map(lambda x: \"label_\" + str(x[0])) + \"};\\n\"\n                tikz += label_strings.str.cat()\n\n                # add timestamps at the border\n                time_df = self.data[\"nodes\"].iloc[: self.data[\"nodes\"][\"end\"].max()]\n                time_df.loc[:, [\"x\", \"y\"]] = (time_df[[\"x\", \"y\"]] + time_df[[\"x\", \"y\"]].shift(-1)) / 2\n                time_df = time_df.iloc[:-1]\n                time_strings: pd.Series = \"\\\\Vertex[\"\n                time_strings += \"label=$\" + time_df[\"start\"].astype(str) + \"$,\"\n                time_strings += \"fontsize=\\\\fontsize{\" + str(int(time_df[\"size\"].mean())) + \"}{10}\\\\selectfont,\"\n                time_strings += \"opacity=0.0,style={draw=none},\"\n                time_strings += (\n                    \"x=\"\n                    + (\n                        (time_df[\"x\"] - 0.5) * unit_str_to_float(self.config[\"width\"], \"cm\")\n                        - (offset if self.config[\"orientation\"] in [\"up\", \"down\"] else 0)\n                    ).astype(str)\n                    + \",\"\n                )\n                time_strings += (\n                    \"y=\"\n                    + (\n                        (time_df[\"y\"] - 0.5) * unit_str_to_float(self.config[\"height\"], \"cm\")\n                        - (offset if self.config[\"orientation\"] in [\"left\", \"right\"] else 0)\n                    ).astype(str)\n                    + \"]\"\n                )\n                time_strings += \"{\" + time_df.index.map(lambda x: \"time_\" + str(x[0])) + \"};\\n\"\n                tikz += time_strings.str.cat()\n\n        # generate edge strings\n        if not self.data[\"edges\"].empty:\n            edge_strings: pd.Series = \"\\\\Edge[\"\n            if self.config[\"curved\"]:\n                edge_strings += \"bend=15,\"\n            if self.config[\"directed\"]:\n                edge_strings += \"Direct,\"\n            if self.data[\"edges\"][\"color\"].str.startswith(\"#\").all():\n                self.data[\"edges\"][\"color\"] = self.data[\"edges\"][\"color\"].map(hex_to_rgb)\n                edge_strings += \"RGB,color={\" + self.data[\"edges\"][\"color\"].astype(str).str.strip(\"()\") + \"},\"\n            else:\n                edge_strings += \"color=\" + self.data[\"edges\"][\"color\"] + \",\"\n            edge_strings += \"lw=\" + self.data[\"edges\"][\"size\"].astype(str) + \",\"\n            edge_strings += \"opacity=\" + self.data[\"edges\"][\"opacity\"].astype(str) + \"]\"\n            edge_strings += (\n                \"(\"\n                + self.data[\"edges\"]\n                .index.to_frame()[\"source\"]\n                .map(lambda x: f\"{x[0]}{x[1]}\" if isinstance(x, tuple) else str(x))\n                + \")(\"\n                + self.data[\"edges\"]\n                .index.to_frame()[\"target\"]\n                .map(lambda x: f\"{x[0]}{x[1]}\" if isinstance(x, tuple) else str(x))\n                + \");\\n\"\n            )\n            tikz += edge_strings.str.cat()\n\n        return tikz\n\n    def _replace_with_LaTeX_math_symbol(self, node_label: str) -&gt; str:\n        \"\"\"Replace certain symbols with LaTeX math symbols.\"\"\"\n        replacements = {\n            \"-&gt;\": r\"\\to \",\n            \"&lt;-\": r\"\\gets \",\n            \"&lt;-&gt;\": r\"\\leftrightarrow \",\n            \"=&gt;\": r\"\\Rightarrow \",\n            \"&lt;=\": r\"\\Leftarrow \",\n            \"&lt;=&gt;\": r\"\\Leftrightarrow \",\n            \"!=\": r\"\\neq \",\n        }\n        if self.config[\"separator\"].strip() in replacements:\n            node_label = node_label.replace(\n                self.config[\"separator\"],\n                replacements[self.config[\"separator\"].strip()],\n            )\n        return node_label\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_tikz/backend/#pathpyG.visualisations._tikz.backend.TikzBackend.__init__","title":"<code>__init__</code>","text":"<p>Initialize the TikZ backend with plot data and configuration.</p> <p>Sets up the backend to process the provided plot data and validates that the plot type is supported by the TikZ backend.</p> <p>Parameters:</p> Name Type Description Default <code>plot</code> <code>pathpyG.visualisations.pathpy_plot.PathPyPlot</code> <p>PathPyPlot instance containing graph data, layout, and styling</p> required <code>show_labels</code> <code>bool</code> <p>Whether to display node labels in the generated output</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the plot type is not supported by the TikZ backend</p> Note <p>Currently only static NetworkPlot instances are supported. Temporal networks require, e.g. the manim backend instead.</p> Source code in <code>src/pathpyG/visualisations/_tikz/backend.py</code> <pre><code>def __init__(self, plot: PathPyPlot, show_labels: bool):\n    \"\"\"Initialize the TikZ backend with plot data and configuration.\n\n    Sets up the backend to process the provided plot data and validates\n    that the plot type is supported by the TikZ backend.\n\n    Args:\n        plot: PathPyPlot instance containing graph data, layout, and styling\n        show_labels: Whether to display node labels in the generated output\n\n    Raises:\n        ValueError: If the plot type is not supported by the TikZ backend\n\n    Note:\n        Currently only static NetworkPlot instances are supported.\n        Temporal networks require, e.g. the manim backend instead.\n    \"\"\"\n    super().__init__(plot, show_labels=show_labels)\n    self._kind = SUPPORTED_KINDS.get(type(plot), None)  # type: ignore[arg-type]\n    if self._kind is None:\n        logger.error(f\"Plot of type {type(plot)} not supported by Tikz backend.\")\n        raise ValueError(f\"Plot of type {type(plot)} not supported.\")\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_tikz/backend/#pathpyG.visualisations._tikz.backend.TikzBackend.compile_pdf","title":"<code>compile_pdf</code>","text":"<p>Compile LaTeX source to PDF format using pdflatex.</p> <p>Generates a high-quality PDF document suitable for printing and publication. Uses latexmk with PDF mode for robust compilation and automatic dependency handling.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>(pdf_file_path, temp_directory_path) for the compiled PDF</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If LaTeX compilation fails or pdflatex is not available</p> Note <p>Requires latexmk and a PDF-capable LaTeX engine (pdflatex, xelatex, etc.).</p> Source code in <code>src/pathpyG/visualisations/_tikz/backend.py</code> <pre><code>def compile_pdf(self) -&gt; tuple:\n    \"\"\"Compile LaTeX source to PDF format using pdflatex.\n\n    Generates a high-quality PDF document suitable for printing and\n    publication. Uses latexmk with PDF mode for robust compilation\n    and automatic dependency handling.\n\n    Returns:\n        tuple: (pdf_file_path, temp_directory_path) for the compiled PDF\n\n    Raises:\n        AttributeError: If LaTeX compilation fails or pdflatex is not available\n\n    Note:\n        Requires latexmk and a PDF-capable LaTeX engine (pdflatex, xelatex, etc.).\n    \"\"\"\n    temp_dir, current_dir = prepare_tempfile()\n    # save the tex file\n    self.save(\"default.tex\")\n\n    # latex compiler\n    command = [\n        \"latexmk\",\n        \"--pdf\",\n        \"-shell-escape\",\n        \"--interaction=nonstopmode\",\n        \"default.tex\",\n    ]\n\n    try:\n        subprocess.check_output(command, stderr=subprocess.STDOUT)\n    except subprocess.CalledProcessError as e:\n        logger.error(\"latexmk compiler failed with output:\\n%s\", e.output.decode())\n        raise AttributeError from e\n    finally:\n        # change back to the current directory\n        os.chdir(current_dir)\n\n    # return the name of the folder and temp pdf file\n    return os.path.join(temp_dir, \"default.pdf\"), temp_dir\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_tikz/backend/#pathpyG.visualisations._tikz.backend.TikzBackend.compile_svg","title":"<code>compile_svg</code>","text":"<p>Compile LaTeX source to SVG format using the LaTeX toolchain.</p> <p>Performs a complete compilation workflow: TeX \u2192 DVI \u2192 SVG conversion. Uses latexmk for robust LaTeX compilation and dvisvgm for high-quality SVG conversion with proper text rendering.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>(svg_file_path, temp_directory_path) for the compiled SVG</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If LaTeX compilation fails or required tools are missing</p> Compilation Steps <ol> <li>Generate temporary directory and save TeX source</li> <li>Run latexmk to compile TeX \u2192 DVI</li> <li>Use dvisvgm to convert DVI \u2192 SVG</li> <li>Return paths for file access and cleanup</li> </ol> Note <p>Both latexmk and dvisvgm must be available in the system PATH.</p> Source code in <code>src/pathpyG/visualisations/_tikz/backend.py</code> <pre><code>def compile_svg(self) -&gt; tuple:\n    \"\"\"Compile LaTeX source to SVG format using the LaTeX toolchain.\n\n    Performs a complete compilation workflow: TeX \u2192 DVI \u2192 SVG conversion.\n    Uses latexmk for robust LaTeX compilation and dvisvgm for high-quality\n    SVG conversion with proper text rendering.\n\n    Returns:\n        tuple: (svg_file_path, temp_directory_path) for the compiled SVG\n\n    Raises:\n        AttributeError: If LaTeX compilation fails or required tools are missing\n\n    Compilation Steps:\n        1. Generate temporary directory and save TeX source\n        2. Run latexmk to compile TeX \u2192 DVI\n        3. Use dvisvgm to convert DVI \u2192 SVG\n        4. Return paths for file access and cleanup\n\n    Note:\n        Both latexmk and dvisvgm must be available in the system PATH.\n    \"\"\"\n    temp_dir, current_dir = prepare_tempfile()\n    # save the tex file\n    self.save(\"default.tex\")\n\n    # latex compiler\n    command = [\n        \"latexmk\",\n        \"--interaction=nonstopmode\",\n        \"default.tex\",\n    ]\n    try:\n        subprocess.check_output(command, stderr=subprocess.STDOUT)\n    except subprocess.CalledProcessError as e:\n        logger.error(\"latexmk compiler failed with output:\\n%s\", e.output.decode())\n        raise AttributeError from e\n\n    # dvisvgm command\n    command = [\n        \"dvisvgm\",\n        \"default.dvi\",\n        \"-o\",\n        \"default.svg\",\n    ]\n    try:\n        subprocess.check_output(command, stderr=subprocess.STDOUT)\n    except subprocess.CalledProcessError as e:\n        logger.error(\"dvisvgm command failed with output:\\n%s\", e.output.decode())\n        raise AttributeError from e\n    finally:\n        # change back to the current directory\n        os.chdir(current_dir)\n\n    # return the name of the folder and temp svg file\n    return os.path.join(temp_dir, \"default.svg\"), temp_dir\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_tikz/backend/#pathpyG.visualisations._tikz.backend.TikzBackend.save","title":"<code>save</code>","text":"<p>Save the network visualization to a file in the specified format.</p> <p>Automatically detects the output format from the file extension and performs the necessary compilation steps. Supports TeX (raw LaTeX), PDF (compiled document), and SVG (vector graphics) formats.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Output file path with extension (.tex, .pdf, or .svg)</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the file extension is not supported</p> Note <p>PDF and SVG compilation requires LaTeX toolchain installation. The method handles temporary file creation and cleanup automatically.</p> Source code in <code>src/pathpyG/visualisations/_tikz/backend.py</code> <pre><code>def save(self, filename: str) -&gt; None:\n    \"\"\"Save the network visualization to a file in the specified format.\n\n    Automatically detects the output format from the file extension and\n    performs the necessary compilation steps. Supports TeX (raw LaTeX),\n    PDF (compiled document), and SVG (vector graphics) formats.\n\n    Args:\n        filename: Output file path with extension (.tex, .pdf, or .svg)\n\n    Raises:\n        NotImplementedError: If the file extension is not supported\n\n    Note:\n        PDF and SVG compilation requires LaTeX toolchain installation.\n        The method handles temporary file creation and cleanup automatically.\n    \"\"\"\n    if filename.endswith(\"tex\"):\n        with open(filename, \"w+\") as new:\n            new.write(self.to_tex())\n    elif filename.endswith(\"pdf\"):\n        # compile temporary pdf\n        temp_file, temp_dir = self.compile_pdf()\n        # Copy a file with new name\n        shutil.copy(temp_file, filename)\n        # remove the temporal directory\n        shutil.rmtree(temp_dir)\n    elif filename.endswith(\"svg\"):\n        # compile temporary svg\n        temp_file, temp_dir = self.compile_svg()\n        # Copy a file with new name\n        shutil.copy(temp_file, filename)\n        # remove the temporal directory\n        shutil.rmtree(temp_dir)\n    else:\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_tikz/backend/#pathpyG.visualisations._tikz.backend.TikzBackend.show","title":"<code>show</code>","text":"<p>Display the network visualization in the current environment.</p> <p>Compiles the network to SVG format and displays it either inline (in Jupyter notebooks) or opens it in the default web browser. The display method is automatically chosen based on the environment.</p> <p>The method creates temporary files for compilation and cleans them up automatically after display.</p> Environment Detection <ul> <li>Interactive (Jupyter): Displays SVG inline using IPython.display</li> <li>Non-interactive: Opens SVG file in default web browser</li> </ul> Note <p>Requires LaTeX toolchain with TikZ and dvisvgm for SVG compilation. Temporary files are automatically cleaned up after a brief delay.</p> Source code in <code>src/pathpyG/visualisations/_tikz/backend.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Display the network visualization in the current environment.\n\n    Compiles the network to SVG format and displays it either inline\n    (in Jupyter notebooks) or opens it in the default web browser.\n    The display method is automatically chosen based on the environment.\n\n    The method creates temporary files for compilation and cleans them\n    up automatically after display.\n\n    Environment Detection:\n        - **Interactive (Jupyter)**: Displays SVG inline using IPython.display\n        - **Non-interactive**: Opens SVG file in default web browser\n\n    Note:\n        Requires LaTeX toolchain with TikZ and dvisvgm for SVG compilation.\n        Temporary files are automatically cleaned up after a brief delay.\n    \"\"\"\n    # compile temporary pdf\n    temp_file, temp_dir = self.compile_svg()\n\n    if config[\"environment\"][\"interactive\"]:\n        from IPython.display import SVG, display\n\n        # open the file, read the content and display it\n        # workaround because it is not possible to embed files in vs code\n        # https://github.com/microsoft/vscode-jupyter/discussions/13769\n        with open(temp_file, \"r\") as svg_file:\n            svg = SVG(svg_file.read())\n        display(svg)\n    else:\n        # open the file in the webbrowser\n        webbrowser.open(r\"file:///\" + temp_file)\n\n    # Wait for .1 second before temp file is deleted\n    time.sleep(0.1)\n\n    # remove the temporal directory\n    shutil.rmtree(temp_dir)\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_tikz/backend/#pathpyG.visualisations._tikz.backend.TikzBackend.to_tex","title":"<code>to_tex</code>","text":"<p>Generate complete LaTeX document with TikZ network visualization.</p> <p>Combines the network data with a LaTeX template to create a complete document ready for compilation. The template includes all necessary packages, document setup, and TikZ drawing commands.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Complete LaTeX document source code</p> Process <ol> <li>Load template - Retrieves the appropriate template for the plot type</li> <li>Generate TikZ - Converts network data to TikZ drawing commands</li> <li>Template substitution - Fills template variables with graph data</li> <li>Return final string - Complete LaTeX document ready for compilation</li> </ol> Template Variables <ul> <li><code>$classoptions</code>: LaTeX class options</li> <li><code>$width</code>, <code>$height</code>: Document dimensions</li> <li><code>$margin</code>: Margin around the drawing area</li> <li><code>$tikz</code>: TikZ drawing commands for nodes and edges</li> </ul> Note <p>The generated document is self-contained and includes all necessary TikZ packages and configuration for network visualization.</p> Source code in <code>src/pathpyG/visualisations/_tikz/backend.py</code> <pre><code>def to_tex(self) -&gt; str:\n    \"\"\"Generate complete LaTeX document with TikZ network visualization.\n\n    Combines the network data with a LaTeX template to create a complete\n    document ready for compilation. The template includes all necessary\n    packages, document setup, and TikZ drawing commands.\n\n    Returns:\n        str: Complete LaTeX document source code\n\n    Process:\n        1. **Load template** - Retrieves the appropriate template for the plot type\n        2. **Generate TikZ** - Converts network data to TikZ drawing commands\n        3. **Template substitution** - Fills template variables with graph data\n        4. **Return final string** - Complete LaTeX document ready for compilation\n\n    Template Variables:\n        - `$classoptions`: LaTeX class options\n        - `$width`, `$height`: Document dimensions\n        - `$margin`: Margin around the drawing area\n        - `$tikz`: TikZ drawing commands for nodes and edges\n\n    Note:\n        The generated document is self-contained and includes all necessary\n        TikZ packages and configuration for network visualization.\n    \"\"\"\n    # get path to the pathpy templates\n    template_dir = os.path.join(\n        os.path.dirname(os.path.dirname(__file__)),\n        os.path.normpath(\"_tikz/templates\"),\n    )\n\n    # get template files\n    with open(os.path.join(template_dir, \"static.tex\")) as template:\n        tex_template = template.read()\n\n    # generate data\n    data = self.to_tikz()\n\n    # fill template with data\n    tex = Template(tex_template).substitute(\n        classoptions=self.config.get(\"latex_class_options\"),\n        width=unit_str_to_float(self.config.get(\"width\"), \"cm\"),  # type: ignore[arg-type]\n        height=unit_str_to_float(self.config.get(\"height\"), \"cm\"),  # type: ignore[arg-type]\n        margin=self.config.get(\"margin\"),\n        tikz=data,\n    )\n\n    return tex\n</code></pre>"},{"location":"reference/pathpyG/visualisations/_tikz/backend/#pathpyG.visualisations._tikz.backend.TikzBackend.to_tikz","title":"<code>to_tikz</code>","text":"<p>Generate TikZ drawing commands for the network visualization.</p> <p>Converts the processed graph data (nodes, edges, layout) into TikZ-specific drawing commands. Handles node positioning, styling, edge routing, and label placement according to the configured visualization parameters.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>TikZ drawing commands ready for inclusion in LaTeX document</p> Generated Elements <ul> <li>Node commands - <code>\\Vertex</code> with labels, positions, colors, and sizes</li> <li>Edge commands - <code>\\Edge</code> with styling and optional curvature</li> </ul> Note <p>The output assumes the tikz-network package is loaded in the template. Coordinates are assumed to be normalized to [0, 1] range and scaled according to the specified document dimensions.</p> Source code in <code>src/pathpyG/visualisations/_tikz/backend.py</code> <pre><code>def to_tikz(self) -&gt; str:\n    r\"\"\"Generate TikZ drawing commands for the network visualization.\n\n    Converts the processed graph data (nodes, edges, layout) into TikZ-specific\n    drawing commands. Handles node positioning, styling, edge routing, and\n    label placement according to the configured visualization parameters.\n\n    Returns:\n        str: TikZ drawing commands ready for inclusion in LaTeX document\n\n    Generated Elements:\n        - **Node commands** - `\\Vertex` with labels, positions, colors, and sizes\n        - **Edge commands** - `\\Edge` with styling and optional curvature\n\n    Note:\n        The output assumes the tikz-network package is loaded in the template.\n        Coordinates are assumed to be normalized to [0, 1] range and scaled\n        according to the specified document dimensions.\n    \"\"\"\n    tikz = \"\"\n    # generate node strings\n    if not self.data[\"nodes\"].empty:\n        node_strings: pd.Series = \"\\\\Vertex[\"\n        # show labels if specified\n        if self.show_labels and self._kind == \"static\":\n            node_strings += (\n                \"label=$\" + self.data[\"nodes\"].index.astype(str).map(self._replace_with_LaTeX_math_symbol) + \"$,\"\n            )\n            node_strings += (\n                r\"fontsize=\\fontsize{\" + str(int(0.6 * self.data[\"nodes\"][\"size\"].mean())) + r\"}{10}\\selectfont,\"\n            )\n        # Convert hex colors to rgb if necessary\n        if self.data[\"nodes\"][\"color\"].str.startswith(\"#\").all():\n            self.data[\"nodes\"][\"color\"] = self.data[\"nodes\"][\"color\"].map(hex_to_rgb)\n            node_strings += \"RGB,color={\" + self.data[\"nodes\"][\"color\"].astype(str).str.strip(\"()\") + \"},\"\n        else:\n            node_strings += \"color=\" + self.data[\"nodes\"][\"color\"] + \",\"\n        # add other options\n        node_strings += \"size=\" + (self.data[\"nodes\"][\"size\"] * 0.075).astype(str) + \",\"\n        node_strings += \"opacity=\" + self.data[\"nodes\"][\"opacity\"].astype(str) + \",style={draw opacity=\" + self.data[\"nodes\"][\"opacity\"].astype(str) + \"},\" \n        # add position\n        node_strings += (\n            \"x=\"\n            + ((self.data[\"nodes\"][\"x\"] - 0.5) * unit_str_to_float(self.config[\"width\"], \"cm\")).astype(str)\n            + \",\"\n        )\n        node_strings += (\n            \"y=\"\n            + ((self.data[\"nodes\"][\"y\"] - 0.5) * unit_str_to_float(self.config[\"height\"], \"cm\")).astype(str)\n            + \"]\"\n        )\n        # add node name\n        node_strings += (\n            \"{\"\n            + self.data[\"nodes\"].index.map(lambda x: f\"{x[0]}{x[1]}\" if isinstance(x, tuple) else str(x))\n            + \"};\\n\"\n        )\n        tikz += node_strings.str.cat()\n\n        if self.show_labels and self._kind == \"unfolded\":\n            # add labels at the starting nodes only\n            min_time = self.data[\"nodes\"][\"start\"].min()\n            offset = 0.06 * self.data[\"nodes\"][\"size\"].mean()\n            sign = 1 if self.config[\"orientation\"] in [\"down\", \"left\"] else -1\n            label_df = self.data[\"nodes\"][self.data[\"nodes\"][\"start\"] == min_time]\n            label_strings: pd.Series = \"\\\\Vertex[\"\n            label_strings += \"label=$\" + label_df.index.map(lambda x: str(x[0])) + \"$,\"\n            label_strings += \"fontsize=\\\\fontsize{\" + str(int(label_df[\"size\"].mean())) + \"}{10}\\\\selectfont,\"\n            label_strings += \"opacity=0.0,style={draw=none},\"\n            label_strings += (\n                \"x=\"\n                + (\n                    (label_df[\"x\"] - 0.5) * unit_str_to_float(self.config[\"width\"], \"cm\")\n                    + (sign * offset if self.config[\"orientation\"] in [\"left\", \"right\"] else 0)\n                ).astype(str)\n                + \",\"\n            )\n            label_strings += (\n                \"y=\"\n                + (\n                    (label_df[\"y\"] - 0.5) * unit_str_to_float(self.config[\"height\"], \"cm\")\n                    + (sign * offset if self.config[\"orientation\"] in [\"down\", \"up\"] else 0)\n                ).astype(str)\n                + \"]\"\n            )\n            label_strings += \"{\" + label_df.index.map(lambda x: \"label_\" + str(x[0])) + \"};\\n\"\n            tikz += label_strings.str.cat()\n\n            # add timestamps at the border\n            time_df = self.data[\"nodes\"].iloc[: self.data[\"nodes\"][\"end\"].max()]\n            time_df.loc[:, [\"x\", \"y\"]] = (time_df[[\"x\", \"y\"]] + time_df[[\"x\", \"y\"]].shift(-1)) / 2\n            time_df = time_df.iloc[:-1]\n            time_strings: pd.Series = \"\\\\Vertex[\"\n            time_strings += \"label=$\" + time_df[\"start\"].astype(str) + \"$,\"\n            time_strings += \"fontsize=\\\\fontsize{\" + str(int(time_df[\"size\"].mean())) + \"}{10}\\\\selectfont,\"\n            time_strings += \"opacity=0.0,style={draw=none},\"\n            time_strings += (\n                \"x=\"\n                + (\n                    (time_df[\"x\"] - 0.5) * unit_str_to_float(self.config[\"width\"], \"cm\")\n                    - (offset if self.config[\"orientation\"] in [\"up\", \"down\"] else 0)\n                ).astype(str)\n                + \",\"\n            )\n            time_strings += (\n                \"y=\"\n                + (\n                    (time_df[\"y\"] - 0.5) * unit_str_to_float(self.config[\"height\"], \"cm\")\n                    - (offset if self.config[\"orientation\"] in [\"left\", \"right\"] else 0)\n                ).astype(str)\n                + \"]\"\n            )\n            time_strings += \"{\" + time_df.index.map(lambda x: \"time_\" + str(x[0])) + \"};\\n\"\n            tikz += time_strings.str.cat()\n\n    # generate edge strings\n    if not self.data[\"edges\"].empty:\n        edge_strings: pd.Series = \"\\\\Edge[\"\n        if self.config[\"curved\"]:\n            edge_strings += \"bend=15,\"\n        if self.config[\"directed\"]:\n            edge_strings += \"Direct,\"\n        if self.data[\"edges\"][\"color\"].str.startswith(\"#\").all():\n            self.data[\"edges\"][\"color\"] = self.data[\"edges\"][\"color\"].map(hex_to_rgb)\n            edge_strings += \"RGB,color={\" + self.data[\"edges\"][\"color\"].astype(str).str.strip(\"()\") + \"},\"\n        else:\n            edge_strings += \"color=\" + self.data[\"edges\"][\"color\"] + \",\"\n        edge_strings += \"lw=\" + self.data[\"edges\"][\"size\"].astype(str) + \",\"\n        edge_strings += \"opacity=\" + self.data[\"edges\"][\"opacity\"].astype(str) + \"]\"\n        edge_strings += (\n            \"(\"\n            + self.data[\"edges\"]\n            .index.to_frame()[\"source\"]\n            .map(lambda x: f\"{x[0]}{x[1]}\" if isinstance(x, tuple) else str(x))\n            + \")(\"\n            + self.data[\"edges\"]\n            .index.to_frame()[\"target\"]\n            .map(lambda x: f\"{x[0]}{x[1]}\" if isinstance(x, tuple) else str(x))\n            + \");\\n\"\n        )\n        tikz += edge_strings.str.cat()\n\n    return tikz\n</code></pre>"},{"location":"tutorial/basic_concepts/","title":"Basic Concepts","text":"In\u00a0[1]: Copied! <pre>%%capture\n# !pip install torch\n# !pip install torch_geometric\n# !pip install git+https://github.com/pathpy/pathpyG.git\n</pre> %%capture # !pip install torch # !pip install torch_geometric # !pip install git+https://github.com/pathpy/pathpyG.git In\u00a0[2]: Copied! <pre>import os\nimport tempfile\n\nimport pandas as pd\nimport torch\nfrom torch_geometric.data import Data\n\nimport pathpyG as pp\n</pre> import os import tempfile  import pandas as pd import torch from torch_geometric.data import Data  import pathpyG as pp  In\u00a0[3]: Copied! <pre>d = Data(edge_index = torch.tensor([[0,1,0], [2,2,1]]))\ng = pp.Graph(d)\nprint(g)\n</pre> d = Data(edge_index = torch.tensor([[0,1,0], [2,2,1]])) g = pp.Graph(d) print(g) <pre>Directed graph with 3 nodes and 3 edges\n{'Edge Attributes': {}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\n</pre> <p>If we do not need additional node or edge attributes, we can use the class function <code>Graph.from_edge_index</code> to directly create a graph based on an edge index:</p> In\u00a0[4]: Copied! <pre>g = pp.Graph.from_edge_index(torch.tensor([[0,1,0], [2,2,1]]))\nprint(g)\n</pre> g = pp.Graph.from_edge_index(torch.tensor([[0,1,0], [2,2,1]])) print(g) <pre>Directed graph with 3 nodes and 3 edges\n{'Edge Attributes': {}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\n</pre> <p>We may want to inlude isolated nodes that do not have an edge. We can do so by passing a <code>num_nodes</code> parameter. The following graph thus contains a fourth node (which we could name as <code>d</code>) that is not connected to any of the other nodes.</p> In\u00a0[5]: Copied! <pre>g = pp.Graph.from_edge_index(torch.tensor([[0,1,0], [2,2,1]]), num_nodes=4)\nprint(g)\n</pre> g = pp.Graph.from_edge_index(torch.tensor([[0,1,0], [2,2,1]]), num_nodes=4) print(g) <pre>Directed graph with 4 nodes and 3 edges\n{'Edge Attributes': {}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\n</pre> <p>In both cases, the <code>Graph</code> instance has a property <code>g.data</code> that stores a <code>pyG</code> <code>Data</code> object that includes the edge index as well as any further node-, edge- or graph-level attributes.</p> In\u00a0[6]: Copied! <pre>print(g.data)\n</pre> print(g.data) <pre>Data(edge_index=[2, 3], num_nodes=4, node_sequence=[4, 1])\n</pre> In\u00a0[7]: Copied! <pre>print(g.data.edge_index)\n</pre> print(g.data.edge_index) <pre>EdgeIndex([[0, 0, 1],\n           [2, 1, 2]], sparse_size=(4, 4), nnz=3, sort_order=row)\n</pre> <p>Note that the <code>edge_index</code> is actually of type <code>pyG.EdgeIndex</code>, which is a subclass of <code>torch.Tensor</code>. Any tensor passed as an edge index in the constructor of <code>Graph</code> will automatically be converted to an <code>EdgeIndex</code> instance, as this internally allows us to provide efficient edge traveral routines based on sparse matrix operations. To support this, the edge index will be automatically sorted by row when the <code>Graph</code> object is created. To avoid this additional sort operation, you can pass an already sorted <code>EdgeIndex</code> object in the <code>Data</code> object in the constructor or using the <code>from_edge_index</code> class function.</p> <p>We can use the generators <code>nodes</code> and <code>edges</code> to iterate through the nodes and edges of a graph as follows:</p> In\u00a0[8]: Copied! <pre>for v in g.nodes:\n    print(v)\n\nfor e in g.edges:\n    print(e)\n</pre> for v in g.nodes:     print(v)  for e in g.edges:     print(e) <pre>0\n1\n2\n3\n(0, 2)\n(0, 1)\n(1, 2)\n</pre> <p>While the index-based representation of nodes allows for efficient tensor-based operations, it is often convenient to use string identifiers to refer to nodes. To simplify the handling of graphs with such node identifiers, <code>pathpyG</code> provides a class <code>IndexMap</code> that transparently maps string identifiers to integer indices. For our small example graph, we can create an <code>IndexMap</code> that associates node indices with string IDs. For our example, we can create a mapping as follows:</p> In\u00a0[9]: Copied! <pre>m = pp.IndexMap(['a', 'b', 'c', 'd'])\nprint(m)\n</pre> m = pp.IndexMap(['a', 'b', 'c', 'd']) print(m) <pre>a -&gt; 0\nb -&gt; 1\nc -&gt; 2\nd -&gt; 3\n\n</pre> <p>We can use the functions <code>IndexMap.to_id</code> or <code>IndexMap.to_idx</code> to map a node to an index or an ID:</p> In\u00a0[10]: Copied! <pre>print(m.to_id(0))\n</pre> print(m.to_id(0)) <pre>a\n</pre> In\u00a0[11]: Copied! <pre>print(m.to_idx('b'))\n</pre> print(m.to_idx('b')) <pre>1\n</pre> <p><code>pathpyG</code> can apply this mapping transparently for the user. For this, we can add a mapping to a <code>Graph</code> object, either by passing it in the constructor or by setting the <code>mapping</code> attribute of an existing <code>Graph</code> instance.</p> In\u00a0[12]: Copied! <pre>g.mapping = m\n</pre> g.mapping = m <p>If we now iterate through the nodes and edges of the graph, we get:</p> In\u00a0[13]: Copied! <pre>for v in g.nodes:\n    print(v)\n\nfor e in g.edges:\n    print(e)\n</pre> for v in g.nodes:     print(v)  for e in g.edges:     print(e) <pre>a\nb\nc\nd\n('a', 'c')\n('a', 'b')\n('b', 'c')\n</pre> <p>We can also pass an <code>IndexMap</code> object to the constructor of the <code>Graph</code> class. This transparently applies the mapping in all future operations on this graph instance.</p> In\u00a0[14]: Copied! <pre>g = pp.Graph.from_edge_index(torch.tensor([[0,1,0], [2,2,1]]), num_nodes = 4, mapping=m)\n</pre> g = pp.Graph.from_edge_index(torch.tensor([[0,1,0], [2,2,1]]), num_nodes = 4, mapping=m) <p>Above, we have created a graph based on an edge index tensor and we then additionally applied a mapping that we manually defined. We often have data in the form on an edge list, where edges are given as tuples of non-numeric node identifiers. The class function <code>Graph.from_edge_list</code> simplifies the construction of a <code>Graph</code> from such edge lists. It automatically creates an internal integer-based representation of the edge index along with the associated <code>IndexMap</code>, where integer node indices are based on the lexicographic order of node IDs.</p> In\u00a0[15]: Copied! <pre>g = pp.Graph.from_edge_list([('a','b'), ('b','c'), ('a','c')])\nprint(g)\nprint(g.data.edge_index)\nprint(g.mapping)\n</pre> g = pp.Graph.from_edge_list([('a','b'), ('b','c'), ('a','c')]) print(g) print(g.data.edge_index) print(g.mapping) <pre>Directed graph with 3 nodes and 3 edges\n{'Edge Attributes': {}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\nEdgeIndex([[0, 0, 1],\n           [1, 2, 2]], sparse_size=(3, 3), nnz=3, sort_order=row)\na -&gt; 0\nb -&gt; 1\nc -&gt; 2\n\n</pre> <p>We can also pass a custom index mapping, e.g. mapping node <code>c</code> to idex 1 and node <code>b</code> to index 2 (thus deviating from a lexicographic order):</p> In\u00a0[16]: Copied! <pre>g = pp.Graph.from_edge_list([('a','b'), ('a','c'), ('b','c')], mapping = pp.IndexMap(['a', 'c', 'b']))\nprint(g.data.edge_index)\nprint(g.mapping)\n</pre> g = pp.Graph.from_edge_list([('a','b'), ('a','c'), ('b','c')], mapping = pp.IndexMap(['a', 'c', 'b'])) print(g.data.edge_index) print(g.mapping) <pre>EdgeIndex([[0, 0, 2],\n           [2, 1, 1]], sparse_size=(3, 3), nnz=3, sort_order=row)\na -&gt; 0\nc -&gt; 1\nb -&gt; 2\n\n</pre> In\u00a0[17]: Copied! <pre>g.get_successors(0)\n</pre> g.get_successors(0) Out[17]: <pre>tensor([2, 1])</pre> In\u00a0[18]: Copied! <pre>g.get_predecessors(0)\n</pre> g.get_predecessors(0) Out[18]: <pre>tensor([], dtype=torch.int64)</pre> <p>Note that, even if a mapping is defined, the <code>get_successors</code> and <code>get_predecessors</code> functions always return a tensor with node indices, rather than node IDs. This is useful to support fast tensor-based operations on the list of successors and predecessors. We can however manually map node indices using the <code>IndexMap</code> object stored in the <code>mapping</code> attribute.</p> <p>If we instead want to traverse graphs based on string node IDs, we can use the <code>successors</code> and <code>predecessors</code> generators of the <code>Graph</code> object, which -- if a mapping is defined - yield the string IDs of successor or predecessor nodes for a given node (also identified by its string identifier).</p> In\u00a0[19]: Copied! <pre>for v in g.successors('a'):\n    print(v)\n</pre> for v in g.successors('a'):     print(v) <pre>b\nc\n</pre> In\u00a0[20]: Copied! <pre>for v in g.predecessors('c'):\n    print(v)\n</pre> for v in g.predecessors('c'):     print(v) <pre>a\nb\n</pre> <p>To check (in constant time) whether an edge exists in the graph, we can call the <code>is_edge</code> function:</p> In\u00a0[21]: Copied! <pre>g.is_edge('a', 'b')\n</pre> g.is_edge('a', 'b') Out[21]: <pre>True</pre> <p>Alternatively, we can use the following function to check (in constant time) whether node <code>b</code> is a successor of <code>a</code></p> In\u00a0[22]: Copied! <pre>'b' in g.successors('a')\n</pre> 'b' in g.successors('a') Out[22]: <pre>True</pre> <p>By default, graph objects in <code>pathpyG</code> are directed, i.e. for the graph above, the edge <code>(b,a)</code> does not exist, which we can verify as follows:</p> In\u00a0[23]: Copied! <pre>print('a' in g.successors('b'))\nprint(g.is_edge('b', 'a'))\n</pre> print('a' in g.successors('b')) print(g.is_edge('b', 'a')) <pre>False\nFalse\n</pre> <p>To calculate (directed) in- and out-degrees of nodes, we can use the properties <code>in_degrees</code> and <code>out_degrees</code>, which return a dictionary that maps node IDs to their degrees:</p> In\u00a0[24]: Copied! <pre>for v in g.nodes:\n    print(f\"{v} -&gt; {g.in_degrees[v]}\")\n</pre> for v in g.nodes:     print(f\"{v} -&gt; {g.in_degrees[v]}\") <pre>a -&gt; 0\nc -&gt; 2\nb -&gt; 1\n</pre> <p>The <code>in_degree</code> and <code>out_degree</code> properties are shortcuts to a general <code>degree</code> function that can be used to calculate (weighted) in- and outdegrees.</p> In\u00a0[25]: Copied! <pre>g.degrees(mode='in')\n</pre> g.degrees(mode='in') Out[25]: <pre>{'a': 0, 'c': 2, 'b': 1}</pre> In\u00a0[26]: Copied! <pre>g.degrees(mode='out')\n</pre> g.degrees(mode='out') Out[26]: <pre>{'a': 2, 'c': 0, 'b': 1}</pre> <p>Degrees can be alternatively returned as torch.tensors.</p> In\u00a0[27]: Copied! <pre>g.degrees(mode='in', return_tensor=True)\n</pre> g.degrees(mode='in', return_tensor=True) Out[27]: <pre>tensor([0, 2, 1], dtype=torch.int32)</pre> <p>We can also use arbitrary numerical edge attributes that will be used for a weighted (in- or out) degree calculation.</p> In\u00a0[28]: Copied! <pre>g.data.edge_weight=torch.tensor([1.0, 2.0, 3.0])\n</pre> g.data.edge_weight=torch.tensor([1.0, 2.0, 3.0]) In\u00a0[29]: Copied! <pre>g.degrees(mode='in', edge_attr='edge_weight', return_tensor=True)\n</pre> g.degrees(mode='in', edge_attr='edge_weight', return_tensor=True) Out[29]: <pre>tensor([0., 5., 1.])</pre> In\u00a0[30]: Copied! <pre>g.degrees(mode='out', edge_attr='edge_weight', return_tensor=True)\n</pre> g.degrees(mode='out', edge_attr='edge_weight', return_tensor=True) Out[30]: <pre>tensor([3., 0., 3.])</pre> <p>Importantly, irrespective of how we have generated the graph object, the actual node and edge data are always stored as a <code>pyG</code> data object. This allows us to use the full power of <code>torch</code> and <code>pyG</code>, including the application of transforms, splits, or any easy migration between CPU and GPU-based computation.</p> In\u00a0[31]: Copied! <pre>g.data\n</pre> g.data Out[31]: <pre>Data(edge_index=[2, 3], num_nodes=3, node_sequence=[3, 1], edge_weight=[3])</pre> <p>In general, <code>pathpyG</code> handles device placement (i.e. if a tensor should be placed on CPU or GPU memory) similar to <code>pytorch</code>. By default, all tensors are created on the CPU, as we can see below:</p> In\u00a0[32]: Copied! <pre>g.data.is_cuda\n</pre> g.data.is_cuda Out[32]: <pre>False</pre> <p>If we instead want to create a graph on the GPU, we can specify the device during graph creation.</p> In\u00a0[33]: Copied! <pre>if torch.cuda.is_available():\n    g = pp.Graph.from_edge_list([('a','b'), ('b','c'), ('a','c')], device='cuda')\n    g.data.is_cuda\nelse:\n    print(\"CUDA not available\")\n</pre> if torch.cuda.is_available():     g = pp.Graph.from_edge_list([('a','b'), ('b','c'), ('a','c')], device='cuda')     g.data.is_cuda else:     print(\"CUDA not available\") <pre>CUDA not available\n</pre> <p>We can move a graph that is stored on the GPU back to the CPU using the familiar <code>to</code> function:</p> In\u00a0[34]: Copied! <pre>g = g.to('cpu')\n</pre> g = g.to('cpu') In\u00a0[35]: Copied! <pre>g.data['node_class'] = torch.tensor([[0], [0], [1]])\ng.data['edge_weight'] = torch.tensor([[1], [2], [3]])\ng.data['feature'] = torch.tensor([3, 2])\n</pre> g.data['node_class'] = torch.tensor([[0], [0], [1]]) g.data['edge_weight'] = torch.tensor([[1], [2], [3]]) g.data['feature'] = torch.tensor([3, 2]) <p>Once we have added attributes to nodes, edges, or the graph, those attributes, along with their type and shape will be shown when you print a string representation of the graph object:</p> In\u00a0[36]: Copied! <pre>print(g)\n</pre> print(g) <pre>Directed graph with 3 nodes and 3 edges\n{   'Edge Attributes': {'edge_weight': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([3, 1])\"},\n    'Graph Attributes': {'feature': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([2])\", 'num_nodes': \"&lt;class 'int'&gt;\"},\n    'Node Attributes': {'node_class': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([3, 1])\"}}\n</pre> <p>To simplify access to attribute values, the <code>Graph</code> class provides getter and setter functions that allow to access attribute values based on node identifiers. To access the feature <code>node_feature</code> of node <code>a</code>, we can write:</p> In\u00a0[37]: Copied! <pre>g['node_class', 'a']\n</pre> g['node_class', 'a'] Out[37]: <pre>tensor([0])</pre> <p>To access the weight of edge <code>(a, b)</code> we can write:</p> In\u00a0[38]: Copied! <pre>g['edge_weight', 'a', 'b']\n</pre> g['edge_weight', 'a', 'b'] Out[38]: <pre>tensor([1])</pre> <p>And finally, graph-based attributes can accessed as follows:</p> In\u00a0[39]: Copied! <pre>g['feature']\n</pre> g['feature'] Out[39]: <pre>tensor([3, 2])</pre> <p>We can also use the setter functions to change attributes:</p> In\u00a0[40]: Copied! <pre>g['node_class'] = torch.tensor([[7], [2], [3]])\n</pre> g['node_class'] = torch.tensor([[7], [2], [3]]) In\u00a0[41]: Copied! <pre>g['node_class', 'a']\n</pre> g['node_class', 'a'] Out[41]: <pre>tensor([7])</pre> <p>To create sparse adjacency matrix representations of graphs, we can use the following function:</p> In\u00a0[42]: Copied! <pre>print(g.sparse_adj_matrix())\n</pre> print(g.sparse_adj_matrix()) <pre>&lt;COOrdinate sparse matrix of dtype 'float32'\n\twith 3 stored elements and shape (3, 3)&gt;\n  Coords\tValues\n  (0, 2)\t1.0\n  (0, 1)\t1.0\n  (2, 1)\t1.0\n</pre> <p>This returns a <code>scipy.sparse.coo_matrix</code> object, which can be turned into a dense <code>numpy</code> matrix as follows:</p> In\u00a0[43]: Copied! <pre>print(g.sparse_adj_matrix().todense())\n</pre> print(g.sparse_adj_matrix().todense()) <pre>[[0. 1. 1.]\n [0. 0. 0.]\n [0. 1. 0.]]\n</pre> <p>By passing the name of the attribute, we can use edge attributes in the creation of the adjacency matrix. To create a sparse, weighted adjacency matrix that uses the <code>edge_weight</code> attribute of our graph object we can simply write:</p> In\u00a0[44]: Copied! <pre>print(g.sparse_adj_matrix(edge_attr='edge_weight').todense())\n</pre> print(g.sparse_adj_matrix(edge_attr='edge_weight').todense()) <pre>[[0 2 1]\n [0 0 0]\n [0 3 0]]\n</pre> <p>By default, graphs in <code>pathpyG</code> are directed. To represent undirected edges, we must add edges in both directions. We can use the <code>to_undirected()</code> function to make a directed graph undirected, which adds all (missing) edges that point in the opposite direction. This will also automatically duplicate and assign the corresponding edge attributes to the newly formed (directed) edges, i.e. edges are assumed to have the same attributes in both directions.</p> In\u00a0[45]: Copied! <pre>g_u = g.to_undirected()\nprint(g_u)\n</pre> g_u = g.to_undirected() print(g_u) <pre>Undirected graph with 3 nodes and 3 edges\n{   'Edge Attributes': {'edge_weight': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([6, 1])\"},\n    'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"},\n    'Node Attributes': {'node_class': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([3, 1])\"}}\n</pre> <p>By default, the <code>Graph</code> object can contain multiple identical edges, so the following is possible:</p> In\u00a0[46]: Copied! <pre>g = pp.Graph.from_edge_list([('a', 'b'), ('b', 'c'), ('c', 'a'), ('a', 'b')])\nprint(g.data.edge_index)\n</pre> g = pp.Graph.from_edge_list([('a', 'b'), ('b', 'c'), ('c', 'a'), ('a', 'b')]) print(g.data.edge_index) <pre>EdgeIndex([[0, 0, 1, 2],\n           [1, 1, 2, 0]], sparse_size=(3, 3), nnz=4, sort_order=row)\n</pre> <p>It is often convenient, to coalesce multi-edges into weighted single-edges, i.e. in the example above we may prefer a graph where each edge occurs once in the edge index, but the edge <code>a-&gt;b</code> has a weight attribute of two, while the two other edges have one.</p> <p>In <code>pathpyG</code> we can do this by turning a graph into a weighted graph, which will coalesce edges and add an edge weight attribute that counts multi-edges in the original istance.</p> In\u00a0[47]: Copied! <pre>g_w = g.to_weighted_graph()\nprint(g_w.data.edge_index)\nprint(g_w['edge_weight', 'a', 'b'])\nprint(g_w['edge_weight', 'b', 'c'])\nprint(g_w['edge_weight', 'c', 'a'])\n</pre> g_w = g.to_weighted_graph() print(g_w.data.edge_index) print(g_w['edge_weight', 'a', 'b']) print(g_w['edge_weight', 'b', 'c']) print(g_w['edge_weight', 'c', 'a']) <pre>EdgeIndex([[0, 1, 2],\n           [1, 2, 0]], sparse_size=(3, 3), nnz=3, sort_order=row)\n</pre> <pre>tensor(2.)\ntensor(1.)\ntensor(1.)\n</pre> <p>As we will see in a separate notebook focusing on the advanced (temporal) graph visualization features of <code>pathpyG</code>, it is easy to generate (interactive) HTML plots of graphs, that are embedded into jupyter notebooks. You can simply call the <code>pp.plot</code> function on the Graph object:</p> In\u00a0[48]: Copied! <pre>pp.plot(g);\n</pre> pp.plot(g); In\u00a0[49]: Copied! <pre>g = pp.Graph.from_edge_list([('a','b'), ('b','c'), ('c','a')])\nprint(g)\n\ndf = pp.io.graph_to_df(g)\nprint(df)\n</pre> g = pp.Graph.from_edge_list([('a','b'), ('b','c'), ('c','a')]) print(g)  df = pp.io.graph_to_df(g) print(df) <pre>Directed graph with 3 nodes and 3 edges\n{'Edge Attributes': {}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\n   v  w\n0  a  b\n1  b  c\n2  c  a\n</pre> <p>All edge attributes are preserved in this operation, as provided in the following example:</p> In\u00a0[50]: Copied! <pre>g.data.edge_weight = torch.tensor([1.0, 2.0, 3.0])\nprint(g)\n\ndf = pp.io.graph_to_df(g)\nprint(df)\n</pre> g.data.edge_weight = torch.tensor([1.0, 2.0, 3.0]) print(g)  df = pp.io.graph_to_df(g) print(df) <pre>Directed graph with 3 nodes and 3 edges\n{'Edge Attributes': {'edge_weight': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([3])\"}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\n   v  w  edge_weight\n0  a  b          1.0\n1  b  c          2.0\n2  c  a          3.0\n</pre> <p>Note that the <code>pp.io.graph_to_df</code> function only includes <code>edge</code>-level data. To also include <code>node</code>-level attributes, you need to create a separate <code>DataFrame</code> for those attributes.</p> In\u00a0[51]: Copied! <pre>node_attr = pd.DataFrame({'v': ['b', 'a', 'c'], 'node_size': [5.0, 2.0, 1.0]})\nprint(node_attr)\n</pre> node_attr = pd.DataFrame({'v': ['b', 'a', 'c'], 'node_size': [5.0, 2.0, 1.0]}) print(node_attr) <pre>   v  node_size\n0  b        5.0\n1  a        2.0\n2  c        1.0\n</pre> <p>You can add node attributes from a <code>DataFrame</code> to a graph using the <code>add_node_attributes</code> function:</p> In\u00a0[52]: Copied! <pre>pp.io.add_node_attributes(node_attr, g)\nprint(g.data.node_size)\n</pre> pp.io.add_node_attributes(node_attr, g) print(g.data.node_size) <pre>tensor([2., 5., 1.], dtype=torch.float64)\n</pre> <p>Similarly, you can also add additional edge attributes from a <code>DataFrame</code> using the <code>add_edge_attributes</code> function:</p> In\u00a0[53]: Copied! <pre>edge_attr = pd.DataFrame({'v': ['c', 'a', 'b'], 'w': ['a', 'b', 'c'], 'edge_weight': [2.0, 3.0, 5.0]})\nprint(edge_attr)\npp.io.add_edge_attributes(edge_attr, g)\nprint(g.data.edge_index)\nprint(g.data.edge_weight)\n</pre> edge_attr = pd.DataFrame({'v': ['c', 'a', 'b'], 'w': ['a', 'b', 'c'], 'edge_weight': [2.0, 3.0, 5.0]}) print(edge_attr) pp.io.add_edge_attributes(edge_attr, g) print(g.data.edge_index) print(g.data.edge_weight) <pre>   v  w  edge_weight\n0  c  a          2.0\n1  a  b          3.0\n2  b  c          5.0\n</pre> <pre>EdgeIndex([[0, 1, 2],\n           [1, 2, 0]], sparse_size=(3, 3), nnz=3, sort_order=row)\ntensor([5., 2., 3.], dtype=torch.float64)\n</pre> <p>If you do not want to use the <code>uid</code>s of the nodes, you can also specify the parameter <code>node_indices=True</code>, which will use the integer indices of nodes instead.</p> In\u00a0[54]: Copied! <pre>df = pp.io.graph_to_df(g, node_indices=True)\nprint(df)\n</pre> df = pp.io.graph_to_df(g, node_indices=True) print(df) <pre>   v  w  edge_weight\n0  0  1          5.0\n1  1  2          2.0\n2  2  0          3.0\n</pre> In\u00a0[55]: Copied! <pre>with tempfile.TemporaryDirectory() as tmpdirname:\n    print('created temporary directory', tmpdirname)\n    tmp_file = os.path.join(tmpdirname, 'test_graph.csv')\n    pp.io.write_csv(g, path_or_buf=tmp_file)\n\n    csv_g = pp.io.read_csv_graph(filename=tmp_file)\npp.plot(csv_g);\n</pre> with tempfile.TemporaryDirectory() as tmpdirname:     print('created temporary directory', tmpdirname)     tmp_file = os.path.join(tmpdirname, 'test_graph.csv')     pp.io.write_csv(g, path_or_buf=tmp_file)      csv_g = pp.io.read_csv_graph(filename=tmp_file) pp.plot(csv_g); <pre>created temporary directory /tmp/tmphtme_3yw\n</pre> <p>Hint</p> <p>         Note that the edges in the above visualisation have varying thickness. This corresponds to the edge weights in the graph.     </p> In\u00a0[56]: Copied! <pre>pp.algorithms.centrality.closeness_centrality(g)\n</pre> pp.algorithms.centrality.closeness_centrality(g) Out[56]: <pre>{'a': 0.6666666666666666, 'b': 0.6666666666666666, 'c': 0.6666666666666666}</pre> In\u00a0[57]: Copied! <pre>pp.algorithms.centrality.eigenvector_centrality(g)\n</pre> pp.algorithms.centrality.eigenvector_centrality(g) Out[57]: <pre>{'a': 0.5773502691896258, 'b': 0.5773502691896258, 'c': 0.5773502691896258}</pre> In\u00a0[58]: Copied! <pre>pp.algorithms.centrality.katz_centrality(g)\n</pre> pp.algorithms.centrality.katz_centrality(g) Out[58]: <pre>{'a': 0.5773502691896258, 'b': 0.5773502691896258, 'c': 0.5773502691896258}</pre>"},{"location":"tutorial/basic_concepts/#basic-pathpyg-concepts","title":"Basic pathpyG Concepts\u00b6","text":""},{"location":"tutorial/basic_concepts/#prerequisites","title":"Prerequisites\u00b6","text":"<p>First, we need to set up our Python environment that has PyTorch, PyTorch Geometric and PathpyG installed. Depending on where you are executing this notebook, this might already be (partially) done. E.g. Google Colab has PyTorch installed by default so we only need to install the remaining dependencies. The DevContainer that is part of our GitHub Repository on the other hand already has all of the necessary dependencies installed.</p> <p>In the following, we install the packages for usage in Google Colab using Jupyter magic commands. For other environments comment in or out the commands as necessary. For more details on how to install <code>pathpyG</code> especially if you want to install it with GPU-support, we refer to our documentation. Note that <code>%%capture</code> discards the full output of the cell to not clutter this tutorial with unnecessary installation details. If you want to print the output, you can comment <code>%%capture</code> out.</p>"},{"location":"tutorial/basic_concepts/#motivation-and-learning-objectives","title":"Motivation and Learning Objectives\u00b6","text":"<p>This first step of our multi-stage introductory tutorial introduces key concepts of <code>pathpyG</code>. While <code>pathpyG</code> targets GPU-accelerated analysis and learning using higher-order graph models for time series data on graphs, it can also be used to represent, analyze and interactively visualize static graphs. For this, it provides a <code>Graph</code> class that is build around the <code>torch_geometric.data.Data</code> object, which has the advantage that we can directly apply <code>pyG</code> transforms and use the <code>Graph</code> object for deep graph learning.</p> <p>In this tutorial you will learn how we can use <code>pathpyG</code> to represent static graphs. We start with basic features to create directed and undirected graphs with node-, edge-, and graph-level attributes. We also show how we can read and write graph data and how we can implement graph algorithms that are based on a traversal of nodes and edges.</p> <p>We first import the modules <code>torch</code>, <code>torch_geometric</code> and <code>pathpyG</code>.</p>"},{"location":"tutorial/basic_concepts/#creating-graph-objects","title":"Creating Graph objects\u00b6","text":"<p>Let's start by generating a simple, directed graph with three nodes <code>a</code>, <code>b</code>, <code>c</code> and three edges <code>(a,b)</code>, <code>(b,c)</code> and <code>(a,b)</code>. The three nodes <code>a</code>, <code>b</code>, and <code>c</code> can be represented by integer indices $0, 1$ and $2$ respectively. Following the tensor-based representation in <code>pyG</code>, we use an <code>edge_index</code> tensor with shape <code>(2,m)</code> to represent the <code>m</code> edges of a graph. We can then add this to a <code>Data</code> object that can hold additional node and edge attributes. We finally pass the <code>Data</code> object to the constructor of the <code>Graph</code> class.</p> <p>Using the mapping of node names to indices specified above, the following code generates a directed <code>Graph</code> with three edges <code>(a,c)</code>, <code>(b,c)</code> and <code>(a,b)</code>.</p>"},{"location":"tutorial/basic_concepts/#traversing-graphs","title":"Traversing Graphs\u00b6","text":"<p>The <code>Graph</code> object provides <code>get_successors</code> and <code>get_predecessors</code> functions, which return the indices of nodes that are connected to a node with a given index. Based on cached CSR (compressed sparse row) and CSC (compressed sparse column) representations cached for the sorted <code>EdgeIndex</code>, access to the successors and predecessors of a node works in constant time, i.e. it does not require to enumerate the <code>edge_index</code> tensor.</p> <p>For node <code>a</code> with index $0$ in our directed network we obtain:</p>"},{"location":"tutorial/basic_concepts/#node-edge-or-graph-level-attributes","title":"Node-, Edge- or Graph-Level Attributes\u00b6","text":"<p>Real-world graphs often have node-, edge-, or graph-level attributes. In <code>pathpyG</code>, we can add attributes as tensors, either by directly assigning them to the <code>pyG</code> data object of an existing graph (or by adding them to the <code>Data</code> object passed to the constructor). Following the <code>pyG</code> semantics of attribute names, we use the prefixes <code>node_</code> and <code>edge_</code> to refer to node- and edge-level attributes. Attributes without those prefixes are assumed to refer to graph-level attributes.</p>"},{"location":"tutorial/basic_concepts/#reading-and-writing-graph-data","title":"Reading and writing graph data\u00b6","text":"<p><code>pathpyG</code> supports reading and writing graph data in various formats using <code>pandas.DataFrame</code>s as an interface. For example, we can create a graph from an edge list and then transform it to a <code>DataFrame</code> that holds the edge list:</p>"},{"location":"tutorial/basic_concepts/#reading-and-writing-from-and-to-csv-files","title":"Reading and writing from and to <code>.csv</code> files\u00b6","text":"<p>As mentioned above, we can read and write graph data into various common formats. A common format to store edge lists is the <code>.csv</code> format. We can easily read a graph from a <code>.csv</code> file using the <code>pp.io.read_csv_graph</code> function and write a graph to a <code>.csv</code> file using the <code>pp.io.write_csv</code> function.</p>"},{"location":"tutorial/basic_concepts/#networkx-delegate-mechanism","title":"<code>networkx</code> Delegate Mechanism\u00b6","text":"<p>To calculate node centralities, we can use a <code>networkx</code> delegate mechanism implemented in the module <code>pathpyG.algorithms.centrality</code>. Simply speaking, you can call any function implented in the <code>networkx.centrality</code> module whose name ends with <code>_centrality</code>. The <code>pathpyG</code> graph object will be internally converted to a <code>networkx.DiGraph</code> object, the corresponding centrality function (with all of its parameters) will be called, and the result will be mapped back to nodes based on node IDs.</p> <p>In order to calculate the closeness centralities of all nodes for the graph above, we can call:</p>"},{"location":"tutorial/dbgnn/","title":"Causality-Aware GNNs","text":"In\u00a0[28]: Copied! <pre>%%capture\n# !pip install torch\n# !pip install torch_geometric\n# !pip install git+https://github.com/pathpy/pathpyG.git\n</pre> %%capture # !pip install torch # !pip install torch_geometric # !pip install git+https://github.com/pathpy/pathpyG.git In\u00a0[29]: Copied! <pre>import os\nimport tempfile\nfrom copy import deepcopy\nfrom urllib import request\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport scipy as sp\nimport torch\nfrom sklearn.manifold import TSNE\nfrom sklearn.metrics import balanced_accuracy_score\nfrom torch_geometric.transforms import RandomNodeSplit\n\nimport pathpyG as pp\nfrom pathpyG.nn.dbgnn import DBGNN\n\ndevice = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n</pre> import os import tempfile from copy import deepcopy from urllib import request  import matplotlib.pyplot as plt import numpy as np import scipy as sp import torch from sklearn.manifold import TSNE from sklearn.metrics import balanced_accuracy_score from torch_geometric.transforms import RandomNodeSplit  import pathpyG as pp from pathpyG.nn.dbgnn import DBGNN  device = torch.device('cuda' if torch.cuda.is_available() else 'cpu') In\u00a0[30]: Copied! <pre>if os.path.exists('../data/temporal_clusters.tedges'):\n    print(\"Loading dataset from local path...\")\n    t = pp.io.read_csv_temporal_graph('../data/temporal_clusters.tedges', header=False)\nelse:\n    print(\"Loading dataset from remote URL...\")\n    with tempfile.TemporaryDirectory() as tmpdir:\n        url = \"https://raw.githubusercontent.com/pathpy/pathpyG/refs/heads/main/docs/data/temporal_clusters.tedges\"\n        file_path = os.path.join(tmpdir, 'temporal_clusters.tedges')\n        request.urlretrieve(url, file_path)\n        t = pp.io.read_csv_temporal_graph(file_path, header=False)\n\nt = t.to(device)\n</pre> if os.path.exists('../data/temporal_clusters.tedges'):     print(\"Loading dataset from local path...\")     t = pp.io.read_csv_temporal_graph('../data/temporal_clusters.tedges', header=False) else:     print(\"Loading dataset from remote URL...\")     with tempfile.TemporaryDirectory() as tmpdir:         url = \"https://raw.githubusercontent.com/pathpy/pathpyG/refs/heads/main/docs/data/temporal_clusters.tedges\"         file_path = os.path.join(tmpdir, 'temporal_clusters.tedges')         request.urlretrieve(url, file_path)         t = pp.io.read_csv_temporal_graph(file_path, header=False)  t = t.to(device) <pre>Loading dataset from local path...\n</pre> <p>This example has created in such a way that the nodes naturally form three clusters, which are highlighted in the interactive visualization below:</p> In\u00a0[31]: Copied! <pre>style = {}\nstyle[\"node_color\"] = [\"green\"] * 10 + [\"red\"] * 10 + [\"blue\"] * 10\npp.plot(t, **style, show_labels=False);\n</pre> style = {} style[\"node_color\"] = [\"green\"] * 10 + [\"red\"] * 10 + [\"blue\"] * 10 pp.plot(t, **style, show_labels=False); In\u00a0[32]: Copied! <pre>pp.plot(t.to_static_graph(), **style, show_labels=False);\n</pre> pp.plot(t.to_static_graph(), **style, show_labels=False); <p>In fact, the topology of this graph corresponds to that of a random graph, i.e. there are not patterns whatsoever in the topology of links. Nevertheless, the temporal graph contains a cluster pattern in the topology of causal or time-respecting paths. In particular, the temporal ordering of time-stamped edges is such that nodes with the same cluster label are more frequently connected by time-respecting paths than nodes with different cluster labels. Hence, nodes within the same clusters can more strongly influence each other in a causal way, i.e. via multiple interactions that follow the arrow of time.</p> <p>Traditional (temporal) graph neural networks will not be able to learn from this pattern, as it is due to the specific microscopic temporal ordering of edges. Using higher-order De Bruijn graph models implemented in pathpyG, we can learn from temporal graph data that contains such patterns. Let us explain this step by step.</p> <p>Referring to the previous tutorial on causal paths in temporal graphs, we first create a node-time directed acyclic graph that captures the causal structure of the temporal graph. In this small example, we will only consider two time-stamped edges $(u,v;t)$ and $(v,w;t')$ to contribute to a causal path iff $0 &lt; t'-t \\leq 1$, i.e. we use a delta for the maximum time difference of one time step.</p> In\u00a0[33]: skip-execution Copied! <pre>%%capture\nm = pp.MultiOrderModel.from_temporal_graph(t, max_order=2)\n</pre> %%capture m = pp.MultiOrderModel.from_temporal_graph(t, max_order=2) In\u00a0[34]: skip-execution Copied! <pre>print(m)\n</pre> print(m) <pre>MultiOrderModel with max. order 2\n</pre> <p>We can get the first and second order networks from the Multi Order Network object. The first order network is the network of nodes and edges, while the second order network is the network of first order edges as second order nodes and second order edges. The second order network is a De Bruijn graph that captures the temporal-topological patterns in the data.</p> In\u00a0[35]: skip-execution Copied! <pre>g = m.layers[1]\ng2 = m.layers[2]\n</pre> g = m.layers[1] g2 = m.layers[2] In\u00a0[36]: skip-execution Copied! <pre>pp.plot(g, edge_size=1, show_labels=False);\n</pre> pp.plot(g, edge_size=1, show_labels=False); <p>Since it does not consider patterns in the causal topology of the temporal graph, this is not a meaningful model. We can instead use a second-order De Bruijn graph model, which we can easily fit to the paths:</p> In\u00a0[37]: skip-execution Copied! <pre>layout_style = {}\nlayout_style[\"layout\"] = \"Fruchterman-Reingold\"\nlayout_style[\"seed\"] = 1\nlayout_style[\"k\"] = 0.5\nlayout_style[\"iterations\"] = 300\nlayout = pp.layout(g2, **layout_style)\npp.plot(g2, backend=\"matplotlib\", layout=layout, edge_size=0.5, node_size=3, show_labels=False);\n</pre> layout_style = {} layout_style[\"layout\"] = \"Fruchterman-Reingold\" layout_style[\"seed\"] = 1 layout_style[\"k\"] = 0.5 layout_style[\"iterations\"] = 300 layout = pp.layout(g2, **layout_style) pp.plot(g2, backend=\"matplotlib\", layout=layout, edge_size=0.5, node_size=3, show_labels=False); <p>In this graph, every node is a link and links correspond to causal paths of length two, i.e. temporally ordered sequences consisting of two edges that overlap in the center node. In this graph, we clearly see a cluster pattern that is due to the way in which temporal edges are ordered in time. In particular, we see three clusters, where the edges in three of the clusters correspond to causal paths of length two that connect nodes within each of the three clusters. The edges in the fourth cluster (in the center of the visualization) represent causal paths that connect nodes in different clusters.</p> In\u00a0[38]: skip-execution Copied! <pre>t_shuffled = deepcopy(t)\nt_shuffled.shuffle_time()\n</pre> t_shuffled = deepcopy(t) t_shuffled.shuffle_time() In\u00a0[39]: skip-execution Copied! <pre>%%capture\ng2_shuffled = pp.MultiOrderModel.from_temporal_graph(t_shuffled, max_order=2).layers[2]\n</pre> %%capture g2_shuffled = pp.MultiOrderModel.from_temporal_graph(t_shuffled, max_order=2).layers[2] In\u00a0[40]: skip-execution Copied! <pre>print(g2_shuffled)\n</pre> print(g2_shuffled) <pre>Directed graph with 557 nodes and 1993 edges\n{   'Edge Attributes': {'edge_weight': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([1993])\"},\n    'Graph Attributes': {'inverse_idx': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([60000])\", 'num_nodes': \"&lt;class 'int'&gt;\"},\n    'Node Attributes': {}}\n</pre> In\u00a0[41]: skip-execution Copied! <pre>layout = pp.layout(g2_shuffled, **layout_style)\npp.plot(g2_shuffled, backend=\"matplotlib\", layout=layout, edge_size=0.5, node_size=3, show_labels=False);\n</pre> layout = pp.layout(g2_shuffled, **layout_style) pp.plot(g2_shuffled, backend=\"matplotlib\", layout=layout, edge_size=0.5, node_size=3, show_labels=False); <p>We now find that the cluster pattern in the second-order graph has vanished. In fact, there is no pattern whatsoever since the underlying (static) graph topology is random and the random shuffling of time stamps leads to random causal paths.</p> In\u00a0[42]: skip-execution Copied! <pre>L = g2.laplacian(normalization='rw', edge_attr='edge_weight')\nL_shuffled= g2_shuffled.laplacian(normalization='rw',edge_attr='edge_weight')\n</pre> L = g2.laplacian(normalization='rw', edge_attr='edge_weight') L_shuffled= g2_shuffled.laplacian(normalization='rw',edge_attr='edge_weight') <p>We then calculate the eigenvalues and eigenvectors of the Laplacians, and compute the Fiedler vector, i.e. the eigenvector that corresponds to the second-smallest eigenvalue of the Laplacian.</p> In\u00a0[43]: skip-execution Copied! <pre>w,v = sp.linalg.eig(L.todense(),left= False, right = True)\nw_shuffled, v_shuffled = sp.linalg.eig(L_shuffled.todense())\n</pre> w,v = sp.linalg.eig(L.todense(),left= False, right = True) w_shuffled, v_shuffled = sp.linalg.eig(L_shuffled.todense()) In\u00a0[44]: skip-execution Copied! <pre>fiedler = v[:,np.argsort(w)[1]]\nfiedler_shuffled = v_shuffled[:,np.argsort(w_shuffled)[1]]\n</pre> fiedler = v[:,np.argsort(w)[1]] fiedler_shuffled = v_shuffled[:,np.argsort(w_shuffled)[1]] <p>Below, we show that the clusters in the causal topology of the temporal graph correspond to clusters in the distribution of entries in the Fiedler vector, while there is no such pattern for the Fiedler vector of the second-order graph constructed from the shuffled temporal graph:</p> In\u00a0[45]: Copied! <pre>def higher_order_class_assignment(ho_node_id):\n    \"\"\"Assign class labels based on the higher-order node ids.\n    \n    There are three classes that were assigned based on the original node ids:\n        - Class 0: node ids 0-9\n        - Class 1: node ids 10-19\n        - Class 2: node ids 20-29\n\n    The higher-order patterns were constructed such that the clusters are formed by second-order nodes whose first-order node ids belong to the same class.\n    We therefore assign higher-order class labels based on the first-order node ids in the higher-order node id tuple.\n    \"\"\"\n    if ho_node_id[0] &lt; 10 and ho_node_id[1] &lt; 10:\n        return 0\n    elif ho_node_id[0] &lt; 20 and ho_node_id[0] &gt;= 10 and ho_node_id[1] &lt; 20 and ho_node_id[1] &gt;= 10:\n        return 1\n    elif ho_node_id[0] &lt; 30 and ho_node_id[0] &gt;= 20 and ho_node_id[1] &lt; 30 and ho_node_id[1] &gt;= 20:\n        return 2\n    else:\n        return 3\n</pre> def higher_order_class_assignment(ho_node_id):     \"\"\"Assign class labels based on the higher-order node ids.          There are three classes that were assigned based on the original node ids:         - Class 0: node ids 0-9         - Class 1: node ids 10-19         - Class 2: node ids 20-29      The higher-order patterns were constructed such that the clusters are formed by second-order nodes whose first-order node ids belong to the same class.     We therefore assign higher-order class labels based on the first-order node ids in the higher-order node id tuple.     \"\"\"     if ho_node_id[0] &lt; 10 and ho_node_id[1] &lt; 10:         return 0     elif ho_node_id[0] &lt; 20 and ho_node_id[0] &gt;= 10 and ho_node_id[1] &lt; 20 and ho_node_id[1] &gt;= 10:         return 1     elif ho_node_id[0] &lt; 30 and ho_node_id[0] &gt;= 20 and ho_node_id[1] &lt; 30 and ho_node_id[1] &gt;= 20:         return 2     else:         return 3 In\u00a0[46]: Copied! <pre>colors = {0: 'green', 1: 'red', 2: 'blue', 3: 'gray'}\nopacities = {0: 0.6, 1: 0.6, 2: 0.6, 3: 0.1}\n</pre> colors = {0: 'green', 1: 'red', 2: 'blue', 3: 'gray'} opacities = {0: 0.6, 1: 0.6, 2: 0.6, 3: 0.1} <p>In the plots below, we have colored those entries of the Fiedler vectors that correspond to edges connecting nodes within one of the three clusters shown above. The Fiedler vector shows a clear pattern, which translates to the cluster pattern in the causal topology that we have planted into our synthetic temporal graph.</p> In\u00a0[47]: skip-execution Copied! <pre>ho_class_ids = list(map(higher_order_class_assignment, g2.nodes))\nplt.scatter(\n    range(g2.n), np.real(fiedler), c=[colors[i] for i in ho_class_ids], alpha=[opacities[i] for i in ho_class_ids]\n)\nplt.ylim(-0.25, 0.25)\n</pre> ho_class_ids = list(map(higher_order_class_assignment, g2.nodes)) plt.scatter(     range(g2.n), np.real(fiedler), c=[colors[i] for i in ho_class_ids], alpha=[opacities[i] for i in ho_class_ids] ) plt.ylim(-0.25, 0.25) Out[47]: <pre>(-0.25, 0.25)</pre> <p>No such pattern exists in the Fiedler vector of the second-order graph corresponding to the shuffled <code>TemporalGraph</code>.</p> In\u00a0[48]: skip-execution Copied! <pre>shuffled_ho_class_ids = list(map(higher_order_class_assignment, g2_shuffled.nodes))\nplt.scatter(\n    range(g2_shuffled.n),\n    np.real(fiedler_shuffled),\n    c=[colors[i] for i in shuffled_ho_class_ids],\n    alpha=[opacities[i] for i in shuffled_ho_class_ids],\n)\nplt.ylim(-0.25, 0.25)\n</pre> shuffled_ho_class_ids = list(map(higher_order_class_assignment, g2_shuffled.nodes)) plt.scatter(     range(g2_shuffled.n),     np.real(fiedler_shuffled),     c=[colors[i] for i in shuffled_ho_class_ids],     alpha=[opacities[i] for i in shuffled_ho_class_ids], ) plt.ylim(-0.25, 0.25) Out[48]: <pre>(-0.25, 0.25)</pre> <p>We now set up a <code>pytorch_geometric.Data</code> object that contains all of the information needed to train the DBGNN model. For this, we can use a convenience function of the <code>MultiOrderModel</code> class in <code>pathpyG</code>. Combining a first- and a second-order model, this uses the edge indices and the weight tensors for a message passing scheme. it further constructs an <code>edge_index</code> of a bipartite graph that uses the last node in a second-order node to map messages back to first-order nodes.</p> In\u00a0[49]: skip-execution Copied! <pre>data = m.to_dbgnn_data(max_order=2, mapping=\"last\")\ndata.y = torch.tensor([int(i) // 10 for i in t.nodes], device=device)\n</pre> data = m.to_dbgnn_data(max_order=2, mapping=\"last\") data.y = torch.tensor([int(i) // 10 for i in t.nodes], device=device) In\u00a0[50]: skip-execution Copied! <pre>data = RandomNodeSplit(num_val=0, num_test=0.3)(data)\n\nmodel = DBGNN(num_features=[g.n, g2.n], num_classes=len(data.y.unique()), hidden_dims=[16, 32, 8], p_dropout=0.4).to(\n    device\n)\n\noptimizer = torch.optim.Adam(model.parameters(), lr=0.005)\nloss_function = torch.nn.CrossEntropyLoss()\n</pre> data = RandomNodeSplit(num_val=0, num_test=0.3)(data)  model = DBGNN(num_features=[g.n, g2.n], num_classes=len(data.y.unique()), hidden_dims=[16, 32, 8], p_dropout=0.4).to(     device )  optimizer = torch.optim.Adam(model.parameters(), lr=0.005) loss_function = torch.nn.CrossEntropyLoss() <p>The following function evaluates the prediction of our model based on the balanced accuracy score for categorical predictions.</p> In\u00a0[51]: skip-execution Copied! <pre>def test(model, data):\n    \"\"\"Evaluate the model on training and test data.\"\"\"\n    model.eval()\n\n    _, pred = model(data).max(dim=1)\n\n    metrics_train = balanced_accuracy_score(data.y[data.train_mask].cpu(), pred[data.train_mask].cpu().numpy())\n\n    metrics_test = balanced_accuracy_score(data.y[data.test_mask].cpu(), pred[data.test_mask].cpu().numpy())\n\n    return metrics_train, metrics_test\n</pre> def test(model, data):     \"\"\"Evaluate the model on training and test data.\"\"\"     model.eval()      _, pred = model(data).max(dim=1)      metrics_train = balanced_accuracy_score(data.y[data.train_mask].cpu(), pred[data.train_mask].cpu().numpy())      metrics_test = balanced_accuracy_score(data.y[data.test_mask].cpu(), pred[data.test_mask].cpu().numpy())      return metrics_train, metrics_test In\u00a0[52]: skip-execution Copied! <pre>losses = []\nfor epoch in range(50):\n    output = model(data)\n    loss = loss_function(output[data.train_mask], data.y[data.train_mask])\n    loss.backward()\n    optimizer.step()\n    optimizer.zero_grad()\n    losses.append(loss)\n\n    if epoch % 10 == 0:\n        train_ba, test_ba = test(model, data)\n        print(f\"Epoch: {epoch}, Loss: {loss}, Train balanced accuracy: {train_ba}, Test balanced accuracy: {test_ba}\")\n</pre> losses = [] for epoch in range(50):     output = model(data)     loss = loss_function(output[data.train_mask], data.y[data.train_mask])     loss.backward()     optimizer.step()     optimizer.zero_grad()     losses.append(loss)      if epoch % 10 == 0:         train_ba, test_ba = test(model, data)         print(f\"Epoch: {epoch}, Loss: {loss}, Train balanced accuracy: {train_ba}, Test balanced accuracy: {test_ba}\") <pre>Epoch: 0, Loss: 1.8728970289230347, Train balanced accuracy: 0.3333333333333333, Test balanced accuracy: 0.3333333333333333\nEpoch: 10, Loss: 0.8794518709182739, Train balanced accuracy: 0.6666666666666666, Test balanced accuracy: 0.6666666666666666\nEpoch: 20, Loss: 0.3931295871734619, Train balanced accuracy: 0.9583333333333334, Test balanced accuracy: 1.0\nEpoch: 30, Loss: 0.16060538589954376, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\nEpoch: 40, Loss: 0.08556197583675385, Train balanced accuracy: 1.0, Test balanced accuracy: 1.0\n</pre> In\u00a0[53]: skip-execution Copied! <pre>model.eval()\nlatent = model.higher_order_layers[0].forward(data.x_h, data.edge_index_higher_order).detach()\nlatent = model.higher_order_layers[1].forward(latent, data.edge_index_higher_order).detach()\nnode_embedding = TSNE(n_components=2, learning_rate=\"auto\", init=\"random\").fit_transform(latent.cpu())\n\nembedding_layout = {v: node_embedding[g2.mapping.to_idx(v)] for v in g2.nodes}\npp.plot(g2, backend=\"matplotlib\", layout=embedding_layout, show_labels=False, edge_size=0.3, node_size=3, edge_opacity=0.1, node_color=[colors[i] for i in ho_class_ids]);\n</pre> model.eval() latent = model.higher_order_layers[0].forward(data.x_h, data.edge_index_higher_order).detach() latent = model.higher_order_layers[1].forward(latent, data.edge_index_higher_order).detach() node_embedding = TSNE(n_components=2, learning_rate=\"auto\", init=\"random\").fit_transform(latent.cpu())  embedding_layout = {v: node_embedding[g2.mapping.to_idx(v)] for v in g2.nodes} pp.plot(g2, backend=\"matplotlib\", layout=embedding_layout, show_labels=False, edge_size=0.3, node_size=3, edge_opacity=0.1, node_color=[colors[i] for i in ho_class_ids]); <p>We can further generate latent space representations of the nodes generated by the last bipartite layer of our architecture:</p> In\u00a0[54]: skip-execution Copied! <pre>model.eval()\nlatent = model.forward(data).detach()\nnode_embedding = TSNE(n_components=2, learning_rate='auto', init='random', perplexity=10).fit_transform(latent.cpu())\n\nembedding_layout = {v: node_embedding[g.mapping.to_idx(v)] for v in g.nodes}\npp.plot(g, backend=\"matplotlib\", layout=embedding_layout, show_labels=False, edge_size=0.3, node_size=3, edge_opacity=0.1, **style);\n</pre> model.eval() latent = model.forward(data).detach() node_embedding = TSNE(n_components=2, learning_rate='auto', init='random', perplexity=10).fit_transform(latent.cpu())  embedding_layout = {v: node_embedding[g.mapping.to_idx(v)] for v in g.nodes} pp.plot(g, backend=\"matplotlib\", layout=embedding_layout, show_labels=False, edge_size=0.3, node_size=3, edge_opacity=0.1, **style); In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorial/dbgnn/#causality-aware-graph-neural-networks","title":"Causality-Aware Graph Neural Networks\u00b6","text":""},{"location":"tutorial/dbgnn/#prerequisites","title":"Prerequisites\u00b6","text":"<p>First, we need to set up our Python environment that has PyTorch, PyTorch Geometric and PathpyG installed. Depending on where you are executing this notebook, this might already be (partially) done. E.g. Google Colab has PyTorch installed by default so we only need to install the remaining dependencies. The DevContainer that is part of our GitHub Repository on the other hand already has all of the necessary dependencies installed.</p> <p>In the following, we install the packages for usage in Google Colab using Jupyter magic commands. For other environments comment in or out the commands as necessary. For more details on how to install <code>pathpyG</code> especially if you want to install it with GPU-support, we refer to our documentation. Note that <code>%%capture</code> discards the full output of the cell to not clutter this tutorial with unnecessary installation details. If you want to print the output, you can comment <code>%%capture</code> out.</p>"},{"location":"tutorial/dbgnn/#motivation-and-learning-objectives","title":"Motivation and Learning Objectives\u00b6","text":"<p>In previous tutorials, we have introduced causal paths in temporal graphs, and how we can use them to generate higher-order De Bruijn graph models that capture temporal-topological patterns in time series data. In this tutorial, we will show how we can use De Bruijn Graph Neural Networks, a causality-aware deep learning architecture for temporal graph data. The details of this approach are introduced in this paper. The architecture is implemented in pathpyG and can be readily applied to temporal graph data.</p> <p>Below we illustrate this method in a supervised node classification task, i.e. given a temporal graph we will use the temporal-topological patterns in the graph to classify nodes.</p> <p>We start by importing a few modules:</p>"},{"location":"tutorial/dbgnn/#temporal-topological-clusters-in-temporal-graphs","title":"Temporal-Topological Clusters in Temporal Graphs\u00b6","text":"<p>Let us load a small synthetic toy example for a temporal graph with 60.000 time-stamped interactions between 30 nodes. We use the <code>TemporalGraph</code> class to load this example from a file containing edges with discrete time-stamps.</p> <p>Dataset Availability</p> <p>         Depending on how you are executing this notebook, you may need to download the dataset first. We automatically check if the dataset is available in the relative path <code>../data/temporal_clusters.tedges</code>, which is the default location if you cloned the pathpyG repository. If the file is not found, we download it from the GitHub repository.     </p>"},{"location":"tutorial/dbgnn/#modelling-causal-structures-with-higher-order-de-bruijn-graphs","title":"Modelling Causal Structures with Higher-Order De Bruijn Graphs\u00b6","text":"<p>But what is the origin for the cluster pattern? In the visualization above, you will notice that the time-stamped edges randomly interconnect nodes within and across clusters, actually there is no correlation whatsoever between the topology of links and the cluster membership of the nodes. Hence, the notion of clusters does not correspond to the common idea of cluster patterns in static graphs, which we can highlight further by plotting the static time-aggregated network:</p>"},{"location":"tutorial/dbgnn/#comparison-to-temporal-graph-with-shuffled-time-stamps","title":"Comparison to Temporal Graph with Shuffled Time Stamps\u00b6","text":"<p>You may wonder whether this pattern is really due to the temporal ordering of time-stamped edges. It is easy to check this. We can simply randomly shuffle the time stamps of all edges, which will break any correlations in the temporal ordering that lead to patterns in the causal topology.</p> <p>We repeat the path calculation for this shuffled temporal graph and construct the second-order De Bruijn Graph model again:</p>"},{"location":"tutorial/dbgnn/#spectral-clustering-with-second-order-graph-laplacian","title":"Spectral clustering with second-order graph Laplacian\u00b6","text":"<p>To take a different perspective on cluster patterns, we can actually use <code>pathpyG</code> to apply a spectral analysis to the higher-order graph. We can simply calculate a generalization of the Laplacian matrix to the second-order graph both for the actual temporal graph and its shuffled counterpart:</p>"},{"location":"tutorial/dbgnn/#node-classification-with-causality-aware-graph-neural-networks","title":"Node Classification with Causality-Aware Graph Neural Networks\u00b6","text":"<p>Let us now explore how we can develop a causality-aware deep graph learning architecture that utilizes this pattern in the causal topology. We will follow the architecture introduced in this work. The architecture actually performs message passing in higher-order models with multiple orders at once. In a final message passing step, a bipartite graph is used to obtain vector-space representations of actual nodes in the temporal graph.</p>"},{"location":"tutorial/dbgnn/#training-the-model","title":"Training the model\u00b6","text":"<p>We are now ready to train and evaluate our causality-aware graph neural network. We will frist create a random split of the nodes, set the optimizer and the hyperparameters of our model.</p>"},{"location":"tutorial/dbgnn/#causality-aware-latent-space-representation-of-nodes","title":"Causality-aware latent space representation of nodes\u00b6","text":"<p>We can inspect the model by plotting a latent space representation of the edges generated by the second-order layer of our architecture.</p>"},{"location":"tutorial/generative_models/","title":"Generative Models for Random Graphs","text":"In\u00a0[1]: Copied! <pre>%%capture\n# !pip install torch\n# !pip install torch_geometric\n# !pip install git+https://github.com/pathpy/pathpyG.git\n</pre> %%capture # !pip install torch # !pip install torch_geometric # !pip install git+https://github.com/pathpy/pathpyG.git In\u00a0[2]: Copied! <pre>import string\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\nimport pathpyG as pp\n</pre> import string  import numpy as np from matplotlib import pyplot as plt  import pathpyG as pp <p>To generate a random Erd\u00f6s-Renyi graph using the so-called $G(n,p)$ model where $n$ is the number of nodes and $p$ is the probability for each node pair to be connected, we can call:</p> In\u00a0[3]: Copied! <pre>g = pp.algorithms.generative_models.erdos_renyi_gnp(n=20, p=0.2)\npp.plot(g);\n</pre> g = pp.algorithms.generative_models.erdos_renyi_gnp(n=20, p=0.2) pp.plot(g); <p>By default, no self-loops are added. If we want self-loops to be generated with probability $p$ we can do this as follows (note that self-loops are currently not plotted):</p> In\u00a0[4]: Copied! <pre>g = pp.algorithms.generative_models.erdos_renyi_gnp(n=20, p=0.2, self_loops=True)\npp.plot(g);\n</pre> g = pp.algorithms.generative_models.erdos_renyi_gnp(n=20, p=0.2, self_loops=True) pp.plot(g); <p>This also works for directed networks and we can specify a given node ID mapping:</p> In\u00a0[5]: Copied! <pre>g = pp.algorithms.generative_models.erdos_renyi_gnp(\n    n=20, p=0.2, directed=True, mapping=pp.IndexMap([x for x in string.ascii_lowercase])\n)\npp.plot(g);\n</pre> g = pp.algorithms.generative_models.erdos_renyi_gnp(     n=20, p=0.2, directed=True, mapping=pp.IndexMap([x for x in string.ascii_lowercase]) ) pp.plot(g); <p>For the random realizations generated by the $G(n,p)$ model with connection probability $p$, we have an expected number of $p \\cdot \\binom{n}{2}$ edges, i.e. the number of edges in each realization varies.</p> <p>We can use the alternative $G(n,m)$ formulation of the Erd\u00f6s-Renyi model, which generates a fixed number of $m$ edges chosen uniformly at random:</p> In\u00a0[6]: Copied! <pre>g = pp.algorithms.generative_models.erdos_renyi_gnm(\n    n=20, m=40, mapping=pp.IndexMap([x for x in string.ascii_lowercase])\n)\nprint(g)\npp.plot(g);\n</pre> g = pp.algorithms.generative_models.erdos_renyi_gnm(     n=20, m=40, mapping=pp.IndexMap([x for x in string.ascii_lowercase]) ) print(g) pp.plot(g); <pre>Undirected graph with 26 nodes and 40 edges\n{'Edge Attributes': {}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\n</pre> <p>Naturally, the maximum number of edges that we can create depends on the size of the graph (and whether edges are directed and whether we allow for self-loops). The following fails:</p> In\u00a0[7]: Copied! <pre>try:\n    g = pp.algorithms.generative_models.erdos_renyi_gnm(\n        n=20, m=195, mapping=pp.IndexMap([x for x in string.ascii_lowercase])\n    )\nexcept Exception as e:\n    print(f\"Error: {e}\")\n</pre> try:     g = pp.algorithms.generative_models.erdos_renyi_gnm(         n=20, m=195, mapping=pp.IndexMap([x for x in string.ascii_lowercase])     ) except Exception as e:     print(f\"Error: {e}\") <pre>2025-11-12 14:06:23 - Given number of edges is larger than theoretical maximum\n</pre> <pre>Error: Given number of edges is larger than theoretical maximum\n</pre> <p>To check how many edges a directed/undirected graph with/without self-loop can possibly have, you can use the <code>max_edges</code> function:</p> In\u00a0[8]: Copied! <pre>pp.algorithms.generative_models.max_edges(n=20, directed=False, self_loops=False)\n</pre> pp.algorithms.generative_models.max_edges(n=20, directed=False, self_loops=False) Out[8]: <pre>190</pre> <p>We often use random graph models to generate randomized versions of empirical networks. For this prupose, <code>pathpyG</code> provides <code>_randomize</code> variants for random graph models, which can be used to automatically fit the model parameters to an empirical graph, thus generating a randomized version that preserves the corresponding aggregate characteristics defined by the model.</p> <p>Let's try this for randomized versions of the Karate club network, which we can load from the netzschleuder database:</p> In\u00a0[9]: Copied! <pre>g_karate = pp.io.read_netzschleuder_graph('karate', '77')\nprint(g_karate)\n</pre> g_karate = pp.io.read_netzschleuder_graph('karate', '77') print(g_karate) <pre>Undirected graph with 34 nodes and 77 edges\n{   'Edge Attributes': {},\n    'Graph Attributes': {   'analyses_average_degree': \"&lt;class 'float'&gt;\",\n                            'analyses_degree_assortativity': \"&lt;class 'float'&gt;\",\n                            'analyses_degree_std_dev': \"&lt;class 'float'&gt;\",\n                            'analyses_diameter': \"&lt;class 'int'&gt;\",\n                            'analyses_edge_properties': \"&lt;class 'list'&gt;\",\n                            'analyses_edge_reciprocity': \"&lt;class 'float'&gt;\",\n                            'analyses_global_clustering': \"&lt;class 'float'&gt;\",\n                            'analyses_hashimoto_radius': \"&lt;class 'float'&gt;\",\n                            'analyses_is_bipartite': \"&lt;class 'bool'&gt;\",\n                            'analyses_is_directed': \"&lt;class 'bool'&gt;\",\n                            'analyses_knn_proj_1': \"&lt;class 'float'&gt;\",\n                            'analyses_knn_proj_2': \"&lt;class 'float'&gt;\",\n                            'analyses_largest_component_fraction': \"&lt;class 'float'&gt;\",\n                            'analyses_mixing_time': \"&lt;class 'float'&gt;\",\n                            'analyses_num_edges': \"&lt;class 'int'&gt;\",\n                            'analyses_num_vertices': \"&lt;class 'int'&gt;\",\n                            'analyses_transition_gap': \"&lt;class 'float'&gt;\",\n                            'analyses_vertex_properties': \"&lt;class 'list'&gt;\",\n                            'num_nodes': \"&lt;class 'int'&gt;\"},\n    'Node Attributes': {   'node__pos': \"&lt;class 'numpy.ndarray'&gt;\",\n                           'node_groups': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([34])\",\n                           'node_name': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([34])\"}}\n</pre> <p>Using <code>erdos_renyi_gnm_randomize</code>, we obtain a random graph with the same number of nodes and edges.</p> In\u00a0[10]: Copied! <pre>r_karate = pp.algorithms.generative_models.erdos_renyi_gnm_randomize(g_karate)\nprint(r_karate)\n</pre> r_karate = pp.algorithms.generative_models.erdos_renyi_gnm_randomize(g_karate) print(r_karate) <pre>Undirected graph with 34 nodes and 77 edges\n{'Edge Attributes': {}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\n</pre> <p>Note that node, edge, and graph attributes are not preserved, but it is easy to add back those manually that you want to reassign.</p> In\u00a0[11]: Copied! <pre>r_karate.data.node_groups = g_karate.data.node_groups\nprint(r_karate)\n</pre> r_karate.data.node_groups = g_karate.data.node_groups print(r_karate) <pre>Undirected graph with 34 nodes and 77 edges\n{'Edge Attributes': {}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {'node_groups': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([34])\"}}\n</pre> <p>Using <code>erdos_renyi_gnp_randomize</code>, we obtain a random graph with the same number of nodes and where the expected number of edges matches the original graph, i.e. in each random realization the actual number of edges varies:</p> In\u00a0[12]: Copied! <pre>r_karate_1 = pp.algorithms.generative_models.erdos_renyi_gnp_randomize(g_karate)\nr_karate_2 = pp.algorithms.generative_models.erdos_renyi_gnp_randomize(g_karate)\nprint(r_karate_1)\nprint(r_karate_2)\n</pre> r_karate_1 = pp.algorithms.generative_models.erdos_renyi_gnp_randomize(g_karate) r_karate_2 = pp.algorithms.generative_models.erdos_renyi_gnp_randomize(g_karate) print(r_karate_1) print(r_karate_2) <pre>Undirected graph with 34 nodes and 81 edges\n{'Edge Attributes': {}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\nUndirected graph with 34 nodes and 67 edges\n{'Edge Attributes': {}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\n</pre> <p>Plotting the distribution of edges in the random realization confirms that we get a distribution that is centered around the edge count of our empirical graph.</p> In\u00a0[13]: Copied! <pre>edge_counts = []\nfor i in range(200):\n    r_karate = pp.algorithms.generative_models.erdos_renyi_gnp_randomize(g_karate)\n    edge_counts.append(r_karate.m)\nax = plt.hist(edge_counts)\nplt.axvline(x=g_karate.m, color='red')\n</pre> edge_counts = [] for i in range(200):     r_karate = pp.algorithms.generative_models.erdos_renyi_gnp_randomize(g_karate)     edge_counts.append(r_karate.m) ax = plt.hist(edge_counts) plt.axvline(x=g_karate.m, color='red') Out[13]: <pre>&lt;matplotlib.lines.Line2D at 0x7fec977ef4c0&gt;</pre> <p>We can finally use the Molloy-Reed configuration model to generate random graphs with a given degree sequence:</p> In\u00a0[14]: Copied! <pre>g = pp.algorithms.generative_models.molloy_reed([2,2,3,2,3])\nprint(pp.statistics.degree_sequence(g))\nprint(g)\npp.plot(g);\n</pre> g = pp.algorithms.generative_models.molloy_reed([2,2,3,2,3]) print(pp.statistics.degree_sequence(g)) print(g) pp.plot(g); <pre>tensor([2, 2, 3, 2, 3], dtype=torch.int32)\nUndirected graph with 5 nodes and 6 edges\n{'Edge Attributes': {}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\n</pre> <p>Not every sequence of integers is the degree sequence of a corresponding graph, the following thus fails:</p> In\u00a0[15]: Copied! <pre>try:\n    g = pp.algorithms.generative_models.molloy_reed([2,2,6,2,3])\nexcept Exception as e:\n    print(f\"Error: {e}\")\n</pre> try:     g = pp.algorithms.generative_models.molloy_reed([2,2,6,2,3]) except Exception as e:     print(f\"Error: {e}\") <pre>2025-11-12 14:06:25 - given degree sequence is not graphic\n</pre> <pre>Error: given degree sequence is not graphic\n</pre> <p>We can test whether a sequence of integers is graphic, i.e. whether we can use it to generate a Molloy-Reed random graph:</p> In\u00a0[16]: Copied! <pre>pp.algorithms.generative_models.is_graphic_erdos_gallai([2,2,6,2,3])\n</pre> pp.algorithms.generative_models.is_graphic_erdos_gallai([2,2,6,2,3]) Out[16]: <pre>False</pre> <p>We can use the Molloy-Reed model to randomize empirical networks, generating a random graph with the same degree sequence but a randomized topology:</p> In\u00a0[17]: Copied! <pre>r_karate = pp.algorithms.generative_models.molloy_reed_randomize(g_karate)\nprint(r_karate)\nprint(pp.statistics.degree_sequence(g_karate))\nprint(pp.statistics.degree_sequence(r_karate))\n</pre> r_karate = pp.algorithms.generative_models.molloy_reed_randomize(g_karate) print(r_karate) print(pp.statistics.degree_sequence(g_karate)) print(pp.statistics.degree_sequence(r_karate)) <pre>Undirected graph with 34 nodes and 77 edges\n{'Edge Attributes': {}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\ntensor([16,  9, 10,  6,  3,  4,  4,  4,  5,  2,  3,  1,  2,  5,  2,  2,  2,  2,\n         2,  3,  2,  2,  1,  5,  3,  3,  2,  4,  3,  4,  4,  6, 12, 16],\n       dtype=torch.int32)\ntensor([16,  9, 10,  6,  3,  4,  4,  4,  5,  2,  3,  1,  2,  5,  2,  2,  2,  2,\n         2,  3,  2,  2,  1,  5,  3,  3,  2,  4,  3,  4,  4,  6, 12, 16],\n       dtype=torch.int32)\n</pre> <p>Finally, the <code>generative_models</code> module also contains implementations of the Watts-Strogatz model as well as the stochastic block model. Different from the models above, those models cannot be used to randomize a graph though.</p> In\u00a0[18]: Copied! <pre>g = pp.algorithms.generative_models.watts_strogatz(n=100, s=2, p=0.1)\npp.plot(g);\n</pre> g = pp.algorithms.generative_models.watts_strogatz(n=100, s=2, p=0.1) pp.plot(g); <p>To generate an undirected random graph based on the stochastic block model, we must minimally specify two parameters:</p> <p>The stochastic block matrix $M$ contains edge probabilities for all pairs of nodes where the source and target belong to different blocks.</p> <p>The block assignment vector $z$ assigns nodes to blocks (based on their index). The length of this vector implicitly determined the number of nodes.</p> <p>In the example below, we generate a random graph with eight nodes, where the first four nodes <code>a</code> - <code>d</code> are assigned to block 0 and the last four nodes <code>e</code> - <code>h</code> are assigned to block 1. Edges between node pairs where both nodes are in block 0 are generated with probability $0.95$. If both nodes are in block 1 edges are generated with probability $0.85$. If the nodes are in different blocks, edges are generated with probability $0.1$.</p> In\u00a0[19]: Copied! <pre>M = np.matrix('0.95 0.15; 0.15 0.85')\nprint(M)\nz = np.array([0, 0, 0, 0, 1, 1, 1, 1])\n\ng = pp.algorithms.generative_models.stochastic_block_model(M, z, pp.IndexMap(list('abcdefgh')))\npp.plot(g, node_color=z.tolist());\n</pre> M = np.matrix('0.95 0.15; 0.15 0.85') print(M) z = np.array([0, 0, 0, 0, 1, 1, 1, 1])  g = pp.algorithms.generative_models.stochastic_block_model(M, z, pp.IndexMap(list('abcdefgh'))) pp.plot(g, node_color=z.tolist()); <pre>[[0.95 0.15]\n [0.15 0.85]]\n</pre> <p>To generate a graph with three fully connected cliques, we can specify the parameters as follows:</p> In\u00a0[20]: Copied! <pre>M = np.matrix('1 0 0;0 1 0;0 0 1')\nprint(M)\nz = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2])\ng = pp.algorithms.generative_models.stochastic_block_model(M, z, pp.IndexMap(list('abcdefghi')))\nprint(g)\npp.plot(g, node_color=z.tolist());\n</pre> M = np.matrix('1 0 0;0 1 0;0 0 1') print(M) z = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2]) g = pp.algorithms.generative_models.stochastic_block_model(M, z, pp.IndexMap(list('abcdefghi'))) print(g) pp.plot(g, node_color=z.tolist()); <pre>[[1 0 0]\n [0 1 0]\n [0 0 1]]\nUndirected graph with 9 nodes and 9 edges\n{'Edge Attributes': {}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\n</pre>"},{"location":"tutorial/generative_models/#generative-models-for-random-graphs","title":"Generative Models for Random Graphs\u00b6","text":""},{"location":"tutorial/generative_models/#prerequisites","title":"Prerequisites\u00b6","text":"<p>First, we need to set up our Python environment that has PyTorch, PyTorch Geometric and PathpyG installed. Depending on where you are executing this notebook, this might already be (partially) done. E.g. Google Colab has PyTorch installed by default so we only need to install the remaining dependencies. The DevContainer that is part of our GitHub Repository on the other hand already has all of the necessary dependencies installed.</p> <p>In the following, we install the packages for usage in Google Colab using Jupyter magic commands. For other environments comment in or out the commands as necessary. For more details on how to install <code>pathpyG</code> especially if you want to install it with GPU-support, we refer to our documentation. Note that <code>%%capture</code> discards the full output of the cell to not clutter this tutorial with unnecessary installation details. If you want to print the output, you can comment <code>%%capture</code> out.</p>"},{"location":"tutorial/generative_models/#motivation-and-learning-objectives","title":"Motivation and Learning Objectives\u00b6","text":"<p><code>pathpyG</code> provides implementations for several basic generative models for random graphs, such as different variants of the Erd\u00f6s-Renyi model for random graphs, the Molloy-Reed configuration model for random graphs with given degree sequence or distribution, or the Watts-Strogatz models for small-world graphs.</p> <p>These models are implemented in the module <code>pathpyG.algorithms.generative_models</code>. In this tutorial, we will learn how to use these models to generate random graphs with <code>pathpyG</code>.</p> <p>We start by importing the necessary packages and modules.</p>"},{"location":"tutorial/implementation_concepts/","title":"Implementation Concepts","text":"In\u00a0[1]: Copied! <pre>%%capture\n# !pip install torch\n# !pip install torch_geometric\n# !pip install git+https://github.com/pathpy/pathpyG.git\n</pre> %%capture # !pip install torch # !pip install torch_geometric # !pip install git+https://github.com/pathpy/pathpyG.git In\u00a0[2]: Copied! <pre>import torch\nfrom torch_geometric.data import Data\nfrom torch_geometric.utils import cumsum, degree, sort_edge_index\n\nimport pathpyG as pp\n</pre> import torch from torch_geometric.data import Data from torch_geometric.utils import cumsum, degree, sort_edge_index  import pathpyG as pp In\u00a0[3]: Copied! <pre>mapping = pp.IndexMap(list(\"abcdef\"))\ngraph = pp.Graph.from_edge_index(\n    edge_index=torch.tensor([[0, 1, 3, 4, 2, 2, 5], [2, 2, 5, 5, 3, 4, 0]]), mapping=mapping\n)\npp.plot(graph);\n</pre> mapping = pp.IndexMap(list(\"abcdef\")) graph = pp.Graph.from_edge_index(     edge_index=torch.tensor([[0, 1, 3, 4, 2, 2, 5], [2, 2, 5, 5, 3, 4, 0]]), mapping=mapping ) pp.plot(graph); <p>We can create the line graph for this graph using the <code>lift_order_edge_index</code> function as follows:</p> In\u00a0[4]: Copied! <pre>second_order_edge_index = pp.algorithms.lift_order.lift_order_edge_index(edge_index=graph.data.edge_index, num_nodes=graph.n)\nsecond_order_mapping = pp.IndexMap(graph.edges)\nsecond_order_data = Data(edge_index=second_order_edge_index, node_sequence=graph.data.edge_index.t())\nline_graph = pp.Graph(data=second_order_data, mapping=second_order_mapping)\npp.plot(line_graph);\n</pre> second_order_edge_index = pp.algorithms.lift_order.lift_order_edge_index(edge_index=graph.data.edge_index, num_nodes=graph.n) second_order_mapping = pp.IndexMap(graph.edges) second_order_data = Data(edge_index=second_order_edge_index, node_sequence=graph.data.edge_index.t()) line_graph = pp.Graph(data=second_order_data, mapping=second_order_mapping) pp.plot(line_graph); <p>To create the higher-order <code>PathpyG.Graph</code>, we needed to specify a <code>node_sequence</code> in the <code>Data</code> object. The node sequence above was given by the original edges of the graph. This <code>node_sequence</code> keeps track of which original nodes correspond to which higher-order nodes in the higher-order graph. In a second order graph, each higher-order node corresponds to an edge in the original graph. In a graph of order k, each higher-order node corresponds to a path of length k in the original graph. With this, we can always trace back which higher-order node corresponds to which original nodes.</p> <p>As long as we have this mapping from higher-order nodes to original nodes, we can always do an additional line graph transformation to create even higher order graphs. Below, we create a third-order graph:</p> In\u00a0[5]: Copied! <pre>third_order_edge_index = pp.algorithms.lift_order.lift_order_edge_index(edge_index=line_graph.data.edge_index, num_nodes=line_graph.n)\nthird_order_data = Data(edge_index=third_order_edge_index, node_sequence=torch.cat([line_graph.data.node_sequence[line_graph.data.edge_index[0]], line_graph.data.node_sequence[line_graph.data.edge_index[1]][:, -1:]], dim=1))\nthird_order_mapping = pp.IndexMap([tuple(seq) for seq in graph.mapping.to_ids(third_order_data.node_sequence).tolist()])\nthird_order_graph = pp.Graph(data=third_order_data, mapping=third_order_mapping)\npp.plot(third_order_graph);\n</pre> third_order_edge_index = pp.algorithms.lift_order.lift_order_edge_index(edge_index=line_graph.data.edge_index, num_nodes=line_graph.n) third_order_data = Data(edge_index=third_order_edge_index, node_sequence=torch.cat([line_graph.data.node_sequence[line_graph.data.edge_index[0]], line_graph.data.node_sequence[line_graph.data.edge_index[1]][:, -1:]], dim=1)) third_order_mapping = pp.IndexMap([tuple(seq) for seq in graph.mapping.to_ids(third_order_data.node_sequence).tolist()]) third_order_graph = pp.Graph(data=third_order_data, mapping=third_order_mapping) pp.plot(third_order_graph); <p>Note that above, we constructed the <code>node_sequence</code> for the third-order graph by concatenating the sequences of the two nodes that form each edge in the second-order graph. However, only the first node in the sequence of the higher-order source and the last node in the sequence of the higher-order target node are different. The middle nodes are the same for both higher-order nodes since they represent the overlapping part of the paths.</p> In\u00a0[6]: Copied! <pre>def lift_order_edge_index(edge_index: torch.Tensor, num_nodes: int ) -&gt; torch.Tensor:\n    \"\"\"Lift order function as implemented in PathpyG.\"\"\"\n    outdegree = degree(edge_index[0], dtype=torch.long, num_nodes=num_nodes)\n    outdegree_per_dst = outdegree[edge_index[1]]\n    num_new_edges = outdegree_per_dst.sum()\n    ho_edge_srcs = torch.repeat_interleave(outdegree_per_dst)\n    ptrs = cumsum(outdegree, dim=0)[:-1]\n    ho_edge_dsts = torch.repeat_interleave(ptrs[edge_index[1]], outdegree_per_dst)\n    idx_correction = torch.arange(num_new_edges, dtype=torch.long)\n    idx_correction -= cumsum(outdegree_per_dst, dim=0)[ho_edge_srcs]\n    ho_edge_dsts += idx_correction\n    return torch.stack([ho_edge_srcs, ho_edge_dsts], dim=0)\n</pre> def lift_order_edge_index(edge_index: torch.Tensor, num_nodes: int ) -&gt; torch.Tensor:     \"\"\"Lift order function as implemented in PathpyG.\"\"\"     outdegree = degree(edge_index[0], dtype=torch.long, num_nodes=num_nodes)     outdegree_per_dst = outdegree[edge_index[1]]     num_new_edges = outdegree_per_dst.sum()     ho_edge_srcs = torch.repeat_interleave(outdegree_per_dst)     ptrs = cumsum(outdegree, dim=0)[:-1]     ho_edge_dsts = torch.repeat_interleave(ptrs[edge_index[1]], outdegree_per_dst)     idx_correction = torch.arange(num_new_edges, dtype=torch.long)     idx_correction -= cumsum(outdegree_per_dst, dim=0)[ho_edge_srcs]     ho_edge_dsts += idx_correction     return torch.stack([ho_edge_srcs, ho_edge_dsts], dim=0) <p>However, what the function does exactly is obfuscated by the heavy use of tensor operations. Let us break down the function step-by-step to understand what is happening internally.</p> <p>Note</p> <p>         Due to the high complexity of the tensor operations, we will maintain to lines of explanations that try to explain the same concepts with different words. One explanation line will be added to the code snippets as comments and the other explanation line will be provided in the markdown cells between the code snippets.     </p> <p>Edge index must be sorted!</p> <p>     The <code>lift_order_edge_index</code> function assumes that the input <code>edge_index</code> is sorted by source nodes. This is not enforced by the function itself, because we ensure that the edge indices are sorted whenever we create a <code>PathpyG.Graph</code> object. This step is crucial for the correct functioning of the <code>lift_order_edge_index</code> function.     </p> <ol> <li>The function first computes the outdegree of each node in the graph using the <code>degree</code> function from <code>torch_geometric.utils</code>. This gives us a tensor containing the number of outgoing edges for each node.</li> </ol> In\u00a0[7]: Copied! <pre># Compute the outdegree of each node used to get all the edge combinations leading to a higher-order edge\noutdegree = degree(graph.data.edge_index[0], dtype=torch.long, num_nodes=graph.n)\nprint(\"Outdegree per node:\")\nfor node in graph.nodes:\n    print(f\"\\t{node}: {outdegree[graph.mapping.to_idx(node)].item()}\")\n</pre> # Compute the outdegree of each node used to get all the edge combinations leading to a higher-order edge outdegree = degree(graph.data.edge_index[0], dtype=torch.long, num_nodes=graph.n) print(\"Outdegree per node:\") for node in graph.nodes:     print(f\"\\t{node}: {outdegree[graph.mapping.to_idx(node)].item()}\") <pre>Outdegree per node:\n\ta: 1\n\tb: 1\n\tc: 2\n\td: 1\n\te: 1\n\tf: 1\n</pre> <ol> <li>Next, we map the outdegree values to the destination nodes of each edge in the edge index. This gives us a tensor where each entry corresponds to the outdegree of the target node of each edge.</li> </ol> <p>Note</p> <p>         This helps us because for the line graph transformation, we need to transform each edge into a node and then connect these nodes (previously edges) if a node in the original graph connects them. Therefore, we need to create a higher-order edge for each combination of incoming and outgoing edges for each node in the original graph. The outdegree of the target node tells us how many outgoing edges there are for each target node, which directly translates to how many higher-order edges we need to create for each incoming edge.     </p> In\u00a0[8]: Copied! <pre># For each center node, we need to combine each outgoing edge with each incoming edge\n# We achieve this by creating `outdegree` number of edges for each destination node \n# of the old edge index\noutdegree_per_dst = outdegree[graph.data.edge_index[1]]\nprint(\"\\nOutdegree per destination node of each edge:\")\nfor e, outdeg in zip(graph.edges, outdegree_per_dst.tolist()):\n    print(f\"\\t{e}: {outdeg}\")\n</pre> # For each center node, we need to combine each outgoing edge with each incoming edge # We achieve this by creating `outdegree` number of edges for each destination node  # of the old edge index outdegree_per_dst = outdegree[graph.data.edge_index[1]] print(\"\\nOutdegree per destination node of each edge:\") for e, outdeg in zip(graph.edges, outdegree_per_dst.tolist()):     print(f\"\\t{e}: {outdeg}\") <pre>\nOutdegree per destination node of each edge:\n\t('a', 'c'): 2\n\t('b', 'c'): 2\n\t('c', 'd'): 1\n\t('c', 'e'): 1\n\t('d', 'f'): 1\n\t('e', 'f'): 1\n\t('f', 'a'): 1\n</pre> <ol> <li>Next, we create the source nodes for the higher-order graph. For this, we create a new index that maps the original edges to its index as a higher-order node. This is done by creating a range from 0 to the number of edges in the original graph. We then repeat each index according to the outdegree of the corresponding target node. This way, we create a source node for each combination of incoming and outgoing edges for each target node, which will be the edges in the higher-order graph.</li> </ol> In\u00a0[9]: Copied! <pre># Use each edge from the edge index as node and assign the new indices in the order of the original edge index\n# Each higher order node has one outgoing edge for each outgoing edge of the original destination node\n# Since we keep the ordering, we can just repeat each node using the `outdegree_per_dst` tensor\nho_edge_srcs = torch.repeat_interleave(outdegree_per_dst)\nprint(\"\\nHigher-order edge source indices:\\n\", ho_edge_srcs.tolist())\nprint(\"Higher-order edge sources:\\n\", graph.mapping.to_ids(graph.data.edge_index[:, ho_edge_srcs]).T)\n</pre> # Use each edge from the edge index as node and assign the new indices in the order of the original edge index # Each higher order node has one outgoing edge for each outgoing edge of the original destination node # Since we keep the ordering, we can just repeat each node using the `outdegree_per_dst` tensor ho_edge_srcs = torch.repeat_interleave(outdegree_per_dst) print(\"\\nHigher-order edge source indices:\\n\", ho_edge_srcs.tolist()) print(\"Higher-order edge sources:\\n\", graph.mapping.to_ids(graph.data.edge_index[:, ho_edge_srcs]).T) <pre>\nHigher-order edge source indices:\n [0, 0, 1, 1, 2, 3, 4, 5, 6]\nHigher-order edge sources:\n [['a' 'c']\n ['a' 'c']\n ['b' 'c']\n ['b' 'c']\n ['c' 'd']\n ['c' 'e']\n ['d' 'f']\n ['e' 'f']\n ['f' 'a']]\n</pre> <ol> <li>Now, we need to create the target nodes for the higher-order edges. For this, we first need to know where the edges of each node start in the original edge index. We can compute this by calculating the cumulative sum of the outdegree values of all nodes. This gives us a tensor where each entry corresponds to the starting index of the edges for each node in the original edge index.</li> </ol> <p>Cumulative Sum</p> <p>         There is one <code>cumsum</code> implementation in PyTorch and one in PyTorch Geometric. The one in PyTorch Geometric starts with an initial zero value, while the one in PyTorch does not. This means that the <code>torch.cumsum</code> function will give us the end pointers of the edges for each node, while the <code>torch_geometric.utils.cumsum</code> function will give us the start pointers (including a last pointer that is equal to the total number of edges). Therefore, we use the <code>torch_geometric.utils.cumsum</code> function here and remove the last entry afterwards.     </p> In\u00a0[10]: Copied! <pre># For each node, we calculate pointers of shape (num_nodes,) that indicate the start of the original edges\n# (new higher-order nodes) that have the node as source node\nptrs = cumsum(outdegree, dim=0)[:-1]\nprint(\"Edge start pointers per node:\\n\", ptrs.tolist())\n</pre> # For each node, we calculate pointers of shape (num_nodes,) that indicate the start of the original edges # (new higher-order nodes) that have the node as source node ptrs = cumsum(outdegree, dim=0)[:-1] print(\"Edge start pointers per node:\\n\", ptrs.tolist()) <pre>Edge start pointers per node:\n [0, 1, 2, 4, 5, 6]\n</pre> <ol> <li>With the starting pointers of the edges for each node, we can start with the creation of the target nodes for the higher-order edges. Remember that we assigned the node indices based on the order of edges in the original edge index and ordered the higher-order source nodes accordingly. Therefore, we are essentially going through each edge, and combine it with each outgoing edge of the edges target node to create the higher-order edges. Since the edges are ordered by source nodes, we are going through all nodes in the original graph in order by going through each outgoing edge of each node. This means that for each edge in the original graph, we can look up where the outgoing edges of its target node start in the original edge index using the <code>ptrs</code> tensor we created in the previous step. We then repeat these starting pointers according to the outdegree of the corresponding target node to create a target node for each combination of incoming and outgoing edges for each target node.</li> </ol> In\u00a0[11]: Copied! <pre># Use these pointers to get the start of the edges for each higher-order src and repeat it `outdegree` times\n# Since we keep the ordering, all new higher-order edges that have the same src are indexed consecutively\nho_edge_dsts = torch.repeat_interleave(ptrs[graph.data.edge_index[1]], outdegree_per_dst)\nprint(\"Higher-order edge destination indices (before correction):\\n\", ho_edge_dsts.tolist())\n</pre> # Use these pointers to get the start of the edges for each higher-order src and repeat it `outdegree` times # Since we keep the ordering, all new higher-order edges that have the same src are indexed consecutively ho_edge_dsts = torch.repeat_interleave(ptrs[graph.data.edge_index[1]], outdegree_per_dst) print(\"Higher-order edge destination indices (before correction):\\n\", ho_edge_dsts.tolist()) <pre>Higher-order edge destination indices (before correction):\n [2, 2, 2, 2, 4, 5, 6, 6, 0]\n</pre> <ol> <li>For now, we do not have the correct indices for the higher-order target nodes yet. Since we only repeated the starting pointers of the edges for each target node, we only have the correct offsets for each group of higher-order edges corresponding to each target node. However, within each group, we need to assign the correct indices to the higher-order target nodes. Luckily, we only need to count up from the starting pointer for each group corresponding to one incoming edge in the original graph due to the ordering of the edges. For this, we create a correction index that counts up from 0 to the total number of higher-order edges.</li> </ol> In\u00a0[12]: Copied! <pre># Since the above only repeats the start of the edges, we need to add (0, 1, 2, 3, ...)\n# for all `outdegree` number of edges consecutively to get the correct destination nodes\n# We can achieve this by starting with a range from (0, 1, ..., num_new_edges)\nidx_correction = torch.arange(ho_edge_srcs.size(0), dtype=torch.long)\nprint(\"Index correction (before adjustment):\\n\", idx_correction.tolist())\n</pre> # Since the above only repeats the start of the edges, we need to add (0, 1, 2, 3, ...) # for all `outdegree` number of edges consecutively to get the correct destination nodes # We can achieve this by starting with a range from (0, 1, ..., num_new_edges) idx_correction = torch.arange(ho_edge_srcs.size(0), dtype=torch.long) print(\"Index correction (before adjustment):\\n\", idx_correction.tolist()) <pre>Index correction (before adjustment):\n [0, 1, 2, 3, 4, 5, 6, 7, 8]\n</pre> <ol> <li>We then subtract the cumulative sum of the outdegree values of the higher-order source nodes from this correction index. This effectively resets the counting for each group of higher-order edges corresponding to each target node.</li> </ol> In\u00a0[13]: Copied! <pre># Then, we subtract the cumulative sum of the outdegree for each destination node\nidx_correction -= cumsum(outdegree_per_dst, dim=0)[ho_edge_srcs]\nprint(\"Index correction (after adjustment):\\n\", idx_correction.tolist())\n</pre> # Then, we subtract the cumulative sum of the outdegree for each destination node idx_correction -= cumsum(outdegree_per_dst, dim=0)[ho_edge_srcs] print(\"Index correction (after adjustment):\\n\", idx_correction.tolist()) <pre>Index correction (after adjustment):\n [0, 1, 0, 1, 0, 0, 0, 0, 0]\n</pre> <ol> <li>Finally, we add this correction index to the starting pointers of the edges for each target node to get the correct indices for the higher-order target nodes.</li> </ol> In\u00a0[14]: Copied! <pre># Add this tensor to the destination nodes to get the correct destination nodes for each higher-order edge        \nho_edge_dsts += idx_correction\nprint(\"Higher-order edge destination indices (after correction):\\n\", ho_edge_dsts.tolist())\nprint(\"Higher-order edge destinations:\\n\", graph.mapping.to_ids(graph.data.edge_index[:, ho_edge_dsts]).T)\n</pre> # Add this tensor to the destination nodes to get the correct destination nodes for each higher-order edge         ho_edge_dsts += idx_correction print(\"Higher-order edge destination indices (after correction):\\n\", ho_edge_dsts.tolist()) print(\"Higher-order edge destinations:\\n\", graph.mapping.to_ids(graph.data.edge_index[:, ho_edge_dsts]).T) <pre>Higher-order edge destination indices (after correction):\n [2, 3, 2, 3, 4, 5, 6, 6, 0]\nHigher-order edge destinations:\n [['c' 'd']\n ['c' 'e']\n ['c' 'd']\n ['c' 'e']\n ['d' 'f']\n ['e' 'f']\n ['f' 'a']\n ['f' 'a']\n ['a' 'c']]\n</pre> <p>This gives us the final higher-order edge index that we can return from the function.</p> In\u00a0[15]: Copied! <pre>tedges = [\n    (\"a\", \"b\", 1),\n    (\"a\", \"b\", 2),\n    (\"b\", \"a\", 3),\n    (\"b\", \"c\", 3),\n    (\"d\", \"c\", 4),\n    (\"a\", \"b\", 4),\n    (\"c\", \"b\", 4),\n    (\"c\", \"d\", 5),\n    (\"b\", \"a\", 5),\n    (\"c\", \"b\", 6),\n]\nt = pp.TemporalGraph.from_edge_list(tedges)\npp.plot(t);\n</pre> tedges = [     (\"a\", \"b\", 1),     (\"a\", \"b\", 2),     (\"b\", \"a\", 3),     (\"b\", \"c\", 3),     (\"d\", \"c\", 4),     (\"a\", \"b\", 4),     (\"c\", \"b\", 4),     (\"c\", \"d\", 5),     (\"b\", \"a\", 5),     (\"c\", \"b\", 6), ] t = pp.TemporalGraph.from_edge_list(tedges) pp.plot(t); <p>We can create a second-order graph from this temporal graph using the <code>lift_order_temporal</code> function. This second-order graph is typically referred to as an event graph. Each node in the graph is an event (edge) in the original temporal graph and two events are connected if they can follow each other in time respecting a maximum time difference <code>delta</code>. Here, we set <code>delta=2</code> which means that two events can be connected if the time difference between them is at most 2 time units.</p> In\u00a0[16]: Copied! <pre>event_edge_index = pp.algorithms.temporal.lift_order_temporal(t, delta=2)\nevent_mapping = pp.IndexMap(t.temporal_edges)\nevent_data = Data(edge_index=event_edge_index, node_sequence=graph.data.edge_index.t())\nevent_graph = pp.Graph(data=event_data, mapping=event_mapping)\npp.plot(event_graph);\n</pre> event_edge_index = pp.algorithms.temporal.lift_order_temporal(t, delta=2) event_mapping = pp.IndexMap(t.temporal_edges) event_data = Data(edge_index=event_edge_index, node_sequence=graph.data.edge_index.t()) event_graph = pp.Graph(data=event_data, mapping=event_mapping) pp.plot(event_graph); <pre>\r  0%|          | 0/6 [00:00&lt;?, ?it/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 6/6 [00:00&lt;00:00, 2869.21it/s]</pre> <pre>\n</pre> <p>Starting with the event graph, we have a static higher-order representation of the temporal graph that we can use to create higher-order models. For each following lift-order transformations, we can use the same principles as described in the previous section on order-lifting and line graph transformations.</p> In\u00a0[17]: Copied! <pre>def filter_time_respecting_edges(event_edge_index: torch.Tensor, timestamps: torch.Tensor, delta: int) -&gt; torch.Tensor:  # noqa: D103\n    # Subtract timestamps of the two events to get the time difference\n    time_diff = timestamps[event_edge_index[1]] - timestamps[event_edge_index[0]]\n    # Create masks for filtering\n    # Remove non-time-respecting higher-order edges\n    non_negative_mask = time_diff &gt; 0\n    # Remove edges that are too far apart in time based on delta\n    delta_mask = time_diff &lt;= delta\n    # Combine masks to get the final time-respecting edges\n    time_respecting_mask = non_negative_mask &amp; delta_mask\n    # Filter the event_edge_index using the time_respecting_mask\n    return event_edge_index[:, time_respecting_mask]\n</pre> def filter_time_respecting_edges(event_edge_index: torch.Tensor, timestamps: torch.Tensor, delta: int) -&gt; torch.Tensor:  # noqa: D103     # Subtract timestamps of the two events to get the time difference     time_diff = timestamps[event_edge_index[1]] - timestamps[event_edge_index[0]]     # Create masks for filtering     # Remove non-time-respecting higher-order edges     non_negative_mask = time_diff &gt; 0     # Remove edges that are too far apart in time based on delta     delta_mask = time_diff &lt;= delta     # Combine masks to get the final time-respecting edges     time_respecting_mask = non_negative_mask &amp; delta_mask     # Filter the event_edge_index using the time_respecting_mask     return event_edge_index[:, time_respecting_mask] <p>We can combine the above filter function with the <code>lift_order_edge_index</code> function to create a lift-order function for temporal graphs as follows:</p> <p>Warning</p> <p>     If we use the standard <code>lift_order_edge_index</code> function, we need to ensure that the input edge index is sorted by source nodes because the <code>edge_index</code> of a <code>TemporalGraph</code> is sorted by time and not by source nodes.     </p> In\u00a0[18]: Copied! <pre># Sort by source node indices\nsorted_edge_index, time = sort_edge_index(t.data.edge_index.as_tensor(), t.data.time)\n# Lift the edge index to the second order\nsecond_order_edge_index = pp.algorithms.lift_order.lift_order_edge_index(edge_index=sorted_edge_index, num_nodes=t.n)\n# Filter the edges based on the lifted edge index\nfiltered_edge_index = filter_time_respecting_edges(second_order_edge_index, timestamps=time, delta=2)\n# Create `pp.Graph` from the filtered edge index\nfiltered_event_mapping = pp.IndexMap([tuple([*t.mapping.to_ids(edge).tolist(), timestamp.item()]) for edge, timestamp in zip(sorted_edge_index.t(), time)])\nfiltered_event_data = Data(edge_index=filtered_edge_index, node_sequence=sorted_edge_index.t())\nfiltered_event_graph = pp.Graph(data=filtered_event_data, mapping=filtered_event_mapping)\npp.plot(filtered_event_graph);\n</pre> # Sort by source node indices sorted_edge_index, time = sort_edge_index(t.data.edge_index.as_tensor(), t.data.time) # Lift the edge index to the second order second_order_edge_index = pp.algorithms.lift_order.lift_order_edge_index(edge_index=sorted_edge_index, num_nodes=t.n) # Filter the edges based on the lifted edge index filtered_edge_index = filter_time_respecting_edges(second_order_edge_index, timestamps=time, delta=2) # Create `pp.Graph` from the filtered edge index filtered_event_mapping = pp.IndexMap([tuple([*t.mapping.to_ids(edge).tolist(), timestamp.item()]) for edge, timestamp in zip(sorted_edge_index.t(), time)]) filtered_event_data = Data(edge_index=filtered_edge_index, node_sequence=sorted_edge_index.t()) filtered_event_graph = pp.Graph(data=filtered_event_data, mapping=filtered_event_mapping) pp.plot(filtered_event_graph); <p>Note</p> <p>         The indexing of the above implementation is different from the one currently implemented in PathpyG. So while the illustrations look identical, the actual indices of the higher-order nodes will differ.     </p> <p>However, the above implementation has a large memory consumption for graphs with many edges because the full higher-order edge index is created before filtering. Therefore, we implement a more memory-efficient version in PathpyG that constructs the higher-order edges from the temporal graph sequentially for each timestamp. This implementation looks as follows:</p> In\u00a0[19]: Copied! <pre>def lift_order_temporal(g: pp.TemporalGraph, delta: int = 1):  # noqa: D103\n    indices = torch.arange(0, g.data.edge_index.size(1))\n\n    unique_t = torch.unique(g.data.time)\n    second_order = []\n\n    # lift order: find possible continuations for edges in each time stamp\n    for t in unique_t:\n\n        # find indices of all source edges that occur at unique timestamp t\n        src_time_mask = g.data.time == t\n        src_edge_idx = indices[src_time_mask]\n\n        # find indices of all edges that can possibly continue edges occurring at time t for the given delta\n        dst_time_mask = (g.data.time &gt; t) &amp; (g.data.time &lt;= t + delta)\n        dst_edge_idx = indices[dst_time_mask]\n\n        if dst_edge_idx.size(0) &gt; 0 and src_edge_idx.size(0) &gt; 0:\n            # compute second-order edges between src and dst idx\n            # create all possible combinations of src and dst edges\n            x = torch.cartesian_prod(src_edge_idx, dst_edge_idx)\n            # filter combinations for real higher-order edges\n            # for all edges where dst in src_edges (g.data.edge_index[1, x[:, 0]]) matches src in dst_edges (g.data.edge_index[0, x[:, 1]])\n            ho_edge_index = x[g.data.edge_index[1, x[:, 0]] == g.data.edge_index[0, x[:, 1]]]\n            second_order.append(ho_edge_index)\n\n    ho_index = torch.cat(second_order, dim=0).t().contiguous()\n    return ho_index\n</pre> def lift_order_temporal(g: pp.TemporalGraph, delta: int = 1):  # noqa: D103     indices = torch.arange(0, g.data.edge_index.size(1))      unique_t = torch.unique(g.data.time)     second_order = []      # lift order: find possible continuations for edges in each time stamp     for t in unique_t:          # find indices of all source edges that occur at unique timestamp t         src_time_mask = g.data.time == t         src_edge_idx = indices[src_time_mask]          # find indices of all edges that can possibly continue edges occurring at time t for the given delta         dst_time_mask = (g.data.time &gt; t) &amp; (g.data.time &lt;= t + delta)         dst_edge_idx = indices[dst_time_mask]          if dst_edge_idx.size(0) &gt; 0 and src_edge_idx.size(0) &gt; 0:             # compute second-order edges between src and dst idx             # create all possible combinations of src and dst edges             x = torch.cartesian_prod(src_edge_idx, dst_edge_idx)             # filter combinations for real higher-order edges             # for all edges where dst in src_edges (g.data.edge_index[1, x[:, 0]]) matches src in dst_edges (g.data.edge_index[0, x[:, 1]])             ho_edge_index = x[g.data.edge_index[1, x[:, 0]] == g.data.edge_index[0, x[:, 1]]]             second_order.append(ho_edge_index)      ho_index = torch.cat(second_order, dim=0).t().contiguous()     return ho_index <p>Note that above we do not use the same indexing trick that is used in the standard <code>lift_order_edge_index</code> function. Instead, we create all possible combinations of incoming and outgoing edges for all incoming edges at each timestamp. Therefore, we need a filtering step afterwards to ensure that only valid higher-order edges are created. However, we can skip the sorting step beforehand because we create all possible edge combinations using the cartesian product.</p> <p>It is also possible to combine both approaches, i.e., we create the higher-order edges for each timestamp separately using the indexing trick from the standard <code>lift_order_edge_index</code> function. While it saves the filtering step, it again requires sorting the edges beforehand which has been shown to be similar in performance to the above method. The code would look as follows:</p> In\u00a0[20]: Copied! <pre>def lift_order_temporal_combined(g: pp.TemporalGraph, delta: int = 1):  # noqa: D103\n    indices = torch.arange(0, g.data.edge_index.size(1))\n\n    unique_t = torch.unique(g.data.time)\n    second_order = []\n\n    # lift order: find possible continuations for edges in each time stamp\n    for i in range(unique_t.size(0)):\n        t = unique_t[i]\n\n        # find indices of all source edges that occur at unique timestamp t\n        src_time_mask = g.data.time == t\n        src_edge_idx = indices[src_time_mask]\n\n        # find indices of all edges that can possibly continue edges occurring at time t for the given delta\n        dst_time_mask = (g.data.time &gt; t) &amp; (g.data.time &lt;= t + delta)\n        dst_node_mask = torch.isin(g.data.edge_index[0], g.data.edge_index[1, src_edge_idx])\n        dst_edge_idx = indices[dst_time_mask &amp; dst_node_mask]\n\n        if dst_edge_idx.size(0) &gt; 0 and src_edge_idx.size(0) &gt; 0:\n            # get sorted dst edges for efficient processing\n            src_edges = g.data.edge_index[:, src_edge_idx]\n            dst_edges = g.data.edge_index[:, dst_edge_idx]\n            sorted_idx = torch.argsort(dst_edges[0])\n            dst_edge_idx = dst_edge_idx[sorted_idx]\n            dst_edges = dst_edges[:, sorted_idx]\n\n            # Use indexing trick to create higher-order edges\n            outdegree = degree(dst_edges[0], dtype=torch.long, num_nodes=g.n)\n            outdegree_per_dst = outdegree[src_edges[1]]\n            num_new_edges = outdegree_per_dst.sum()\n            ho_edge_srcs = torch.repeat_interleave(outdegree_per_dst)\n            ptrs = cumsum(outdegree, dim=0)[:-1]\n            ho_edge_dsts = torch.repeat_interleave(ptrs[src_edges[1]], outdegree_per_dst)\n            idx_correction = torch.arange(num_new_edges, dtype=torch.long)\n            idx_correction -= cumsum(outdegree_per_dst, dim=0)[ho_edge_srcs]\n            ho_edge_dsts += idx_correction\n            second_order.append(torch.stack([src_edge_idx[ho_edge_srcs], dst_edge_idx[ho_edge_dsts]], dim=0))\n\n    ho_index = torch.cat(second_order, dim=1)\n    return ho_index\n</pre> def lift_order_temporal_combined(g: pp.TemporalGraph, delta: int = 1):  # noqa: D103     indices = torch.arange(0, g.data.edge_index.size(1))      unique_t = torch.unique(g.data.time)     second_order = []      # lift order: find possible continuations for edges in each time stamp     for i in range(unique_t.size(0)):         t = unique_t[i]          # find indices of all source edges that occur at unique timestamp t         src_time_mask = g.data.time == t         src_edge_idx = indices[src_time_mask]          # find indices of all edges that can possibly continue edges occurring at time t for the given delta         dst_time_mask = (g.data.time &gt; t) &amp; (g.data.time &lt;= t + delta)         dst_node_mask = torch.isin(g.data.edge_index[0], g.data.edge_index[1, src_edge_idx])         dst_edge_idx = indices[dst_time_mask &amp; dst_node_mask]          if dst_edge_idx.size(0) &gt; 0 and src_edge_idx.size(0) &gt; 0:             # get sorted dst edges for efficient processing             src_edges = g.data.edge_index[:, src_edge_idx]             dst_edges = g.data.edge_index[:, dst_edge_idx]             sorted_idx = torch.argsort(dst_edges[0])             dst_edge_idx = dst_edge_idx[sorted_idx]             dst_edges = dst_edges[:, sorted_idx]              # Use indexing trick to create higher-order edges             outdegree = degree(dst_edges[0], dtype=torch.long, num_nodes=g.n)             outdegree_per_dst = outdegree[src_edges[1]]             num_new_edges = outdegree_per_dst.sum()             ho_edge_srcs = torch.repeat_interleave(outdegree_per_dst)             ptrs = cumsum(outdegree, dim=0)[:-1]             ho_edge_dsts = torch.repeat_interleave(ptrs[src_edges[1]], outdegree_per_dst)             idx_correction = torch.arange(num_new_edges, dtype=torch.long)             idx_correction -= cumsum(outdegree_per_dst, dim=0)[ho_edge_srcs]             ho_edge_dsts += idx_correction             second_order.append(torch.stack([src_edge_idx[ho_edge_srcs], dst_edge_idx[ho_edge_dsts]], dim=0))      ho_index = torch.cat(second_order, dim=1)     return ho_index <p>In contrast to the <code>lift_order_edge_index</code> implementation, the temporal version splits the edges into source and destination edges based on timestamps. For each timestamp, we select the edges that occur at that timestamp as source edges and all edges that occur at later timestamps (within the delta time window) as destination edges. Then, instead of repeating the higher-order source nodes for all edges, we only repeat them for the destination edges.</p> In\u00a0[21]: Copied! <pre>path_mapping = pp.IndexMap(list(\"abcde\"))\npaths = pp.PathData(mapping=path_mapping)\npaths.append_walk(list(\"ab\"))\npaths.append_walk(list(\"abd\"))\npaths.append_walk(list(\"abec\"))\npaths.append_walk(list(\"dbecb\"))\n# To create an index map for path nodes, we need a unique identifier for each node in each path\n# There are two problems with this:\n# 1) The same node can appear in multiple paths (we solve this by using the path id)\n# 2) The same node can appear multiple times in the same path (we solve this by using the step id)\npath_id = torch.repeat_interleave(paths.data.dag_num_nodes)\npath_step_id = torch.arange(paths.data.node_sequence.size(0)) - cumsum(paths.data.dag_num_nodes)[:-1].repeat_interleave(paths.data.dag_num_nodes)\nnode_id = paths.mapping.to_ids(paths.data.node_sequence.flatten())\npath_node_mapping = pp.IndexMap([f\"path {p}, step {s}, node {n}\" for p, s, n in zip(path_id.tolist(), path_step_id.tolist(), node_id.tolist())])\npp.plot(\n    pp.Graph.from_edge_index(paths.data.edge_index, mapping=path_node_mapping)\n);\n</pre> path_mapping = pp.IndexMap(list(\"abcde\")) paths = pp.PathData(mapping=path_mapping) paths.append_walk(list(\"ab\")) paths.append_walk(list(\"abd\")) paths.append_walk(list(\"abec\")) paths.append_walk(list(\"dbecb\")) # To create an index map for path nodes, we need a unique identifier for each node in each path # There are two problems with this: # 1) The same node can appear in multiple paths (we solve this by using the path id) # 2) The same node can appear multiple times in the same path (we solve this by using the step id) path_id = torch.repeat_interleave(paths.data.dag_num_nodes) path_step_id = torch.arange(paths.data.node_sequence.size(0)) - cumsum(paths.data.dag_num_nodes)[:-1].repeat_interleave(paths.data.dag_num_nodes) node_id = paths.mapping.to_ids(paths.data.node_sequence.flatten()) path_node_mapping = pp.IndexMap([f\"path {p}, step {s}, node {n}\" for p, s, n in zip(path_id.tolist(), path_step_id.tolist(), node_id.tolist())]) pp.plot(     pp.Graph.from_edge_index(paths.data.edge_index, mapping=path_node_mapping) ); <p><code>pp.PathData</code> is the core class for working with paths in PathpyG. It allows us to gather a collection of paths that are all walks on the same underlying graph. All paths are stored using one <code>edge_index</code> internally. Thus, two nodes in a path that both correspond to the same node in the underlying graph will not share the same index in the path graph. Instead, each occurrence of a node in a path is represented by a separate node in the path graph. This allows us to represent paths that visit the same node multiple times without ambiguity. The information about the underlying graph is stored in the internal <code>PathData.data.node_sequence</code> tensor, similar to higher-order graphs. Let us look at the example above to illustrate this:</p> In\u00a0[22]: Copied! <pre>print(\"The paths represented using edge index look as follows:\")\nfor edge in paths.data.edge_index.t():\n    print(\n        f\"\\tInternal {edge.tolist()}: Underlying graph edge {paths.mapping.to_ids(paths.data.node_sequence[edge].view(-1)).tolist()}\"\n    )\n</pre> print(\"The paths represented using edge index look as follows:\") for edge in paths.data.edge_index.t():     print(         f\"\\tInternal {edge.tolist()}: Underlying graph edge {paths.mapping.to_ids(paths.data.node_sequence[edge].view(-1)).tolist()}\"     ) <pre>The paths represented using edge index look as follows:\n\tInternal [0, 1]: Underlying graph edge ['a', 'b']\n\tInternal [2, 3]: Underlying graph edge ['a', 'b']\n\tInternal [3, 4]: Underlying graph edge ['b', 'd']\n\tInternal [5, 6]: Underlying graph edge ['a', 'b']\n\tInternal [6, 7]: Underlying graph edge ['b', 'e']\n\tInternal [7, 8]: Underlying graph edge ['e', 'c']\n\tInternal [9, 10]: Underlying graph edge ['d', 'b']\n\tInternal [10, 11]: Underlying graph edge ['b', 'e']\n\tInternal [11, 12]: Underlying graph edge ['e', 'c']\n\tInternal [12, 13]: Underlying graph edge ['c', 'b']\n</pre> <p><code>PathData</code> additionally stores some metadata about the paths so that you can easily access information about which nodes belong to which path. This includes</p> <ul> <li><code>dag_weight</code>: A tensor that stores the weight of each path (i.e., the number of times the path was observed).</li> <li><code>dag_num_edges</code>: A tensor that stores the number of edges in each path.</li> <li><code>dag_num_nodes</code>: A tensor that stores the number of nodes in each path.</li> </ul> <p>Using this information, you can, e.g., access the second path in the collection as follows:</p> In\u00a0[23]: Copied! <pre>start = paths.data.dag_num_nodes[:1].sum().item()\nend = start + paths.data.dag_num_nodes[1].item()\npaths.mapping.to_ids(paths.data.node_sequence[start:end].view(-1)).tolist()\n</pre> start = paths.data.dag_num_nodes[:1].sum().item() end = start + paths.data.dag_num_nodes[1].item() paths.mapping.to_ids(paths.data.node_sequence[start:end].view(-1)).tolist() Out[23]: <pre>['a', 'b', 'd']</pre> <p>Lastly, since we are using an <code>edge_index</code> internally, the <code>lift_order_edge_index</code> function works out-of-the-box for paths. A second-order representation of the paths can be created as follows:</p> In\u00a0[24]: Copied! <pre>paths.mapping.to_ids(paths.data.node_sequence[paths.data.edge_index.t()].squeeze()).tolist()\n</pre> paths.mapping.to_ids(paths.data.node_sequence[paths.data.edge_index.t()].squeeze()).tolist() Out[24]: <pre>[['a', 'b'],\n ['a', 'b'],\n ['b', 'd'],\n ['a', 'b'],\n ['b', 'e'],\n ['e', 'c'],\n ['d', 'b'],\n ['b', 'e'],\n ['e', 'c'],\n ['c', 'b']]</pre> In\u00a0[25]: Copied! <pre>second_order_edge_index = pp.algorithms.lift_order.lift_order_edge_index(\n    edge_index=paths.data.edge_index, num_nodes=paths.data.num_nodes\n)\n# Again, the index map would not be unique normally\n# Hence, we use the path id and step id (here a step is an edge in the path) to create a unique mapping for each higher-order node\npath_id = torch.repeat_interleave(paths.data.dag_num_edges)\npath_step_id = torch.arange(paths.data.dag_num_edges.sum()) - cumsum(paths.data.dag_num_edges)[:-1].repeat_interleave(paths.data.dag_num_edges)\nnode_id = paths.mapping.to_ids(paths.data.node_sequence[paths.data.edge_index.t()].squeeze())\nsecond_order_path_node_mapping = pp.IndexMap([f\"path {p}, step {s}, edge {n}\" for p, s, n in zip(path_id.tolist(), path_step_id.tolist(), node_id.tolist())])\nsecond_order_paths = pp.Graph.from_edge_index(edge_index=second_order_edge_index, mapping=second_order_path_node_mapping)\npp.plot(\n    second_order_paths,\n);\n</pre> second_order_edge_index = pp.algorithms.lift_order.lift_order_edge_index(     edge_index=paths.data.edge_index, num_nodes=paths.data.num_nodes ) # Again, the index map would not be unique normally # Hence, we use the path id and step id (here a step is an edge in the path) to create a unique mapping for each higher-order node path_id = torch.repeat_interleave(paths.data.dag_num_edges) path_step_id = torch.arange(paths.data.dag_num_edges.sum()) - cumsum(paths.data.dag_num_edges)[:-1].repeat_interleave(paths.data.dag_num_edges) node_id = paths.mapping.to_ids(paths.data.node_sequence[paths.data.edge_index.t()].squeeze()) second_order_path_node_mapping = pp.IndexMap([f\"path {p}, step {s}, edge {n}\" for p, s, n in zip(path_id.tolist(), path_step_id.tolist(), node_id.tolist())]) second_order_paths = pp.Graph.from_edge_index(edge_index=second_order_edge_index, mapping=second_order_path_node_mapping) pp.plot(     second_order_paths, ); <p>With the concepts above, we can now create multi-order models using the <code>MultiOrderModel</code> class. This class allows us to create higher-order models of arbitrary order from a given base temporal graph or paths. Let's look at an example of creating a multi-order model from a temporal graph:</p> In\u00a0[26]: Copied! <pre>m_t = pp.MultiOrderModel.from_temporal_graph(t, max_order=2)\npp.plot(m_t.layers[2]);\n</pre> m_t = pp.MultiOrderModel.from_temporal_graph(t, max_order=2) pp.plot(m_t.layers[2]); <pre>\r  0%|          | 0/6 [00:00&lt;?, ?it/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 6/6 [00:00&lt;00:00, 2878.07it/s]</pre> <pre>\n</pre> <p>We can see that the second-order graph created by the <code>MultiOrderModel</code> is different from the one created by the <code>lift_order_temporal</code> function directly. This is because the <code>MultiOrderModel</code> higher-order DeBruijn graph representation. This representation merges higher-order nodes that correspond to the same path in the original graph. This means that temporal edges that appear in the event graph as different nodes will be merged into one node in the DeBruijn graph if they correspond to the same path in the original graph. This results in a more compact representation of the higher-order graph.</p> <p>The same is true for paths. We can create a multi-order model from a collection of paths as follows:</p> In\u00a0[27]: Copied! <pre>m_p = pp.MultiOrderModel.from_path_data(paths, max_order=2)\npp.plot(m_p.layers[2]);\n</pre> m_p = pp.MultiOrderModel.from_path_data(paths, max_order=2) pp.plot(m_p.layers[2]); <p>We can see that the higher-order node <code>a-&gt;b</code> which appeared thrice in the second-order graph created by the <code>lift_order_edge_index</code> function is now merged into one node in the DeBruijn graph representation.</p> In\u00a0[28]: Copied! <pre># We create the third-order representation of the paths\nthird_order_edge_index = pp.algorithms.lift_order.lift_order_edge_index(\n    edge_index=second_order_paths.data.edge_index, num_nodes=second_order_paths.n\n)\n</pre> # We create the third-order representation of the paths third_order_edge_index = pp.algorithms.lift_order.lift_order_edge_index(     edge_index=second_order_paths.data.edge_index, num_nodes=second_order_paths.n ) <ol> <li>Update Node Sequences: Next, we need to update the internal <code>node_sequence</code> tensor to reflect the new higher-order nodes. For this, we create a new <code>node_sequence</code> by concatenating the last node of the target node sequence to the source node sequence. This way, we create a new sequence that corresponds to the paths represented by the next order nodes.</li> </ol> In\u00a0[29]: Copied! <pre>second_order_node_sequence = paths.data.node_sequence[paths.data.edge_index.t()].squeeze()\nthird_order_node_sequence = torch.cat([\n    second_order_node_sequence[second_order_paths.data.edge_index[0]],\n    second_order_node_sequence[second_order_paths.data.edge_index[1]][:, -1:]\n], dim=1)\n</pre> second_order_node_sequence = paths.data.node_sequence[paths.data.edge_index.t()].squeeze() third_order_node_sequence = torch.cat([     second_order_node_sequence[second_order_paths.data.edge_index[0]],     second_order_node_sequence[second_order_paths.data.edge_index[1]][:, -1:] ], dim=1) <ol> <li>Merge Higher-Order Nodes: Finally, we need to merge the higher-order nodes that correspond to the same path in the original graph. For this, we create a unique mapping from the new <code>node_sequence</code> to unique indices. We can then use this mapping to update the higher-order edge index to reflect the merged nodes and then aggregate duplicate edges.</li> </ol> In\u00a0[30]: Copied! <pre>third_order_paths = pp.algorithms.lift_order.aggregate_edge_index(\n    edge_index=third_order_edge_index, node_sequence=third_order_node_sequence\n)\n</pre> third_order_paths = pp.algorithms.lift_order.aggregate_edge_index(     edge_index=third_order_edge_index, node_sequence=third_order_node_sequence ) <p>After performing these steps, we can again visualize the resulting higher-order graph:</p> In\u00a0[31]: Copied! <pre>third_order_paths.mapping = pp.IndexMap([tuple(mapping.to_ids(v).tolist()) for v in third_order_paths.data.node_sequence])\npp.plot(third_order_paths);\n</pre> third_order_paths.mapping = pp.IndexMap([tuple(mapping.to_ids(v).tolist()) for v in third_order_paths.data.node_sequence]) pp.plot(third_order_paths); <p>These steps can be repeated for each order until we reach the desired maximum order for the <code>MultiOrderModel</code>.</p> In\u00a0[32]: Copied! <pre>def get_all_paths_DAG(g: pp.Graph) -&gt; dict:\n    \"\"\"Calculate all existing paths from any root node to any leaf node in a directed acyclic graph (DAG).\"\"\"\n    paths_of_length = {}\n    edge_index = g.data.edge_index.as_tensor()\n\n    # calculate degrees\n    out_degree = degree(edge_index[0], num_nodes=g.n, dtype=torch.long)\n    in_degree = degree(edge_index[1], num_nodes=g.n, dtype=torch.long)\n\n    # identify root nodes with in-degree zero\n    roots = torch.where(in_degree == 0)[0]\n    leafs = out_degree == 0\n\n    # create path tensor that contains all paths that are not yet at a leaf node\n    paths = roots.unsqueeze(1)\n    # remove all paths that are already at a leaf node\n    paths_of_length[1] = paths[leafs[roots]].cpu().tolist()\n    # continue all paths that are not at a leaf node\n    paths = paths[~leafs[roots]]\n    # remember nodes that haven't been traversed yet\n    nodes = roots[~leafs[roots]]\n\n    ptrs = cumsum(out_degree, dim=0)\n\n    # count all longest paths in DAG\n    step = 1\n    while nodes.size(0) &gt; 0 or step &gt; g.n:\n        idx_repeat = torch.repeat_interleave(out_degree[nodes])\n        next_idx = torch.repeat_interleave(ptrs[nodes], out_degree[nodes])\n        idx_correction = (\n            torch.arange(next_idx.size(0), device=edge_index.device) - cumsum(out_degree[nodes], dim=0)[idx_repeat]\n        )\n        next_idx += idx_correction\n        next_nodes = edge_index[1][next_idx]\n        paths = torch.cat([paths[idx_repeat], next_nodes.unsqueeze(1)], dim=1)\n        paths_of_length[step] = paths[leafs[next_nodes]].tolist()\n        paths = paths[~leafs[next_nodes]]\n        nodes = next_nodes[~leafs[next_nodes]]\n        step += 1\n\n    return paths_of_length\n</pre> def get_all_paths_DAG(g: pp.Graph) -&gt; dict:     \"\"\"Calculate all existing paths from any root node to any leaf node in a directed acyclic graph (DAG).\"\"\"     paths_of_length = {}     edge_index = g.data.edge_index.as_tensor()      # calculate degrees     out_degree = degree(edge_index[0], num_nodes=g.n, dtype=torch.long)     in_degree = degree(edge_index[1], num_nodes=g.n, dtype=torch.long)      # identify root nodes with in-degree zero     roots = torch.where(in_degree == 0)[0]     leafs = out_degree == 0      # create path tensor that contains all paths that are not yet at a leaf node     paths = roots.unsqueeze(1)     # remove all paths that are already at a leaf node     paths_of_length[1] = paths[leafs[roots]].cpu().tolist()     # continue all paths that are not at a leaf node     paths = paths[~leafs[roots]]     # remember nodes that haven't been traversed yet     nodes = roots[~leafs[roots]]      ptrs = cumsum(out_degree, dim=0)      # count all longest paths in DAG     step = 1     while nodes.size(0) &gt; 0 or step &gt; g.n:         idx_repeat = torch.repeat_interleave(out_degree[nodes])         next_idx = torch.repeat_interleave(ptrs[nodes], out_degree[nodes])         idx_correction = (             torch.arange(next_idx.size(0), device=edge_index.device) - cumsum(out_degree[nodes], dim=0)[idx_repeat]         )         next_idx += idx_correction         next_nodes = edge_index[1][next_idx]         paths = torch.cat([paths[idx_repeat], next_nodes.unsqueeze(1)], dim=1)         paths_of_length[step] = paths[leafs[next_nodes]].tolist()         paths = paths[~leafs[next_nodes]]         nodes = next_nodes[~leafs[next_nodes]]         step += 1      return paths_of_length <p>The function above starts at all root nodes (nodes with no incoming edges) and iteratively traverses all possible next nodes while keeping track of all current paths. Whenever a path reaches a leaf node (a node with no outgoing edges), it is added to the list of longest paths and removed from the current paths. This continues until all paths have reached a leaf node.</p> <p>Tip</p> <p>     Getting the next nodes for all current paths is done using a similar indexing trick as in the <code>lift_order_edge_index</code> function. This allows us to efficiently get all next nodes for all current paths in one go using tensor operations.     </p>"},{"location":"tutorial/implementation_concepts/#general-concepts-of-the-tensor-based-implementations","title":"General Concepts of the Tensor-based Implementations\u00b6","text":""},{"location":"tutorial/implementation_concepts/#prerequisites","title":"Prerequisites\u00b6","text":"<p>First, we need to set up our Python environment that has PyTorch, PyTorch Geometric and PathpyG installed. Depending on where you are executing this notebook, this might already be (partially) done. E.g. Google Colab has PyTorch installed by default so we only need to install the remaining dependencies. The DevContainer that is part of our GitHub Repository on the other hand already has all of the necessary dependencies installed.</p> <p>In the following, we install the packages for usage in Google Colab using Jupyter magic commands. For other environments comment in or out the commands as necessary. For more details on how to install <code>pathpyG</code> especially if you want to install it with GPU-support, we refer to our documentation. Note that <code>%%capture</code> discards the full output of the cell to not clutter this tutorial with unnecessary installation details. If you want to print the output, you can comment <code>%%capture</code> out.</p>"},{"location":"tutorial/implementation_concepts/#motivation-and-learning-objectives","title":"Motivation and Learning Objectives\u00b6","text":"<p>The inner workings of the core classes of PathpyG are based on tensor operations provided by PyTorch and PyTorch Geometric. Especially the creation of higher-order structures using the lift-order functions and the <code>MultiOderModel</code> heavily rely on tensor operations for efficiency reasons. While these implementations are highly optimized, they are very hard to read and understand for newcomers. This tutorial aims to explain the general concepts and ideas behind these implementations in a more accessible way. Additionally, we will provide step-by-step explanations of the core functions in the following sections.</p>"},{"location":"tutorial/implementation_concepts/#order-lifting-and-line-graph-transformations","title":"Order-lifting and Line Graph Transformations\u00b6","text":"<p>At the core of creating higher-order models is the <code>lift_order_edge_index</code> function that is essentially a line graph transformation. Given an edge index of a graph and the number of nodes in the graph, this function creates the edge index for the corresponding line graph. Let's look at an example:</p>"},{"location":"tutorial/implementation_concepts/#under-the-hood-of-lift_order_edge_index","title":"Under the Hood of <code>lift_order_edge_index</code>\u00b6","text":"<p>Let us now take a closer look at how the <code>lift_order_edge_index</code> function works under the hood. The whole function essentially only needs 10 lines of code and looks as follows:</p>"},{"location":"tutorial/implementation_concepts/#temporal-order-lifting","title":"Temporal Order Lifting\u00b6","text":"<p>One of the core functionalities of PathpyG is the ability to create temporal higher-order models. For this, an extension of the <code>lift_order_edge_index</code> function to temporal graphs is needed. We implement this in the <code>lift_order_temporal</code> function. This function works similarly to the <code>lift_order_edge_index</code> function, but with some additional steps to account for the temporal aspect of the graph. The main difference is that we need to ensure that the higher-order edges respect the temporal ordering of the original edges. Let us take a look at an example:</p>"},{"location":"tutorial/implementation_concepts/#internals-of-the-lift_order_temporal-function","title":"Internals of the <code>lift_order_temporal</code> Function\u00b6","text":"<p>The simplest way to implement the <code>lift_order_temporal</code> function would be to first create the full higher-order edge index using the <code>lift_order_edge_index</code> function and then filter out the edges that do not respect the temporal ordering. The filter function could look as follows:</p>"},{"location":"tutorial/implementation_concepts/#paths-in-pathpyg","title":"Paths in PathpyG\u00b6","text":"<p>One other core functionality of PathpyG is the ability to work with paths. Paths are sequences of nodes that represent a walk through the graph. We show an example below:</p>"},{"location":"tutorial/implementation_concepts/#multi-order-models","title":"Multi-Order Models\u00b6","text":""},{"location":"tutorial/implementation_concepts/#internals-of-the-multiordermodel-class","title":"Internals of the <code>MultiOrderModel</code> Class\u00b6","text":"<p>Let us now take a closer look at how the <code>MultiOrderModel</code> class works under the hood. We already saw that the <code>MultiOrderModel</code> merges higher-order nodes from the line/event graph transformations.</p> <p>This is done in 3 distinct steps which we will go through using the paths example above:</p> <ol> <li>Order Lifting: First, we create the higher-order edge index using the appropriate lift-order function (<code>lift_order_edge_index</code> or <code>lift_order_temporal</code>) depending on whether we are working with paths or temporal graphs in the first order and <code>lift_order_edge_index</code> for the second order and beyond regardless of the input type.</li> </ol> <p>Note</p> <p>         While we merge the higher-order nodes and aggregate the higher-order edges for each order, we need to use the original higher-order edge index to create the next order. This is because the transitivity of paths is only preserved in the original higher-order edge index.     </p>"},{"location":"tutorial/implementation_concepts/#other-tensor-based-implementations","title":"Other Tensor-based Implementations\u00b6","text":"<p>The concepts from above can also be useful to implement other functionalities using tensor operations.</p>"},{"location":"tutorial/implementation_concepts/#longest-path-extraction","title":"Longest Path Extraction\u00b6","text":"<p>One example is the extraction of all longest paths from a directed acyclic graph (DAG). This can be done by iterating through all nodes in the DAG in topological order at the same time. We provide an example implementation below:</p>"},{"location":"tutorial/manim_tutorial/","title":"Temporal Graph Visualisation using Manim","text":"In\u00a0[1]: Copied! <pre># %%capture\n# # !pip install torch\n# !pip install torch_geometric\n# !pip install git+https://github.com/pathpy/pathpyG.git\n</pre> # %%capture # # !pip install torch # !pip install torch_geometric # !pip install git+https://github.com/pathpy/pathpyG.git <p>Note that using the <code>Manim</code>-backend in <code>PathpyG</code> requires the installation of <code>Manim</code>. It will not be automatically installed with <code>PathpyG</code> due to its additional dependencies. We recommend using the installation instructions in the <code>Manim</code> documentation or our provided DevContainer.</p> In\u00a0[2]: Copied! <pre>import os\nimport tempfile\n\nimport pathpyG as pp\n</pre> import os import tempfile  import pathpyG as pp <p>Next, we can create a temporal graph that we want to visualise:</p> In\u00a0[3]: Copied! <pre>t = pp.TemporalGraph.from_edge_list(\n    [\n        (\"a\", \"b\", 1),\n        (\"b\", \"c\", 5),\n        (\"c\", \"d\", 9),\n        (\"d\", \"a\", 9),\n        (\"a\", \"b\", 10),\n        (\"b\", \"c\", 10),\n        (\"a\", \"b\", 8),\n        (\"b\", \"c\", 13),\n        (\"c\", \"d\", 17),\n        (\"d\", \"a\", 19),\n        (\"a\", \"b\", 20),\n        (\"b\", \"c\", 18),\n    ]\n)\n</pre> t = pp.TemporalGraph.from_edge_list(     [         (\"a\", \"b\", 1),         (\"b\", \"c\", 5),         (\"c\", \"d\", 9),         (\"d\", \"a\", 9),         (\"a\", \"b\", 10),         (\"b\", \"c\", 10),         (\"a\", \"b\", 8),         (\"b\", \"c\", 13),         (\"c\", \"d\", 17),         (\"d\", \"a\", 19),         (\"a\", \"b\", 20),         (\"b\", \"c\", 18),     ] ) <p>The <code>plot</code> function using Manim as backend allows  to use a variety of customization options to visualize temporal graphs and outputs a video. Some examples are provided below, e.g. the <code>node_size</code> or the <code>edge_size</code>.</p> In\u00a0[4]: Copied! <pre>pp.plot(t, backend=\"manim\", node_size=20, edge_size=10, edge_color=\"red\", node_color=\"gray\")\n</pre> pp.plot(t, backend=\"manim\", node_size=20, edge_size=10, edge_color=\"red\", node_color=\"gray\") <pre>                                                                                          \r</pre>                  Your browser does not support the video tag.              Out[4]: <pre>&lt;pathpyG.visualisations._manim.backend.ManimBackend at 0x7f46c204b6a0&gt;</pre> <p>The videos can be exported as <code>.mp4</code> or <code>.gif</code> if you provide a filename to the <code>plot</code> function.</p> In\u00a0[5]: skip-execution Copied! <pre>with tempfile.TemporaryDirectory() as tmpdirname:\n    tmp_path = os.path.join(tmpdirname, \"temporal_graph_manim.gif\")\n\n    pp.plot(\n        t,\n        backend=\"manim\",\n        node_size=20,\n        edge_size=4,\n        edge_color=\"red\",\n        node_color=\"gray\",\n        filename=tmp_path,\n    )\n    print(f\"Animation saved to {tmp_path}\")\n    print(f\"Files in temp dir: {os.listdir(tmpdirname)}\")\n</pre> with tempfile.TemporaryDirectory() as tmpdirname:     tmp_path = os.path.join(tmpdirname, \"temporal_graph_manim.gif\")      pp.plot(         t,         backend=\"manim\",         node_size=20,         edge_size=4,         edge_color=\"red\",         node_color=\"gray\",         filename=tmp_path,     )     print(f\"Animation saved to {tmp_path}\")     print(f\"Files in temp dir: {os.listdir(tmpdirname)}\") <pre>                                                                                             \r</pre> <pre>Animation saved to /tmp/tmp27x6c4lg/temporal_graph_manim.gif\nFiles in temp dir: ['temporal_graph_manim.gif']\n</pre> In\u00a0[6]: skip-execution Copied! <pre>pp.plot(\n    t,\n    backend=\"manim\",\n    layout_window_size=[3, 1],\n    layout=\"fa2\",\n    node_size=12,\n    edge_color={(\"b\", \"c\", 10): \"green\"},\n    node_color={(\"a\", 3): \"yellow\", (\"a\", 0): \"green\", (\"b\", 3): \"black\"},\n)\n</pre> pp.plot(     t,     backend=\"manim\",     layout_window_size=[3, 1],     layout=\"fa2\",     node_size=12,     edge_color={(\"b\", \"c\", 10): \"green\"},     node_color={(\"a\", 3): \"yellow\", (\"a\", 0): \"green\", (\"b\", 3): \"black\"}, ) <pre>                                                                                           \r</pre>                  Your browser does not support the video tag.              Out[6]: <pre>&lt;pathpyG.visualisations._manim.backend.ManimBackend at 0x7f46b639a830&gt;</pre> In\u00a0[7]: Copied! <pre>g = pp.io.read_netzschleuder_graph('sp_baboons', 'observational', time_attr='time')\n</pre> g = pp.io.read_netzschleuder_graph('sp_baboons', 'observational', time_attr='time') <p>The timestamps are provided in seconds since epoch (converted from unix time). We first convert them to a more human-readable format (hours since the first interaction):</p> In\u00a0[8]: Copied! <pre>g.data.time -= g.data.time.min()\ng.data.time = g.data.time // (60 * 60 * 12) # convert to 12 hours intervals\n</pre> g.data.time -= g.data.time.min() g.data.time = g.data.time // (60 * 60 * 12) # convert to 12 hours intervals <p>The dataset contains different types of interactions between the baboons. We can use this information to color the edges based on the interaction type:</p> In\u00a0[9]: Copied! <pre>colors = []\nfor category in g.data[\"edge_category\"]:\n    match category:\n        case \"Affiliative\":\n            colors.append(\"red\")\n        case \"Agonistic\":\n            colors.append(\"green\")\n        case \"Other\":\n            colors.append(\"grey\")\n</pre> colors = [] for category in g.data[\"edge_category\"]:     match category:         case \"Affiliative\":             colors.append(\"red\")         case \"Agonistic\":             colors.append(\"green\")         case \"Other\":             colors.append(\"grey\") In\u00a0[10]: skip-execution Copied! <pre>pp.plot(\n    g,\n    backend=\"manim\",\n    layout_window_size=12,  # three days\n    layout=\"kk\",\n    edge_color=colors,\n    edge_size=2.5,\n    delta=500,  # Each time step is 500 ms\n)\n</pre> pp.plot(     g,     backend=\"manim\",     layout_window_size=12,  # three days     layout=\"kk\",     edge_color=colors,     edge_size=2.5,     delta=500,  # Each time step is 500 ms ) <pre>                                                                                           \r</pre>                  Your browser does not support the video tag.              Out[10]: <pre>&lt;pathpyG.visualisations._manim.backend.ManimBackend at 0x7f46b87daad0&gt;</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorial/manim_tutorial/#temporal-network-visualizations-with-manim","title":"Temporal Network Visualizations with Manim\u00b6","text":""},{"location":"tutorial/manim_tutorial/#prerequisites","title":"Prerequisites\u00b6","text":"<p>First, we need to set up our Python environment that has PyTorch, PyTorch Geometric and PathpyG installed. Depending on where you are executing this notebook, this might already be (partially) done. E.g. Google Colab has PyTorch installed by default so we only need to install the remaining dependencies. The DevContainer that is part of our GitHub Repository on the other hand already has all of the necessary dependencies installed.</p> <p>In the following, we install the packages for usage in Google Colab using Jupyter magic commands. For other environments comment in or out the commands as necessary. For more details on how to install <code>pathpyG</code> especially if you want to install it with GPU-support, we refer to our documentation. Note that <code>%%capture</code> discards the full output of the cell to not clutter this tutorial with unnecessary installation details. If you want to print the output, you can comment <code>%%capture</code> out.</p>"},{"location":"tutorial/manim_tutorial/#motivation-and-learning-objectives","title":"Motivation and Learning Objectives\u00b6","text":"<p>While you already learned how to visualise graphs with <code>PathpyG</code> in the interactive graph visualisation tutorial, those visualisations mostly considered static graphs. In this tutorial, you will learn how to use the <code>Manim</code> backend in <code>PathpyG</code> to generate videos (<code>.mp4</code>) or animations (<code>.gif</code>) of temporal graphs.</p>"},{"location":"tutorial/manim_tutorial/#lets-get-started","title":"Let's Get Started\u00b6","text":"<p>We need to import <code>PathpyG</code> first:</p>"},{"location":"tutorial/manim_tutorial/#dynamic-customisations-and-layout","title":"Dynamic Customisations and Layout\u00b6","text":"<p>Since we use <code>manim</code> to animate temporal networks, we can also use dynamic customisations that change over time. For example, we can change the <code>node_size</code> or <code>edge_size</code> over time. To change those properties dynamically, we can provide a dictionary that maps node/source-target id and the time step to the desired property value.</p> <p>Additionally, we can use dynamic layouts that are based on sliding windows. For example, we can use a <code>ForceAtlas2</code> layout that is computed based on a sliding window of the last 3 time steps. This allows us to have a layout that changes over time but is still stable enough to be visually appealing.</p> <p>The following shows an example where all of the customisations described above are used:</p>"},{"location":"tutorial/manim_tutorial/#real-world-example","title":"Real-World Example\u00b6","text":"<p>As a final example, we show how to visualise a real-world temporal graph with <code>Manim</code>. We use Netschleuder Online Repository (see our next tutorial our next tutorial Graph Learning in Netzschleuder Data for more information) to obtain a temporal interaction graph between baboons and color the types of interactions in different colors.</p>"},{"location":"tutorial/netzschleuder/","title":"Graph Learning in Netzschleuder Data","text":"In\u00a0[1]: Copied! <pre>%%capture\n# !pip install torch\n# !pip install torch_geometric\n# !pip install git+https://github.com/pathpy/pathpyG.git\n</pre> %%capture # !pip install torch # !pip install torch_geometric # !pip install git+https://github.com/pathpy/pathpyG.git In\u00a0[2]: Copied! <pre>import torch\nimport torch_geometric\nfrom matplotlib import pyplot as plt\nfrom sklearn import metrics\nfrom sklearn.decomposition import TruncatedSVD\nfrom torch.nn import ReLU, Sigmoid\nfrom torch_geometric.nn import GCNConv, Sequential\n\nimport pathpyG as pp\n</pre> import torch import torch_geometric from matplotlib import pyplot as plt from sklearn import metrics from sklearn.decomposition import TruncatedSVD from torch.nn import ReLU, Sigmoid from torch_geometric.nn import GCNConv, Sequential  import pathpyG as pp In\u00a0[3]: Copied! <pre>device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n</pre> device = torch.device('cuda' if torch.cuda.is_available() else 'cpu') In\u00a0[4]: Copied! <pre>g = pp.io.read_netzschleuder_graph(name='polbooks')\ng.mapping = pp.IndexMap(g.data.node_label)\nprint(g)\n</pre> g = pp.io.read_netzschleuder_graph(name='polbooks') g.mapping = pp.IndexMap(g.data.node_label) print(g) <pre>Undirected graph with 105 nodes and 441 edges\n{   'Edge Attributes': {},\n    'Graph Attributes': {   'analyses_average_degree': \"&lt;class 'float'&gt;\",\n                            'analyses_degree_assortativity': \"&lt;class 'float'&gt;\",\n                            'analyses_degree_std_dev': \"&lt;class 'float'&gt;\",\n                            'analyses_diameter': \"&lt;class 'int'&gt;\",\n                            'analyses_edge_properties': \"&lt;class 'list'&gt;\",\n                            'analyses_edge_reciprocity': \"&lt;class 'float'&gt;\",\n                            'analyses_global_clustering': \"&lt;class 'float'&gt;\",\n                            'analyses_hashimoto_radius': \"&lt;class 'float'&gt;\",\n                            'analyses_is_bipartite': \"&lt;class 'bool'&gt;\",\n                            'analyses_is_directed': \"&lt;class 'bool'&gt;\",\n                            'analyses_knn_proj_1': \"&lt;class 'float'&gt;\",\n                            'analyses_knn_proj_2': \"&lt;class 'float'&gt;\",\n                            'analyses_largest_component_fraction': \"&lt;class 'float'&gt;\",\n                            'analyses_mixing_time': \"&lt;class 'float'&gt;\",\n                            'analyses_num_edges': \"&lt;class 'int'&gt;\",\n                            'analyses_num_vertices': \"&lt;class 'int'&gt;\",\n                            'analyses_transition_gap': \"&lt;class 'float'&gt;\",\n                            'analyses_vertex_properties': \"&lt;class 'list'&gt;\",\n                            'num_nodes': \"&lt;class 'int'&gt;\"},\n    'Node Attributes': {'node__pos': \"&lt;class 'numpy.ndarray'&gt;\", 'node_label': \"&lt;class 'numpy.ndarray'&gt;\", 'node_value': \"&lt;class 'numpy.ndarray'&gt;\"}}\n</pre> <p>We can plot this temporal graph in an interactive way:</p> In\u00a0[5]: Copied! <pre>pp.plot(g);\n</pre> pp.plot(g); <p>To see how we can apply GNNs to attributed graphs, let us read the famous karate club network. The record <code>karate</code> actually contains two networks with labels <code>77</code> and <code>78</code>, which refer to two different versions of the data with different numbers of edges. If multiple graph data sets exist in the same record, we can specify the name of the network as second argument.</p> In\u00a0[6]: Copied! <pre>g = pp.io.read_netzschleuder_graph(name='karate', network='78').to(device)\nprint(g)\n</pre> g = pp.io.read_netzschleuder_graph(name='karate', network='78').to(device) print(g) <pre>Undirected graph with 34 nodes and 78 edges\n{   'Edge Attributes': {},\n    'Graph Attributes': {   'analyses_average_degree': \"&lt;class 'float'&gt;\",\n                            'analyses_degree_assortativity': \"&lt;class 'float'&gt;\",\n                            'analyses_degree_std_dev': \"&lt;class 'float'&gt;\",\n                            'analyses_diameter': \"&lt;class 'int'&gt;\",\n                            'analyses_edge_properties': \"&lt;class 'list'&gt;\",\n                            'analyses_edge_reciprocity': \"&lt;class 'float'&gt;\",\n                            'analyses_global_clustering': \"&lt;class 'float'&gt;\",\n                            'analyses_hashimoto_radius': \"&lt;class 'float'&gt;\",\n                            'analyses_is_bipartite': \"&lt;class 'bool'&gt;\",\n                            'analyses_is_directed': \"&lt;class 'bool'&gt;\",\n                            'analyses_knn_proj_1': \"&lt;class 'float'&gt;\",\n                            'analyses_knn_proj_2': \"&lt;class 'float'&gt;\",\n                            'analyses_largest_component_fraction': \"&lt;class 'float'&gt;\",\n                            'analyses_mixing_time': \"&lt;class 'float'&gt;\",\n                            'analyses_num_edges': \"&lt;class 'int'&gt;\",\n                            'analyses_num_vertices': \"&lt;class 'int'&gt;\",\n                            'analyses_transition_gap': \"&lt;class 'float'&gt;\",\n                            'analyses_vertex_properties': \"&lt;class 'list'&gt;\",\n                            'num_nodes': \"&lt;class 'int'&gt;\"},\n    'Node Attributes': {   'node__pos': \"&lt;class 'numpy.ndarray'&gt;\",\n                           'node_groups': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([34])\",\n                           'node_name': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([34])\"}}\n</pre> In\u00a0[7]: Copied! <pre>pp.plot(g);\n</pre> pp.plot(g); <p>We see that the nodes actually have a <code>node_groups</code> property, which maps the nodes to two groups. Those groups are often used as <code>ground truth</code> for communities in this simple illustrative graph. We will instead use it as ground truth categorical node label for a node classification experiment based on a Graph Neural Network.</p> <p>Conveniently, numerical node attributes (either scalar or vector values) are automatically converted to torch tensors, so we can directly use them for a GNN.</p> In\u00a0[8]: Copied! <pre>print(g.data.node_groups)\n</pre> print(g.data.node_groups) <pre>tensor([1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 1, 2, 1, 2, 1, 2, 2,\n        2, 2, 2, 2, 2, 2, 2, 2, 2, 2])\n</pre> <p>For convenience, let us shift the group labels to binary values 0 and 1:</p> In\u00a0[9]: Copied! <pre>g.data.node_groups -= 1\nprint(g.data.node_groups)\n</pre> g.data.node_groups -= 1 print(g.data.node_groups) <pre>tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1,\n        1, 1, 1, 1, 1, 1, 1, 1, 1, 1])\n</pre> <p>We can plot categorical labels by passing node colors in the plot function.</p> In\u00a0[10]: Copied! <pre>pp.plot(g, node_color=[g[\"node_groups\", v].item() for v in g.nodes])\n</pre> pp.plot(g, node_color=[g[\"node_groups\", v].item() for v in g.nodes]) Out[10]: <pre>&lt;pathpyG.visualisations._d3js.backend.D3jsBackend at 0x7ff7d3a7b430&gt;</pre> <p>For convenience, let us shift the group labels to binary values 0 and 1:</p> In\u00a0[11]: Copied! <pre>color_map = {0: \"red\", 1: \"blue\"}\ncolors = [color_map[g[\"node_groups\", v].item()] for v in g.nodes]\npp.plot(g, node_color=colors);\n</pre> color_map = {0: \"red\", 1: \"blue\"} colors = [color_map[g[\"node_groups\", v].item()] for v in g.nodes] pp.plot(g, node_color=colors); <p>To simplify the application of deep learning models, we can retrieve a data object that contains the graph and its attributes:</p> In\u00a0[12]: Copied! <pre>print(g.data)\n</pre> print(g.data) <pre>Data(edge_index=[2, 156], num_nodes=34, node_sequence=[34, 1], node_name=[34], node_groups=[34], node__pos=[34], analyses_average_degree=4.588235294117647, analyses_degree_assortativity=-0.47561309768461424, analyses_degree_std_dev=3.820360677912828, analyses_diameter=5, analyses_edge_properties=[0], analyses_edge_reciprocity=1.0, analyses_global_clustering=0.2556818181818182, analyses_hashimoto_radius=5.292780644548693, analyses_is_bipartite=False, analyses_is_directed=False, analyses_knn_proj_1=3.6123615105719784, analyses_knn_proj_2=1.4566019942625823, analyses_largest_component_fraction=1.0, analyses_mixing_time=7.04834107126513, analyses_num_edges=78, analyses_num_vertices=34, analyses_transition_gap=0.8677276709836416, analyses_vertex_properties=[3])\n</pre> <p>Let's use a one-hot encoding of nodes as a simple additional node feature <code>x</code>, and let's use the node groups as target label <code>y</code>.</p> In\u00a0[13]: Copied! <pre>data = g.data\ng[\"node_feature\"] = torch.eye(g.n, device=device)\ndata['x'] = data['node_feature']\ndata['y'] = data['node_groups'].reshape(-1, 1).float()\n</pre> data = g.data g[\"node_feature\"] = torch.eye(g.n, device=device) data['x'] = data['node_feature'] data['y'] = data['node_groups'].reshape(-1, 1).float() <p>It is easy to define a Graph Convolutional Network that ues the one-hot-encodings of nodes and the topology to predict binary node labels:</p> In\u00a0[14]: Copied! <pre>model = Sequential('node_ohe, edge_index', [\n    (GCNConv(in_channels=data.num_node_features, out_channels=8), 'node_ohe, edge_index -&gt; hidden'),\n    ReLU(inplace=True),\n    (GCNConv(in_channels=8, out_channels=1), 'hidden, edge_index -&gt; output'),\n    Sigmoid(),\n])\nmodel.to(device)\n</pre> model = Sequential('node_ohe, edge_index', [     (GCNConv(in_channels=data.num_node_features, out_channels=8), 'node_ohe, edge_index -&gt; hidden'),     ReLU(inplace=True),     (GCNConv(in_channels=8, out_channels=1), 'hidden, edge_index -&gt; output'),     Sigmoid(), ]) model.to(device) Out[14]: <pre>Sequential(\n  (0) - GCNConv(34, 8): node_ohe, edge_index -&gt; hidden\n  (1) - ReLU(inplace=True): hidden -&gt; hidden\n  (2) - GCNConv(8, 1): hidden, edge_index -&gt; output\n  (3) - Sigmoid(): output -&gt; output\n)</pre> <p>We next apply a <code>RandomNodeSplit</code> transformation to split the nodes in a training and test set.</p> In\u00a0[15]: Copied! <pre>transform = torch_geometric.transforms.RandomNodeSplit(split='train_rest', num_val=0.5, num_test=0)\ndata = transform(data)\n</pre> transform = torch_geometric.transforms.RandomNodeSplit(split='train_rest', num_val=0.5, num_test=0) data = transform(data) <p>We then train our model for 200 epochs on the training set.</p> In\u00a0[16]: Copied! <pre>epochs = 200\n\noptimizer = torch.optim.Adam(model.parameters(), lr=0.01, weight_decay=5e-4)\n    \nlosses = []\n\nmodel.train()\nfor epoch in range(epochs):\n    optimizer.zero_grad()\n    out = model(data.x, data.edge_index)\n    loss = torch.nn.functional.binary_cross_entropy(out[data.train_mask], data.y[data.train_mask])\n    loss.backward()\n    optimizer.step()\n\n    losses.append(loss.cpu().detach().numpy())\n\nplt.plot(range(epochs), losses)\nplt.grid()\n</pre> epochs = 200  optimizer = torch.optim.Adam(model.parameters(), lr=0.01, weight_decay=5e-4)      losses = []  model.train() for epoch in range(epochs):     optimizer.zero_grad()     out = model(data.x, data.edge_index)     loss = torch.nn.functional.binary_cross_entropy(out[data.train_mask], data.y[data.train_mask])     loss.backward()     optimizer.step()      losses.append(loss.cpu().detach().numpy())  plt.plot(range(epochs), losses) plt.grid() <p>We evaluate the model in the test set and calculate the adjusted mutual information for the ground truth.</p> In\u00a0[17]: Copied! <pre>model.eval()\npredicted_groups = model(data.x, data.edge_index).round().long()\nmetrics.adjusted_mutual_info_score(data.y[data.test_mask].squeeze().cpu().numpy(), predicted_groups[data.test_mask].squeeze().cpu().numpy())\n</pre> model.eval() predicted_groups = model(data.x, data.edge_index).round().long() metrics.adjusted_mutual_info_score(data.y[data.test_mask].squeeze().cpu().numpy(), predicted_groups[data.test_mask].squeeze().cpu().numpy()) Out[17]: <pre>1.0</pre> <p>We visualize node representations learned by the model. The test nodes are colored, while training nodes are greyed out.</p> In\u00a0[18]: Copied! <pre># get activations in first-layer\nembedding = model[0].forward(data.x, data.edge_index)\n\n# dimensionality reduction\nsvd = TruncatedSVD()\nlow_dim = svd.fit_transform(embedding.cpu().detach().numpy())\n\n# plot with colors corresponding to groups in validation set\ncolors = {}\nfor v in range(g.n):\n    if not data.val_mask[v]:\n        colors[v] = 'grey'\n    else:\n        if data.y[v].item() == 0.0:\n            colors[v] = 'blue'\n        else:\n            colors[v] = 'orange'\n\nplt.scatter(low_dim[:,0], low_dim[:,1], c=colors.values());\n</pre> # get activations in first-layer embedding = model[0].forward(data.x, data.edge_index)  # dimensionality reduction svd = TruncatedSVD() low_dim = svd.fit_transform(embedding.cpu().detach().numpy())  # plot with colors corresponding to groups in validation set colors = {} for v in range(g.n):     if not data.val_mask[v]:         colors[v] = 'grey'     else:         if data.y[v].item() == 0.0:             colors[v] = 'blue'         else:             colors[v] = 'orange'  plt.scatter(low_dim[:,0], low_dim[:,1], c=colors.values()); <p>This simple code gives you thousands of networks with various meta information at your fingertips, to wich you can directly apply graph learning models provided in pyG, or deep graoh learning architectures defined by yourself.</p>"},{"location":"tutorial/netzschleuder/#learning-in-graphs-from-the-netzschleuder-repository","title":"Learning in Graphs from the Netzschleuder Repository\u00b6","text":""},{"location":"tutorial/netzschleuder/#prerequisites","title":"Prerequisites\u00b6","text":"<p>First, we need to set up our Python environment that has PyTorch, PyTorch Geometric and PathpyG installed. Depending on where you are executing this notebook, this might already be (partially) done. E.g. Google Colab has PyTorch installed by default so we only need to install the remaining dependencies. The DevContainer that is part of our GitHub Repository on the other hand already has all of the necessary dependencies installed.</p> <p>In the following, we install the packages for usage in Google Colab using Jupyter magic commands. For other environments comment in or out the commands as necessary. For more details on how to install <code>pathpyG</code> especially if you want to install it with GPU-support, we refer to our documentation. Note that <code>%%capture</code> discards the full output of the cell to not clutter this tutorial with unnecessary installation details. If you want to print the output, you can comment <code>%%capture</code> out.</p>"},{"location":"tutorial/netzschleuder/#motivation-and-learning-objectives","title":"Motivation and Learning Objectives\u00b6","text":"<p>Access to a large number of graphs with different topological characteristics and from different domains is crucial for the development and evaluation of graph learning methods. Tousands of graph data sets are available scattered throughout the web, possibly using different data formats and with missing information on their actual origin. Addressing this issue the Netschleuder Online Repository by Tiago Peixoto provides a single repository of graphs in a single format, including descriptions, citations, and node-/edge- or graph-level meta-data. To facilitate the development of graph learning techniques, pathpyG provides a feature that allows to directly read networks from the netzschleuder repository via an API.</p> <p>In this brief unit, we will learn how we can retrieve network records and graph data from the netzschleuder repository. We will further demonstrate how we can conveniently apply a Graph Neural Network to predict node-level categories contained in the meta-data.</p> <p>We first need to import a few modules.</p>"},{"location":"tutorial/netzschleuder/#reading-graphs-from-the-netzschleuder-repository","title":"Reading graphs from the netzschleuder repository\u00b6","text":"<p>In the <code>pathpy.io</code> module, there is a function that allows to read graph data from the API.</p> <p>We can read a given networks from the netzschleuder database using its record name. Just browse the Netschleuder Online Repository to find the record names. As an example, we use a graph capturing co-purchase relationships between political books.</p>"},{"location":"tutorial/netzschleuder/#applying-graph-neural-networks-to-netzschleuder-data","title":"Applying Graph Neural Networks to Netzschleuder Data\u00b6","text":""},{"location":"tutorial/paths_higher_order/","title":"Path Data and Higher-Order Models","text":"In\u00a0[1]: Copied! <pre>%%capture\n# !pip install torch\n# !pip install torch_geometric\n# !pip install git+https://github.com/pathpy/pathpyG.git\n</pre> %%capture # !pip install torch # !pip install torch_geometric # !pip install git+https://github.com/pathpy/pathpyG.git In\u00a0[2]: Copied! <pre>import os\nimport tempfile\nfrom urllib import request\n\nimport torch\n\nimport pathpyG as pp\n\ndevice = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n</pre> import os import tempfile from urllib import request  import torch  import pathpyG as pp  device = torch.device('cuda' if torch.cuda.is_available() else 'cpu') <p>For the following examples, we consider a simple directed graph with five nodes <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code> and four edges:</p> In\u00a0[3]: Copied! <pre>g = pp.Graph.from_edge_list([('a', 'c'),\n                             ('b', 'c'),\n                             ('c', 'd'),\n                             ('c', 'e')])\npp.plot(g);\n</pre> g = pp.Graph.from_edge_list([('a', 'c'),                              ('b', 'c'),                              ('c', 'd'),                              ('c', 'e')]) pp.plot(g); In\u00a0[4]: Copied! <pre>paths = pp.PathData(g.mapping)\n\npaths.append_walk(('a', 'c', 'd'), weight=4.0)\npaths.append_walk(('b', 'c', 'e'), weight=4.0)\nprint(paths)\n</pre> paths = pp.PathData(g.mapping)  paths.append_walk(('a', 'c', 'd'), weight=4.0) paths.append_walk(('b', 'c', 'e'), weight=4.0) print(paths) <pre>PathData with 2 paths with total weight 8.0\n</pre> <p>Let us inspect how those walks are internally stored in the <code>PathData</code> object. We find that the class internally stores a <code>pyG.Data</code> object, which contains the properties <code>edge_index</code>, <code>node_sequence</code>, <code>dag_weight</code>, <code>dag_num_edges</code> and <code>dag_num_nodes</code> that can be used to access all of the individual paths.</p> In\u00a0[5]: Copied! <pre>paths.data\n</pre> paths.data Out[5]: <pre>Data(edge_index=[2, 4], node_sequence=[6, 1], dag_weight=[2], dag_num_edges=[2], dag_num_nodes=[2], num_nodes=6)</pre> <p>The <code>edge_index</code> tensor represents an ordered sequence of edges traversed by the walk, where the indices of nodes map to the <code>node_sequence</code> tensor. This additional mapping is neccessary since walks can traverse the same edge multiple times. Moreover, it allows to internally concatenate multiple walks into a single <code>Data</code> object, which is needed for fast GPU-based operations on path data. We can access the first path as follows:</p> In\u00a0[6]: Copied! <pre>paths.data.edge_index[:, :paths.data.dag_num_edges[0]]\n</pre> paths.data.edge_index[:, :paths.data.dag_num_edges[0]] Out[6]: <pre>tensor([[0, 1],\n        [1, 2]])</pre> <p>The <code>node_sequence</code> tensor tells us that the node with index <code>1</code> in the <code>edge_index</code> maps to the node in the graph with index <code>2</code>, which is node <code>c</code>.</p> In\u00a0[7]: Copied! <pre>paths.data.node_sequence[:paths.data.dag_num_nodes[0]]\n</pre> paths.data.node_sequence[:paths.data.dag_num_nodes[0]] Out[7]: <pre>tensor([[0],\n        [2],\n        [3]])</pre> <p>We can index the second edge index accordingly and can see that the <code>node_sequence</code> tensor maps to the sequence <code>b -&gt; c -&gt; e</code>:</p> In\u00a0[8]: Copied! <pre>paths.data.node_sequence[paths.data.edge_index[:, paths.data.dag_num_edges[0]:]]\n</pre> paths.data.node_sequence[paths.data.edge_index[:, paths.data.dag_num_edges[0]:]] Out[8]: <pre>tensor([[[1],\n         [2]],\n\n        [[2],\n         [4]]])</pre> <p>We can actually see a collection of walks as a higher-order generalization of the usual way to define graphs as a collection of dyadic edges (which are simply walks of length one). From this point of view, a standard static (weighted) graph is simply a first-order model of node sequences, which only considers the frequency at which edges are traversed.</p> <p>To generate such a first-order model, we can use the class <code>MultiOderModel</code> and use the first-layer of the model, which is simply a weighted static graph where edge weights count the number of times each edge is traversed by a path. We will explain the class <code>MultiOrderModel</code>, which generalizes this concept to higher-order graph models for any order $k$ in a moment. For now, we can just use it to generate a first-order weighted graph as follows.</p> <p>The generated graph is again based on a <code>pyG.Data</code> object that contains an edge_index and edge weights. As we can see, for the example above the edge_index is just a concatenation of the edge indices of individual walks, where the node indices have been mapped to the correct nodes.</p> In\u00a0[9]: Copied! <pre>m = pp.MultiOrderModel.from_path_data(paths, max_order=1)\ng = m.layers[1]\nprint(g.data.edge_index)\nprint(g.data.edge_weight)\npp.plot(g);\n</pre> m = pp.MultiOrderModel.from_path_data(paths, max_order=1) g = m.layers[1] print(g.data.edge_index) print(g.data.edge_weight) pp.plot(g); <pre>EdgeIndex([[0, 1, 2, 2],\n           [2, 2, 3, 4]], sparse_size=(5, 5), nnz=4, sort_order=row)\ntensor([4., 4., 4., 4.])\n</pre> <p>Why are data on paths and walks interesting in the first place. The answer is that they provide information on the causal topology of complex systems, i.e. which nodes can possibly causally influence each other via paths that follow the arrow of time. This information is lost if we were to split paths into an (unordered) collection of dyadyic interactions between pairs of nodes, i.e. if we were to only onsider links.</p> <p>To illustrate this, let us assume that the four walks above tell us which paths information (or whatever you may be interested in) can take in the simple graph above. That is, we observe something moving from <code>a</code> via <code>c</code> to <code>d</code> and from <code>b</code> via <code>c</code> to <code>e</code>, and each of those events occur four times. However, we never observed that something moving from <code>a</code> to <code>c</code> ended up in <code>d</code>. And neither did we observe that something moving from <code>b</code> to <code>c</code> ended up in <code>e</code>. This means that - assuming that we completely observed all walks or paths - there is no way that <code>a</code> can causally influence <code>e</code> or that <code>b</code> could causally influence <code>d</code> via the center node <code>c</code>. Note that this is not what we would assume if we consider possible paths in the topology of the underlying graph, where paths of length two exist between all four pairs of nodes (<code>a</code>, <code>d</code>), (<code>a</code>, <code>e</code>), (<code>b</code>, <code>d</code>), (<code>b</code>, <code>e</code>).</p> <p>Hence, we can use data capturing actually observed paths or walks ion a network in contrast to which paths or walks would theoretically be possible based on the topology.</p> <p>As a contrast, consider the following observations of walks in the same graph.</p> In\u00a0[10]: Copied! <pre>paths_2 = pp.PathData(g.mapping)\n\npaths_2.append_walk(('a', 'c', 'd'), weight=2)\npaths_2.append_walk(('a', 'c', 'e'), weight=2)\npaths_2.append_walk(('b', 'c', 'd'), weight=2)\npaths_2.append_walk(('b', 'c', 'e'), weight=2)\nprint(paths_2)\n</pre> paths_2 = pp.PathData(g.mapping)  paths_2.append_walk(('a', 'c', 'd'), weight=2) paths_2.append_walk(('a', 'c', 'e'), weight=2) paths_2.append_walk(('b', 'c', 'd'), weight=2) paths_2.append_walk(('b', 'c', 'e'), weight=2) print(paths_2) <pre>PathData with 4 paths with total weight 8.0\n</pre> <p>Here we have observed walks along all four possible paths of length two, each walk occurring only two times. Like in the example before, each edge was traversed exactly four times and thus the weighted edge index of a first-order graph model is identical to the one before:</p> In\u00a0[11]: Copied! <pre>m = pp.MultiOrderModel.from_path_data(paths_2, max_order=1)\ng = m.layers[1]\nprint(g.data.edge_index)\nprint(g.data.edge_weight)\npp.plot(g);\n</pre> m = pp.MultiOrderModel.from_path_data(paths_2, max_order=1) g = m.layers[1] print(g.data.edge_index) print(g.data.edge_weight) pp.plot(g); <pre>EdgeIndex([[0, 1, 2, 2],\n           [2, 2, 3, 4]], sparse_size=(5, 5), nnz=4, sort_order=row)\ntensor([4., 4., 4., 4.])\n</pre> <p>This is a first-order graph representation, as it only captures the (weighted) edges in the underlying path data, i.e. we could say that we only count the frequency of paths (or walks) of length one. This naturally gives rise to an <code>edge_index</code> tensor with shape $(2,m)$, where $m$ is the number of unique edges in the graph that are traversed by the paths.</p> In\u00a0[12]: Copied! <pre>m = pp.MultiOrderModel.from_path_data(paths, max_order=2)\npp.plot(m.layers[2], edge_size=5);\n</pre> m = pp.MultiOrderModel.from_path_data(paths, max_order=2) pp.plot(m.layers[2], edge_size=5); <p>For $k=2$, we obtain a second-order De Bruijn graph where second-order nodes are first-order edges and second-order edges represent walks of length two in the original graph. Edge weights capture observation frequencies of those walks. In our example, we have two different walks of length two ($a$ -&gt; $c$ -&gt; $d$ and $b$ -&gt; $c$ -&gt; $e$), represented by two edges $(a-c, c-d)$ and $(b-c, c-e)$. Each of those walks appears four times so the weights of both edges are four.</p> In\u00a0[13]: Copied! <pre>print(g.mapping)\nprint(g.data.edge_index)\nprint(g.data.edge_weight)\n</pre> print(g.mapping) print(g.data.edge_index) print(g.data.edge_weight) <pre>a -&gt; 0\nb -&gt; 1\nc -&gt; 2\nd -&gt; 3\ne -&gt; 4\n\nEdgeIndex([[0, 1, 2, 2],\n           [2, 2, 3, 4]], sparse_size=(5, 5), nnz=4, sort_order=row)\ntensor([4., 4., 4., 4.])\n</pre> <p>While this goes beyond the scope of this tutorial, thanks to the tensor-based representation of paths, the construction ofhigher-order De Bruijn graphs can be done based on efficient GPU operations, i.e. we can scale it up to large graphs.</p> <p>Let us have a closer look at our examples above. While the first-order edge indices of the two path objects <code>paths</code> and <code>paths_2</code> are the same, we find that the second-order edge indices are actually different. For <code>paths_2</code> we have four different paths of length two, each occurring twice. Hence, our second-order De Bruijn graph has four edges, each with weight two. These edges correspond to all possible paths of length two in the underlying graph.</p> In\u00a0[14]: Copied! <pre>m = pp.MultiOrderModel.from_path_data(paths_2, max_order=2)\npp.plot(m.layers[2]);\n</pre> m = pp.MultiOrderModel.from_path_data(paths_2, max_order=2) pp.plot(m.layers[2]); In\u00a0[15]: Copied! <pre>print(g.mapping)\nprint(g.data.edge_index)\nprint(g.data.edge_weight)\n</pre> print(g.mapping) print(g.data.edge_index) print(g.data.edge_weight) <pre>a -&gt; 0\nb -&gt; 1\nc -&gt; 2\nd -&gt; 3\ne -&gt; 4\n\nEdgeIndex([[0, 1, 2, 2],\n           [2, 2, 3, 4]], sparse_size=(5, 5), nnz=4, sort_order=row)\ntensor([4., 4., 4., 4.])\n</pre> <p>We thus find that the second-order De Bruijn graph representation of paths is sensitive to the differences in the causal topology, while a first-order graph is not. This is the basis to generalize network analysis and graph learning to causality-aware graph models for various kinds of time series data on graphs. In particular, as we shall see in more detail in a later tutorial, we can use paths to generate k-th order graphs that can be used to generalize Graph Neural Networks to higher-order De Bruijn Graphs.</p> <p>Note that all higher-order graphs are simply <code>Graph</code> objects, which means that we can iterate through the nodes of a higher-order graph just like for normal graphs. Node indices are automatically mapped, yielding tuples of first-order node identifiers.</p> In\u00a0[16]: Copied! <pre>for n in g.nodes:\n    print(n)\n</pre> for n in g.nodes:     print(n) <pre>a\nb\nc\nd\ne\n</pre> <p>Edges are tuples with two elements, where each element is a k-th order node, i.e. a tuple of node IDs of length $k$. I.e. for a second-order model the edges are tuples of length two, each entry containing s tuple of length two.</p> In\u00a0[17]: Copied! <pre>for e in g.edges:\n    print(e)\n</pre> for e in g.edges:     print(e) <pre>('a', 'c')\n('b', 'c')\n('c', 'd')\n('c', 'e')\n</pre> <p>The weight attribute stores a tensor whose entries capture the frequencies of edges, i.e. the frequencies of paths of length $k$.</p> In\u00a0[18]: Copied! <pre>for e in g.edges:\n    print(e, g['edge_weight', e[0], e[1]].item())\n</pre> for e in g.edges:     print(e, g['edge_weight', e[0], e[1]].item()) <pre>('a', 'c') 4.0\n('b', 'c') 4.0\n('c', 'd') 4.0\n('c', 'e') 4.0\n</pre> <p>We can finally plot a higher-order De Bruijn graph in the same way as a first-order graph.</p> In\u00a0[19]: Copied! <pre>pp.plot(g);\n</pre> pp.plot(g); <p>Let us compare this to a second-order graph model of the second path data set <code>paths_2</code> from above, which corresponds to a network where all possible paths of length two actually occur. Hence, different from the data in <code>paths</code>, all pairs of nodes in this graph can causally influence each other via paths of length two.</p> In\u00a0[20]: Copied! <pre>m1 = pp.MultiOrderModel.from_path_data(paths, max_order=2)\nprint(m1.estimate_order(paths, significance_threshold=0.01))\n</pre> m1 = pp.MultiOrderModel.from_path_data(paths, max_order=2) print(m1.estimate_order(paths, significance_threshold=0.01)) <pre>2\n</pre> <pre>/home/runner/work/pathpyG/pathpyG/.venv/lib/python3.10/site-packages/torch_geometric/edge_index.py:863: UserWarning: Sparse CSR tensor support is in beta state. If you miss a functionality in the sparse tensor support, please submit a feature request to https://github.com/pytorch/pytorch/issues. (Triggered internally at /pytorch/aten/src/ATen/SparseCsrTensorImpl.cpp:53.)\n  return torch.sparse_csr_tensor(\n</pre> <p>For <code>paths_2</code> where the observed paths are in line what we would expect based on the weighted edges in the first-order graph model, we correctly find that we do not need to consider a second-order model</p> In\u00a0[21]: Copied! <pre>m2 = pp.MultiOrderModel.from_path_data(paths_2, max_order=2)\nprint(m2.estimate_order(paths_2, significance_threshold=0.01))\n</pre> m2 = pp.MultiOrderModel.from_path_data(paths_2, max_order=2) print(m2.estimate_order(paths_2, significance_threshold=0.01)) <pre>1\n</pre> <p>Admittedly, the situation in the <code>paths</code> data is extreme insofar as two of the possible paths of lengths two have not been observed at all. We can also have more subtle deviations from the expectation based on the first-order graph model. Consider the following case, where two of the paths are observed more often than two other paths. Note that we have assigned the path frequencies such that again all edges are traversed with exactly the same frequencies, i.e. all edge weights are again equal in the first-order graph.</p> In\u00a0[22]: Copied! <pre>g = pp.Graph.from_edge_list([('a', 'c'),\n                             ('b', 'c'),\n                             ('c', 'd'),\n                             ('c', 'e')])\npaths_3 = pp.PathData(g.mapping)\n\npaths_3.append_walk(('a', 'c', 'd'), weight=6.0)\npaths_3.append_walk(('a', 'c', 'e'), weight=2.0)\n\npaths_3.append_walk(('b', 'c', 'e'), weight=6.0)\npaths_3.append_walk(('b', 'c', 'd'), weight=2.0)\n\nm3 = pp.MultiOrderModel.from_path_data(paths_3, max_order=2)\nprint(m3.layers[1].data.edge_weight)\nprint(m3.estimate_order(paths_3, significance_threshold=0.01))\n</pre> g = pp.Graph.from_edge_list([('a', 'c'),                              ('b', 'c'),                              ('c', 'd'),                              ('c', 'e')]) paths_3 = pp.PathData(g.mapping)  paths_3.append_walk(('a', 'c', 'd'), weight=6.0) paths_3.append_walk(('a', 'c', 'e'), weight=2.0)  paths_3.append_walk(('b', 'c', 'e'), weight=6.0) paths_3.append_walk(('b', 'c', 'd'), weight=2.0)  m3 = pp.MultiOrderModel.from_path_data(paths_3, max_order=2) print(m3.layers[1].data.edge_weight) print(m3.estimate_order(paths_3, significance_threshold=0.01)) <pre>tensor([8., 8., 8., 8.])\n1\n</pre> <p>In this example, due to the relatively small number of observations, the deviations from the expected baseline are still not strong enough to detect the optimal order of two (at least not for a significance threshold of $0.01$). We would need to raise the signififance threshold to $0.15$ to detect order two:</p> In\u00a0[23]: Copied! <pre>print(m3.estimate_order(paths_3, significance_threshold=0.15))\n</pre> print(m3.estimate_order(paths_3, significance_threshold=0.15)) <pre>2\n</pre> <p>Alternatively, we are able to detect a significant deviation from a first-order model for a significance threshold of $0.01$ if we make the deviations more extreme. If we observe two fo the paths seven times, while the other two are only observed once we find that order two is significant at a sigificance threshold of $0.01$.</p> In\u00a0[24]: Copied! <pre>paths_3 = pp.PathData(g.mapping)\n\npaths_3.append_walk(('a', 'c', 'd'), weight=7.0)\npaths_3.append_walk(('a', 'c', 'e'), weight=1.0)\n\npaths_3.append_walk(('b', 'c', 'e'), weight=7.0)\npaths_3.append_walk(('b', 'c', 'd'), weight=1.0)\n\nm3 = pp.MultiOrderModel.from_path_data(paths_3, max_order=2)\nprint(m3.layers[1].data.edge_weight)\nprint(m3.estimate_order(paths_3, significance_threshold=0.01))\n</pre> paths_3 = pp.PathData(g.mapping)  paths_3.append_walk(('a', 'c', 'd'), weight=7.0) paths_3.append_walk(('a', 'c', 'e'), weight=1.0)  paths_3.append_walk(('b', 'c', 'e'), weight=7.0) paths_3.append_walk(('b', 'c', 'd'), weight=1.0)  m3 = pp.MultiOrderModel.from_path_data(paths_3, max_order=2) print(m3.layers[1].data.edge_weight) print(m3.estimate_order(paths_3, significance_threshold=0.01)) <pre>tensor([8., 8., 8., 8.])\n</pre> <pre>2\n</pre> <p>The ability to detect the optimal higher-order for a given data set in a statistically principled way is a powerful feature of the modelling framework of higher-order De Bruijn Graphs. Admittedly, the likelihood-based model selection approach has its limitations especially for small data sets or partially observed graphs, where it can both over- or underfit. To address this, we have developed an alternative Bayesian model selection technique that is explained and evaluated in the following paper:</p> <p>L Petrovic, I Scholtes: Learning the Markov order of paths, In Proc. of the ACM Web Conference (WWW'22), April 2022</p> <p>Unfortunately, this method has not yet been implemented in <code>pathpyG</code> but we are planning to add it soon.</p> In\u00a0[25]: Copied! <pre>if os.path.exists('../data/tube_paths_train.ngram'):\n    print(\"Loading dataset from local path...\")\n    paths_tube = pp.io.read_csv_path_data(path_or_buf='../data/tube_paths_train.ngram', sep=',', weight=True)\nelse:\n    print(\"Loading dataset from remote URL...\")\n    with tempfile.TemporaryDirectory() as tmpdir:\n        url = \"https://raw.githubusercontent.com/pathpy/pathpyG/refs/heads/main/docs/data/tube_paths_train.ngram\"\n        file_path = os.path.join(tmpdir, 'tube_paths_train.ngram')\n        request.urlretrieve(url, file_path)\n        paths_tube = pp.io.read_csv_path_data(path_or_buf=file_path, sep=',', weight=True)\nprint(paths_tube)\n</pre> if os.path.exists('../data/tube_paths_train.ngram'):     print(\"Loading dataset from local path...\")     paths_tube = pp.io.read_csv_path_data(path_or_buf='../data/tube_paths_train.ngram', sep=',', weight=True) else:     print(\"Loading dataset from remote URL...\")     with tempfile.TemporaryDirectory() as tmpdir:         url = \"https://raw.githubusercontent.com/pathpy/pathpyG/refs/heads/main/docs/data/tube_paths_train.ngram\"         file_path = os.path.join(tmpdir, 'tube_paths_train.ngram')         request.urlretrieve(url, file_path)         paths_tube = pp.io.read_csv_path_data(path_or_buf=file_path, sep=',', weight=True) print(paths_tube) <pre>Loading dataset from local path...\n</pre> <pre>PathData with 61748 paths with total weight 2147865.0\n</pre> <p>To plot a (first-order) graph representation of the London Tube metro network, we can use the following code:</p> In\u00a0[26]: Copied! <pre>m = pp.MultiOrderModel.from_path_data(paths_tube, max_order=1)\ng = m.layers[1]\n# Normalize edge weights and scale for better visualization\ng.data.edge_weight = 5 * g.data.edge_weight / g.data.edge_weight.max()\npp.plot(g);\n</pre> m = pp.MultiOrderModel.from_path_data(paths_tube, max_order=1) g = m.layers[1] # Normalize edge weights and scale for better visualization g.data.edge_weight = 5 * g.data.edge_weight / g.data.edge_weight.max() pp.plot(g); <p>In general, the maximum size of a higher-order model could grow exponentially with the number of nodes in the underlying graph. However, for most empirical data sets, higher-order models are actually sparse, which allows us to efficiently construct them using GPU-based operations. We demonstrate this in the London Tube data sets by constructing all higher-order De Bruijn graph models up to order 20, which takes approx. 25 seconds on a mobile GPU (RTX A2000) and yields reasonably sized higher-order models.</p> In\u00a0[27]: skip-execution Copied! <pre>paths_tube.to(device)\nm = pp.MultiOrderModel.from_path_data(paths_tube, max_order=20)\nprint(m.layers[20])\n</pre> paths_tube.to(device) m = pp.MultiOrderModel.from_path_data(paths_tube, max_order=20) print(m.layers[20]) <pre>Directed graph with 5634 nodes and 4729 edges\n{   'Edge Attributes': {'edge_weight': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([4729])\"},\n    'Graph Attributes': {'inverse_idx': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([18950])\", 'num_nodes': \"&lt;class 'int'&gt;\"},\n    'Node Attributes': {}}\n</pre> <p>As we shall see in the following two units, the <code>MultiOrderGraph</code> class is also the basis for the GPU-based analysis and modelling of causal structures in temporal graphs. In particular, the underlying generalization of first-order static graph models to higher-order De Bruijn graphs allows us to easily build causality-aware graph neural network architectures that consider both the topology and the temoral ordering of time-stamped edges in a temporal graph. We will</p>"},{"location":"tutorial/paths_higher_order/#path-data-and-higher-order-de-bruijn-graphs","title":"Path Data and Higher-Order De Bruijn Graphs\u00b6","text":""},{"location":"tutorial/paths_higher_order/#prerequisites","title":"Prerequisites\u00b6","text":"<p>First, we need to set up our Python environment that has PyTorch, PyTorch Geometric and PathpyG installed. Depending on where you are executing this notebook, this might already be (partially) done. E.g. Google Colab has PyTorch installed by default so we only need to install the remaining dependencies. The DevContainer that is part of our GitHub Repository on the other hand already has all of the necessary dependencies installed.</p> <p>In the following, we install the packages for usage in Google Colab using Jupyter magic commands. For other environments comment in or out the commands as necessary. For more details on how to install <code>pathpyG</code> especially if you want to install it with GPU-support, we refer to our documentation. Note that <code>%%capture</code> discards the full output of the cell to not clutter this tutorial with unnecessary installation details. If you want to print the output, you can comment <code>%%capture</code> out.</p>"},{"location":"tutorial/paths_higher_order/#motivation-and-learning-objective","title":"Motivation and Learning Objective\u00b6","text":"<p>While <code>pathpyG</code> is useful to handle and visualize static graphs - as the name suggests - its main advantage is that it facilitates the analysis of time series data that can be used to calculate paths in a graph. As we shall see in the following tutorial, there are various situations in which naturally have access to data on paths, including data on (random) walks or trajectories, traces of dynamical processes giving rise to node sequences or directed acyclic graphs, or time-respecting paths in temporal graphs. ``pathpyG` can be used to model patterns in such data based on higher-order De Bruijn graph models.</p> <p>In this first unit, we will show how <code>pathpyG</code> supports to represent data on paths in graphs. Like graphs, such data are internally stored as tensors, which facilitates GPU-based operations to create higher-order De Bruijn graphs.</p> <p>We first import the modules <code>torch</code> and <code>pathpyG</code>. By setting the device used by <code>torch</code>, we can specify whether we want to run our code on the CPU or on the GPU.</p>"},{"location":"tutorial/paths_higher_order/#using-pathdata-to-store-walks-or-paths-in-a-graph","title":"Using <code>PathData</code> to store walks or paths in a graph\u00b6","text":"<p>Assume that we have time series data that captures observations of trajectories (i.e. walks or paths) in the graph above. For example, we could observe four walks of length two, four each of the following:</p> <ul> <li>4 x <code>a</code> -&gt; <code>c</code> -&gt; <code>d</code></li> <li>4 x <code>b</code> -&gt; <code>c</code> -&gt; <code>e</code></li> </ul> <p>Note that we define the length of a walk or path as the number of edges that are traversed, i.e. a sequence that consists of a single node, e.g. <code>a</code>, is considered a walk of length zero, while every edge in a graph is a walk of length one.</p> <p><code>pp.PathData</code> supports to store and model such sequential data. We first create an instance of the <code>PathData</code> class. To consistently map node IDs to indices across <code>Graph</code> and <code>PathData</code> objects, we can pass the <code>IndexMap</code> object from the <code>Graph</code> above in the constructor. We then use the <code>append_walk</code> function to add observations of our two walks, where the <code>weight</code> argument is used to indicate the number of times each path or walk has been observed.</p>"},{"location":"tutorial/paths_higher_order/#from-graphs-to-higher-order-de-bruijn-graph-models","title":"From Graphs to Higher-Order De Bruijn Graph Models\u00b6","text":"<p>As we have seen above, the use of a first-order graph model discards information in path data, which capture which nodes can possibly causally influence each other via paths. A key feature of <code>pathpyG</code> is it allows to generalize this first-order modelling perspective to $k$-th order De Bruijn graph models for paths, where the nodes in a $k$-th order De Bruijn graph model are sequences of $k$ nodes. Edges connect pairs of nodes that overlap in $k-1$ nodes and capture paths of length $k$.</p> <p>A De Bruijn graph of order $k=1$ is simply a normal (weighted) static graph consisting of nodes and edges. Pairs of nodes connected by edges overlap in $k-1=0$ nodes and capture paths of length $k=1$, i.e. simple dyadic edges in the underlying path data.</p> <p>For a De Bruijn graph with order $k=2$, in our example above, an edge connects a pair of nodes $(a,b)$ and $(b,c)$ that overlaps in the $k-1=1$ node $b$. Such an edge represents the path $a -&gt; b -&gt; c$ of length two. We can use the <code>MultiOderModel</code> class to generate a second-order De Bruijn graph representation of the path data above. We just have to set the <code>max_order</code> parameter to two and use the second layer of the resulting <code>MultiOrderModel</code> instance.</p>"},{"location":"tutorial/paths_higher_order/#detecting-the-optimal-order-of-higher-order-de-bruijn-graph-models","title":"Detecting the Optimal Order of Higher-Order De Bruijn Graph Models\u00b6","text":"<p>The fact that we can model the same set of paths with higher-order De Bruijn graph models with different orders $k$ raises an important question: What is the optimal order to model a given <code>PathData</code> instance. It is actually easy to answer this question in our example above.</p> <p>For the data contained in <code>paths</code>, we observe only two of the four possible paths, which is different from what we would expect based on a first-order graph model. To capture this pattern in the node sequenves, a first-order graph model is not sufficient and we need a second-order De Bruoijn graph model.</p> <p>For <code>paths_2</code> this is different: Here we observe all four paths of length two with the same frequency, which is exactly what we would expect based on the first-order weighted graph, where all edge weights are the same. Hence, for <code>paths_2</code> the second-order De Bruijn graph model contains no additional information compared to a first-order weighted graph, which means a first-order model is sufficient.</p> <p>While it is easy to see this in the toy example, for real data we need a principled method to automatically determine the optimal order of a higher-order De Bruijn graph model. Luckily, this can be achieved based on statistical model selection in a multi-order De Bruijn graph model. Here we cannot explain the details of this method, so we kindly refer you to the following paper:</p> <p>I Scholtes: When is a Network a Network?: Multi-Order Graphical Model Selection in Pathways and Temporal Networks, In Proc. of SIGKDD 2017, August 2017</p> <p>The method introduced in this paper is implemented in <code>pathpyG</code>. To determine the optimal order of a higher-order De Bruijn graph model for the node sequences contained in a given <code>PathData</code> instance, we can use the <code>MultiOderModel.estimate_order</code> method. Since the method is based on statistical hypothesis testing, we can also pass a significance threshold, which - in line with the interpretation of p-values - bounds the type I error rate of our test, i.e. the rate at which we wrongly reject the null hypothesis that the true optimal order of a data set is $k-1$ in favor of the alternative hypothesis that the order is $k$.</p> <p>Let us test this for our toy example. Using a significance threshold of $0.01$, we determine the optimal order for the data set <code>paths</code> that should actually warrant a second-order model:</p>"},{"location":"tutorial/paths_higher_order/#loading-empirical-path-data-from-n-gram-files","title":"Loading empirical path data from N-Gram Files\u00b6","text":"<p>For real data on walks in graphs it is not convenient to manually construct and add walks based on edge tensors. We can instead use the <code>pp.io.read_csv_path_data</code> function to load such data from an n-gram file, i.e. a text file where each line corresponds to one observed walk consisting of comma-separated node IDs. If we set the argument <code>weight=True</code>, the last component of each line is considered to be the observation frequency of that particular walk.</p> <p>As an example, the file <code>data/tube_paths_train.ngram</code> contains observed passenger itineraries between nodes in a graph that representes the network of London Tube stations. Each of those itineraries is associated with an observation frequencies. The following is an excerpt from that file:</p> <pre><code>Southwark,Waterloo,212.0\nLiverpool Street,Bank / Monument,1271.0\nBarking,West Ham,283.0\nTufnell Park,Kentish Town,103.0\n...\n</code></pre> <p>Note that this will automatically create an internal mapping of node IDs to indices.</p> <p>Dataset Availability</p> <p>         Depending on how you are executing this notebook, you may need to download the dataset first. We automatically check if the dataset is available in the relative path <code>../data/tube_paths_train.ngram</code>, which is the default location if you cloned the pathpyG repository. If the file is not found, we download it from the GitHub repository.     </p>"},{"location":"tutorial/temporal_graphs/","title":"Temporal Graphs","text":"In\u00a0[1]: Copied! <pre>%%capture\n# !pip install torch\n# !pip install torch_geometric\n# !pip install git+https://github.com/pathpy/pathpyG.git\n</pre> %%capture # !pip install torch # !pip install torch_geometric # !pip install git+https://github.com/pathpy/pathpyG.git In\u00a0[2]: Copied! <pre>import os\nimport tempfile\n\nimport torch\nfrom torch_geometric.data import Data\n\nimport pathpyG as pp\n</pre> import os import tempfile  import torch from torch_geometric.data import Data  import pathpyG as pp <p>We can create a temporal graph object from a list of time-stamped edges. Since <code>TemporalGraph</code> is a subclass of the <code>Graph</code> class, the internal structures are very similar:</p> In\u00a0[3]: Copied! <pre>tedges = [('a', 'b', 1),('a', 'b', 2), ('b', 'a', 3), ('b', 'c', 3), ('d', 'c', 4), ('a', 'b', 4), ('c', 'b', 4),\n          ('c', 'd', 5), ('b', 'a', 5), ('c', 'b', 6)]\nt = pp.TemporalGraph.from_edge_list(tedges)\nprint(t.mapping)\nprint(t.n)\nprint(t.m)\n</pre> tedges = [('a', 'b', 1),('a', 'b', 2), ('b', 'a', 3), ('b', 'c', 3), ('d', 'c', 4), ('a', 'b', 4), ('c', 'b', 4),           ('c', 'd', 5), ('b', 'a', 5), ('c', 'b', 6)] t = pp.TemporalGraph.from_edge_list(tedges) print(t.mapping) print(t.n) print(t.m) <pre>a -&gt; 0\nb -&gt; 1\nc -&gt; 2\nd -&gt; 3\n\n4\n10\n</pre> <p>By default, all temporal graphs are directed. We can create an undirected version a temporal graph as follows:</p> In\u00a0[4]: Copied! <pre>x = t.to_undirected()\nprint(x.mapping)\nprint(x.n)\nprint(x.m)\n</pre> x = t.to_undirected() print(x.mapping) print(x.n) print(x.m) <pre>a -&gt; 0\nb -&gt; 1\nc -&gt; 2\nd -&gt; 3\n\n4\n20\n</pre> <p>We can also directly create a temporal graph from an instance of <code>pyG.TemporalData</code></p> In\u00a0[5]: Copied! <pre>td = Data(edge_index=torch.Tensor([[0, 1, 2, 0], [1, 2, 3, 1]]).long(), time=torch.Tensor([0, 1, 2, 3]), num_nodes=4)\nprint(td)\nt2 = pp.TemporalGraph(td)\nprint(t2)\n</pre> td = Data(edge_index=torch.Tensor([[0, 1, 2, 0], [1, 2, 3, 1]]).long(), time=torch.Tensor([0, 1, 2, 3]), num_nodes=4) print(td) t2 = pp.TemporalGraph(td) print(t2) <pre>Data(edge_index=[2, 4], time=[4], num_nodes=4)\nTemporal Graph with 4 nodes, 3 unique edges and 4 events in [0.0, 3.0]\n{'Edge Attributes': {}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\n</pre> <p>We can restrict a temporal graph to a time window, which returns a temporal graph that only contains time-stamped edges in the given time interval.</p> In\u00a0[6]: Copied! <pre>t1 = t.get_window(0, 4)\nprint(t1)\nprint(t1.m)\nprint(t1.start_time)\nprint(t1.end_time)\n</pre> t1 = t.get_window(0, 4) print(t1) print(t1.m) print(t1.start_time) print(t1.end_time) <pre>Temporal Graph with 4 nodes, 3 unique edges and 4 events in [1, 3]\n{'Edge Attributes': {}, 'Graph Attributes': {}, 'Node Attributes': {}}\n4\n1\n3\n</pre> <p>We can also extract a TemporalGraph object for a batch of temporal edges, which is defined by the start and end index of the edges defining the batch.</p> In\u00a0[7]: Copied! <pre>t1 = t.get_batch(1, 6)\nprint(t1)\nprint(t1.m)\nprint(t1.start_time)\nprint(t1.end_time)\n</pre> t1 = t.get_batch(1, 6) print(t1) print(t1.m) print(t1.start_time) print(t1.end_time) <pre>Temporal Graph with 4 nodes, 4 unique edges and 5 events in [2, 4]\n{'Edge Attributes': {}, 'Graph Attributes': {}, 'Node Attributes': {}}\n5\n2\n4\n</pre> <p>We can easily convert a temporal graph into a weighted time-aggregated static graph, where edge weights count the number of occurrences of an edge across all timestamps.</p> In\u00a0[8]: Copied! <pre>g = t.to_static_graph(weighted=True)\nprint(g)\n</pre> g = t.to_static_graph(weighted=True) print(g) <pre>Directed graph with 4 nodes and 6 edges\n{'Edge Attributes': {'edge_weight': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([6])\"}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\n</pre> <p>We can also aggregate a temporal graph within a certain time window:</p> In\u00a0[9]: Copied! <pre>g = t.to_static_graph(time_window=(1, 3), weighted=True)\nprint(g)\n</pre> g = t.to_static_graph(time_window=(1, 3), weighted=True) print(g) <pre>Directed graph with 2 nodes and 1 edges\n{'Edge Attributes': {'edge_weight': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([1])\"}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\n</pre> <p>Finally, we can use the class <code>RollingTimeWindow</code> to perform a rolling window analysis. The class returns an iterable object, where each iteration yields a time-aggregated weighted graph object as well as the corresponding time window.</p> In\u00a0[10]: Copied! <pre>r = pp.algorithms.RollingTimeWindow(t, window_size=3, step_size=1, return_window=True)\nfor g, w in r:\n    print(\"Time window \", w)\n    print(g)\n    print(g.data.edge_index)\n    print(\"---\")\n</pre> r = pp.algorithms.RollingTimeWindow(t, window_size=3, step_size=1, return_window=True) for g, w in r:     print(\"Time window \", w)     print(g)     print(g.data.edge_index)     print(\"---\") <pre>Time window  (1, 4)\nDirected graph with 3 nodes and 3 edges\n{'Edge Attributes': {'edge_weight': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([3])\"}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\nEdgeIndex([[0, 1, 1],\n           [1, 0, 2]], sparse_size=(3, 3), nnz=3, sort_order=row)\n---\nTime window  (2, 5)\nDirected graph with 4 nodes and 5 edges\n{'Edge Attributes': {'edge_weight': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([5])\"}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\nEdgeIndex([[0, 1, 1, 2, 3],\n           [1, 0, 2, 1, 2]], sparse_size=(4, 4), nnz=5, sort_order=row)\n---\nTime window  (3, 6)\nDirected graph with 4 nodes and 6 edges\n{'Edge Attributes': {'edge_weight': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([6])\"}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\nEdgeIndex([[0, 1, 1, 2, 2, 3],\n           [1, 0, 2, 1, 3, 2]], sparse_size=(4, 4), nnz=6, sort_order=row)\n---\nTime window  (4, 7)\nDirected graph with 4 nodes and 5 edges\n{'Edge Attributes': {'edge_weight': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([5])\"}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\nEdgeIndex([[0, 1, 2, 2, 3],\n           [1, 0, 1, 3, 2]], sparse_size=(4, 4), nnz=5, sort_order=row)\n---\nTime window  (5, 8)\nDirected graph with 4 nodes and 3 edges\n{'Edge Attributes': {'edge_weight': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([3])\"}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\nEdgeIndex([[1, 2, 2],\n           [0, 1, 3]], sparse_size=(4, 4), nnz=3, sort_order=row)\n---\nTime window  (6, 9)\nDirected graph with 3 nodes and 1 edges\n{'Edge Attributes': {'edge_weight': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([1])\"}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\nEdgeIndex([[2],\n           [1]], sparse_size=(3, 3), nnz=1, sort_order=row)\n---\n</pre> <p>We can visualize temporal graphs using the plot function just like static graphs:</p> In\u00a0[11]: Copied! <pre>pp.plot(t);\n</pre> pp.plot(t); <p>The source nodes, destination nodes and timestamps of time-stamped edges are stored as a <code>pyG TemporalData</code> object, which we can access in the following way.</p> In\u00a0[12]: Copied! <pre>t.data\n</pre> t.data Out[12]: <pre>Data(edge_index=[2, 10], time=[10], num_nodes=4)</pre> In\u00a0[13]: Copied! <pre>print(t.data.edge_index)\n</pre> print(t.data.edge_index) <pre>EdgeIndex([[0, 0, 1, 1, 3, 0, 2, 2, 1, 2],\n           [1, 1, 0, 2, 2, 1, 1, 3, 0, 1]], sparse_size=(4, 4), nnz=10)\n</pre> In\u00a0[14]: Copied! <pre>print(t.data.time)\n</pre> print(t.data.time) <pre>tensor([1, 2, 3, 3, 4, 4, 4, 5, 5, 6])\n</pre> <p>With the generator functions <code>edges</code> and <code>temporal_edges</code> we can iterate through the time-ordered (temporal) multi-edges of a temporal graph.</p> In\u00a0[15]: Copied! <pre>for v, w in t.edges:\n    print(v, w)\n</pre> for v, w in t.edges:     print(v, w) <pre>a b\na b\nb a\nb c\nd c\na b\nc b\nc d\nb a\nc b\n</pre> In\u00a0[16]: Copied! <pre>for v, w, time in t.temporal_edges:\n    print(v, w, time)\n</pre> for v, w, time in t.temporal_edges:     print(v, w, time) <pre>a b 1\na b 2\nb a 3\nb c 3\nd c 4\na b 4\nc b 4\nc d 5\nb a 5\nc b 6\n</pre> <p>We are often interested in time-respecting paths in a temporal graph. A time-respecting path consists of a sequence of nodes $v_0,...,v_l$ where consecutive nodes are connected by time-stamped edges that occur (i) in the right temporal ordering, and (ii) within a maximum time difference of $\\delta\\in \\N$.</p> <p>To calculate time-respecting paths in a temporal graph, we can construct a directed acyclic graph (DAG), where each time-stamped edge $(u,v;t)$ in the temporal graph is represented by a node and two nodes representing time-stamped edges $(u,v;t_1)$ and $(v,w;t_2)$ are connected by an edge iff $0 &lt; t_2-t_1 \\leq \\delta$. This implies that (i) each edge in the resulting DAG represents a time-respecting path of length two, and (ii) time-respecting paths of any lenghts are represented by paths in this DAG.</p> <p>We can construct such a DAG using the function <code>pp.algorithms.lift_order_temporal</code>, which returns an edge_index. We can pass this to the constructor of a <code>Graph</code> object, which we can use to visualize the resulting DAG.</p> In\u00a0[17]: Copied! <pre>%%capture\ne_i = pp.algorithms.lift_order_temporal(t, delta=1)\n</pre> %%capture e_i = pp.algorithms.lift_order_temporal(t, delta=1) In\u00a0[18]: Copied! <pre>dag_mapping = pp.IndexMap([f\"{v}-&gt;{w}: {time}\" for v, w, time in t.temporal_edges ])\ndag = pp.Graph.from_edge_index(e_i, mapping=dag_mapping)\npp.plot(dag);\n</pre> dag_mapping = pp.IndexMap([f\"{v}-&gt;{w}: {time}\" for v, w, time in t.temporal_edges ]) dag = pp.Graph.from_edge_index(e_i, mapping=dag_mapping) pp.plot(dag); <p>For $\\delta=1$, this DAG with three connected components tells us that the underlying temporal graph has  the following time-respecting paths (of different lengths):</p> <p>Length one: a -&gt; b b -&gt; a b -&gt; c c -&gt; b c -&gt; d d -&gt; c</p> <p>Length two: a -&gt; b -&gt; a (twice, starting at time 2 and time 4) b -&gt; a -&gt; b a -&gt; b -&gt; c b -&gt; c -&gt; b c -&gt; b -&gt; a d -&gt; c -&gt; d</p> <p>Length three: a -&gt; b -&gt; a -&gt; b b -&gt; a -&gt; b -&gt; a a -&gt; b -&gt; c -&gt; b b -&gt; c -&gt; b -&gt; a</p> <p>Length four: a -&gt; b -&gt; a -&gt; b -&gt; a a -&gt; b -&gt; c -&gt; b -&gt; a</p> <p>We can can use the function <code>pp.algorithms.temporal.temporal_shortest_paths</code> to calculate shortest time-respecting path distances between any pair of nodes. This also returns a predecessor matrix, which can be used to reconstruct all shortest time-respecting paths (in analogy to the Dijkstra algorithm for static graphs):</p> In\u00a0[19]: Copied! <pre>%%capture\ndist, pred = pp.algorithms.temporal_shortest_paths(t, delta=1)\n</pre> %%capture dist, pred = pp.algorithms.temporal_shortest_paths(t, delta=1) In\u00a0[20]: Copied! <pre>print(t.mapping)\nprint(dist)\nprint(pred)\n</pre> print(t.mapping) print(dist) print(pred) <pre>a -&gt; 0\nb -&gt; 1\nc -&gt; 2\nd -&gt; 3\n\n[[ 0.  1.  2. inf]\n [ 1.  0.  1. inf]\n [ 2.  1.  0.  1.]\n [inf inf  1.  0.]]\n[[ 0  0  1 -1]\n [ 1  1  1 -1]\n [ 1  2  2  2]\n [-1 -1  3  3]]\n</pre> <p>In the example above, the four <code>inf</code> values indicate that there is no time-respecting paths between the four node pairs (a, d), (b, d), (d,a) and (d, b). This is not something we would expect based on the (strongly connected) topology of the time-aggregated graph, which is shown below:</p> In\u00a0[21]: Copied! <pre>g = t.to_static_graph(weighted=True)\npp.plot(g);\n</pre> g = t.to_static_graph(weighted=True) pp.plot(g); <p>Similar to simple graphs, we can read and write temporal graph data into various common formats. For example, we can easily convert our temporal graph to a Pandas DataFrame using the <code>temporal_graph_to_df</code> function and create a temporal graph from a DataFrame using the <code>df_to_temporal_graph</code> function:</p> In\u00a0[22]: Copied! <pre>tedges = [('a', 'b', 1),('a', 'b', 2), ('b', 'a', 3), ('b', 'c', 3), ('d', 'c', 4), ('a', 'b', 4), ('c', 'b', 4),\n              ('c', 'd', 5), ('b', 'a', 5), ('c', 'b', 6)]\nt = pp.TemporalGraph.from_edge_list(tedges)\ndf = pp.io.temporal_graph_to_df(t)\nprint(df)\n</pre> tedges = [('a', 'b', 1),('a', 'b', 2), ('b', 'a', 3), ('b', 'c', 3), ('d', 'c', 4), ('a', 'b', 4), ('c', 'b', 4),               ('c', 'd', 5), ('b', 'a', 5), ('c', 'b', 6)] t = pp.TemporalGraph.from_edge_list(tedges) df = pp.io.temporal_graph_to_df(t) print(df) <pre>   v  w  t\n0  a  b  1\n1  a  b  2\n2  b  a  3\n3  b  c  3\n4  d  c  4\n5  a  b  4\n6  c  b  4\n7  c  d  5\n8  b  a  5\n9  c  b  6\n</pre> In\u00a0[23]: Copied! <pre>t = pp.io.df_to_temporal_graph(df)\nprint(t)\n</pre> t = pp.io.df_to_temporal_graph(df) print(t) <pre>Temporal Graph with 4 nodes, 6 unique edges and 10 events in [1, 6]\n{'Edge Attributes': {}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\n</pre> In\u00a0[24]: Copied! <pre>with tempfile.TemporaryDirectory() as tmpdirname:\n    print('created temporary directory', tmpdirname)\n    tmp_file = os.path.join(tmpdirname, 'test_graph.csv')\n    pp.io.write_csv(t, path_or_buf=tmp_file)\n\n    csv_t = pp.io.read_csv_temporal_graph(filename=tmp_file)\npp.plot(csv_t);\n</pre> with tempfile.TemporaryDirectory() as tmpdirname:     print('created temporary directory', tmpdirname)     tmp_file = os.path.join(tmpdirname, 'test_graph.csv')     pp.io.write_csv(t, path_or_buf=tmp_file)      csv_t = pp.io.read_csv_temporal_graph(filename=tmp_file) pp.plot(csv_t); <pre>created temporary directory /tmp/tmp68papqxu\n</pre> In\u00a0[25]: Copied! <pre>t_baboons = pp.io.read_netzschleuder_graph('sp_baboons', 'observational', time_attr='time')\nt_baboons.data.time = (t_baboons.data.time - t_baboons.data.time.min()) // 60 # convert to minutes\nprint(t_baboons)\n</pre> t_baboons = pp.io.read_netzschleuder_graph('sp_baboons', 'observational', time_attr='time') t_baboons.data.time = (t_baboons.data.time - t_baboons.data.time.min()) // 60 # convert to minutes print(t_baboons) <pre>Temporal Graph with 23 nodes, 291 unique edges and 2423 events in [0, 38955]\n{   'Edge Attributes': {   'edge_behavior': \"&lt;class 'numpy.ndarray'&gt;\",\n                           'edge_category': \"&lt;class 'numpy.ndarray'&gt;\",\n                           'edge_duration': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([2423])\",\n                           'edge_localization': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([2423])\",\n                           'edge_point': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([2423])\"},\n    'Graph Attributes': {   'analyses_average_degree': \"&lt;class 'float'&gt;\",\n                            'analyses_degree_assortativity': \"&lt;class 'float'&gt;\",\n                            'analyses_degree_std_dev': \"&lt;class 'float'&gt;\",\n                            'analyses_diameter': \"&lt;class 'int'&gt;\",\n                            'analyses_edge_properties': \"&lt;class 'list'&gt;\",\n                            'analyses_edge_reciprocity': \"&lt;class 'float'&gt;\",\n                            'analyses_global_clustering': \"&lt;class 'float'&gt;\",\n                            'analyses_hashimoto_radius': \"&lt;class 'float'&gt;\",\n                            'analyses_is_bipartite': \"&lt;class 'bool'&gt;\",\n                            'analyses_is_directed': \"&lt;class 'bool'&gt;\",\n                            'analyses_largest_component_fraction': \"&lt;class 'float'&gt;\",\n                            'analyses_mixing_time': \"&lt;class 'float'&gt;\",\n                            'analyses_num_edges': \"&lt;class 'int'&gt;\",\n                            'analyses_num_vertices': \"&lt;class 'int'&gt;\",\n                            'analyses_transition_gap': \"&lt;class 'float'&gt;\",\n                            'analyses_vertex_properties': \"&lt;class 'list'&gt;\",\n                            'num_nodes': \"&lt;class 'int'&gt;\"},\n    'Node Attributes': {'node__pos': \"&lt;class 'numpy.ndarray'&gt;\", 'node_name': \"&lt;class 'numpy.ndarray'&gt;\"}}\n</pre> <p>To calculate the temporal closeness centrality, which is defined based on the length of shortest time-respecting paths of a node to all other nodes, we can write the following:</p> In\u00a0[26]: Copied! <pre>%%capture\ncl = pp.algorithms.centrality.temporal_closeness_centrality(t_baboons, delta=24*60)\n</pre> %%capture cl = pp.algorithms.centrality.temporal_closeness_centrality(t_baboons, delta=24*60) In\u00a0[27]: Copied! <pre>print(cl)\nnode_size = {v: 15 * (x / max(cl.values())) for v, x in cl.items()}\npp.plot(t_baboons, node_size=node_size, node_color=t_baboons.nodes);\n</pre> print(cl) node_size = {v: 15 * (x / max(cl.values())) for v, x in cl.items()} pp.plot(t_baboons, node_size=node_size, node_color=t_baboons.nodes); <pre>{0: 356.4, 1: 390.5, 2: 385.0, 3: 392.33333333333337, 4: 378.4, 5: 399.66666666666663, 6: 374.0, 7: 352.0, 8: 357.5, 9: 352.0, 10: 297.0, 11: 0.0, 12: 374.0, 13: 366.66666666666663, 14: 352.0, 15: 407.0, 16: 363.0, 17: 352.0, 18: 385.0, 19: 348.33333333333337, 20: 174.16666666666666, 21: 145.5666666666667, 22: 159.50000000000003}\n</pre> <p>The definition of time-respecting paths depends on our maximum time difference parameter $\\delta$, which implies that different values of this parameter also yield different centralities. This means that we can calculate temporal node centralities for different \"time scales\" of a temporal graph.</p> In\u00a0[28]: Copied! <pre>%%capture\ncl = pp.algorithms.centrality.temporal_closeness_centrality(t_baboons, delta=1)\n</pre> %%capture cl = pp.algorithms.centrality.temporal_closeness_centrality(t_baboons, delta=1) In\u00a0[29]: Copied! <pre>print(cl)\nnode_size = {v: 15 * (x / max(cl.values())) for v, x in cl.items()}\npp.plot(t_baboons, node_size=node_size, node_color=t_baboons.nodes);\n</pre> print(cl) node_size = {v: 15 * (x / max(cl.values())) for v, x in cl.items()} pp.plot(t_baboons, node_size=node_size, node_color=t_baboons.nodes); <pre>{0: 308.0, 1: 374.0, 2: 374.0, 3: 374.0, 4: 363.0, 5: 396.0, 6: 352.0, 7: 308.0, 8: 319.0, 9: 286.0, 10: 176.0, 11: 0.0, 12: 352.0, 13: 345.4, 14: 330.0, 15: 396.0, 16: 330.0, 17: 319.0, 18: 374.0, 19: 297.0, 20: 22.0, 21: 22.0, 22: 22.0}\n</pre> <p>We can also calculate the temporal betweenness centrality, which is based on the number of shortest time-respecting paths between pairs of nodes that pass through a given node. Again, this centrality score is sensitive to the time scale parameter $\\delta$.</p> In\u00a0[30]: Copied! <pre>%%capture\nbw = pp.algorithms.centrality.temporal_betweenness_centrality(t_baboons, delta=24*60)\n</pre> %%capture bw = pp.algorithms.centrality.temporal_betweenness_centrality(t_baboons, delta=24*60) In\u00a0[31]: Copied! <pre>print(bw)\nnode_size = {v: 15 * (x / max(bw.values())) for v, x in bw.items()}\npp.plot(t_baboons, node_size=node_size, node_color=t_baboons.nodes);\n</pre> print(bw) node_size = {v: 15 * (x / max(bw.values())) for v, x in bw.items()} pp.plot(t_baboons, node_size=node_size, node_color=t_baboons.nodes); <pre>defaultdict(&lt;function temporal_betweenness_centrality.&lt;locals&gt;.&lt;lambda&gt; at 0x7fb16a4c7490&gt;, {np.int64(0): 25.49506219995845, np.int64(9): 16.45944229302354, np.int64(10): 7.0646313362884605, np.int64(8): 10.16539885356489, np.int64(15): 18.70808072720025, np.int64(7): 2.5893301614085957, np.int64(5): 2.9692172804080914, np.int64(19): 8.975171000727638, np.int64(16): 0.7515158959863081, np.int64(18): 25.805683205683206, np.int64(17): 4.9153382565147306, np.int64(4): 17.320833765556717, np.int64(6): 2.1058097733020373, np.int64(12): 3.688175274115717, np.int64(1): 32.60701972686802, np.int64(2): 3.8280206113998165, np.int64(14): 2.9724179092311167, np.int64(3): 5.4875089420452685, np.int64(13): 6.091342786717137, np.int64(11): 1.7763568394002505e-15})\n</pre> In\u00a0[32]: Copied! <pre>%%capture\nbw = pp.algorithms.centrality.temporal_betweenness_centrality(t_baboons, delta=1)\n</pre> %%capture bw = pp.algorithms.centrality.temporal_betweenness_centrality(t_baboons, delta=1) In\u00a0[33]: Copied! <pre>print(bw)\nnode_size = {v: 15 * (x / max(bw.values())) for v, x in bw.items()}\npp.plot(t_baboons, node_size=node_size, node_color=t_baboons.nodes);\n</pre> print(bw) node_size = {v: 15 * (x / max(bw.values())) for v, x in bw.items()} pp.plot(t_baboons, node_size=node_size, node_color=t_baboons.nodes); <pre>defaultdict(&lt;function temporal_betweenness_centrality.&lt;locals&gt;.&lt;lambda&gt; at 0x7fb16a41f760&gt;, {np.int64(0): 9.71445146547012e-15, np.int64(3): 1.999999999999984, np.int64(13): 0.99999999999998, np.int64(1): 1.0000000000000135, np.int64(12): -1.0047518372857667e-14, np.int64(18): 1.500000000000005, np.int64(7): 1.5543122344752192e-15, np.int64(8): -1.199040866595169e-14, np.int64(4): -1.4474532683550478e-14, np.int64(17): 0.4999999999999865, np.int64(2): 1.9999999999999858, np.int64(14): 1.0000000000000062, np.int64(5): 0.999999999999996, np.int64(16): 2.609024107869118e-15, np.int64(15): 0.9999999999999972, np.int64(6): -2.220446049250313e-16, np.int64(9): 1.0519363158323358e-14, np.int64(10): 3.3306690738754696e-15, np.int64(11): 0.0, np.int64(19): -1.1018963519404679e-14})\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorial/temporal_graphs/#temporal-graph-analysis","title":"Temporal Graph Analysis\u00b6","text":""},{"location":"tutorial/temporal_graphs/#prerequisites","title":"Prerequisites\u00b6","text":"<p>First, we need to set up our Python environment that has PyTorch, PyTorch Geometric and PathpyG installed. Depending on where you are executing this notebook, this might already be (partially) done. E.g. Google Colab has PyTorch installed by default so we only need to install the remaining dependencies. The DevContainer that is part of our GitHub Repository on the other hand already has all of the necessary dependencies installed.</p> <p>In the following, we install the packages for usage in Google Colab using Jupyter magic commands. For other environments comment in or out the commands as necessary. For more details on how to install <code>pathpyG</code> especially if you want to install it with GPU-support, we refer to our documentation. Note that <code>%%capture</code> discards the full output of the cell to not clutter this tutorial with unnecessary installation details. If you want to print the output, you can comment <code>%%capture</code> out.</p>"},{"location":"tutorial/temporal_graphs/#motivation-and-learning-objectives","title":"Motivation and Learning Objectives\u00b6","text":"<p>In this tutorial we will introduce the representation of temporal graph data using the <code>TemporalGraph</code> class and how such data can be used to calculate shortest time respecting paths between nodes as well temporal node cemtralities.</p>"},{"location":"tutorial/temporal_graphs/#extracting-time-respecting-paths-in-temporal-networks","title":"Extracting Time-Respecting Paths in Temporal Networks\u00b6","text":""},{"location":"tutorial/temporal_graphs/#reading-and-writing-temporal-graph-data","title":"Reading and writing temporal graph data\u00b6","text":""},{"location":"tutorial/temporal_graphs/#temporal-centralities-in-empirical-temporal-networks","title":"Temporal Centralities in Empirical Temporal Networks\u00b6","text":"<p><code>pathpyG</code>'s ability to calculate (shortest) time-respecting paths enables us to calulate different notions of temporal centralities for nodes in empirial temporal networks. We can download an empirical temporal graph from Netzschleuder:</p>"},{"location":"tutorial/trp_higher_order/","title":"Higher-Order Models for Time-Respecting Paths","text":"In\u00a0[1]: Copied! <pre>%%capture\n# !pip install torch\n# !pip install torch_geometric\n# !pip install git+https://github.com/pathpy/pathpyG.git\n</pre> %%capture # !pip install torch # !pip install torch_geometric # !pip install git+https://github.com/pathpy/pathpyG.git In\u00a0[2]: Copied! <pre>import torch\n\nimport pathpyG as pp\n\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n</pre> import torch  import pathpyG as pp  device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\") In\u00a0[3]: Copied! <pre>tedges = [('a', 'b', 1),('a', 'b', 2), ('b', 'a', 3), ('b', 'c', 3), ('d', 'c', 4), ('a', 'b', 4), ('c', 'b', 4),\n              ('c', 'd', 5), ('b', 'a', 5), ('c', 'b', 6)]\nt = pp.TemporalGraph.from_edge_list(tedges)\nprint(t)\n</pre> tedges = [('a', 'b', 1),('a', 'b', 2), ('b', 'a', 3), ('b', 'c', 3), ('d', 'c', 4), ('a', 'b', 4), ('c', 'b', 4),               ('c', 'd', 5), ('b', 'a', 5), ('c', 'b', 6)] t = pp.TemporalGraph.from_edge_list(tedges) print(t) <pre>Temporal Graph with 4 nodes, 6 unique edges and 10 events in [1, 6]\n{'Edge Attributes': {}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\n</pre> <p>To better understand this temporal graph, we can again create a directed acyclic graph that represents the topology of time-respecting paths:</p> In\u00a0[4]: Copied! <pre>e_i = pp.algorithms.lift_order_temporal(t, delta=1)\nmapping = pp.IndexMap([f'{v}-{w}-{time}' for v, w, time in t.temporal_edges])\ndag = pp.Graph.from_edge_index(e_i, mapping=mapping)\npp.plot(dag);\n</pre> e_i = pp.algorithms.lift_order_temporal(t, delta=1) mapping = pp.IndexMap([f'{v}-{w}-{time}' for v, w, time in t.temporal_edges]) dag = pp.Graph.from_edge_index(e_i, mapping=mapping) pp.plot(dag); <pre>\r  0%|          | 0/6 [00:00&lt;?, ?it/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 6/6 [00:00&lt;00:00, 2429.84it/s]</pre> <pre>\n</pre> <p>For $\\delta=1$, we again have the following time-respecting paths:</p> <p>Length one: a -&gt; b b -&gt; a b -&gt; c c -&gt; b c -&gt; d d -&gt; c Length two: a -&gt; b -&gt; a (twice) b -&gt; a -&gt; b a -&gt; b -&gt; c b -&gt; c -&gt; b c -&gt; b -&gt; a d -&gt; c -&gt; d Length three: a -&gt; b -&gt; a -&gt; b b -&gt; a -&gt; b -&gt; a a -&gt; b -&gt; c -&gt; b b -&gt; c -&gt; b -&gt; a Length four: a -&gt; b -&gt; a -&gt; b -&gt; a a -&gt; b -&gt; c -&gt; b -&gt; a</p> <p>As you can see, these time-respecting paths are actually very similar to the paths data that we have previously represented using the <code>PathData</code> object. In fact, we could - in theory - first extract all time-respecting paths of all lengths, add them to a <code>PathData</code> object and then use the <code>MultiOderModel</code> class to generate higher-order De Bruijn graph models of all orders. In the example above, since we have paths of length one to four, we could create higher-order models with orders from one to four.</p> <p>However, this approach would not be efficient for large temporal graphs, as it is computationally expensive to calculate all possible time-respecting paths as well as subpaths of length $k$, especially for larger values of $\\delta$. To avoid this bottleneck, <code>pathpyG</code> uses a smarter, GPU-based algorithm to calculate time-respecting paths of length $k$ that are needed for a given order $k$.</p> <p>For the example above, we can generate all higher-order models up to order four as follows:</p> In\u00a0[5]: Copied! <pre>m = pp.MultiOrderModel.from_temporal_graph(t, delta=1, max_order=4)\n\nprint(m.layers[3])\nprint(m.layers[4])\n</pre> m = pp.MultiOrderModel.from_temporal_graph(t, delta=1, max_order=4)  print(m.layers[3]) print(m.layers[4]) <pre>\r  0%|          | 0/6 [00:00&lt;?, ?it/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 6/6 [00:00&lt;00:00, 3181.52it/s]</pre> <pre>Directed graph with 6 nodes and 4 edges\n{   'Edge Attributes': {'edge_weight': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([4])\"},\n    'Graph Attributes': {'inverse_idx': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([7])\", 'num_nodes': \"&lt;class 'int'&gt;\"},\n    'Node Attributes': {}}\nDirected graph with 4 nodes and 2 edges\n{'Edge Attributes': {'edge_weight': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([2])\"}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\n</pre> <pre>\n</pre> <p>Remember that in a $k$-th order model nodes capture paths of length $k-1$, while edges capture paths of length $k$.</p> <p>This implies that the first-order model has four nodes and six edges, which simply corresponds to the time-aggregated weighted graph for our example temporal network.</p> In\u00a0[6]: Copied! <pre>print(m.layers[1])\npp.plot(m.layers[1]);\n</pre> print(m.layers[1]) pp.plot(m.layers[1]); <pre>Directed graph with 4 nodes and 6 edges\n{'Edge Attributes': {'edge_weight': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([6])\"}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\n</pre> <p>For the second-order model, we have six nodes, which map to the six different edges (each edge trivially being a time-respecting path of length one) of the temporal graph. The six edges in the second-order model represent the six different time-respecting paths of length two (see above). Since the time-respecting path $a \\rightarrow b \\rightarrow a$  occurs twice at different times, we have one edge with weight two.</p> In\u00a0[7]: Copied! <pre>print(m.layers[2])\nprint(m.layers[2].data.edge_weight)\npp.plot(m.layers[2]);\n</pre> print(m.layers[2]) print(m.layers[2].data.edge_weight) pp.plot(m.layers[2]); <pre>Directed graph with 6 nodes and 6 edges\n{   'Edge Attributes': {'edge_weight': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([6])\"},\n    'Graph Attributes': {'inverse_idx': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([10])\", 'num_nodes': \"&lt;class 'int'&gt;\"},\n    'Node Attributes': {}}\ntensor([2., 1., 1., 1., 1., 1.])\n</pre> <p>For the third-oder mode, we have four edges representing the four different time-respecting paths of length three in the temporal graph above:</p> In\u00a0[8]: Copied! <pre>print(m.layers[3])\npp.plot(m.layers[3]);\n</pre> print(m.layers[3]) pp.plot(m.layers[3]); <pre>Directed graph with 6 nodes and 4 edges\n{   'Edge Attributes': {'edge_weight': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([4])\"},\n    'Graph Attributes': {'inverse_idx': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([7])\", 'num_nodes': \"&lt;class 'int'&gt;\"},\n    'Node Attributes': {}}\n</pre> <p>And finally, for the model with order $k=4$ we only have two edges, representing the two time-respecting paths $a \\rightarrow b \\rightarrow a \\rightarrow b \\rightarrow a$ and $a \\rightarrow b \\rightarrow c \\rightarrow b \\rightarrow a$:</p> In\u00a0[9]: Copied! <pre>print(m.layers[4])\npp.plot(m.layers[4]);\n</pre> print(m.layers[4]) pp.plot(m.layers[4]); <pre>Directed graph with 4 nodes and 2 edges\n{'Edge Attributes': {'edge_weight': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([2])\"}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\n</pre> <p>Intuitively, since in our example there are no time-respecting paths longer than four, if we were to generate a multi-order model with De Bruijn graphs with orders larger than four, those graphs cannot contain any edges. We see this in the following example. The first-order graph is simply the time-aggregated weighted graph, i.e. the number of nodes is equal to the number of nodes in the temporal graph and the number of edges is equal to the number of different time-stamped edges. In each graph of order $k&gt;1$, the number of nodes corresponds to the number of edges in the graph with order $k-1$, since each of those nodes corresponds to a time-respecting path of length $k-1$, which are represented by edges in a $k-1$-th order gaph. This implies that the graph with order five has two nodes, which are the two time-respecting paths of length four. Those nodes are not connected since there is no time-respecting path with length five.</p> In\u00a0[10]: Copied! <pre>m = pp.MultiOrderModel.from_temporal_graph(t, delta=1, max_order=5)\n\nprint(m.layers[4])\nprint(m.layers[5])\npp.plot(m.layers[5]);\n</pre> m = pp.MultiOrderModel.from_temporal_graph(t, delta=1, max_order=5)  print(m.layers[4]) print(m.layers[5]) pp.plot(m.layers[5]); <pre>\r  0%|          | 0/6 [00:00&lt;?, ?it/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 6/6 [00:00&lt;00:00, 2789.69it/s]</pre> <pre>\n</pre> <pre>Directed graph with 4 nodes and 2 edges\n{'Edge Attributes': {'edge_weight': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([2])\"}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\nDirected graph with 2 nodes and 0 edges\n{'Edge Attributes': {'edge_weight': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([0])\"}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\n</pre> In\u00a0[11]: Copied! <pre>t_sp = pp.io.read_netzschleuder_graph(\"sp_high_school\", \"proximity\", time_attr=\"time\")\nprint(t_sp)\n</pre> t_sp = pp.io.read_netzschleuder_graph(\"sp_high_school\", \"proximity\", time_attr=\"time\") print(t_sp) <pre>Temporal Graph with 329 nodes, 5818 unique edges and 188508 events in [1385982020, 1386345580]\n{   'Edge Attributes': {},\n    'Graph Attributes': {   'analyses_average_degree': \"&lt;class 'float'&gt;\",\n                            'analyses_degree_assortativity': \"&lt;class 'float'&gt;\",\n                            'analyses_degree_std_dev': \"&lt;class 'float'&gt;\",\n                            'analyses_diameter': \"&lt;class 'int'&gt;\",\n                            'analyses_edge_properties': \"&lt;class 'list'&gt;\",\n                            'analyses_edge_reciprocity': \"&lt;class 'float'&gt;\",\n                            'analyses_global_clustering': \"&lt;class 'float'&gt;\",\n                            'analyses_hashimoto_radius': \"&lt;class 'float'&gt;\",\n                            'analyses_is_bipartite': \"&lt;class 'bool'&gt;\",\n                            'analyses_is_directed': \"&lt;class 'bool'&gt;\",\n                            'analyses_knn_proj_1': \"&lt;class 'float'&gt;\",\n                            'analyses_knn_proj_2': \"&lt;class 'float'&gt;\",\n                            'analyses_largest_component_fraction': \"&lt;class 'float'&gt;\",\n                            'analyses_mixing_time': \"&lt;class 'float'&gt;\",\n                            'analyses_num_edges': \"&lt;class 'int'&gt;\",\n                            'analyses_num_vertices': \"&lt;class 'int'&gt;\",\n                            'analyses_transition_gap': \"&lt;class 'float'&gt;\",\n                            'analyses_vertex_properties': \"&lt;class 'list'&gt;\",\n                            'num_nodes': \"&lt;class 'int'&gt;\"},\n    'Node Attributes': {   'node__pos': \"&lt;class 'numpy.ndarray'&gt;\",\n                           'node_class': \"&lt;class 'numpy.ndarray'&gt;\",\n                           'node_gender': \"&lt;class 'numpy.ndarray'&gt;\",\n                           'node_id': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([329])\"}}\n</pre> <p>To generate a <code>MultiOrderModel</code> consisting of multiple layers of higher-order De Bruijn graph models, we can use the <code>MultiOrderModel.from_temporal_graph</code> method. We can further specify the maximum order of the highest-order layer, as well as the maximum time difference $\\delta$ for time-respecting paths.</p> <p>We use a maximum time difference of 15 minutes. As you can see below, we can efficiently generate a 5-th order model despite using a temporal graph with more than 188,000 time-stamped edges and considering all time-respecting paths up to length five with a large maximum time difference. Thanks to the use of GPU-accelerated operations, creating such a model takes less than 12 seconds on an (old) RTX 2090 GPU.</p> In\u00a0[\u00a0]: skip-execution Copied! <pre>%%capture\nm = pp.MultiOrderModel.from_temporal_graph(t_sp.to(device), delta=900, max_order=5)\n</pre> %%capture m = pp.MultiOrderModel.from_temporal_graph(t_sp.to(device), delta=900, max_order=5) In\u00a0[13]: skip-execution Copied! <pre>print(m.layers[1])\nprint(m.layers[3])\n</pre> print(m.layers[1]) print(m.layers[3]) <pre>Directed graph with 329 nodes and 5818 edges\n{'Edge Attributes': {'edge_weight': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([5818])\"}, 'Graph Attributes': {'num_nodes': \"&lt;class 'int'&gt;\"}, 'Node Attributes': {}}\nDirected graph with 18421 nodes and 26233 edges\n{   'Edge Attributes': {'edge_weight': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([26233])\"},\n    'Graph Attributes': {'inverse_idx': \"&lt;class 'torch.Tensor'&gt; -&gt; torch.Size([942642])\", 'num_nodes': \"&lt;class 'int'&gt;\"},\n    'Node Attributes': {}}\n</pre> <p>How can we use such higher-order graph models for graph learning tasks? We will demonstrate this in the next unit of our tutorial.</p>"},{"location":"tutorial/trp_higher_order/#higher-order-models-for-time-respecting-paths-in-temporal-graphs","title":"Higher-Order Models for Time-Respecting Paths in Temporal Graphs\u00b6","text":""},{"location":"tutorial/trp_higher_order/#prerequisites","title":"Prerequisites\u00b6","text":"<p>First, we need to set up our Python environment that has PyTorch, PyTorch Geometric and PathpyG installed. Depending on where you are executing this notebook, this might already be (partially) done. E.g. Google Colab has PyTorch installed by default so we only need to install the remaining dependencies. The DevContainer that is part of our GitHub Repository on the other hand already has all of the necessary dependencies installed.</p> <p>In the following, we install the packages for usage in Google Colab using Jupyter magic commands. For other environments comment in or out the commands as necessary. For more details on how to install <code>pathpyG</code> especially if you want to install it with GPU-support, we refer to our documentation. Note that <code>%%capture</code> discards the full output of the cell to not clutter this tutorial with unnecessary installation details. If you want to print the output, you can comment <code>%%capture</code> out.</p>"},{"location":"tutorial/trp_higher_order/#motivation-and-learning-objectives","title":"Motivation and Learning Objectives\u00b6","text":"<p>In the previous tutorial, we have seen how we can use higher-order models to model paths in complex networks. In this example, paths were directly given in terms of sequences of nodes traversed by some process (like a random walk). We have further seen that higher-order De Bruijn graph models can be used to capture patterns that influence the causal topology of a complex network, i.e. which nodes can possibly influence each other via paths. The same is true for time-respecting paths in a temporal graph. Due to the fact that time-stamped edges need to occur in the correct temporal ordering (and within a given time interval based on the maximum time difference $\\delta$), the causal topology given by time-respecting paths can be very different from what we would expect from the (static) topology of links.</p> <p>In the following, we will show how we can easiy and efficiently construct higher-order models for time-respecting paths in a temporal graph. To illustrate this, we use the same toy example as before:</p>"},{"location":"tutorial/trp_higher_order/#constructing-higher-order-de-bruijn-graph-models-for-empirical-temporal-networks","title":"Constructing Higher-Order De Bruijn Graph Models for Empirical Temporal Networks\u00b6","text":"<p>Let us now use <code>pathpyG</code> to construct higher-order De Bruijn graph models for time-respecting paths in empirical temporal network. For this, we first read a number of temporal graphs using the Netzschleuder interface. In the following, we use a publicly available data set:</p> <ul> <li>Face-to-face interactions in a highschool (Mastrandrea, Fournet, Barrat, 2015)</li> </ul>"},{"location":"tutorial/visualisation/","title":"Interactive Graph Visualisation","text":"In\u00a0[1]: Copied! <pre>%%capture\n# !pip install torch\n# !pip install torch_geometric\n# !pip install git+https://github.com/pathpy/pathpyG.git\n</pre> %%capture # !pip install torch # !pip install torch_geometric # !pip install git+https://github.com/pathpy/pathpyG.git In\u00a0[2]: Copied! <pre>import os\nimport tempfile\n\nimport pathpyG as pp\n</pre> import os import tempfile  import pathpyG as pp <p>With these preparations complete, we are ready to construct our first graph. This is achieved through the <code>Graph.from_edge_list</code> constructor provided by <code>pathpyG</code>, a method that allows us to transform a list of edges into a basic graphical representation.</p> In\u00a0[3]: Copied! <pre>g = pp.Graph.from_edge_list([['a', 'b'], ['c','b']])\npp.plot(g, edge_color='gray');\n</pre> g = pp.Graph.from_edge_list([['a', 'b'], ['c','b']]) pp.plot(g, edge_color='gray'); <p>After successfully creating a simple graph using <code>pathpyG</code>, our next step is to examine its structure. This is a crucial part of the process as it gives us an initial understanding of the complexity and scale of our graph. By printing out the number of nodes and edges, we gain insight into the size and connectivity of the graph.</p> <p>Although it may seem unnecessary for this simple graph, it's good practice to gather information about the number of nodes and edges before attempting to visualize it. This preemptive step is crucial, especially when dealing with larger graphs. Visualizing extensive networks can be a time-consuming or even unfeasible task, depending on the sheer volume of elements that need to be represented. Therefore, understanding the graph's scale upfront helps in efficiently planning the visualization process and avoiding potential complications that could arise with larger datasets.</p> In\u00a0[4]: Copied! <pre>f'Our graph has {g.n} nodes and {g.m} edges.'\n</pre> f'Our graph has {g.n} nodes and {g.m} edges.' Out[4]: <pre>'Our graph has 3 nodes and 2 edges.'</pre> In\u00a0[5]: Copied! <pre>pp.plot(g);\n</pre> pp.plot(g); In\u00a0[6]: Copied! <pre>pp.plot(g, backend=\"matplotlib\");\n</pre> pp.plot(g, backend=\"matplotlib\"); In\u00a0[7]: Copied! <pre>pp.plot(g, backend=\"matplotlib\", layout=\"fr\");\n</pre> pp.plot(g, backend=\"matplotlib\", layout=\"fr\"); <p>Additionally, <code>pathpyG</code> offers the flexibility to incorporate custom layout algorithms. If you have developed your own method or have specific requirements for node positioning, you can directly provide the node coordinates to the visualization. This capability ensures that <code>pathpyG</code> can cater to a wide range of visualization needs, from simple and automatic layouts to highly customized and complex arrangements, making it a versatile tool in the field of data visualization.</p> In\u00a0[8]: Copied! <pre>layout = {\"a\": [0.25, 0.75], \"b\": [1, 1], \"c\": [0, 0]}\npp.plot(g, backend=\"matplotlib\", layout=layout);\n</pre> layout = {\"a\": [0.25, 0.75], \"b\": [1, 1], \"c\": [0, 0]} pp.plot(g, backend=\"matplotlib\", layout=layout); In\u00a0[9]: Copied! <pre>style = {}\nstyle[\"node_color\"] = (255, 1, 255)  # RGB tuple\nstyle[\"edge_color\"] = \"green\"  # Color name as str\npp.plot(g, **style);\n</pre> style = {} style[\"node_color\"] = (255, 1, 255)  # RGB tuple style[\"edge_color\"] = \"green\"  # Color name as str pp.plot(g, **style); <p>In <code>pathpyG</code>, there are various methods for assigning styles to objects, each offering a different level of customization and control. A straightforward approach, as previously shown, involves using a single value, such as a color string (e.g., <code>'green'</code>) or an RGB tuple (e.g., <code>(255,1,255)</code>). Applying this single value uniformly alters the appearance of all elements within a specific category, providing a quick and easy way to set a general style. However, for more detailed styling, one can utilize a <code>list</code> of values. In this approach, each value in the <code>list</code> is associated with an element according to its index position. This method is particularly familiar and efficient when working with tensors, where the association of values to elements is often index-based.</p> <p>Additionally, a more tailored approach can be employed through the use of dictionaries. In this case, each element id is paired with a corresponding value in the <code>dict</code>. Elements not included in the dictionary are assigned default values, ensuring that every element is styled, albeit some with custom and others with default styles. The types of values that can be used in these styling methods are diverse, including strings, integers, floats, and tuples, each type depending on the specific styling parameter being adjusted. This flexibility in value types and assignment methods allows for a high degree of customization, enabling the creation of visually distinct and information-rich visualizations.</p> In\u00a0[10]: Copied! <pre>style = {}\nstyle[\"node_color\"] = [\"red\", \"green\", \"blue\"]  # list based approach\nstyle[\"node_size\"] = {\"a\": 40, \"b\": 10, \"c\": 25}  # dict based approach\nstyle[\"node_opacity\"] = {\"b\": 0.5, \"c\": 0.3}  # missing dict value\nstyle[\"edge_color\"] = [\"orange\", \"#00FF00\"]  # hex based color\npp.plot(g, **style);\n</pre> style = {} style[\"node_color\"] = [\"red\", \"green\", \"blue\"]  # list based approach style[\"node_size\"] = {\"a\": 40, \"b\": 10, \"c\": 25}  # dict based approach style[\"node_opacity\"] = {\"b\": 0.5, \"c\": 0.3}  # missing dict value style[\"edge_color\"] = [\"orange\", \"#00FF00\"]  # hex based color pp.plot(g, **style); In\u00a0[11]: Copied! <pre>style = {}\nstyle[\"edge_color\"] = [1, 9]  # int values\n\nstyle[\"node_color\"] = pp.algorithms.centrality.degree_centrality(g)\nstyle[\"cmap\"] = \"plasma\"  # new color map from matplotlib for nodes\npp.plot(g, **style);\n</pre> style = {} style[\"edge_color\"] = [1, 9]  # int values  style[\"node_color\"] = pp.algorithms.centrality.degree_centrality(g) style[\"cmap\"] = \"plasma\"  # new color map from matplotlib for nodes pp.plot(g, **style); In\u00a0[12]: Copied! <pre>with tempfile.TemporaryDirectory() as tmpdirname:\n    filename = os.path.join(tmpdirname, 'test_plot.html')\n    pp.plot(g, filename=filename)\n    print(f'Plot saved to {filename}')\n    print(f'File exists: {os.path.exists(filename)}')\n</pre> with tempfile.TemporaryDirectory() as tmpdirname:     filename = os.path.join(tmpdirname, 'test_plot.html')     pp.plot(g, filename=filename)     print(f'Plot saved to {filename}')     print(f'File exists: {os.path.exists(filename)}') <pre>Plot saved to /tmp/tmpwk9rszyd/test_plot.html\nFile exists: True\n</pre> In\u00a0[13]: Copied! <pre>n = pp.io.read_netzschleuder_graph('karate', '77')\n</pre> n = pp.io.read_netzschleuder_graph('karate', '77') In\u00a0[14]: Copied! <pre>pp.plot(n);\n</pre> pp.plot(n); In\u00a0[15]: Copied! <pre>node_color = [n['node_groups',v].item() for v in n.nodes]\npp.plot(n, edge_color='gray',node_color=node_color);\n</pre> node_color = [n['node_groups',v].item() for v in n.nodes] pp.plot(n, edge_color='gray',node_color=node_color); In\u00a0[16]: Copied! <pre>t = pp.TemporalGraph.from_edge_list(\n        [\n            (\"a\", \"b\", 1),\n            (\"b\", \"c\", 5),\n            (\"c\", \"d\", 9),\n            (\"d\", \"a\", 9),\n            (\"a\", \"b\", 10),\n            (\"b\", \"c\", 10),\n        ]\n    )\n</pre> t = pp.TemporalGraph.from_edge_list(         [             (\"a\", \"b\", 1),             (\"b\", \"c\", 5),             (\"c\", \"d\", 9),             (\"d\", \"a\", 9),             (\"a\", \"b\", 10),             (\"b\", \"c\", 10),         ]     ) In\u00a0[17]: Copied! <pre>pp.plot(t);\n</pre> pp.plot(t); <p>Besides the standard formatting options available in <code>pathpyG</code>, temporal plots come with specific options tailored to their unique nature. These specialized settings allow for precise control over the time dimension of the visualization. The <code>delta</code> option lets you adjust the progression speed through the time steps of your visualization. Here, a value of 1000 translates to a one-second interval, providing a way to calibrate the pace at which the temporal data unfolds.</p> In\u00a0[18]: Copied! <pre>color = {\"a\": \"blue\", \"b\": \"red\", \"c\": \"green\", \"d\": \"yellow\"}\npp.plot(t, node_color=color, delta=2500);\n</pre> color = {\"a\": \"blue\", \"b\": \"red\", \"c\": \"green\", \"d\": \"yellow\"} pp.plot(t, node_color=color, delta=2500);"},{"location":"tutorial/visualisation/#interactive-graph-visualization","title":"Interactive Graph Visualization\u00b6","text":""},{"location":"tutorial/visualisation/#prerequisites","title":"Prerequisites\u00b6","text":"<p>First, we need to set up our Python environment that has PyTorch, PyTorch Geometric and PathpyG installed. Depending on where you are executing this notebook, this might already be (partially) done. E.g. Google Colab has PyTorch installed by default so we only need to install the remaining dependencies. The DevContainer that is part of our GitHub Repository on the other hand already has all of the necessary dependencies installed.</p> <p>In the following, we install the packages for usage in Google Colab using Jupyter magic commands. For other environments comment in or out the commands as necessary. For more details on how to install <code>pathpyG</code> especially if you want to install it with GPU-support, we refer to our documentation. Note that <code>%%capture</code> discards the full output of the cell to not clutter this tutorial with unnecessary installation details. If you want to print the output, you can comment <code>%%capture</code> out.</p>"},{"location":"tutorial/visualisation/#motivation","title":"Motivation\u00b6","text":"<p>This tutorial is specifically designed to guide you through the process of visualizing your data using <code>pathpyG</code>, an advanced data visualization tool. Data visualization is a crucial aspect of data analysis and interpretation, allowing for the transformation of complex datasets into visually appealing and easy-to-understand formats. pathpyG excels in this area by providing a range of functionalities that cater to both beginners and advanced users. Throughout this tutorial, you will be introduced to the basic and advanced features of pathpyG, empowering you to effectively visualize your data. This will not only enhance your understanding of your data but also enable you to communicate your findings more effectively to others.</p> <p>Visualization is a core concept of <code>pathpyG</code> because it bridges the gap between raw data and meaningful visual representations. We, as humans, are wired to process visual information much more rapidly compared to text or audio. This innate ability enables us to quickly identify patterns, outliers, and trends in visual data. Data visualization leverages this capability by graphically representing data, thereby facilitating the swift interpretation of large and complex datasets. Interactive visualizations further this advantage by allowing users to directly engage with the data, exploring and analyzing it in an intuitive and insightful manner. Whether it's understanding the intricate details of microscopic structures or grasping the dynamics of global phenomena, visualizations are instrumental in helping researchers and analysts gain deeper insights and effectively communicate their findings.</p>"},{"location":"tutorial/visualisation/#learning-objectives","title":"Learning objectives\u00b6","text":"<p>In this tutorial, you will learn to master the art of creating simple yet powerful interactive visualizations using <code>pathpyG</code>. You will learn the nuances of customizing the style of your visualizations, enabling you to tailor them to your specific needs and preferences. This customization extends to the aesthetics, layout, and interactive elements, ensuring that your visualizations are not only informative but also engaging. Additionally, the tutorial covers the essential skills needed to save your visualizations in various formats, making it easier to share your work across different platforms and audiences. Lastly, a significant part of the tutorial is dedicated to creating temporal visualizations. These types of visualizations are particularly useful in understanding and presenting data that changes over time, offering dynamic insights into trends and patterns that static visualizations cannot capture. By the end of this tutorial, you will have a comprehensive understanding of how to effectively use pathpyG to create and customize a wide range of visualizations.</p>"},{"location":"tutorial/visualisation/#lets-get-started","title":"Let's Get Started\u00b6","text":"<p>To embark on our journey of visualizing data with <code>pathpyG</code>, the initial step involves initializing and loading the required modules, a crucial process that sets the foundation for our data visualization work. This preparation ensures that all necessary tools and functionalities from <code>pathpyG</code> are at our disposal.</p> <p>In anticipation of enhancing our graphs with additional attributes, we also include the <code>torch</code> package in our setup. <code>torch</code> is renowned for its robust capabilities in data processing and machine learning, and its inclusion allows us to enrich our graphs with more complex and informative attributes.</p>"},{"location":"tutorial/visualisation/#the-plot-function","title":"The <code>plot</code> Function\u00b6","text":"<p>The <code>plot</code> function in <code>pathpyG</code> stands out as the simplest and most direct method for creating visualizations. Designed to encapsulate all the plotting capabilities of <code>pathpyG</code> in a single command, it streamlines the process of generating quick and efficient plots. This functionality is particularly beneficial for users who seek immediate visual feedback from their data without delving into more complex coding. The only prerequisite for using this function is the <code>Graph</code> object, which serves as the foundation for the visualization. Moreover, when working within an interactive environment, such as a <code>Jupyter notebook</code>, the <code>plot</code> function is particularly powerful. In such settings, invoking the <code>plot</code> command will automatically generate and display an interactive visualization. This feature is particularly beneficial as it allows for immediate visual feedback, making it an ideal tool for exploratory data analysis where quick and efficient visualization is key.</p>"},{"location":"tutorial/visualisation/#kwargs-in-the-plot-function","title":"<code>kwargs</code> in the <code>plot</code> function\u00b6","text":"<p>In <code>pathpyG</code>, the customization of your plot is managed through keyword arguments (kwargs), where each customization is specified as a keyword followed by its corresponding value. This approach is what gives the <code>plot</code> function its remarkable flexibility, allowing it to adapt to a wide variety of plotting requirements. Whether you're aiming for a simple graph or a complex, multi-faceted visualization, the keyword arguments provide the tools to tailor your plot precisely to your needs.</p> <p>However, this wealth of options can be somewhat overwhelming for beginners, given the extensive range of available choices. But worry not, as we will guide you through the most essential and basic options, ensuring you have a solid foundation to start from. By mastering these fundamental aspects, you'll be well on your way to effectively utilizing <code>pathpyG</code>'s plot function, gradually building up to more advanced features as you gain confidence and expertise.</p>"},{"location":"tutorial/visualisation/#plotting-backends","title":"Plotting Backends\u00b6","text":"<p>In the diverse world of data visualization, there is no one-size-fits-all technique, as different scenarios demand different approaches. Recognizing this, <code>pathpyG</code> offers a variety of plotting backends, each tailored for specific use cases, ensuring that users have the right tools for their unique requirements.</p> <ul> <li><p>For instance, <code>pathpyG</code> facilitates interactive visualizations, as previously demonstrated, which are immensely useful for dynamic exploration of data. This feature is particularly beneficial in educational settings, exploratory data analysis, and communication, where interaction with the data can lead to deeper understanding and insights.</p> </li> <li><p>On the other hand, <code>pathpyG</code> also integrates with matplotlib, a widely recognized package for creating static plots. This is especially efficient for visualizing large graphs where interactivity might be less critical.</p> </li> <li><p>Additionally, <code>pathpyG</code> caters to the academic and publication community by offering tikz plots, which are highly valued in formal publications for their precision and quality. (Note that for generating tikz plots, currently, the installation of <code>latexmk</code> is necessary to produce the corresponding <code>.tex</code> and <code>.pdf</code> files.)</p> </li> </ul> <p>Let's generate a static png image using the <code>matplotlib</code> backend:</p>"},{"location":"tutorial/visualisation/#quick-introduction-to-layouts","title":"Quick Introduction to Layouts\u00b6","text":"<p>An important aspect to consider is the layout of your plot. The previous plot we generated is static, meaning the positions of the nodes are fixed and do not change. This fixed arrangement presents a unique challenge, as finding the optimal placement for nodes and edges to convey information effectively is not a straightforward task. To assist with this, <code>pathpyG</code> supports simple layout functions designed to create visually appealing and coherent graphs. By default, nodes are assigned random locations for computational efficiency. However, this arrangement can be significantly improved with the use of the <code>layout</code> keyword in the <code>plot</code> function, allowing for more structured and meaningful representations of your graph.</p> <p>For example, <code>pathpyG</code> includes support for sophisticated layout algorithms, such as the Fruchterman-Reingold algorithm for force-directed layouts. This can be activated using the <code>\"fr\"</code> option, which applies a physics-based approach to arrange nodes and edges in a way that visually represents their relational dynamics. Such force-directed layouts are particularly useful for highlighting the underlying structure and relationships within the data.</p>"},{"location":"tutorial/visualisation/#styling-your-plots","title":"Styling Your Plots\u00b6","text":"<p>To enhance the effectiveness and appeal of our visualizations in <code>pathpyG</code>, styling of our plots becomes a key aspect. The ability to style your plots is not just about aesthetic appeal; it is about effectively conveying more information through visual means. Depending on the type of plot you are working with, there are multiple styling options available to tailor your visualization to your specific needs. The fundamental principle here is that the styles applied to your plot should not be dependent on the data of your model. In other words, you should be able to present the same data in different styles, depending on the context or the information you wish to highlight. To facilitate this, styles are organized in dictionaries, which are then incorporated into the <code>plot</code> function.</p> <p>For network plots, where the focus is on the topology of the data, there are several basic styling options you can adjust, including the <code>size</code>, <code>color</code>, and <code>opacity</code> of each node and edge object. These options provide a foundational level of customization, allowing you to make your graph more readable and visually appealing. However, the styling possibilities extend further, varying according to the specific kind of plot you are creating. To distinguish between the styling of edges and nodes, a prefix corresponding to each element type is added to the keyword, such as <code>node_size</code>. This distinction ensures that your styling choices are accurately applied to the intended elements of the graph, further enhancing the clarity and effectiveness of your visualization.</p>"},{"location":"tutorial/visualisation/#colormaps","title":"Colormaps\u00b6","text":"<p>In many instances, particularly when visualizing numerical data, the use of color gradients to represent values can greatly enhance the clarity and effectiveness of a plot. <code>pathpyG</code> addresses this need through its native support for <code>colormaps</code>. When the colors of node or edge elements are defined using <code>int</code> or <code>float</code> values, <code>pathpyG</code> automatically assigns colors based on these colormaps, effectively interpolating the correct color value for each element. By default, <code>pathpyG</code> offers a simple colormap that transitions from red to green, sufficient for many basic visualization needs. However, for more customized or advanced styling, users have the option to utilize any colormap from the extensive color palettes provided by <code>matplotlib</code>. Thit library offer a wide range of color schemes, enabling you to select the perfect palette to convey the nuances of your data.</p>"},{"location":"tutorial/visualisation/#saving-plots","title":"Saving Plots\u00b6","text":"<p>In <code>pathpyG</code>, sharing your plots or incorporating them into various mediums is facilitated by the ability to save them as files. This functionality is conveniently accessed by simply adding the <code>filename</code> keyword within the plot function. When you specify a filename, <code>pathpyG</code> assigns the appropriate backend to use based on the file extension provided. For instance, if you save your file with an <code>.html</code> extension, <code>pathpyG</code> generates a standalone interactive visualization, perfect for web applications or interactive presentations. On the other hand, if you choose to save your plot as a <code>.png</code> file, a static image is created using the <code>matplotlib</code> backend, ideal for including in documents, reports, or presentations where interactivity is not required. Additionally, for those seeking to incorporate plots into academic papers or publications, saving the file with a <code>.tex</code> extension activates the <code>tikz</code> backend. This feature is particularly beneficial for creating high-quality, publication-ready figures.</p>"},{"location":"tutorial/visualisation/#larger-network-visualizations","title":"Larger Network Visualizations\u00b6","text":"<p>Having covered the basics, we are now well-prepared to venture into the realm of larger network visualizations using <code>pathpyG</code>.</p>"},{"location":"tutorial/visualisation/#temporal-network-visualizations","title":"Temporal Network Visualizations\u00b6","text":"<p>In the realm of network analysis, <code>pathpyG</code> particularly excels in handling and visualizing temporal graphs, a domain where both nodes and edges can change their properties over time. This dynamic aspect of temporal graphs adds a layer of complexity and richness to data analysis, capturing the evolution of relationships and properties within the network. <code>pathpyG</code> supports this advanced functionality, allowing users to apply the same versatile <code>plot</code> function used for static graphs to <code>TemporalGraph</code> data structures. This integration means that all the customization options, styling features, and layout choices previously explored for static network visualizations are also applicable to temporal graphs. The ability to utilize these tools in the context of temporal data opens up a world of possibilities for in-depth analysis and insightful visualization of networks where time plays a crucial role. Whether you're tracking changes in social networks, analyzing traffic patterns, or studying dynamic biological systems, <code>pathpyG</code>'s capabilities in temporal network visualization provide a powerful tool to uncover and illustrate the temporal dynamics inherent in these complex systems.</p>"}]}